//------------------------------------------------------------------------------
// <copyright file="NavigatorInput.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------
using System;
using System.Text;
using System.Collections;
using System.Diagnostics;
using System.Xml;
using System.Xml.XPath;
using ISourceLineInfo = MS.Internal.Xml.ISourceLineInfo;

namespace Microsoft.Xml.Query.Xslt {

    // This class is designed to help XSLT parser with reading stylesheet. We should be able to load SS from
    // XmlReader, URL, XPathNavigator. The simples way to load from URL and XmlReader is to load xml to XPathDocument and 
    // use navigator over XPathDocument. To avoid intermediate storage XsltInput can work directly from reader and limits
    // navigation over SS nodes to XmlReader like MoveTo* functions.
    // document("") function in the case of XslInput(XmlReader) will read SS again. To be able to "reread" SS 
    // we should be garanteed that Xml.Reader.BaseUri != "".

    // Simplest way to implement two ways if XslInput is to make it abstract class and put implementation in its subclasses.
    // In purpose to not have two additional classes, two additional files and bunch of virtual functions we put both 
    // implementation into base XslImput class. (navigator == null) means that reader is used.

    // To aline XPathNavigator and XmlReader we 
    //     1. Restrict all navigation to pure reader ability: 
    //         a) Forward only, one pass.
    //         b) You should call MoveToFirstChildren on nonempty element node. (or may be skip)
    //         c) You should call MoveToParent when no more children is available.
    //     2. Extend XmlReader to XPath data model.
    //         a) merge all text, WS and CDATA nodes.
    //         b) make distinction between NS and other attributes
    //         c) keep track of all namespaces available for each node
    //     3. Real problem in XmlReader part we have with MoveToParent(). Navigator will be positioned on real parent while 
    //        Reader can't do this. It will be positioned on EndElement or anythig after it. To allign behavior here
    //        we are prohibinting to assess node properties (NodeType, LocalName, Value) after MoveToParent().
    //     3.1. The special part of this problem for XmlReader is <A></A>. MoveToFirstChild() sould be called. It it should 
    //          return false (to line with Navigator) Reader stays on </A> 
    //     4. We don't need value of Element nodes. To lineup with XmlReader set it to string.Empty.
    //     5. XPathDocument ignores whitespaces ot the root level. To acomplish this with reader we use it's Depth property.
    //     6. Namespaces are in reverce order in XPathDocument. We are not adressing this problem.

    internal class XsltInput : ISourceLineInfo {
        private InputScopeManager   scopeManager;
        private XsltInput           next;
        private Keywords            atoms;

        private XPathNavigator      navigator;
        private XmlValidatingReader reader;
        private string              text;           // Special state for reader base Input. when it != null reader stays after all
        private bool                textIsWhite;    //    merged text nodes. textIsWhite true alny if all partes was WS or SWS
        private bool                shouldCloseReader;
        private int                 depth;

        // Cahced properties. MoveTo* functions set them.
        private XPathNodeType       nodeType;
        private string              localName;
        private string              namespaceUri;
        private string              value;

        public XsltInput(XPathNavigator navigator) {
            Init(navigator);
        }

        public XsltInput(XmlReader reader) {
            if (reader.BaseURI == null || reader.BaseURI == "") {
                Init((new System.Xml.XPath.XPathDocument(reader, XmlSpace.Preserve)).CreateNavigator());
            }
            else {
                Init(reader);
            }
        }

        public XsltInput(string uri) {
            CompareInputs(uri);
            Init(new XmlTextReader(uri));
    //      Debug.Assert(uri == this.reader.BaseURI);
        }
        private void Init(XPathNavigator navigator) {
            if (navigator == null) throw new ArgumentException(nameof(navigator));
            this.navigator = navigator;
            this.scopeManager = new InputScopeManager(navigator.NameTable);
            this.atoms        = new Keywords(navigator.NameTable);
            if (this.navigator.NodeType == XPathNodeType.Root) {
                this.navigator.MoveToFirstChild();
                // ??? Do we need to check result.
            }
            StepOnNodeNav();
        }

        private void Init(XmlReader reader) {
            if (reader == null) throw new ArgumentException(nameof(reader));
            this.reader = EnsureExpandEntities(reader);
            this.scopeManager = new InputScopeManager(reader.NameTable);
            this.atoms        = new Keywords(reader.NameTable);
            this.ReadNextSiblig();
            StepOnNodeRdr();
        }

        private XmlValidatingReader EnsureExpandEntities(XmlReader reader) {
            XmlValidatingReader vr = reader as XmlValidatingReader;
            if (vr == null || vr.EntityHandling != EntityHandling.ExpandEntities) {
                vr = new XmlValidatingReader( reader );
                vr.EntityHandling = EntityHandling.ExpandEntities;
                vr.ValidationType = ValidationType.None;
                this.shouldCloseReader = true;
            }
            return vr;
        }

        public void Close() {
            if (shouldCloseReader) {
                Debug.Assert(this.reader != null);
                this.reader.Close();
                this.reader = null;
            }
        }

        private void SetCachedPropertiesFromNavigator() {
            Debug.Assert(this.navigator != null);
            nodeType     = this.navigator.NodeType;
            localName    = this.navigator.LocalName;
            namespaceUri = this.navigator.NamespaceURI;
            value        = (nodeType != XPathNodeType.Element) ? this.navigator.Value : string.Empty;
        }

        private void SetCachedPropertiesFromReader() {
            Debug.Assert(this.reader != null);
            nodeType     = ConvertNodeType(this.reader.NodeType);
            localName    = this.reader.LocalName;
            namespaceUri = this.reader.NamespaceURI;
            value        = this.reader.Value;
            if (nodeType == XPathNodeType.Attribute && IsNamespace(this.reader)) {
                nodeType = XPathNodeType.Namespace;
                namespaceUri = string.Empty;
                if (localName == "xmlns") {
                    localName = string.Empty;
                }
            }
        }

        public XsltInput Next {
            get { return this.next; }
            set { this.next = value; }
        }

        public Keywords Atoms { get { return this.atoms; } }        

        public XPathNavigator Navigator { get { return this.navigator; } }

        // Propertes we have cached
        public XPathNodeType NodeType     { get { return this.nodeType;     } }
        public string        Value        { get { return this.value;        } }
        public string        LocalName    { get { return this.localName;    } }
        public string        NamespaceUri { get { return this.namespaceUri; } }

        public int           Depth        { get { return this.depth;        } }

        // Prefix, IsEmptyElement and BaseURI are not cached
        public  string Prefix {
            get { 
                Debug.Assert(! IsTextType(this.NodeType));
                if (navigator != null) {
                    return this.navigator.Prefix;
                }
                else {
                    return this.reader.Prefix;
                }
            }
        }

        public bool IsEmptyElement {
            get { 
                Debug.Assert(! IsTextType(this.NodeType));
                if (navigator != null) {
                    return this.navigator.IsEmptyElement;
                }
                else {
                    return this.reader.IsEmptyElement;
                }
            }
        }

        public string BaseUri {
            get { 
                Debug.Assert(! IsTextType(this.NodeType));
                if (navigator != null) {
                    return this.navigator.BaseURI;
                }
                else {
                    return this.reader.BaseURI;
                }
            }
        }
        
        public string LookupXmlNamespace(string prefix) {
            Debug.Assert(prefix != null);
            string nsUri = (navigator != null 
                ? this.navigator.GetNamespace(prefix) 
                : this.reader.LookupNamespace(prefix)
            );
            if (nsUri != null) {
                return nsUri;
            }
            if (prefix.Length == 0) {
                return string.Empty;
            }
            throw new XmlException("SR.Xslt_InvalidPrefix, prefix");
        }

        static bool IsNamespace(XmlReader reader) {
            Debug.Assert(reader.NodeType == XmlNodeType.Attribute);
            return reader.Prefix == "xmlns" || reader.Prefix.Length == 0 && reader.LocalName == "xmlns";
        }

        static bool NextAttribute(XmlReader reader) {
            do  {
                if (! reader.MoveToNextAttribute()) {
                    return false;
                }
            }while (IsNamespace(reader));
            return true;
        }
        
        static bool NextNamespace(XmlReader reader) {
            do  {
                if (! reader.MoveToNextAttribute()) {
                    return false;
                }
            }while (! IsNamespace(reader));
            return true;
        }
        
        public bool MoveToFirstAttribute() {
            Debug.Assert(this.NodeType == XPathNodeType.Element);
            if (navigator != null) {
                if (this.navigator.MoveToFirstAttribute()) {
                    SetCachedPropertiesFromNavigator();
                    return true;
                }
            }
            else {
                if (NextAttribute(this.reader)) {
                    SetCachedPropertiesFromReader();
                    return true;
                }
                else {
                    // Attributes and namespaces are mixed in reader. It's posible that we are position on NS now.
                    // To fixup this problem:
                    this.reader.MoveToElement(); 
                }
            }
            return false;
        }

        public bool MoveToNextAttribute() {
            Debug.Assert(this.NodeType == XPathNodeType.Attribute);
            if (navigator != null) {
                if (this.navigator.MoveToNextAttribute()) {
                    SetCachedPropertiesFromNavigator();
                    return true;
                }
            }
            else {
                if (NextAttribute(this.reader)) {
                    SetCachedPropertiesFromReader();
                    return true;
                }
            }
            return false;
        }

        public bool MoveToFirstNamespace() {
            Debug.Assert(this.NodeType == XPathNodeType.Element);
            if (navigator != null) {
                if (this.navigator.MoveToFirstNamespace(XPathNamespaceScope.Local)) {
                    SetCachedPropertiesFromNavigator();
                    return true;
                }
            }
            else {
                if (NextNamespace(this.reader)) {
                    SetCachedPropertiesFromReader();
                    return true;
                }
                else {
                    // Attributes and namespaces are mixed in reader. It's posible that we are position on Attribute now.
                    // To fixup this problem:
                    this.reader.MoveToElement(); 
                }
            }
            return false;
        }

        public bool MoveToNextNamespace() {
            Debug.Assert(this.NodeType == XPathNodeType.Namespace);
            if (navigator != null) {
                if (this.navigator.MoveToNextNamespace(XPathNamespaceScope.Local)) {
                    SetCachedPropertiesFromNavigator();
                    return true;
                }
            }
            else {
                if (NextNamespace(this.reader)) {
                    SetCachedPropertiesFromReader();
                    return true;
                }
            }
            return false;
        }

        public void MoveToElement() {
            Debug.Assert(this.NodeType == XPathNodeType.Attribute || this.NodeType == XPathNodeType.Namespace, "We should be on an attribute or on a namespace to call MoveToElement");
            if (navigator != null) {
                this.navigator.MoveToParent();
                SetCachedPropertiesFromNavigator();
            }
            else {
                this.reader.MoveToElement();
                SetCachedPropertiesFromReader();
            }
        }

        // Debulg subsystem
        enum Moves {
            Next, Child, Parent
        };

        Moves lastMove   = Moves.Child;
        bool  lastResult = true;

        [System.Diagnostics.Conditional("DEBUG")]
        private void SetLastMove(Moves lastMove, bool lastResult) {
            this.lastMove   = lastMove;
            this.lastResult = lastResult;
        }
        // --------------------

        private void StepOnNodeNav() {
            SetCachedPropertiesFromNavigator();
            if (this.NodeType == XPathNodeType.Element) {
                this.scopeManager.PushScope();
            }
        }

        private void StepOnNodeRdr() {
            if (this.text == null) {
                SetCachedPropertiesFromReader();
            }
            else {
                this.value        = this.text;
                this.localName    = string.Empty;
                this.namespaceUri = string.Empty;
                this.nodeType = (
                    (! this.textIsWhite                  ) ? XPathNodeType.Text :
                    (reader.XmlSpace == XmlSpace.Preserve) ? XPathNodeType.SignificantWhitespace :
                    /*default:                          */   XPathNodeType.Whitespace
                );
            }
            if (this.NodeType == XPathNodeType.Element) {
                this.scopeManager.PushScope();
            }
        }

        private void StepOffNode () {
            if (this.NodeType == XPathNodeType.Element) {
                this.scopeManager.PopScope();
            }
        }

        private bool MoveToFirstChildAny() {
            bool result;
            if (navigator != null) {
                result = this.navigator.MoveToFirstChild();
                if (result) {
                    StepOnNodeNav();
                    depth ++;
                }
            }
            else {
                if (this.reader.IsEmptyElement) {
                    result = false;
                }
                else {
                    result = this.ReadNextSiblig();
                    Debug.Assert(result, "For non-empty element ReadNextSiblig() can't fail");
                    StepOnNodeRdr();
                    depth ++;
                }
            }
            return result;
        }

        public bool MoveToFirstChild() {
            Debug.Assert(this.lastResult && this.lastMove != Moves.Parent, "We should sucessfuly move MoveToNextSibling() after MoveToParent()");
            Debug.Assert(this.NodeType == XPathNodeType.Element);
            bool result = MoveToFirstChildAny();
            if (result) {
                // Pass commants and PIs
                if(this.NodeType == XPathNodeType.Comment || this.NodeType == XPathNodeType.ProcessingInstruction) {
                    result = this.MoveToNextSibling();
                }
                if (! result) {
                    this.MoveToParent();
                }
            }
            SetLastMove(Moves.Child, result);
            return result;
        }

        private bool MoveToNextSiblingAny() {
            bool result;
            StepOffNode();
            if (navigator != null) {
                result = this.navigator.MoveToNext();
                if (result) {
                    StepOnNodeNav();
                }
            }
            else {
                result = this.ReadNextSiblig();
                if (result) {
                    StepOnNodeRdr();
                }
            }
            return result;
        }

        public bool MoveToNextSibling() {
#if DEBUG
            if (this.lastMove == Moves.Next) {
                Debug.Assert(this.lastResult, "we can't move next if we already failed doing this");
                Debug.Assert(this.NodeType != XPathNodeType.Element, "We should call MoveToFirstChild() on all elements. See SkipElement().");
            }
#endif
            bool result;
            do {
                result = this.MoveToNextSiblingAny();
            }while (result && (this.NodeType == XPathNodeType.Comment || this.NodeType == XPathNodeType.ProcessingInstruction));
            SetLastMove(Moves.Next, result);
            return result;
        }

        public  bool MoveToParent() {
            Debug.Assert(this.lastMove == Moves.Next && ! this.lastResult, "we can't move parent before read all children");
            bool result;
            // We shouldn't call StepOffNode() here because we already left last node.
            if (navigator != null) {
                result = this.navigator.MoveToParent();
            }
            else {
                result = true; // this not exectely true if we are on root.
            }
            depth --;
            SetLastMove(Moves.Parent, result);
            return result;
        }

        public void SkipNode() {
            if (this.NodeType == XPathNodeType.Element && this.MoveToFirstChild()) {
                do {
                    this.SkipNode();
                } while(this.MoveToNextSibling());
                this.MoveToParent();
            }
        }

        private bool ReadNextSiblig() {
            if (this.text != null) {
                this.text = null;
                return this.reader.NodeType != XmlNodeType.EndElement;
            }
            XmlSpace space = reader.XmlSpace;
            this.textIsWhite = true;
            do {
                if (! reader.Read()) {
                    return this.text != null;
                }
                switch (reader.NodeType) {
                case XmlNodeType.Text:
                    this.textIsWhite = false;
                    goto case XmlNodeType.SignificantWhitespace;
                case XmlNodeType.CDATA:
                    if (this.textIsWhite && ! IsWhitespace(reader.Value)) {
                        this.textIsWhite = false;
                    }
                    goto case XmlNodeType.SignificantWhitespace;
                case XmlNodeType.Whitespace:
                case XmlNodeType.SignificantWhitespace:
                    if (this.text == null) {
                        if (this.reader.Depth == 0 && this.textIsWhite) {
                            continue; // We should ignore whitespace nodes on root level as XPathDocument does this.
                        }
                        this.text = reader.Value;
                    }
                    else {
                        this.text += reader.Value;
                    }
                    break;
                case XmlNodeType.EntityReference :
                    Debug.Assert(false, "Entety references whould be resolved for us");
                    break;
                case XmlNodeType.DocumentType:
                case XmlNodeType.XmlDeclaration:
                    break;
                default:
                    if (this.text != null) {
                        return true;
                    }
                    return this.reader.NodeType != XmlNodeType.EndElement;
                }
            }while (true);
        }

        private static bool IsWhitespace(string text) {
            for (int i = text.Length - 1; 0 <= i; i --) {
                if (! XmlCharType.IsWhiteSpace(text[i])) {
                    return false;
                }
            }
            return true;
        }

        private static XPathNodeType ConvertNodeType(XmlNodeType type) {
            switch(type) {
            case XmlNodeType.Element               : return XPathNodeType.Element              ;
            case XmlNodeType.EndElement            : return XPathNodeType.Element              ;
            case XmlNodeType.Attribute             : return XPathNodeType.Attribute            ;
            case XmlNodeType.ProcessingInstruction : return XPathNodeType.ProcessingInstruction;
            case XmlNodeType.Comment               : return XPathNodeType.Comment              ;
            case XmlNodeType.Text                  : return XPathNodeType.Text                 ;
    //            case XmlNodeType.Document              : return XPathNodeType.Root                 ;
            default :
                Debug.Assert(false, "we should't be on this node");
                // We can't be on Text WS, SWS, CDATA -- because we reading them all
                // We can't be on DocumentFragment, Notation, EntityReference, Entity, DocumentType, DocumentFragment, Notation, 
                //                EndElement, EndEntity, XmlDeclaration - we don't know what to do with them on XPath
                //                XsltInput shoud pass them
                return XPathNodeType.All;
            }
        }
        private static bool IsTextType(XPathNodeType nodeType) {
            return (
                nodeType == XPathNodeType.Text || 
                nodeType == XPathNodeType.Whitespace || 
                nodeType == XPathNodeType.SignificantWhitespace
            );
        }

        // -------------------- Keywords testing --------------------

        public bool IsNs(string ns)               { return Ref.Equal(ns, this.NamespaceUri); }
        public bool IsKeyword(string kwd)         { return Ref.Equal(kwd, this.LocalName);  }
        public bool IsXsltNamespace()             { return IsNs(atoms.UrnXsl); }
        public bool IsNullNamespace()             { return IsNs(string.Empty); }
        public bool IsXsltInstruction(string kwd) { return IsKeyword(kwd) && IsXsltNamespace(); }
        public bool IsXsltAttribute(string kwd)   { return IsKeyword(kwd) && IsNullNamespace(); }
        public bool IsWithParam()                 { return IsXsltInstruction(this.Atoms.WithParam); }
        public bool IsSort()                      { return IsXsltInstruction(this.Atoms.Sort     ); }

        
        // -------------------- Scope Management --------------------
        // See private class InputScopeManager bellow.
        // InputScopeManager handles some flags and values with respect of scope level where they as defined.
        // To parse XSLT style sheet we need the folloing values:
        //  ForwardCompatibility -- this flag is set when xsl:version!='1.0'.
        //  CanHaveApplyImports  -- we allow xsl:apply-templates instruction to apear in any template with match!=null, but not inside xsl:for-each
        //                          so it can't be inside global variable and has initial value = false
        //  ExtentionNamespace   -- is defined by extension-element-prefixes attribute on LRE or xsl:stylesheet

        public bool CanHaveApplyImports {
            get { return this.scopeManager.CanHaveApplyImports; }
            set { this.scopeManager.CanHaveApplyImports = value;}
        }

        public void AddExtensionNamespace(string uri) { this.scopeManager.AddExtensionNamespace(uri); }
        public bool IsExtensionNamespace( string uri) { return this.scopeManager.IsExtensionNamespace(uri); }

        public bool ForwardCompatibility {
            get { return this.scopeManager.ForwardCompatibility; }
        }

        public void SetVersion(string ver) {
            // BugBug! -- version shouldn't be NaN !
            if (XmlConvert.ToDouble(ver) < 1) { // should be XmlConvert.ToXPathDouble
                throw new XmlException("InvalidAttrValueKeywords ");
            }
            this.scopeManager.ForwardCompatibility = (ver != "1.0");
        }

        [System.Diagnostics.Conditional("DEBUG")]
        private void CompareInputs(string uri) {
            XsltInput navInput = new XsltInput((new System.Xml.XPath.XPathDocument(uri, XmlSpace.Preserve)).CreateNavigator());
            XsltInput rdrInput = new XsltInput(new XmlTextReader(uri));
            // Test all nodes on the root level. It can be comments, PIs and one element node.
            bool navMove, rdrMove; 
            do {
                CompareNodes(navInput, rdrInput);
                navMove = navInput.MoveToNextSibling();
                rdrMove = rdrInput.MoveToNextSibling();
                Debug.Assert(navMove == rdrMove);
            }while(navMove);
        }

        [System.Diagnostics.Conditional("DEBUG")]
        private void CompareNodes(XsltInput navInput, XsltInput rdrInput) {
            XPathNodeType navNodeType       = navInput.NodeType    ;
            XPathNodeType rdrNodeType       = rdrInput.NodeType    ;
            string        navValue          = navInput.Value       ; 
            string        rdrValue          = rdrInput.Value       ; 
            string        navLocalName      = navInput.LocalName   ;
            string        rdrLocalName      = rdrInput.LocalName   ;
            string        navNamespaceUri   = navInput.NamespaceUri; 
            string        rdrNamespaceUri   = rdrInput.NamespaceUri; 
            int           navDepth          = navInput.Depth       ; 
            int           rdrDepth          = rdrInput.Depth       ; 
            Debug.Assert(navNodeType     == rdrNodeType    );
            Debug.Assert(navLocalName    == rdrLocalName   );
            Debug.Assert(navNamespaceUri == rdrNamespaceUri);
            Debug.Assert(navValue        == rdrValue       );
            Debug.Assert(navDepth        == rdrDepth       );
            if (IsTextType(navNodeType)) {
                return;   // Text is syntetic node for reader breanch. Nothing else is available
            }
            string        navPrefix         = navInput.Prefix        ; 
            string        rdrPrefix         = rdrInput.Prefix        ; 
            string        navBaseUri        = navInput.BaseUri       ; 
            string        rdrBaseUri        = rdrInput.BaseUri       ; 
            bool          navIsEmptyElement = navInput.IsEmptyElement;
            bool          rdrIsEmptyElement = rdrInput.IsEmptyElement;
            Debug.Assert(navIsEmptyElement == rdrIsEmptyElement);
            Debug.Assert(navPrefix         == rdrPrefix        );
            Debug.Assert(navBaseUri        == rdrBaseUri       );
            if (navInput.NodeType == XPathNodeType.Element) {
                bool navMove, rdrMove; 
                /* Compare Namespases (local)*/ {
                    // reader has oposit order of namespaces that navigator.
                    rdrMove = rdrInput.MoveToFirstNamespace();
                    navMove = navInput.MoveToFirstNamespace();
                    Debug.Assert(navMove == rdrMove);
                    if (navMove) {
                        ArrayList names = new ArrayList();
                        ArrayList nss   = new ArrayList();
                        do {
                            names.Add(rdrInput.LocalName);
                            nss  .Add(rdrInput.Value    );
                            rdrMove = rdrInput.MoveToNextNamespace();
                        }while(rdrMove);
                        int count;
                        for (count = names.Count - 1; 0 <= count; -- count) {
                            Debug.Assert(navMove);
                            string name = (string) names[count];
                            string ns   = (string) nss  [count];
                            Debug.Assert(name == navInput.LocalName);
                            Debug.Assert(ns   == navInput.Value    );
                            navMove = navInput.MoveToNextNamespace();
                        }
                        Debug.Assert(-1 == count, "all namespaces from reader was counted");
                        Debug.Assert(! navMove, "all namespaces from navigator was passed");
                        navInput.MoveToElement();
                        rdrInput.MoveToElement();
                    }
                }
                /* Compare attributes */ {
                    navMove = navInput.MoveToFirstAttribute();
                    rdrMove = rdrInput.MoveToFirstAttribute();
                    Debug.Assert(navMove == rdrMove);
                    if (navMove) {
                        do {
                            CompareNodes(navInput, rdrInput);
                            navMove = navInput.MoveToNextAttribute();
                            rdrMove = rdrInput.MoveToNextAttribute();
                            Debug.Assert(navMove == rdrMove);
                        }while(navMove);
                        navInput.MoveToElement();
                        rdrInput.MoveToElement();
                    }
                }
                /* Compare Children */ {
                    navMove = navInput.MoveToFirstChild();
                    rdrMove = rdrInput.MoveToFirstChild();
                    Debug.Assert(navMove == rdrMove);
                    if (navMove) {
                        do {
                            CompareNodes(navInput, rdrInput);
                            navMove = navInput.MoveToNextSibling();
                            rdrMove = rdrInput.MoveToNextSibling();
                            Debug.Assert(navMove == rdrMove);
                        }while(navMove);
                        navInput.MoveToParent();
                        rdrInput.MoveToParent();
                    }
                }
            }
        }
        
        // --------------- GetAtributes(...) -------------------------
        // All Xslt Instructions allows fixed set of attributes in null-ns, no in XSLT-ns and any in other ns.
        // In ForwardCompatibility mode we should ignore any of this problems.
        // We not use these functions for parseing LiteralResultElement and xsl:stylesheet

        private string[] names  = new string[11];
        private string[] values = new string[11];

        public ContextInfo GetAttributes() {
            return GetAttributes(0, 0, names, values);
        }

        public ContextInfo GetAttributes(int required, string name, out string value) {
            names[0] = name;
            ContextInfo ctxInfo = GetAttributes(required, 1, names, values);
            value = values[0];
            return ctxInfo;
        }

        public ContextInfo GetAttributes(int required, string name0, out string value0, string name1, out string value1) {
            names[0] = name0; 
            names[1] = name1;
            ContextInfo ctxInfo = GetAttributes(required, 2, names, values);
            value0 = values[0]; 
            value1 = values[1];
            return ctxInfo;
        }
        
        public ContextInfo GetAttributes(int required, 
            string name0, out string value0, 
            string name1, out string value1, 
            string name2, out string value2
        ) {
            names[0] = name0;
            names[1] = name1;
            names[2] = name2;
            ContextInfo ctxInfo = GetAttributes(required, 3, names, values);
            value0 = values[0];
            value1 = values[1];
            value2 = values[2];
            return ctxInfo;
        }

        public ContextInfo GetAttributes(int required, 
            string name0, out string value0, 
            string name1, out string value1, 
            string name2, out string value2, 
            string name3, out string value3
        ) {
            names[0] = name0;
            names[1] = name1;
            names[2] = name2;
            names[3] = name3;
            ContextInfo ctxInfo = GetAttributes(required, 4, names, values);
            value0 = values[0];
            value1 = values[1];
            value2 = values[2];
            value3 = values[3];
            return ctxInfo;
        }

        public ContextInfo GetAttributes(int required, 
            string name0, out string value0, 
            string name1, out string value1, 
            string name2, out string value2, 
            string name3, out string value3, 
            string name4, out string value4
        ) {
            names[0] = name0;
            names[1] = name1;
            names[2] = name2;
            names[3] = name3;
            names[4] = name4;
            ContextInfo ctxInfo = GetAttributes(required, 4, names, values);
            value0 = values[0];
            value1 = values[1];
            value2 = values[2];
            value3 = values[3];
            value4 = values[4];
            return ctxInfo;
        }

        public ContextInfo GetAttributes(int required, 
            string name0, out string value0, 
            string name1, out string value1, 
            string name2, out string value2, 
            string name3, out string value3,
            string name4, out string value4, 
            string name5, out string value5, 
            string name6, out string value6, 
            string name7, out string value7, 
            string name8, out string value8 
        ) {
            names[0] = name0;
            names[1] = name1;
            names[2] = name2;
            names[3] = name3;
            names[4] = name4;
            names[5] = name5;
            names[6] = name6;
            names[7] = name7;
            names[8] = name8;
            ContextInfo ctxInfo = GetAttributes(required, 9, names, values);
            value0 = values[0];
            value1 = values[1];
            value2 = values[2];
            value3 = values[3];
            value4 = values[4];
            value5 = values[5];
            value6 = values[6];
            value7 = values[7];
            value8 = values[8];
            return ctxInfo;
        }

        public ContextInfo GetAttributes(int required, 
            string name0, out string value0, 
            string name1, out string value1, 
            string name2, out string value2, 
            string name3, out string value3,
            string name4, out string value4, 
            string name5, out string value5, 
            string name6, out string value6, 
            string name7, out string value7, 
            string name8, out string value8, 
            string name9, out string value9
        ) {
            names[0] = name0;
            names[1] = name1;
            names[2] = name2;
            names[3] = name3;
            names[4] = name4;
            names[5] = name5;
            names[6] = name6;
            names[7] = name7;
            names[8] = name8;
            names[9] = name9;
            ContextInfo ctxInfo = GetAttributes(required, 10, names, values);
            value0 = values[0];
            value1 = values[1];
            value2 = values[2];
            value3 = values[3];
            value4 = values[4];
            value5 = values[5];
            value6 = values[6];
            value7 = values[7];
            value8 = values[8];
            value9 = values[9];
            return ctxInfo;
        }

        public ContextInfo GetAttributes(int required, 
            string name0, out string value0, 
            string name1, out string value1, 
            string name2, out string value2, 
            string name3, out string value3,
            string name4, out string value4, 
            string name5, out string value5, 
            string name6, out string value6, 
            string name7, out string value7, 
            string name8, out string value8, 
            string name9, out string value9,
            string name10, out string value10
        ) {
            names[0] = name0;
            names[1] = name1;
            names[2] = name2;
            names[3] = name3;
            names[4] = name4;
            names[5] = name5;
            names[6] = name6;
            names[7] = name7;
            names[8] = name8;
            names[9] = name9;
            names[10] = name10;
            ContextInfo ctxInfo = GetAttributes(required, 11, names, values);
            value0 = values[0];
            value1 = values[1];
            value2 = values[2];
            value3 = values[3];
            value4 = values[4];
            value5 = values[5];
            value6 = values[6];
            value7 = values[7];
            value8 = values[8];
            value9 = values[9];
            value10 = values[10];
            return ctxInfo;
        }

        private ContextInfo GetAttributes(int required, int number, string[] names, string[] values) {
            for(int i = 0; i < number; i ++) {
                values[i] = null;
            }
            string unknownAttribute = null;
            ContextInfo ctxInfo = new ContextInfo(this);
            if (this.MoveToFirstAttribute()) {
                do {
                    ctxInfo.AddAttribute(this);
                    bool found = false;
                    for(int i = 0; i < number; i ++) {
                        if (this.IsXsltAttribute(names[i])) {
                            found = true;
                            values[i] = this.Value;
                            if (Ref.Equal(names[i], Atoms.Version)) {
                                this.SetVersion(this.Value);
                            }
                            break;
                        }
                    }
                    if (! found && (this.IsNullNamespace() || this.IsXsltNamespace())) {
                        unknownAttribute = this.LocalName;
                    }
                } while(this.MoveToNextAttribute());
                this.MoveToElement();
                if (unknownAttribute != null && ! this.scopeManager.ForwardCompatibility) {
                    throw new XmlException("Element has an attribute that XSLT 1.0 does not allow the element to have");
                }
            }
            ctxInfo.Finish(this);
            for (int i = 0; i < required; i ++) {
                if (values[i] == null) {
                    throw new XmlException("SR.Xslt_MissingAttribute names[i]");
                }
            }
            return ctxInfo;
        }

        public ISourceLineInfo BuildLineInfo() {
            if (this.FileName == null) {
                return null;
            }
            return new SourceLineInfo((ISourceLineInfo) this);
        }

        public NsDecl BuildNamespaceList() {
            // Build namespace list of current node:
            NsDecl last = null;
            if (this.MoveToFirstNamespace()) {
                do {
                    last = new NsDecl(last, this.LocalName, this.Value);
                }while(this.MoveToNextNamespace());
                this.MoveToElement();
            }
            return last;
        }

        // ----------------------- ISourceLineInfo -----------------------
        public string FileName  { get { return this.reader != null ? this.reader.BaseURI : null; } }
        public int    StartLine { get { return this.reader != null ? ((IXmlLineInfo)this.reader).LineNumber   : -1; } }
        public int    StartPos  { get { return this.reader != null ? ((IXmlLineInfo)this.reader).LinePosition : -1; } }
        public int    EndLine   { get { return this.StartLine ; } }
        public int    EndPos    { get { return this.StartPos +  this.GetNameSize(); } }

        private int GetNameSize() {
            int nameSize = this.LocalName.Length;
            string prefix = this.Prefix;
            if (prefix.Length != 0) {
                return prefix.Length + 1 + nameSize; // + ':'
            }
            return nameSize; 
        }
        
        private class InputScopeManager {
            private enum ScopeFlags {
                ForwardCompatibility = 0x1,
                CanHaveApplyImports = 0x2,
                NsExtension = 0x4,
                
                InheretedFlags = ForwardCompatibility | CanHaveApplyImports,
            }
            private struct ScopeReord {
                public int        scopeCount;
                public ScopeFlags scopeFlags;
                public string     nsUri;
            }
           
            XmlNameTable nameTable;
            ScopeReord[] records = new ScopeReord[32];
            int lastRecord = 0;
            int lastScopes = 0;  // This is cash of records[lastRecord].scopeCount field;
                                // most often we will have PushScope()/PopScope pare over the same record.
                                // It has sence to avoid adresing this field through array access.

            public InputScopeManager(XmlNameTable nameTable) {
                this.nameTable = nameTable;
                records[0].scopeFlags = 0;
                PushScope();
            }

            public void PushScope() {
                lastScopes ++;
            }

            public void PopScope() {
                if (0 < lastScopes) {
                    lastScopes --;
                }
                else {
                    while(records[-- lastRecord].scopeCount == 0) ;
                    lastScopes = records[lastRecord].scopeCount;
                    lastScopes --;
                }
            }

            private void AddRecord() {
                records[lastRecord].scopeCount = lastScopes;
                lastRecord ++;
                if (lastRecord == records.Length) {
                    ScopeReord[] newRecords = new ScopeReord[lastRecord * 2];
                    Array.Copy(records, 0, newRecords, 0, lastRecord);
                    records = newRecords;
                }
                lastScopes = 0;
            }

            private void SetFlag(bool value, ScopeFlags flag) {
                Debug.Assert(flag == ScopeFlags.ForwardCompatibility || flag == ScopeFlags.CanHaveApplyImports);
                ScopeFlags lastFlags  =  records[lastRecord].scopeFlags;
                //         lastScopes == records[lastRecord].scopeCount; // we know this because we are cashing it.
                bool canReuseLastRecord = lastScopes == 0;                             // last record is from last scope
                if (! canReuseLastRecord) {
                    AddRecord();
                    lastFlags = lastFlags & ScopeFlags.InheretedFlags;
                }
                records[lastRecord].scopeFlags = value ? (lastFlags | flag) : (lastFlags & ~flag);
            }

            public bool ForwardCompatibility {
                get { return (records[lastRecord].scopeFlags & ScopeFlags.ForwardCompatibility) != 0; }
                set { SetFlag(value, ScopeFlags.ForwardCompatibility) ;}
            }

            public bool CanHaveApplyImports {
                get { return (records[lastRecord].scopeFlags & ScopeFlags.CanHaveApplyImports) != 0; }
                set { SetFlag(value, ScopeFlags.CanHaveApplyImports) ;}
            }

            public void AddExtensionNamespace(string uri) { 
                Debug.Assert(uri != null);

                uri = nameTable.Add(uri);

                ScopeFlags lastFlags  =  records[lastRecord].scopeFlags;
                //         lastScopes == records[lastRecord].scopeCount; // we know this because we are cashing it.
                bool canReuseLastRecord = (
                    lastScopes == 0 &&                                   // last record is from last scope
                    (lastFlags & ScopeFlags.NsExtension) == 0            // only flag fields are used in this record
                );
                if (! canReuseLastRecord) {
                    AddRecord();
                    lastFlags = lastFlags & ScopeFlags.InheretedFlags;
                }
                records[lastRecord].nsUri = uri;
                records[lastRecord].scopeFlags = lastFlags | ScopeFlags.NsExtension;
            }

            public bool IsExtensionNamespace(string nsUri) {
                for (int record = this.lastRecord; 0 <= record; record --) {
                    if (
                        (records[record].scopeFlags & ScopeFlags.NsExtension) != 0 &&
                        (records[record].nsUri == nsUri)
                    ) {
                        return true;
                    }
                }
                return false;
            }
        }

        // -------------------------------- ContextInfo ------------------------------------

#if ! NO_Qil_COMMENTS
        StringBuilder dbgCommentBuilder = new StringBuilder();
#endif

        public struct ContextInfo {
            public NsDecl          nsList;
            public string          dbgComment;
            public ISourceLineInfo lineInfo  ;

            public ContextInfo(XsltInput input) {
                this.nsList     = input.BuildNamespaceList();
                this.lineInfo   = input.BuildLineInfo();
#if ! NO_Qil_COMMENTS
                this.dbgComment = null;
                Debug.Assert(input.dbgCommentBuilder.Length == 0);
                input.dbgCommentBuilder.Append("<");
                if (input.Prefix.Length != 0) {
                    input.dbgCommentBuilder.Append(input.Prefix);
                    input.dbgCommentBuilder.Append(":");
                }
                input.dbgCommentBuilder.Append(input.LocalName);
#endif
            }

            public void AddAttribute(XsltInput input) {
#if ! NO_Qil_COMMENTS
                input.dbgCommentBuilder.Append(" ");
                if (input.Prefix.Length != 0) {
                    input.dbgCommentBuilder.Append(input.Prefix);
                    input.dbgCommentBuilder.Append(":");
                }
                input.dbgCommentBuilder.Append(input.LocalName);
                input.dbgCommentBuilder.Append("=\"");
                input.dbgCommentBuilder.Append(input.Value);
                input.dbgCommentBuilder.Append("\"");
#endif
            }

            public void Finish(XsltInput input) {
#if ! NO_Qil_COMMENTS
                input.dbgCommentBuilder.Append(input.IsEmptyElement ? "/>" : ">...");
                this.dbgComment = input.dbgCommentBuilder.ToString();
                input.dbgCommentBuilder.Length = 0;
#endif
            }
        }
    }
}
