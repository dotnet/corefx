<#@ template debug="true" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ Assembly Name="System.Core.dll" #>
<#@ Assembly Name="System.Xml.dll" #>
<#@ import namespace="System" #>

// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

// WARNING: This file is generated and should not be modified directly.
// Instead, modify XmlTextWriterGenerator.t4 and run the following commands:
//
//   TextTransform.exe -a '!!Classname!XmlUtf8RawTextWriter' XmlRawTextWriterGenerator.t4 -out XmlUtf8RawTextWriter.cs
//   TextTransform.exe -a '!!Classname!XmlEncodedRawTextWriter' XmlRawTextWriterGenerator.t4 -out XmlEncodedRawTextWriter.cs

<#
    string classname = Host.ResolveParameterValue(null, null, "Classname");
    bool isUtf8Writer = false;
    bool isEncodedWriter = false;
    string classnameIndent;
    string buffer;
    string bufferType;
    switch (classname)
    {
        case "XmlUtf8RawTextWriter":
            classnameIndent = "XmlUtf8RawTextWriterIndent";
            buffer = "bufBytes";
            bufferType = "byte";
            encodeCharBody = @"/* Surrogate character */
                            if (XmlCharType.IsSurrogate(ch)) {
                                pDst = EncodeSurrogate(pSrc, pSrcEnd, pDst);
                                pSrc += 2;
                            }
                            /* Invalid XML character */
                            else if (ch <= 0x7F || ch >= 0xFFFE) {
                                pDst = InvalidXmlChar(ch, pDst, _entitizeInvalidChars_);
                                pSrc++;
                            }
                            /* Multibyte UTF8 character */
                            else {
                                pDst = EncodeMultibyteUTF8(ch, pDst);
                                pSrc++;
                            }";
            setTextContentMarkBody = "";
            isUtf8Writer = true;
            break;
        case "XmlEncodedRawTextWriter":
            classnameIndent = "XmlEncodedRawTextWriterIndent";
            buffer = "bufChars";
            bufferType = "char";
            encodeCharBody = @"/* Surrogate character */
                            if (XmlCharType.IsSurrogate(ch)) {
                                pDst = EncodeSurrogate(pSrc, pSrcEnd, pDst);
                                pSrc += 2;
                            }
                            /* Invalid XML character */
                            else  if (ch <= 0x7F || ch >= 0xFFFE) {
                                pDst = InvalidXmlChar(ch, pDst, _entitizeInvalidChars_);
                                pSrc++;
                            }
                            /* Other character between SurLowEnd and 0xFFFE */
                            else {
                                *pDst = (char)ch;
                                pDst++;
                                pSrc++;
                            }";
            setTextContentMarkBody = @"
            if (trackTextContent && inTextContent != _value_) {
                ChangeTextContentMark(_value_);
            }";
            isEncodedWriter = true;
            break;
        default:
            throw new ArgumentOutOfRangeException(
                "Classname", classname,
                "Unknown value for Classname.");
    }
#>

using System;
using System.IO;
using System.Xml;
using System.Text;
using System.Diagnostics;
using System.Globalization;

namespace System.Xml
{
    // Concrete implementation of XmlWriter abstract class that serializes events as encoded XML
    // text.  The general-purpose XmlEncodedTextWriter uses the Encoder class to output to any
    // encoding.  The XmlUtf8TextWriter class combined the encoding operation with serialization
    // in order to achieve better performance.
    internal partial class <#= classname #> : XmlRawWriter
    {
        //
        // Fields
        //
        private readonly bool _useAsync;

        // main buffer
        protected byte[] bufBytes;

        // output stream
        protected Stream stream;

        // encoding of the stream or text writer
        protected Encoding encoding;

        // char type tables
        protected XmlCharType xmlCharType = XmlCharType.Instance;

        // buffer positions
        protected int bufPos = 1;     // buffer position starts at 1, because we need to be able to safely step back -1 in case we need to
                                      // close an empty element or in CDATA section detection of double ]; <#= buffer #>[0] will always be 0
        protected int textPos = 1;    // text end position; don't indent first element, pi, or comment
        protected int contentPos;     // element content end position
        protected int cdataPos;       // cdata end position
        protected int attrEndPos;     // end of the last attribute
        protected int bufLen = BUFSIZE;

        // flags
        protected bool writeToNull;
        protected bool hadDoubleBracket;
        protected bool inAttributeValue;

<# if (isEncodedWriter) { #>
        protected int bufBytesUsed;
        protected char[] bufChars;

        // encoder for encoding chars in specified encoding when writing to stream
        protected Encoder encoder;

        // output text writer
        protected TextWriter writer;

        // escaping of characters invalid in the output encoding
        protected bool trackTextContent;
        protected bool inTextContent;
        private int _lastMarkPos;
        private int[] _textContentMarks;   // even indices contain text content start positions
                                           // odd indices contain markup start positions
        private CharEntityEncoderFallback _charEntityFallback;
<# } #>

        // writer settings
        protected NewLineHandling newLineHandling;
        protected bool closeOutput;
        protected bool omitXmlDeclaration;
        protected string newLineChars;
        protected bool checkCharacters;

        protected XmlStandalone standalone;
        protected XmlOutputMethod outputMethod;

        protected bool autoXmlDeclaration;
        protected bool mergeCDataSections;

        //
        // Constants
        //
        private const int BUFSIZE = 2048 * 3;       // Should be greater than default FileStream size (4096), otherwise the FileStream will try to cache the data
        private const int ASYNCBUFSIZE = 64 * 1024; // Set async buffer size to 64KB
        private const int OVERFLOW = 32;            // Allow overflow in order to reduce checks when writing out constant size markup
        private const int INIT_MARKS_COUNT = 64;

        //
        // Constructors
        //
        // Construct and initialize an instance of this class.
        protected <#= classname #>(XmlWriterSettings settings)
        {
            _useAsync = settings.Async;

            // copy settings
            newLineHandling = settings.NewLineHandling;
            omitXmlDeclaration = settings.OmitXmlDeclaration;
            newLineChars = settings.NewLineChars;
            checkCharacters = settings.CheckCharacters;
            closeOutput = settings.CloseOutput;

            standalone = settings.Standalone;
            outputMethod = settings.OutputMethod;
            mergeCDataSections = settings.MergeCDataSections;

            if (checkCharacters && newLineHandling == NewLineHandling.Replace)
            {
                ValidateContentChars(newLineChars, "NewLineChars", false);
            }
        }

<# if (isEncodedWriter) { #>
        // Construct an instance of this class that outputs text to the TextWriter interface.
        public <#= classname #>(TextWriter writer, XmlWriterSettings settings) : this(settings)
        {
            Debug.Assert(writer != null && settings != null);

            this.writer = writer;
            this.encoding = writer.Encoding;
            // the buffer is allocated will OVERFLOW in order to reduce checks when writing out constant size markup
            if (settings.Async)
            {
                bufLen = ASYNCBUFSIZE;
            }
            this.bufChars = new <#= bufferType #>[bufLen + OVERFLOW];

            // Write the xml declaration
            if (settings.AutoXmlDeclaration)
            {
                WriteXmlDeclaration(standalone);
                autoXmlDeclaration = true;
            }
        }
<# } #>

        // Construct an instance of this class that serializes to a Stream interface.
        public <#= classname #>(Stream stream, XmlWriterSettings settings) : this(settings)
        {
            Debug.Assert(stream != null && settings != null);

            this.stream = stream;
            this.encoding = settings.Encoding;

            // the buffer is allocated will OVERFLOW in order to reduce checks when writing out constant size markup
            if (settings.Async)
            {
                bufLen = ASYNCBUFSIZE;
            }

            <#= buffer #> = new <#= bufferType #>[bufLen + OVERFLOW];

<# if (isUtf8Writer) { #>
            // Output UTF-8 byte order mark if Encoding object wants it
            if (!stream.CanSeek || stream.Position == 0)
            {
                ReadOnlySpan<byte> bom = encoding.Preamble;
                if (bom.Length != 0)
                {
                    bom.CopyTo(new Span<byte>(bufBytes).Slice(1));
                    bufPos += bom.Length;
                    textPos += bom.Length;
                }
        }
<# } else { #>
            bufBytes = new byte[bufChars.Length];
            bufBytesUsed = 0;

            // Init escaping of characters not fitting into the target encoding
            trackTextContent = true;
            inTextContent = false;
            _lastMarkPos = 0;
            _textContentMarks = new int[INIT_MARKS_COUNT];
            _textContentMarks[0] = 1;

            _charEntityFallback = new CharEntityEncoderFallback();

            // grab bom before possibly changing encoding settings
            ReadOnlySpan<byte> bom = encoding.Preamble;

            // the encoding instance this creates can differ from the one passed in
            this.encoding = Encoding.GetEncoding(
                settings.Encoding.CodePage,
                _charEntityFallback,
                settings.Encoding.DecoderFallback);

            encoder = encoding.GetEncoder();

            if (!stream.CanSeek || stream.Position == 0)
            {
                if (bom.Length != 0)
                {
                    this.stream.Write(bom);
                }
            }
<# } #>

            // Write the xml declaration
            if (settings.AutoXmlDeclaration)
            {
                WriteXmlDeclaration(standalone);
                autoXmlDeclaration = true;
            }
        }

        //
        // XmlWriter implementation
        //
        // Returns settings the writer currently applies.
        public override XmlWriterSettings Settings
        {
            get
            {
                XmlWriterSettings settings = new XmlWriterSettings();

                settings.Encoding = this.encoding;
                settings.OmitXmlDeclaration = this.omitXmlDeclaration;
                settings.NewLineHandling = this.newLineHandling;
                settings.NewLineChars = this.newLineChars;
                settings.CloseOutput = this.closeOutput;
                settings.ConformanceLevel = ConformanceLevel.Auto;
                settings.CheckCharacters = checkCharacters;

                settings.AutoXmlDeclaration = autoXmlDeclaration;
                settings.Standalone = standalone;
                settings.OutputMethod = outputMethod;

                settings.ReadOnly = true;
                return settings;
            }
        }

        // Write the xml declaration.  This must be the first call.
        internal override void WriteXmlDeclaration(XmlStandalone standalone)
        {
            // Output xml declaration only if user allows it and it was not already output
            if (!omitXmlDeclaration && !autoXmlDeclaration)
            {
                <#= SetTextContentMark(false) #>

                RawText("<?xml version=\"");

                // Version
                RawText("1.0");

                // Encoding
                if (encoding != null)
                {
                    RawText("\" encoding=\"");
                    RawText(encoding.WebName);
                }

                // Standalone
                if (standalone != XmlStandalone.Omit)
                {
                    RawText("\" standalone=\"");
                    RawText(standalone == XmlStandalone.Yes ? "yes" : "no");
                }

                RawText("\"?>");
            }
        }

        internal override void WriteXmlDeclaration(string xmldecl)
        {
            // Output xml declaration only if user allows it and it was not already output
            if (!omitXmlDeclaration && !autoXmlDeclaration)
            {
                WriteProcessingInstruction("xml", xmldecl);
            }
        }

        // Serialize the document type declaration.
        public override void WriteDocType(string name, string pubid, string sysid, string subset)
        {
            Debug.Assert(name != null && name.Length > 0);

            <#= SetTextContentMark(false) #>

            RawText("<!DOCTYPE ");
            RawText(name);
            if (pubid != null)
            {
                RawText(" PUBLIC \"");
                RawText(pubid);
                RawText("\" \"");
                if (sysid != null)
                {
                    RawText(sysid);
                }
                <#= buffer #>[bufPos++] = (<#= bufferType #>)'"';
            }
            else if (sysid != null)
            {
                RawText(" SYSTEM \"");
                RawText(sysid);
                <#= buffer #>[bufPos++] = (<#= bufferType #>)'"';
            }
            else
            {
                <#= buffer #>[bufPos++] = (<#= bufferType #>)' ';
            }

            if (subset != null)
            {
                <#= buffer #>[bufPos++] = (<#= bufferType #>)'[';
                RawText(subset);
                <#= buffer #>[bufPos++] = (<#= bufferType #>)']';
            }

            <#= buffer #>[this.bufPos++] = (<#= bufferType #>)'>';
        }

        // Serialize the beginning of an element start tag: "<prefix:localName"
        public override void WriteStartElement(string prefix, string localName, string ns)
        {
            Debug.Assert(localName != null && localName.Length > 0);
            Debug.Assert(prefix != null);

            <#= SetTextContentMark(false) #>

            <#= buffer #>[bufPos++] = (<#= bufferType #>)'<';
            if (prefix != null && prefix.Length != 0)
            {
                RawText(prefix);
                <#= buffer #>[this.bufPos++] = (<#= bufferType #>)':';
            }

            RawText(localName);

            attrEndPos = bufPos;
        }

        // Serialize the end of an element start tag in preparation for content serialization: ">"
        internal override void StartElementContent()
        {
            <#= buffer #>[bufPos++] = (<#= bufferType #>)'>';

            // StartElementContent is always called; therefore, in order to allow shortcut syntax, we save the
            // position of the '>' character.  If WriteEndElement is called and no other characters have been
            // output, then the '>' character can be overwritten with the shortcut syntax " />".
            contentPos = bufPos;
        }

        // Serialize an element end tag: "</prefix:localName>", if content was output.  Otherwise, serialize
        // the shortcut syntax: " />".
        internal override void WriteEndElement(string prefix, string localName, string ns)
        {
            Debug.Assert(localName != null && localName.Length > 0);
            Debug.Assert(prefix != null);

            <#= SetTextContentMark(false) #>

            if (contentPos != bufPos)
            {
                // Content has been output, so can't use shortcut syntax
                <#= buffer #>[bufPos++] = (<#= bufferType #>)'<';
                <#= buffer #>[bufPos++] = (<#= bufferType #>)'/';

                if (prefix != null && prefix.Length != 0)
                {
                    RawText(prefix);
                    <#= buffer #>[bufPos++] = (<#= bufferType #>)':';
                }
                RawText(localName);
                <#= buffer #>[bufPos++] = (<#= bufferType #>)'>';
            }
            else
            {
                // Use shortcut syntax; overwrite the already output '>' character
                bufPos--;
                <#= buffer #>[bufPos++] = (<#= bufferType #>)' ';
                <#= buffer #>[bufPos++] = (<#= bufferType #>)'/';
                <#= buffer #>[bufPos++] = (<#= bufferType #>)'>';
            }
        }

        // Serialize a full element end tag: "</prefix:localName>"
        internal override void WriteFullEndElement(string prefix, string localName, string ns)
        {
            Debug.Assert(localName != null && localName.Length > 0);
            Debug.Assert(prefix != null);

            <#= SetTextContentMark(false) #>

            <#= buffer #>[bufPos++] = (<#= bufferType #>)'<';
            <#= buffer #>[bufPos++] = (<#= bufferType #>)'/';

            if (prefix != null && prefix.Length != 0)
            {
                RawText(prefix);
                <#= buffer #>[bufPos++] = (<#= bufferType #>)':';
            }
            RawText(localName);
            <#= buffer #>[bufPos++] = (<#= bufferType #>)'>';
        }

        // Serialize an attribute tag using double quotes around the attribute value: 'prefix:localName="'
        public override void WriteStartAttribute(string prefix, string localName, string ns)
        {
            Debug.Assert(localName != null && localName.Length > 0);
            Debug.Assert(prefix != null);

            <#= SetTextContentMark(false) #>

            if (attrEndPos == bufPos)
            {
                <#= buffer #>[bufPos++] = (<#= bufferType #>)' ';
            }

            if (prefix != null && prefix.Length > 0)
            {
                RawText(prefix);
                <#= buffer #>[bufPos++] = (<#= bufferType #>)':';
            }
            RawText(localName);
            <#= buffer #>[bufPos++] = (<#= bufferType #>)'=';
            <#= buffer #>[bufPos++] = (<#= bufferType #>)'"';

            inAttributeValue = true;
        }

        // Serialize the end of an attribute value using double quotes: '"'
        public override void WriteEndAttribute()
        {
            <#= SetTextContentMark(false) #>
            <#= buffer #>[bufPos++] = (<#= bufferType #>)'"';
            inAttributeValue = false;
            attrEndPos = bufPos;
        }

        internal override void WriteNamespaceDeclaration(string prefix, string namespaceName)
        {
            Debug.Assert(prefix != null && namespaceName != null);

            this.WriteStartNamespaceDeclaration(prefix);
            this.WriteString(namespaceName);
            this.WriteEndNamespaceDeclaration();
        }

        internal override bool SupportsNamespaceDeclarationInChunks
        {
            get
            {
                return true;
            }
        }

        internal override void WriteStartNamespaceDeclaration(string prefix)
        {
            Debug.Assert(prefix != null);

            <#= SetTextContentMark(false) #>

            if (prefix.Length == 0)
            {
                RawText(" xmlns=\"");
            }
            else
            {
                RawText(" xmlns:");
                RawText(prefix);
                <#= buffer #>[bufPos++] = (<#= bufferType #>)'=';
                <#= buffer #>[bufPos++] = (<#= bufferType #>)'"';
            }

            inAttributeValue = true;
            <#= SetTextContentMark(true) #>
        }

        internal override void WriteEndNamespaceDeclaration()
        {
            <#= SetTextContentMark(false) #>
            inAttributeValue = false;

            <#= buffer #>[bufPos++] = (<#= bufferType #>)'"';
            attrEndPos = bufPos;
        }

        // Serialize a CData section.  If the "]]>" pattern is found within
        // the text, replace it with "]]><![CDATA[>".
        public override void WriteCData(string text)
        {
            Debug.Assert(text != null);

            <#= SetTextContentMark(false) #>

            if (mergeCDataSections && bufPos == cdataPos)
            {
                // Merge adjacent cdata sections - overwrite the "]]>" characters
                Debug.Assert(bufPos >= 4);
                bufPos -= 3;
            }
            else
            {
                // Start a new cdata section
                <#= buffer #>[bufPos++] = (<#= bufferType #>)'<';
                <#= buffer #>[bufPos++] = (<#= bufferType #>)'!';
                <#= buffer #>[bufPos++] = (<#= bufferType #>)'[';
                <#= buffer #>[bufPos++] = (<#= bufferType #>)'C';
                <#= buffer #>[bufPos++] = (<#= bufferType #>)'D';
                <#= buffer #>[bufPos++] = (<#= bufferType #>)'A';
                <#= buffer #>[bufPos++] = (<#= bufferType #>)'T';
                <#= buffer #>[bufPos++] = (<#= bufferType #>)'A';
                <#= buffer #>[bufPos++] = (<#= bufferType #>)'[';
            }

            WriteCDataSection(text);

            <#= buffer #>[bufPos++] = (<#= bufferType #>)']';
            <#= buffer #>[bufPos++] = (<#= bufferType #>)']';
            <#= buffer #>[bufPos++] = (<#= bufferType #>)'>';

            textPos = bufPos;
            cdataPos = bufPos;
        }

        // Serialize a comment.
        public override void WriteComment(string text)
        {
            Debug.Assert(text != null);

            <#= SetTextContentMark(false) #>

            <#= buffer #>[bufPos++] = (<#= bufferType #>)'<';
            <#= buffer #>[bufPos++] = (<#= bufferType #>)'!';
            <#= buffer #>[bufPos++] = (<#= bufferType #>)'-';
            <#= buffer #>[bufPos++] = (<#= bufferType #>)'-';

            WriteCommentOrPi(text, '-');

            <#= buffer #>[bufPos++] = (<#= bufferType #>)'-';
            <#= buffer #>[bufPos++] = (<#= bufferType #>)'-';
            <#= buffer #>[bufPos++] = (<#= bufferType #>)'>';
        }

        // Serialize a processing instruction.
        public override void WriteProcessingInstruction(string name, string text)
        {
            Debug.Assert(name != null && name.Length > 0);
            Debug.Assert(text != null);

            <#= SetTextContentMark(false) #>

            <#= buffer #>[bufPos++] = (<#= bufferType #>)'<';
            <#= buffer #>[bufPos++] = (<#= bufferType #>)'?';
            RawText(name);

            if (text.Length > 0)
            {
                <#= buffer #>[bufPos++] = (<#= bufferType #>)' ';
                WriteCommentOrPi(text, '?');
            }

            <#= buffer #>[bufPos++] = (<#= bufferType #>)'?';
            <#= buffer #>[bufPos++] = (<#= bufferType #>)'>';
        }

        // Serialize an entity reference.
        public override void WriteEntityRef(string name)
        {
            Debug.Assert(name != null && name.Length > 0);

            <#= SetTextContentMark(false) #>

            <#= buffer #>[bufPos++] = (<#= bufferType #>)'&';
            RawText(name);
            <#= buffer #>[bufPos++] = (<#= bufferType #>)';';

            if (bufPos > bufLen)
            {
                FlushBuffer();
            }

            textPos = bufPos;
        }

        // Serialize a character entity reference.
        public override void WriteCharEntity(char ch)
        {
            string strVal = ((int)ch).ToString("X", NumberFormatInfo.InvariantInfo);

            if (checkCharacters && !xmlCharType.IsCharData(ch))
            {
                // we just have a single char, not a surrogate, therefore we have to pass in '\0' for the second char
                throw XmlConvert.CreateInvalidCharException(ch, '\0');
            }

            <#= SetTextContentMark(false) #>

            <#= buffer #>[bufPos++] = (<#= bufferType #>)'&';
            <#= buffer #>[bufPos++] = (<#= bufferType #>)'#';
            <#= buffer #>[bufPos++] = (<#= bufferType #>)'x';
            RawText(strVal);
            <#= buffer #>[bufPos++] = (<#= bufferType #>)';';

            if (bufPos > bufLen)
            {
                FlushBuffer();
            }

            textPos = bufPos;
        }

        // Serialize a whitespace node.

        public override unsafe void WriteWhitespace(string ws)
        {
            Debug.Assert(ws != null);
            <#= SetTextContentMark(false) #>

            fixed (char* pSrc = ws)
            {
                char* pSrcEnd = pSrc + ws.Length;
                if (inAttributeValue)
                {
                    WriteAttributeTextBlock(pSrc, pSrcEnd);
                }
                else
                {
                    WriteElementTextBlock(pSrc, pSrcEnd);
                }
            }
        }

        // Serialize either attribute or element text using XML rules.

        public override unsafe void WriteString(string text)
        {
            Debug.Assert(text != null);
            <#= SetTextContentMark(true) #>

            fixed (char* pSrc = text)
            {
                char* pSrcEnd = pSrc + text.Length;
                if (inAttributeValue)
                {
                    WriteAttributeTextBlock(pSrc, pSrcEnd);
                }
                else
                {
                    WriteElementTextBlock(pSrc, pSrcEnd);
                }
            }
        }

        // Serialize surrogate character entity.
        public override void WriteSurrogateCharEntity(char lowChar, char highChar)
        {
            <#= SetTextContentMark(false) #>
            int surrogateChar = XmlCharType.CombineSurrogateChar(lowChar, highChar);

            <#= buffer #>[bufPos++] = (<#= bufferType #>)'&';
            <#= buffer #>[bufPos++] = (<#= bufferType #>)'#';
            <#= buffer #>[bufPos++] = (<#= bufferType #>)'x';
            RawText(surrogateChar.ToString("X", NumberFormatInfo.InvariantInfo));
            <#= buffer #>[bufPos++] = (<#= bufferType #>)';';
            textPos = bufPos;
        }

        // Serialize either attribute or element text using XML rules.
        // Arguments are validated in the XmlWellformedWriter layer.

        public override unsafe void WriteChars(char[] buffer, int index, int count)
        {
            Debug.Assert(buffer != null);
            Debug.Assert(index >= 0);
            Debug.Assert(count >= 0 && index + count <= buffer.Length);

            <#= SetTextContentMark(true) #>

            fixed (char* pSrcBegin = &buffer[index])
            {
                if (inAttributeValue)
                {
                    WriteAttributeTextBlock(pSrcBegin, pSrcBegin + count);
                }
                else
                {
                    WriteElementTextBlock(pSrcBegin, pSrcBegin + count);
                }
            }
        }

        // Serialize raw data.
        // Arguments are validated in the XmlWellformedWriter layer

        public override unsafe void WriteRaw(char[] buffer, int index, int count)
        {
            Debug.Assert(buffer != null);
            Debug.Assert(index >= 0);
            Debug.Assert(count >= 0 && index + count <= buffer.Length);

            <#= SetTextContentMark(false) #>

            fixed (char* pSrcBegin = &buffer[index])
            {
                WriteRawWithCharChecking(pSrcBegin, pSrcBegin + count);
            }

            textPos = bufPos;
        }

        // Serialize raw data.

        public override unsafe void WriteRaw(string data)
        {
            Debug.Assert(data != null);

            <#= SetTextContentMark(false) #>

            fixed (char* pSrcBegin = data)
            {
                WriteRawWithCharChecking(pSrcBegin, pSrcBegin + data.Length);
            }

            textPos = bufPos;
        }

        // Flush all bytes in the buffer to output and close the output stream or writer.
        public override void Close()
        {
            try
            {
                FlushBuffer();
                FlushEncoder();
            }
            finally
            {
                // Future calls to Close or Flush shouldn't write to Stream or Writer
                writeToNull = true;

                if (stream != null)
                {
                    try
                    {
                        stream.Flush();
                    }
                    finally
                    {
                        try
                        {
                            if (closeOutput)
                            {
                                stream.Dispose();
                            }
                        }
                        finally
                        {
                            stream = null;
                        }
                    }
                }
<# if (isEncodedWriter) { #>
                else if (writer != null)
                {
                    try
                    {
                        writer.Flush();
                    }
                    finally
                    {
                        try
                        {
                            if (closeOutput)
                            {
                                writer.Dispose();
                            }
                        }
                        finally
                        {
                            writer = null;
                        }
                    }
                }
<# } #>
            }
        }

        // Flush all characters in the buffer to output and call Flush() on the output object.
        public override void Flush()
        {
            FlushBuffer();
            FlushEncoder();
<# if (isUtf8Writer) { #>
            if (stream != null)
            {
                stream.Flush();
            }
<# } else { #>
            if (stream != null)
            {
                stream.Flush();
            }
            else if (writer != null)
            {
                writer.Flush();
            }
<# } #>
        }

        //
        // Implementation methods
        //
        // Flush all characters in the buffer to output.  Do not flush the output object.
        protected virtual void FlushBuffer()
        {
            try
            {
                // Output all characters (except for previous characters stored at beginning of buffer)
                if (!writeToNull)
                {
<# if (isUtf8Writer) { #>
                    Debug.Assert(stream != null);
                    stream.Write(<#= buffer #>, 1, bufPos - 1);
<# } else { #>
                    Debug.Assert(stream != null || writer != null);

                    if (stream != null)
                    {
                        if (trackTextContent)
                        {
                            _charEntityFallback.Reset(_textContentMarks, _lastMarkPos);
                            // reset text content tracking

                            if ((_lastMarkPos & 1) != 0)
                            {
                                // If the previous buffer ended inside a text content we need to preserve that info
                                //   which means the next index to which we write has to be even
                                _textContentMarks[1] = 1;
                                _lastMarkPos = 1;
                            }
                            else
                            {
                                _lastMarkPos = 0;
                            }
                            Debug.Assert(_textContentMarks[0] == 1);
                        }
                        EncodeChars(1, bufPos, true);
                    }
                    else
                    {
                        // Write text to TextWriter
                        writer.Write(<#= buffer #>, 1, bufPos - 1);
                    }
<# } #>
                }
            }
            catch
            {
                // Future calls to flush (i.e. when Close() is called) don't attempt to write to stream
                writeToNull = true;
                throw;
            }
            finally
            {
                // Move last buffer character to the beginning of the buffer (so that previous character can always be determined)
                <#= buffer #>[0] = <#= buffer #>[bufPos - 1];

<# if (isUtf8Writer) { #>
                if (IsSurrogateByte(<#= buffer #>[0]))
                {
                    // Last character was the first byte in a surrogate encoding, so move last three
                    // bytes of encoding to the beginning of the buffer.
                    <#= buffer #>[1] = <#= buffer #>[bufPos];
                    <#= buffer #>[2] = <#= buffer #>[bufPos + 1];
                    <#= buffer #>[3] = <#= buffer #>[bufPos + 2];
                }
<# } #>

                // Reset buffer position
                textPos = (textPos == bufPos) ? 1 : 0;
                attrEndPos = (attrEndPos == bufPos) ? 1 : 0;
                contentPos = 0;    // Needs to be zero, since overwriting '>' character is no longer possible
                cdataPos = 0;      // Needs to be zero, since overwriting ']]>' characters is no longer possible
                bufPos = 1;        // Buffer position starts at 1, because we need to be able to safely step back -1 in case we need to
                                   // close an empty element or in CDATA section detection of double ]; <#= buffer #>[0] will always be 0
            }
        }

<# if (isUtf8Writer) { #>
        private void FlushEncoder()
        {
            // intentionally empty

        }
<# } else { #>
        private void EncodeChars(int startOffset, int endOffset, bool writeAllToStream)
        {
            // Write encoded text to stream
            int chEnc;
            int bEnc;
            bool completed;
            while (startOffset < endOffset)
            {
                if (_charEntityFallback != null)
                {
                    _charEntityFallback.StartOffset = startOffset;
                }
                encoder.Convert(<#= buffer #>, startOffset, endOffset - startOffset, bufBytes, bufBytesUsed, bufBytes.Length - bufBytesUsed, false, out chEnc, out bEnc, out completed);
                startOffset += chEnc;
                bufBytesUsed += bEnc;
                if (bufBytesUsed >= (bufBytes.Length - 16))
                {
                    stream.Write(bufBytes, 0, bufBytesUsed);
                    bufBytesUsed = 0;
                }
            }
            if (writeAllToStream && bufBytesUsed > 0)
            {
                stream.Write(bufBytes, 0, bufBytesUsed);
                bufBytesUsed = 0;
            }
        }

        private void FlushEncoder()
        {
            Debug.Assert(bufPos == 1);
            if (stream != null)
            {
                int chEnc;
                int bEnc;
                bool completed;
                // decode no chars, just flush
                encoder.Convert(<#= buffer #>, 1, 0, bufBytes, 0, bufBytes.Length, true, out chEnc, out bEnc, out completed);
                if (bEnc != 0)
                {
                    stream.Write(bufBytes, 0, bEnc);
                }
            }
        }
<# } #>

        // Serialize text that is part of an attribute value.  The '&', '<', '>', and '"' characters
        // are entitized.
        protected unsafe void WriteAttributeTextBlock(char* pSrc, char* pSrcEnd)
        {
            fixed (<#= bufferType #>* pDstBegin = <#= buffer #>)
            {
                <#= bufferType #>* pDst = pDstBegin + this.bufPos;

                int ch = 0;
                for (;;)
                {
                    <#= bufferType #>* pDstEnd = pDst + (pSrcEnd - pSrc);
                    if (pDstEnd > pDstBegin + bufLen)
                    {
                        pDstEnd = pDstBegin + bufLen;
                    }

<# if (isUtf8Writer) { #>
                    while (pDst < pDstEnd && (xmlCharType.IsAttributeValueChar((char)(ch = *pSrc)) && ch <= 0x7F))
<# } else { #>
                    while (pDst < pDstEnd && xmlCharType.IsAttributeValueChar((char)(ch = *pSrc)))
<# } #>
                    {
                        *pDst = (<#= bufferType #>)ch;
                        pDst++;
                        pSrc++;
                    }
                    Debug.Assert(pSrc <= pSrcEnd);

                    // end of value
                    if (pSrc >= pSrcEnd)
                    {
                        break;
                    }

                    // end of buffer
                    if (pDst >= pDstEnd)
                    {
                        bufPos = (int)(pDst - pDstBegin);
                        FlushBuffer();
                        pDst = pDstBegin + 1;
                        continue;
                    }

                    // some character needs to be escaped
                    switch (ch)
                    {
                        case '&':
                            pDst = AmpEntity(pDst);
                            break;
                        case '<':
                            pDst = LtEntity(pDst);
                            break;
                        case '>':
                            pDst = GtEntity(pDst);
                            break;
                        case '"':
                            pDst = QuoteEntity(pDst);
                            break;
                        case '\'':
                            *pDst = (<#= bufferType #>)ch;
                            pDst++;
                            break;
                        case (char)0x9:
                            if (newLineHandling == NewLineHandling.None)
                            {
                                *pDst = (<#= bufferType #>)ch;
                                pDst++;
                            }
                            else
                            {
                                // escape tab in attributes
                                pDst = TabEntity(pDst);
                            }
                            break;
                        case (char)0xD:
                            if (newLineHandling == NewLineHandling.None)
                            {
                                *pDst = (<#= bufferType #>)ch;
                                pDst++;
                            }
                            else
                            {
                                // escape new lines in attributes
                                pDst = CarriageReturnEntity(pDst);
                            }
                            break;
                        case (char)0xA:
                            if (newLineHandling == NewLineHandling.None)
                            {
                                *pDst = (<#= bufferType #>)ch;
                                pDst++;
                            }
                            else
                            {
                                // escape new lines in attributes
                                pDst = LineFeedEntity(pDst);
                            }
                            break;
                        default:
                            <#= EncodeChar(true) #>
                            continue;
                    }
                    pSrc++;
                }
                bufPos = (int)(pDst - pDstBegin);
            }
        }

        // Serialize text that is part of element content.  The '&', '<', and '>' characters
        // are entitized.
        protected unsafe void WriteElementTextBlock(char* pSrc, char* pSrcEnd)
        {
            fixed (<#= bufferType #>* pDstBegin = <#= buffer #>)
            {
                <#= bufferType #>* pDst = pDstBegin + this.bufPos;

                int ch = 0;
                for (;;)
                {
                    <#= bufferType #>* pDstEnd = pDst + (pSrcEnd - pSrc);
                    if (pDstEnd > pDstBegin + bufLen)
                    {
                        pDstEnd = pDstBegin + bufLen;
                    }

<# if (isUtf8Writer) { #>
                    while (pDst < pDstEnd && (xmlCharType.IsAttributeValueChar((char)(ch = *pSrc)) && ch <= 0x7F))
<# } else { #>
                    while (pDst < pDstEnd && xmlCharType.IsAttributeValueChar((char)(ch = *pSrc)))
<# } #>
                    {
                        *pDst = (<#= bufferType #>)ch;
                        pDst++;
                        pSrc++;
                    }
                    Debug.Assert(pSrc <= pSrcEnd);

                    // end of value
                    if (pSrc >= pSrcEnd)
                    {
                        break;
                    }

                    // end of buffer
                    if (pDst >= pDstEnd)
                    {
                        bufPos = (int)(pDst - pDstBegin);
                        FlushBuffer();
                        pDst = pDstBegin + 1;
                        continue;
                    }

                    // some character needs to be escaped
                    switch (ch)
                    {
                        case '&':
                            pDst = AmpEntity(pDst);
                            break;
                        case '<':
                            pDst = LtEntity(pDst);
                            break;
                        case '>':
                            pDst = GtEntity(pDst);
                            break;
                        case '"':
                        case '\'':
                        case (char)0x9:
                            *pDst = (<#= bufferType #>)ch;
                            pDst++;
                            break;
                        case (char)0xA:
                            if (newLineHandling == NewLineHandling.Replace)
                            {
                                pDst = WriteNewLine(pDst);
                            }
                            else
                            {
                                *pDst = (<#= bufferType #>)ch;
                                pDst++;
                            }
                            break;
                        case (char)0xD:
                            switch (newLineHandling)
                            {
                                case NewLineHandling.Replace:
                                    // Replace "\r\n", or "\r" with NewLineChars
                                    if (pSrc + 1 < pSrcEnd && pSrc[1] == '\n')
                                    {
                                        pSrc++;
                                    }

                                    pDst = WriteNewLine(pDst);
                                    break;

                                case NewLineHandling.Entitize:
                                    // Entitize 0xD
                                    pDst = CarriageReturnEntity(pDst);
                                    break;
                                case NewLineHandling.None:
                                    *pDst = (<#= bufferType #>)ch;
                                    pDst++;
                                    break;
                            }
                            break;
                        default:
                            <#= EncodeChar(true) #>
                            continue;
                    }
                    pSrc++;
                }
                bufPos = (int)(pDst - pDstBegin);
                textPos = bufPos;
                contentPos = 0;
            }
        }

        protected unsafe void RawText(string s)
        {
            Debug.Assert(s != null);

            fixed (char* pSrcBegin = s)
            {
                RawText(pSrcBegin, pSrcBegin + s.Length);
            }
        }

        protected unsafe void RawText(char* pSrcBegin, char* pSrcEnd)
        {
            fixed (<#= bufferType #>* pDstBegin = <#= buffer #>)
            {
                <#= bufferType #>* pDst = pDstBegin + this.bufPos;
                char* pSrc = pSrcBegin;

                int ch = 0;
                for (;;)
                {
                    <#= bufferType #>* pDstEnd = pDst + (pSrcEnd - pSrc);
                    if (pDstEnd > pDstBegin + this.bufLen)
                    {
                        pDstEnd = pDstBegin + this.bufLen;
                    }

<# if (isUtf8Writer) { #>
                    while (pDst < pDstEnd && ((ch = *pSrc) <= 0x7F))
<# } else { #>
                    while (pDst < pDstEnd && ((ch = *pSrc) < XmlCharType.SurHighStart))
<# } #>
                    {
                        pSrc++;
                        *pDst = (<#= bufferType #>)ch;
                        pDst++;
                    }
                    Debug.Assert(pSrc <= pSrcEnd);

                    // end of value
                    if (pSrc >= pSrcEnd)
                    {
                        break;
                    }

                    // end of buffer
                    if (pDst >= pDstEnd)
                    {
                        bufPos = (int)(pDst - pDstBegin);
                        FlushBuffer();
                        pDst = pDstBegin + 1;
                        continue;
                    }

                    <#= EncodeChar(false) #>
                }

                bufPos = (int)(pDst - pDstBegin);
            }
        }

        protected unsafe void WriteRawWithCharChecking(char* pSrcBegin, char* pSrcEnd)
        {
            fixed (<#= bufferType #>* pDstBegin = <#= buffer #>)
            {
                char* pSrc = pSrcBegin;
                <#= bufferType #>* pDst = pDstBegin + bufPos;

                int ch = 0;
                for (;;)
                {
                    <#= bufferType #>* pDstEnd = pDst + (pSrcEnd - pSrc);
                    if (pDstEnd > pDstBegin + bufLen)
                    {
                        pDstEnd = pDstBegin + bufLen;
                    }

<# if (isUtf8Writer) { #>
                    while (pDst < pDstEnd && (xmlCharType.IsTextChar((char)(ch = *pSrc)) && ch <= 0x7F))
<# } else { #>
                    while (pDst < pDstEnd && xmlCharType.IsTextChar((char)(ch = *pSrc)))
<# } #>
                    {
                        *pDst = (<#= bufferType #>)ch;
                        pDst++;
                        pSrc++;
                    }

                    Debug.Assert(pSrc <= pSrcEnd);

                    // end of value
                    if (pSrc >= pSrcEnd)
                    {
                        break;
                    }

                    // end of buffer
                    if (pDst >= pDstEnd)
                    {
                        bufPos = (int)(pDst - pDstBegin);
                        FlushBuffer();
                        pDst = pDstBegin + 1;
                        continue;
                    }

                    // handle special characters
                    switch (ch)
                    {
                        case ']':
                        case '<':
                        case '&':
                        case (char)0x9:
                            *pDst = (<#= bufferType #>)ch;
                            pDst++;
                            break;
                        case (char)0xD:
                            if (newLineHandling == NewLineHandling.Replace)
                            {
                                // Normalize "\r\n", or "\r" to NewLineChars
                                if (pSrc + 1 < pSrcEnd && pSrc[1] == '\n')
                                {
                                    pSrc++;
                                }

                                pDst = WriteNewLine(pDst);
                            }
                            else
                            {
                                *pDst = (<#= bufferType #>)ch;
                                pDst++;
                            }
                            break;
                        case (char)0xA:
                            if (newLineHandling == NewLineHandling.Replace)
                            {
                                pDst = WriteNewLine(pDst);
                            }
                            else
                            {
                                *pDst = (<#= bufferType #>)ch;
                                pDst++;
                            }
                            break;
                        default:
                            <#= EncodeChar(false) #>
                            continue;
                    }
                    pSrc++;
                }
                bufPos = (int)(pDst - pDstBegin);
            }
        }

        protected unsafe void WriteCommentOrPi(string text, int stopChar)
        {
            if (text.Length == 0)
            {
                if (bufPos >= bufLen)
                {
                    FlushBuffer();
                }
                return;
            }
            // write text
            fixed (char* pSrcBegin = text)

            fixed (<#= bufferType #>* pDstBegin = <#= buffer #>)
            {
                char* pSrc = pSrcBegin;

                char* pSrcEnd = pSrcBegin + text.Length;

                <#= bufferType #>* pDst = pDstBegin + bufPos;

                int ch = 0;
                for (;;)
                {
                    <#= bufferType #>* pDstEnd = pDst + (pSrcEnd - pSrc);
                    if (pDstEnd > pDstBegin + bufLen)
                    {
                        pDstEnd = pDstBegin + bufLen;
                    }

<# if (isUtf8Writer) { #>
                    while (pDst < pDstEnd && (xmlCharType.IsTextChar((char)(ch = *pSrc)) && ch != stopChar && ch <= 0x7F))
<# } else { #>
                    while (pDst < pDstEnd && (xmlCharType.IsTextChar((char)(ch = *pSrc)) && ch != stopChar))
<# } #>
                    {
                        *pDst = (<#= bufferType #>)ch;
                        pDst++;
                        pSrc++;
                    }

                    Debug.Assert(pSrc <= pSrcEnd);

                    // end of value
                    if (pSrc >= pSrcEnd)
                    {
                        break;
                    }

                    // end of buffer
                    if (pDst >= pDstEnd)
                    {
                        bufPos = (int)(pDst - pDstBegin);
                        FlushBuffer();
                        pDst = pDstBegin + 1;
                        continue;
                    }

                    // handle special characters
                    switch (ch)
                    {
                        case '-':
                            *pDst = (<#= bufferType #>)'-';
                            pDst++;
                            if (ch == stopChar)
                            {
                                // Insert space between adjacent dashes or before comment's end dashes
                                if (pSrc + 1 == pSrcEnd || *(pSrc + 1) == '-')
                                {
                                    *pDst = (<#= bufferType #>)' ';
                                    pDst++;
                                }
                            }
                            break;
                        case '?':
                            *pDst = (<#= bufferType #>)'?';
                            pDst++;
                            if (ch == stopChar)
                            {
                                // Processing instruction: insert space between adjacent '?' and '>'
                                if (pSrc + 1 < pSrcEnd && *(pSrc + 1) == '>')
                                {
                                    *pDst = (<#= bufferType #>)' ';
                                    pDst++;
                                }
                            }
                            break;
                        case ']':
                            *pDst = (<#= bufferType #>)']';
                            pDst++;
                            break;
                        case (char)0xD:
                            if (newLineHandling == NewLineHandling.Replace)
                            {
                                // Normalize "\r\n", or "\r" to NewLineChars
                                if (pSrc + 1 < pSrcEnd && pSrc[1] == '\n')
                                {
                                    pSrc++;
                                }

                                pDst = WriteNewLine(pDst);
                            }
                            else
                            {
                                *pDst = (<#= bufferType #>)ch;
                                pDst++;
                            }
                            break;
                        case (char)0xA:
                            if (newLineHandling == NewLineHandling.Replace)
                            {
                                pDst = WriteNewLine(pDst);
                            }
                            else
                            {
                                *pDst = (<#= bufferType #>)ch;
                                pDst++;
                            }
                            break;
                        case '<':
                        case '&':
                        case (char)0x9:
                            *pDst = (<#= bufferType #>)ch;
                            pDst++;
                            break;
                        default:
                            <#= EncodeChar(false) #>
                            continue;
                    }
                    pSrc++;
                }
                bufPos = (int)(pDst - pDstBegin);
            }
        }

        protected unsafe void WriteCDataSection(string text)
        {
            if (text.Length == 0)
            {
                if (bufPos >= bufLen)
                {
                    FlushBuffer();
                }
                return;
            }

            // write text

            fixed (char* pSrcBegin = text)

            fixed (<#= bufferType #>* pDstBegin = <#= buffer #>)
            {
                char* pSrc = pSrcBegin;

                char* pSrcEnd = pSrcBegin + text.Length;

                <#= bufferType #>* pDst = pDstBegin + bufPos;

                int ch = 0;
                for (;;)
                {
                    <#= bufferType #>* pDstEnd = pDst + (pSrcEnd - pSrc);
                    if (pDstEnd > pDstBegin + bufLen)
                    {
                        pDstEnd = pDstBegin + bufLen;
                    }

<# if (isUtf8Writer) { #>
                    while (pDst < pDstEnd && (xmlCharType.IsAttributeValueChar((char)(ch = *pSrc)) && ch != ']' && ch <= 0x7F))
<# } else { #>
                    while (pDst < pDstEnd && (xmlCharType.IsAttributeValueChar((char)(ch = *pSrc)) && ch != ']'))
<# } #>
                    {
                        *pDst = (<#= bufferType #>)ch;
                        pDst++;
                        pSrc++;
                    }

                    Debug.Assert(pSrc <= pSrcEnd);

                    // end of value
                    if (pSrc >= pSrcEnd)
                    {
                        break;
                    }

                    // end of buffer
                    if (pDst >= pDstEnd)
                    {
                        bufPos = (int)(pDst - pDstBegin);
                        FlushBuffer();
                        pDst = pDstBegin + 1;
                        continue;
                    }

                    // handle special characters
                    switch (ch)
                    {
                        case '>':
                            if (hadDoubleBracket && pDst[-1] == (<#= bufferType #>)']')
                            {   // pDst[-1] will always correct - there is a padding character at <#= buffer #>[0]
                                // The characters "]]>" were found within the CData text
                                pDst = RawEndCData(pDst);
                                pDst = RawStartCData(pDst);
                            }
                            *pDst = (<#= bufferType #>)'>';
                            pDst++;
                            break;
                        case ']':
                            if (pDst[-1] == (<#= bufferType #>)']')
                            {   // pDst[-1] will always correct - there is a padding character at <#= buffer #>[0]
                                hadDoubleBracket = true;
                            }
                            else
                            {
                                hadDoubleBracket = false;
                            }
                            *pDst = (<#= bufferType #>)']';
                            pDst++;
                            break;
                        case (char)0xD:
                            if (newLineHandling == NewLineHandling.Replace)
                            {
                                // Normalize "\r\n", or "\r" to NewLineChars
                                if (pSrc + 1 < pSrcEnd && pSrc[1] == '\n')
                                {
                                    pSrc++;
                                }

                                pDst = WriteNewLine(pDst);
                            }
                            else
                            {
                                *pDst = (<#= bufferType #>)ch;
                                pDst++;
                            }
                            break;
                        case (char)0xA:
                            if (newLineHandling == NewLineHandling.Replace)
                            {
                                pDst = WriteNewLine(pDst);
                            }
                            else
                            {
                                *pDst = (<#= bufferType #>)ch;
                                pDst++;
                            }
                            break;
                        case '&':
                        case '<':
                        case '"':
                        case '\'':
                        case (char)0x9:
                            *pDst = (<#= bufferType #>)ch;
                            pDst++;
                            break;
                        default:
                            <#= EncodeChar(false) #>
                            continue;
                    }
                    pSrc++;
                }
                bufPos = (int)(pDst - pDstBegin);
            }
        }

<# if (isUtf8Writer) { #>
        // Returns true if UTF8 encoded byte is first of four bytes that encode a surrogate pair.
        // To do this, detect the bit pattern 11110xxx.
        private static bool IsSurrogateByte(byte b)
        {
            return (b & 0xF8) == 0xF0;
        }
<# } #>

        private static unsafe <#= bufferType #>* EncodeSurrogate(char* pSrc, char* pSrcEnd, <#= bufferType #>* pDst)
        {
            Debug.Assert(XmlCharType.IsSurrogate(*pSrc));

            int ch = *pSrc;
            if (ch <= XmlCharType.SurHighEnd)
            {
                if (pSrc + 1 < pSrcEnd)
                {
                    int lowChar = pSrc[1];
                    if (lowChar >= XmlCharType.SurLowStart &&
                        (LocalAppContextSwitches.DontThrowOnInvalidSurrogatePairs || lowChar <= XmlCharType.SurLowEnd))
                    {
<# if (isUtf8Writer) { #>
                        // Calculate Unicode scalar value for easier manipulations (see section 3.7 in Unicode spec)
                        // The scalar value repositions surrogate values to start at 0x10000.

                        ch = XmlCharType.CombineSurrogateChar(lowChar, ch);

                        pDst[0] = (byte)(0xF0 | (ch >> 18));
                        pDst[1] = (byte)(0x80 | (ch >> 12) & 0x3F);
                        pDst[2] = (byte)(0x80 | (ch >> 6) & 0x3F);
                        pDst[3] = (byte)(0x80 | ch & 0x3F);
                        pDst += 4;
<# } else { #>
                        pDst[0] = (<#= bufferType #>)ch;
                        pDst[1] = (<#= bufferType #>)lowChar;
                        pDst += 2;
<# } #>

                        return pDst;
                    }
                    throw XmlConvert.CreateInvalidSurrogatePairException((char)lowChar, (char)ch);
                }
                throw new ArgumentException(SR.Xml_InvalidSurrogateMissingLowChar);
            }
            throw XmlConvert.CreateInvalidHighSurrogateCharException((char)ch);
        }

        private unsafe <#= bufferType #>* InvalidXmlChar(int ch, <#= bufferType #>* pDst, bool entitize)
        {
            Debug.Assert(!xmlCharType.IsWhiteSpace((char)ch));
            Debug.Assert(!xmlCharType.IsAttributeValueChar((char)ch));

            if (checkCharacters)
            {
                // This method will never be called on surrogates, so it is ok to pass in '\0' to the CreateInvalidCharException
                throw XmlConvert.CreateInvalidCharException((char)ch, '\0');
            }
            else
            {
                if (entitize)
                {
                    return CharEntity(pDst, (char)ch);
                }
                else
                {
<# if (isUtf8Writer) { #>
                    if (ch < 0x80)
                    {
<# } #>
                        *pDst = (<#= bufferType #>)ch;
                        pDst++;
<# if (isUtf8Writer) { #>
                    }
                    else
                    {
                        pDst = EncodeMultibyteUTF8(ch, pDst);
                    }
<# } #>
                    return pDst;
                }
            }
        }

        internal unsafe void EncodeChar(ref char* pSrc, char* pSrcEnd, ref <#= bufferType #>* pDst)
        {
            int ch = *pSrc;
            <#= EncodeChar(false) #>
        }

<# if (isUtf8Writer) { #>
        internal static unsafe byte* EncodeMultibyteUTF8(int ch, byte* pDst)
        {
            Debug.Assert(ch >= 0x80 && !XmlCharType.IsSurrogate(ch));

            unchecked
            {
                /* UTF8-2: If ch is in 0x80-0x7ff range, then use 2 bytes to encode it */
                if (ch < 0x800)
                {
                    *pDst = (byte)((sbyte)0xC0 | (ch >> 6));
                }
                /* UTF8-3: If ch is anything else, then default to using 3 bytes to encode it. */
                else
                {
                    *pDst = (byte)((sbyte)0xE0 | (ch >> 12));
                    pDst++;

                    *pDst = (byte)((sbyte)0x80 | (ch >> 6) & 0x3F);
                }
            }

            pDst++;
            *pDst = (byte)(0x80 | ch & 0x3F);
            return pDst + 1;
        }

        // Encode *pSrc as a sequence of UTF8 bytes.  Write the bytes to pDst and return an updated pointer.

        internal static unsafe void CharToUTF8(ref char* pSrc, char* pSrcEnd, ref byte* pDst)
        {
            int ch = *pSrc;
            if (ch <= 0x7F)
            {
                *pDst = (byte)ch;
                pDst++;
                pSrc++;
            }
            else if (XmlCharType.IsSurrogate(ch))
            {
                pDst = EncodeSurrogate(pSrc, pSrcEnd, pDst);
                pSrc += 2;
            }
            else
            {
                pDst = EncodeMultibyteUTF8(ch, pDst);
                pSrc++;
            }
        }
<# } #>

<# if (isEncodedWriter) { #>
        protected void ChangeTextContentMark(bool value)
        {
            Debug.Assert(inTextContent != value);
            Debug.Assert(inTextContent || ((_lastMarkPos & 1) == 0));
            inTextContent = value;
            if (_lastMarkPos + 1 == _textContentMarks.Length)
            {
                GrowTextContentMarks();
            }
            _textContentMarks[++_lastMarkPos] = this.bufPos;
        }

        private void GrowTextContentMarks()
        {
            Debug.Assert(_lastMarkPos + 1 == _textContentMarks.Length);
            int[] newTextContentMarks = new int[_textContentMarks.Length * 2];
            Array.Copy(_textContentMarks, newTextContentMarks, _textContentMarks.Length);
            _textContentMarks = newTextContentMarks;
        }
<# } #>
        // Write NewLineChars to the specified buffer position and return an updated position.
        protected unsafe <#= bufferType #>* WriteNewLine(<#= bufferType #>* pDst)
        {
            fixed (<#= bufferType #>* pDstBegin = <#= buffer #>)
            {
                bufPos = (int)(pDst - pDstBegin);
                // Let RawText do the real work
                RawText(newLineChars);
                return pDstBegin + bufPos;
            }
        }

        // Following methods do not check whether pDst is beyond the bufSize because the buffer was allocated with a OVERFLOW to accommodate
        // for the writes of small constant-length string as below.

        // Entitize '<' as "&lt;".  Return an updated pointer.

        protected static unsafe <#= bufferType #>* LtEntity(<#= bufferType #>* pDst)
        {
            pDst[0] = (<#= bufferType #>)'&';
            pDst[1] = (<#= bufferType #>)'l';
            pDst[2] = (<#= bufferType #>)'t';
            pDst[3] = (<#= bufferType #>)';';
            return pDst + 4;
        }

        // Entitize '>' as "&gt;".  Return an updated pointer.

        protected static unsafe <#= bufferType #>* GtEntity(<#= bufferType #>* pDst)
        {
            pDst[0] = (<#= bufferType #>)'&';
            pDst[1] = (<#= bufferType #>)'g';
            pDst[2] = (<#= bufferType #>)'t';
            pDst[3] = (<#= bufferType #>)';';
            return pDst + 4;
        }

        // Entitize '&' as "&amp;".  Return an updated pointer.

        protected static unsafe <#= bufferType #>* AmpEntity(<#= bufferType #>* pDst)
        {
            pDst[0] = (<#= bufferType #>)'&';
            pDst[1] = (<#= bufferType #>)'a';
            pDst[2] = (<#= bufferType #>)'m';
            pDst[3] = (<#= bufferType #>)'p';
            pDst[4] = (<#= bufferType #>)';';
            return pDst + 5;
        }

        // Entitize '"' as "&quot;".  Return an updated pointer.

        protected static unsafe <#= bufferType #>* QuoteEntity(<#= bufferType #>* pDst)
        {
            pDst[0] = (<#= bufferType #>)'&';
            pDst[1] = (<#= bufferType #>)'q';
            pDst[2] = (<#= bufferType #>)'u';
            pDst[3] = (<#= bufferType #>)'o';
            pDst[4] = (<#= bufferType #>)'t';
            pDst[5] = (<#= bufferType #>)';';
            return pDst + 6;
        }

        // Entitize '\t' as "&#x9;".  Return an updated pointer.

        protected static unsafe <#= bufferType #>* TabEntity(<#= bufferType #>* pDst)
        {
            pDst[0] = (<#= bufferType #>)'&';
            pDst[1] = (<#= bufferType #>)'#';
            pDst[2] = (<#= bufferType #>)'x';
            pDst[3] = (<#= bufferType #>)'9';
            pDst[4] = (<#= bufferType #>)';';
            return pDst + 5;
        }

        // Entitize 0xa as "&#xA;".  Return an updated pointer.

        protected static unsafe <#= bufferType #>* LineFeedEntity(<#= bufferType #>* pDst)
        {
            pDst[0] = (<#= bufferType #>)'&';
            pDst[1] = (<#= bufferType #>)'#';
            pDst[2] = (<#= bufferType #>)'x';
            pDst[3] = (<#= bufferType #>)'A';
            pDst[4] = (<#= bufferType #>)';';
            return pDst + 5;
        }

        // Entitize 0xd as "&#xD;".  Return an updated pointer.

        protected static unsafe <#= bufferType #>* CarriageReturnEntity(<#= bufferType #>* pDst)
        {
            pDst[0] = (<#= bufferType #>)'&';
            pDst[1] = (<#= bufferType #>)'#';
            pDst[2] = (<#= bufferType #>)'x';
            pDst[3] = (<#= bufferType #>)'D';
            pDst[4] = (<#= bufferType #>)';';
            return pDst + 5;
        }

        private static unsafe <#= bufferType #>* CharEntity(<#= bufferType #>* pDst, char ch)
        {
            string s = ((int)ch).ToString("X", NumberFormatInfo.InvariantInfo);
            pDst[0] = (<#= bufferType #>)'&';
            pDst[1] = (<#= bufferType #>)'#';
            pDst[2] = (<#= bufferType #>)'x';
            pDst += 3;

            fixed (char* pSrc = s)
            {
                char* pS = pSrc;
                while ((*pDst++ = (<#= bufferType #>)*pS++) != 0) ;
            }

            pDst[-1] = (<#= bufferType #>)';';
            return pDst;
        }

        // Write "<![CDATA[" to the specified buffer.  Return an updated pointer.

        protected static unsafe <#= bufferType #>* RawStartCData(<#= bufferType #>* pDst)
        {
            pDst[0] = (<#= bufferType #>)'<';
            pDst[1] = (<#= bufferType #>)'!';
            pDst[2] = (<#= bufferType #>)'[';
            pDst[3] = (<#= bufferType #>)'C';
            pDst[4] = (<#= bufferType #>)'D';
            pDst[5] = (<#= bufferType #>)'A';
            pDst[6] = (<#= bufferType #>)'T';
            pDst[7] = (<#= bufferType #>)'A';
            pDst[8] = (<#= bufferType #>)'[';
            return pDst + 9;
        }

        // Write "]]>" to the specified buffer.  Return an updated pointer.

        protected static unsafe <#= bufferType #>* RawEndCData(<#= bufferType #>* pDst)
        {
            pDst[0] = (<#= bufferType #>)']';
            pDst[1] = (<#= bufferType #>)']';
            pDst[2] = (<#= bufferType #>)'>';
            return pDst + 3;
        }

        protected unsafe void ValidateContentChars(string chars, string propertyName, bool allowOnlyWhitespace)
        {
            if (allowOnlyWhitespace)
            {
                if (!xmlCharType.IsOnlyWhitespace(chars))
                {
                    throw new ArgumentException(SR.Format(SR.Xml_IndentCharsNotWhitespace, propertyName));
                }
            }
            else
            {
                string error = null;
                for (int i = 0; i < chars.Length; i++)
                {
                    if (!xmlCharType.IsTextChar(chars[i]))
                    {
                        switch (chars[i])
                        {
                            case '\n':
                            case '\r':
                            case '\t':
                                continue;
                            case '<':
                            case '&':
                            case ']':
                                error = SR.Format(SR.Xml_InvalidCharacter, XmlException.BuildCharExceptionArgs(chars, i));
                                goto Error;
                            default:
                                if (XmlCharType.IsHighSurrogate(chars[i]))
                                {
                                    if (i + 1 < chars.Length)
                                    {
                                        if (XmlCharType.IsLowSurrogate(chars[i + 1]))
                                        {
                                            i++;
                                            continue;
                                        }
                                    }
                                    error = SR.Xml_InvalidSurrogateMissingLowChar;
                                    goto Error;
                                }
                                else if (XmlCharType.IsLowSurrogate(chars[i]))
                                {
                                    error = SR.Format(SR.Xml_InvalidSurrogateHighChar, ((uint)chars[i]).ToString("X", CultureInfo.InvariantCulture));
                                    goto Error;
                                }
                                continue;
                        }
                    }
                }
                return;

            Error:
                throw new ArgumentException(SR.Format(SR.Xml_InvalidCharsInIndent, new string[] { propertyName, error }));
            }
        }
    }

    // Same as base text writer class except that elements, attributes, comments, and pi's are indented.
    internal partial class <#= classnameIndent #> : <#= classname #>
    {
        //
        // Fields
        //
        protected int indentLevel;
        protected bool newLineOnAttributes;
        protected string indentChars;

        protected bool mixedContent;
        private BitStack _mixedContentStack;

        protected ConformanceLevel conformanceLevel = ConformanceLevel.Auto;

        //
        // Constructors
        //
<# if (isEncodedWriter) { #>
        public <#= classnameIndent #>(TextWriter writer, XmlWriterSettings settings) : base(writer, settings)
        {
            Init(settings);
        }
<# } #>

        public <#= classnameIndent #>(Stream stream, XmlWriterSettings settings) : base(stream, settings)
        {
            Init(settings);
        }

        //
        // XmlWriter methods
        //
        public override XmlWriterSettings Settings
        {
            get
            {
                XmlWriterSettings settings = base.Settings;

                settings.ReadOnly = false;
                settings.Indent = true;
                settings.IndentChars = indentChars;
                settings.NewLineOnAttributes = newLineOnAttributes;
                settings.ReadOnly = true;

                return settings;
            }
        }

        public override void WriteDocType(string name, string pubid, string sysid, string subset)
        {
            // Add indentation
            if (!mixedContent && base.textPos != base.bufPos)
            {
                WriteIndent();
            }
            base.WriteDocType(name, pubid, sysid, subset);
        }

        public override void WriteStartElement(string prefix, string localName, string ns)
        {
            Debug.Assert(localName != null && localName.Length != 0 && prefix != null && ns != null);

            // Add indentation
            if (!mixedContent && base.textPos != base.bufPos)
            {
                WriteIndent();
            }
            indentLevel++;
            _mixedContentStack.PushBit(mixedContent);

            base.WriteStartElement(prefix, localName, ns);
        }

        internal override void StartElementContent()
        {
            // If this is the root element and we're writing a document
            //   do not inherit the mixedContent flag into the root element.
            //   This is to allow for whitespace nodes on root level
            //   without disabling indentation for the whole document.
            if (indentLevel == 1 && conformanceLevel == ConformanceLevel.Document)
            {
                mixedContent = false;
            }
            else
            {
                mixedContent = _mixedContentStack.PeekBit();
            }
            base.StartElementContent();
        }

        internal override void OnRootElement(ConformanceLevel currentConformanceLevel)
        {
            // Just remember the current conformance level
            conformanceLevel = currentConformanceLevel;
        }

        internal override void WriteEndElement(string prefix, string localName, string ns)
        {
            // Add indentation
            indentLevel--;
            if (!mixedContent && base.contentPos != base.bufPos)
            {
                // There was content, so try to indent
                if (base.textPos != base.bufPos)
                {
                    WriteIndent();
                }
            }
            mixedContent = _mixedContentStack.PopBit();

            base.WriteEndElement(prefix, localName, ns);
        }

        internal override void WriteFullEndElement(string prefix, string localName, string ns)
        {
            // Add indentation
            indentLevel--;
            if (!mixedContent && base.contentPos != base.bufPos)
            {
                // There was content, so try to indent
                if (base.textPos != base.bufPos)
                {
                    WriteIndent();
                }
            }
            mixedContent = _mixedContentStack.PopBit();

            base.WriteFullEndElement(prefix, localName, ns);
        }

        // Same as base class, plus possible indentation.
        public override void WriteStartAttribute(string prefix, string localName, string ns)
        {
            // Add indentation
            if (newLineOnAttributes)
            {
                WriteIndent();
            }

            base.WriteStartAttribute(prefix, localName, ns);
        }

        public override void WriteCData(string text)
        {
            mixedContent = true;
            base.WriteCData(text);
        }

        public override void WriteComment(string text)
        {
            if (!mixedContent && base.textPos != base.bufPos)
            {
                WriteIndent();
            }

            base.WriteComment(text);
        }

        public override void WriteProcessingInstruction(string target, string text)
        {
            if (!mixedContent && base.textPos != base.bufPos)
            {
                WriteIndent();
            }

            base.WriteProcessingInstruction(target, text);
        }

        public override void WriteEntityRef(string name)
        {
            mixedContent = true;
            base.WriteEntityRef(name);
        }

        public override void WriteCharEntity(char ch)
        {
            mixedContent = true;
            base.WriteCharEntity(ch);
        }

        public override void WriteSurrogateCharEntity(char lowChar, char highChar)
        {
            mixedContent = true;
            base.WriteSurrogateCharEntity(lowChar, highChar);
        }

        public override void WriteWhitespace(string ws)
        {
            mixedContent = true;
            base.WriteWhitespace(ws);
        }

        public override void WriteString(string text)
        {
            mixedContent = true;
            base.WriteString(text);
        }

        public override void WriteChars(char[] buffer, int index, int count)
        {
            mixedContent = true;
            base.WriteChars(buffer, index, count);
        }

        public override void WriteRaw(char[] buffer, int index, int count)
        {
            mixedContent = true;
            base.WriteRaw(buffer, index, count);
        }

        public override void WriteRaw(string data)
        {
            mixedContent = true;
            base.WriteRaw(data);
        }

        public override void WriteBase64(byte[] buffer, int index, int count)
        {
            mixedContent = true;
            base.WriteBase64(buffer, index, count);
        }

        //
        // Private methods
        //
        private void Init(XmlWriterSettings settings)
        {
            indentLevel = 0;
            indentChars = settings.IndentChars;
            newLineOnAttributes = settings.NewLineOnAttributes;
            _mixedContentStack = new BitStack();

            // check indent characters that they are valid XML characters
            if (base.checkCharacters)
            {
                if (newLineOnAttributes)
                {
                    base.ValidateContentChars(indentChars, "IndentChars", true);
                    base.ValidateContentChars(newLineChars, "NewLineChars", true);
                }
                else
                {
                    base.ValidateContentChars(indentChars, "IndentChars", false);
                    if (base.newLineHandling != NewLineHandling.Replace)
                    {
                        base.ValidateContentChars(newLineChars, "NewLineChars", false);
                    }
                }
            }
        }

        // Add indentation to output.  Write newline and then repeat IndentChars for each indent level.
        private void WriteIndent()
        {
            RawText(base.newLineChars);
            for (int i = indentLevel; i > 0; i--)
            {
                RawText(indentChars);
            }
        }
    }
}

<#+
    string encodeCharBody;
    string setTextContentMarkBody;

    string SetTextContentMark(bool value)
    {
        return setTextContentMarkBody
            .Replace("_value_", BoolString(value));
    }

    string EncodeChar(bool entitizeInvalidChars)
    {
        return encodeCharBody
            .Replace("_entitizeInvalidChars_", BoolString(entitizeInvalidChars));
    }

    string BoolString(bool value)
    {
        return value ? "true" : "false";
    }
#>
