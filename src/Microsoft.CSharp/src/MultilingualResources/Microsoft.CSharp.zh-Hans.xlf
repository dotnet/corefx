<?xml version="1.0" encoding="utf-8"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en-US" target-language="zh-Hans" original="MICROSOFT.CSHARP/RESOURCES/STRINGS.RESX" tool-id="MultilingualAppToolkit" product-name="n/a" product-version="n/a" build-num="n/a">
    <header>
      <tool tool-id="MultilingualAppToolkit" tool-name="Multilingual App Toolkit" tool-version="4.0.1387.0" tool-company="Microsoft" />
    </header>
    <body>
      <group id="MICROSOFT.CSHARP/RESOURCES/STRINGS.RESX" datatype="resx">
        <trans-unit id="InternalCompilerError" translate="yes" xml:space="preserve">
          <source>An unexpected exception occurred while binding a dynamic operation</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">绑定动态操作时出现异常</target>
        </trans-unit>
        <trans-unit id="BindRequireArguments" translate="yes" xml:space="preserve">
          <source>Cannot bind call with no calling object</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">无法在没有调用对象的情况下绑定调用</target>
        </trans-unit>
        <trans-unit id="BindCallFailedOverloadResolution" translate="yes" xml:space="preserve">
          <source>Overload resolution failed</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">重载决策失败</target>
        </trans-unit>
        <trans-unit id="BindBinaryOperatorRequireTwoArguments" translate="yes" xml:space="preserve">
          <source>Binary operators must be invoked with two arguments</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">必须使用两个参数调用二元运算符</target>
        </trans-unit>
        <trans-unit id="BindUnaryOperatorRequireOneArgument" translate="yes" xml:space="preserve">
          <source>Unary operators must be invoked with one argument</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">必须使用一个参数调用一元运算符</target>
        </trans-unit>
        <trans-unit id="BindPropertyFailedMethodGroup" translate="yes" xml:space="preserve">
          <source>The name '{0}' is bound to a method and cannot be used like a property</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">名称“{0}”已绑定到某个方法，无法像属性一样使用</target>
        </trans-unit>
        <trans-unit id="BindPropertyFailedEvent" translate="yes" xml:space="preserve">
          <source>The event '{0}' can only appear on the left hand side of +</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">事件 '{0}' 只能出现在左边的 +</target>
        </trans-unit>
        <trans-unit id="BindInvokeFailedNonDelegate" translate="yes" xml:space="preserve">
          <source>Cannot invoke a non-delegate type</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">无法调用非委托类型</target>
        </trans-unit>
        <trans-unit id="BindBinaryAssignmentRequireTwoArguments" translate="yes" xml:space="preserve">
          <source>Binary operators cannot be invoked with one argument</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">无法使用一个参数调用二元运算符</target>
        </trans-unit>
        <trans-unit id="BindBinaryAssignmentFailedNullReference" translate="yes" xml:space="preserve">
          <source>Cannot perform member assignment on a null reference</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">无法对 null 引用执行成员赋值</target>
        </trans-unit>
        <trans-unit id="NullReferenceOnMemberException" translate="yes" xml:space="preserve">
          <source>Cannot perform runtime binding on a null reference</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">无法对 null 引用执行运行时绑定</target>
        </trans-unit>
        <trans-unit id="BindCallToConditionalMethod" translate="yes" xml:space="preserve">
          <source>Cannot dynamically invoke method '{0}' because it has a Conditional attribute</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">无法动态调用方法“{0}”，因为它具有 Conditional 特性</target>
        </trans-unit>
        <trans-unit id="BindToVoidMethodButExpectResult" translate="yes" xml:space="preserve">
          <source>Cannot implicitly convert type 'void' to 'object'</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">无法将类型“void”隐式转换为“object”</target>
        </trans-unit>
        <trans-unit id="BadBinaryOps" translate="yes" xml:space="preserve">
          <source>Operator '{0}' cannot be applied to operands of type '{1}' and '{2}'</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">运算符“{0}”无法应用于“{1}”和“{2}”类型的操作数</target>
        </trans-unit>
        <trans-unit id="BadIndexLHS" translate="yes" xml:space="preserve">
          <source>Cannot apply indexing with [] to an expression of type '{0}'</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">无法将带 [] 的索引应用于“{0}”类型的表达式</target>
        </trans-unit>
        <trans-unit id="BadIndexCount" translate="yes" xml:space="preserve">
          <source>Wrong number of indices inside []; expected '{0}'</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">[] 内的索引数错误；应为“{0}”</target>
        </trans-unit>
        <trans-unit id="BadUnaryOp" translate="yes" xml:space="preserve">
          <source>Operator '{0}' cannot be applied to operand of type '{1}'</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">运算符“{0}”无法应用于“{1}”类型的操作数</target>
        </trans-unit>
        <trans-unit id="NoImplicitConv" translate="yes" xml:space="preserve">
          <source>Cannot implicitly convert type '{0}' to '{1}'</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">无法将类型“{0}”隐式转换为“{1}”</target>
        </trans-unit>
        <trans-unit id="NoExplicitConv" translate="yes" xml:space="preserve">
          <source>Cannot convert type '{0}' to '{1}'</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">不能转换类型 '{0}' 到 '{1}'</target>
        </trans-unit>
        <trans-unit id="ConstOutOfRange" translate="yes" xml:space="preserve">
          <source>Constant value '{0}' cannot be converted to a '{1}'</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">常量值“{0}”无法转换为“{1}”</target>
        </trans-unit>
        <trans-unit id="AmbigBinaryOps" translate="yes" xml:space="preserve">
          <source>Operator '{0}' is ambiguous on operands of type '{1}' and '{2}'</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">运算符“{0}”对于“{1}”和“{2}”类型的操作数具有二义性</target>
        </trans-unit>
        <trans-unit id="AmbigUnaryOp" translate="yes" xml:space="preserve">
          <source>Operator '{0}' is ambiguous on an operand of type '{1}'</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">运算符“{0}”对于“{1}”类型的操作数具有二义性</target>
        </trans-unit>
        <trans-unit id="ValueCantBeNull" translate="yes" xml:space="preserve">
          <source>Cannot convert null to '{0}' because it is a non-nullable value type</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">无法将 null 转换为“{0}”，因为后者是不可以为 null 的值类型</target>
        </trans-unit>
        <trans-unit id="WrongNestedThis" translate="yes" xml:space="preserve">
          <source>Cannot access a non-static member of outer type '{0}' via nested type '{1}'</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">无法通过嵌套类型“{1}”来访问外部类型“{0}”的非静态成员</target>
        </trans-unit>
        <trans-unit id="NoSuchMember" translate="yes" xml:space="preserve">
          <source>'{0}' does not contain a definition for '{1}'</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">“{0}”未包含“{1}”的定义</target>
        </trans-unit>
        <trans-unit id="ObjectRequired" translate="yes" xml:space="preserve">
          <source>An object reference is required for the non-static field, method, or property '{0}'</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">对象引用对于非静态的字段、方法或属性“{0}”是必需的</target>
        </trans-unit>
        <trans-unit id="AmbigCall" translate="yes" xml:space="preserve">
          <source>The call is ambiguous between the following methods or properties: '{0}' and '{1}'</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">以下方法或属性之间的调用具有二义性:“{0}”和“{1}”</target>
        </trans-unit>
        <trans-unit id="BadAccess" translate="yes" xml:space="preserve">
          <source>'{0}' is inaccessible due to its protection level</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">“{0}”不可访问，因为它具有一定的保护级别</target>
        </trans-unit>
        <trans-unit id="MethDelegateMismatch" translate="yes" xml:space="preserve">
          <source>No overload for '{0}' matches delegate '{1}'</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">“{0}”没有与委托“{1}”匹配的重载</target>
        </trans-unit>
        <trans-unit id="AssgLvalueExpected" translate="yes" xml:space="preserve">
          <source>The left-hand side of an assignment must be a variable, property or indexer</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">赋值号左边必须是变量、属性或索引器</target>
        </trans-unit>
        <trans-unit id="NoConstructors" translate="yes" xml:space="preserve">
          <source>The type '{0}' has no constructors defined</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">类型“{0}”未定义构造函数</target>
        </trans-unit>
        <trans-unit id="BadDelegateConstructor" translate="yes" xml:space="preserve">
          <source>The delegate '{0}' does not have a valid constructor</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">委托“{0}”没有有效的构造函数</target>
        </trans-unit>
        <trans-unit id="PropertyLacksGet" translate="yes" xml:space="preserve">
          <source>The property or indexer '{0}' cannot be used in this context because it lacks the get accessor</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">属性或索引器“{0}”不能用在此上下文中，因为它缺少 get 访问器</target>
        </trans-unit>
        <trans-unit id="ObjectProhibited" translate="yes" xml:space="preserve">
          <source>Member '{0}' cannot be accessed with an instance reference; qualify it with a type name instead</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">无法使用实例引用来访问成员“{0}”；请改用类型名来限定它</target>
        </trans-unit>
        <trans-unit id="AssgReadonly" translate="yes" xml:space="preserve">
          <source>A readonly field cannot be assigned to (except in a constructor or a variable initializer)</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">无法对只读的字段赋值(构造函数或变量初始值指定项中除外)</target>
        </trans-unit>
        <trans-unit id="RefReadonly" translate="yes" xml:space="preserve">
          <source>A readonly field cannot be passed ref or out (except in a constructor)</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">对只读字段无法传递 ref 或 out 参数(构造函数中除外)</target>
        </trans-unit>
        <trans-unit id="AssgReadonlyStatic" translate="yes" xml:space="preserve">
          <source>A static readonly field cannot be assigned to (except in a static constructor or a variable initializer)</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">无法对静态只读字段赋值(静态构造函数或变量初始值设定项中除外)</target>
        </trans-unit>
        <trans-unit id="RefReadonlyStatic" translate="yes" xml:space="preserve">
          <source>A static readonly field cannot be passed ref or out (except in a static constructor)</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">无法向静态只读字段传递 ref 或 out 参数(静态构造函数中除外)</target>
        </trans-unit>
        <trans-unit id="AssgReadonlyProp" translate="yes" xml:space="preserve">
          <source>Property or indexer '{0}' cannot be assigned to -- it is read only</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">无法为属性或索引器“{0}”赋值 - 它是只读的</target>
        </trans-unit>
        <trans-unit id="RefProperty" translate="yes" xml:space="preserve">
          <source>A property or indexer may not be passed as an out or ref parameter</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">属性或索引器不得作为 out 或 ref 参数传递</target>
        </trans-unit>
        <trans-unit id="UnsafeNeeded" translate="yes" xml:space="preserve">
          <source>Dynamic calls cannot be used in conjunction with pointers</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">动态调用不能与指针一起使用</target>
        </trans-unit>
        <trans-unit id="BadBoolOp" translate="yes" xml:space="preserve">
          <source>In order to be applicable as a short circuit operator a user-defined logical operator ('{0}') must have the same return type as the type of its 2 parameters</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">为了可以像短路运算符一样应用，用户定义的逻辑运算符(“{0}”)的返回类型必须与它的两个参数的类型相同</target>
        </trans-unit>
        <trans-unit id="MustHaveOpTF" translate="yes" xml:space="preserve">
          <source>The type ('{0}') must contain declarations of operator true and operator false</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">类型(“{0}”)必须包含运算符 True 和运算符 False 的声明</target>
        </trans-unit>
        <trans-unit id="ConstOutOfRangeChecked" translate="yes" xml:space="preserve">
          <source>Constant value '{0}' cannot be converted to a '{1}' (use 'unchecked' syntax to override)</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">常量值“{0}”无法转换为“{1}”(使用“unchecked”语法重写)</target>
        </trans-unit>
        <trans-unit id="AmbigMember" translate="yes" xml:space="preserve">
          <source>Ambiguity between '{0}' and '{1}'</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">在“{0}”和“{1}”之间具有二义性</target>
        </trans-unit>
        <trans-unit id="SizeofUnsafe" translate="yes" xml:space="preserve">
          <source>'{0}' does not have a predefined size, therefore sizeof can only be used in an unsafe context (consider using System.Runtime.InteropServices.Marshal.SizeOf)</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">“{0}”没有预定义的大小，因此 sizeof 只能在不安全的上下文中使用(请考虑使用 System.Runtime.InteropServices.Marshal.SizeOf)</target>
        </trans-unit>
        <trans-unit id="NoImplicitConvCast" translate="yes" xml:space="preserve">
          <source>Cannot implicitly convert type '{0}' to '{1}'. An explicit conversion exists (are you missing a cast?)</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">无法将类型“{0}”隐式转换为“{1}”。存在一个显式转换(是否缺少强制转换?)</target>
        </trans-unit>
        <trans-unit id="InaccessibleGetter" translate="yes" xml:space="preserve">
          <source>The property or indexer '{0}' cannot be used in this context because the get accessor is inaccessible</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">属性或索引器“{0}”不能用在此上下文中，因为 get 访问器不可访问</target>
        </trans-unit>
        <trans-unit id="InaccessibleSetter" translate="yes" xml:space="preserve">
          <source>The property or indexer '{0}' cannot be used in this context because the set accessor is inaccessible</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">属性或索引器“{0}”不能用在此上下文中，因为 set 访问器不可访问</target>
        </trans-unit>
        <trans-unit id="BadArity" translate="yes" xml:space="preserve">
          <source>Using the generic {1} '{0}' requires '{2}' type arguments</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">使用泛型 {1}“{0}”需要“{2}”个类型参数</target>
        </trans-unit>
        <trans-unit id="BadTypeArgument" translate="yes" xml:space="preserve">
          <source>The type '{0}' may not be used as a type argument</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">类型"{0}"不可能用作类型参数</target>
        </trans-unit>
        <trans-unit id="TypeArgsNotAllowed" translate="yes" xml:space="preserve">
          <source>The {1} '{0}' cannot be used with type arguments</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">{1}“{0}”不能与类型参数一起使用</target>
        </trans-unit>
        <trans-unit id="HasNoTypeVars" translate="yes" xml:space="preserve">
          <source>The non-generic {1} '{0}' cannot be used with type arguments</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">非泛型 {1}“{0}”不能与类型参数一起使用</target>
        </trans-unit>
        <trans-unit id="NewConstraintNotSatisfied" translate="yes" xml:space="preserve">
          <source>'{2}' must be a non-abstract type with a public parameterless constructor in order to use it as parameter '{1}' in the generic type or method '{0}'</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">“{2}”必须是具有公共的无参数构造函数的非抽象类型，才能用作泛型类型或方法“{0}”中的参数“{1}”</target>
        </trans-unit>
        <trans-unit id="GenericConstraintNotSatisfiedRefType" translate="yes" xml:space="preserve">
          <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. There is no implicit reference conversion from '{3}' to '{1}'.</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">类型“{3}”不能用作泛型类型或方法“{0}”中的类型参数“{2}”。没有从“{3}”到“{1}”的隐式引用转换。</target>
        </trans-unit>
        <trans-unit id="GenericConstraintNotSatisfiedNullableEnum" translate="yes" xml:space="preserve">
          <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. The nullable type '{3}' does not satisfy the constraint of '{1}'.</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">类型“{3}”不能用作泛型类型或方法“{0}”中的类型参数“{2}”。可以为 null 的类型“{3}”不满足“{1}”的约束。</target>
        </trans-unit>
        <trans-unit id="GenericConstraintNotSatisfiedNullableInterface" translate="yes" xml:space="preserve">
          <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. The nullable type '{3}' does not satisfy the constraint of '{1}'. Nullable types can not satisfy any interface constraints.</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">类型“{3}”不能用作泛型类型或方法“{0}”中的类型参数“{2}”。可以为 null 的类型“{3}”不满足“{1}”的约束。可以为 null 的类型不能满足任何接口约束。</target>
        </trans-unit>
        <trans-unit id="GenericConstraintNotSatisfiedTyVar" translate="yes" xml:space="preserve">
          <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. There is no boxing conversion or type parameter conversion from '{3}' to '{1}'.</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">类型“{3}”不能用作泛型类型或方法“{0}”中的类型参数“{2}”。没有从“{3}”到“{1}”的装箱转换或类型参数转换。</target>
        </trans-unit>
        <trans-unit id="GenericConstraintNotSatisfiedValType" translate="yes" xml:space="preserve">
          <source>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. There is no boxing conversion from '{3}' to '{1}'.</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">类型“{3}”不能用作泛型类型或方法“{0}”中的类型参数“{2}”。没有从“{3}”到“{1}”的装箱转换。</target>
        </trans-unit>
        <trans-unit id="TypeVarCantBeNull" translate="yes" xml:space="preserve">
          <source>Cannot convert null to type parameter '{0}' because it could be a non-nullable value type. Consider using 'default({0})' instead.</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">无法将 null 转换为类型参数“{0}”，因为它可能是不可以为 null 的值类型。请考虑改用“default({0})”。</target>
        </trans-unit>
        <trans-unit id="BadRetType" translate="yes" xml:space="preserve">
          <source>'{1} {0}' has the wrong return type</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">“{1} {0}”的返回类型错误</target>
        </trans-unit>
        <trans-unit id="CantInferMethTypeArgs" translate="yes" xml:space="preserve">
          <source>The type arguments for method '{0}' cannot be inferred from the usage. Try specifying the type arguments explicitly.</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">无法从用法中推断出方法“{0}”的类型参数。请尝试显式指定类型参数。</target>
        </trans-unit>
        <trans-unit id="MethGrpToNonDel" translate="yes" xml:space="preserve">
          <source>Cannot convert method group '{0}' to non-delegate type '{1}'. Did you intend to invoke the method?</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">无法将方法组“{0}”转换为非委托类型“{1}”。是否希望调用此方法?</target>
        </trans-unit>
        <trans-unit id="RefConstraintNotSatisfied" translate="yes" xml:space="preserve">
          <source>The type '{2}' must be a reference type in order to use it as parameter '{1}' in the generic type or method '{0}'</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">类型“{2}”必须是引用类型才能用作泛型类型或方法“{0}”中的参数“{1}”</target>
        </trans-unit>
        <trans-unit id="ValConstraintNotSatisfied" translate="yes" xml:space="preserve">
          <source>The type '{2}' must be a non-nullable value type in order to use it as parameter '{1}' in the generic type or method '{0}'</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">类型“{2}”必须是不可以为 null 值的类型，才能用作泛型类型或方法“{0}”中的参数“{1}”</target>
        </trans-unit>
        <trans-unit id="AmbigUDConv" translate="yes" xml:space="preserve">
          <source>Ambiguous user defined conversions '{0}' and '{1}' when converting from '{2}' to '{3}'</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">从“{2}”转换为“{3}”时，用户定义的转换“{0}”和“{1}”具有二义性</target>
        </trans-unit>
        <trans-unit id="BindToBogus" translate="yes" xml:space="preserve">
          <source>'{0}' is not supported by the language</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">现用语言不支持“{0}”</target>
        </trans-unit>
        <trans-unit id="CantCallSpecialMethod" translate="yes" xml:space="preserve">
          <source>'{0}': cannot explicitly call operator or accessor</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">“{0}”: 无法显式调用运算符或访问器</target>
        </trans-unit>
        <trans-unit id="ConvertToStaticClass" translate="yes" xml:space="preserve">
          <source>Cannot convert to static type '{0}'</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">无法转换为静态类型“{0}”</target>
        </trans-unit>
        <trans-unit id="GenericArgIsStaticClass" translate="yes" xml:space="preserve">
          <source>'{0}': static types cannot be used as type arguments</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">“{0}”: 静态类型不能用作类型参数</target>
        </trans-unit>
        <trans-unit id="IncrementLvalueExpected" translate="yes" xml:space="preserve">
          <source>The operand of an increment or decrement operator must be a variable, property or indexer</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">递增或递减运算符的操作数必须是变量、属性或索引器</target>
        </trans-unit>
        <trans-unit id="NoSuchMemberOrExtension" translate="yes" xml:space="preserve">
          <source>'{0}' does not contain a definition for '{1}' and no extension method '{1}' accepting a first argument of type '{0}' could be found (are you missing a using directive or an assembly reference?)</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">“{0}”未包含“{1}”的定义，并且找不到可接受第一个“{0}”类型参数的扩展方法“{1}”(是否缺少 using 指令或程序集引用?)</target>
        </trans-unit>
        <trans-unit id="ValueTypeExtDelegate" translate="yes" xml:space="preserve">
          <source>Extension methods '{0}' defined on value type '{1}' cannot be used to create delegates</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">无法使用值类型“{1}”定义的扩展方法“{0}”来创建委托</target>
        </trans-unit>
        <trans-unit id="BadArgCount" translate="yes" xml:space="preserve">
          <source>No overload for method '{0}' takes '{1}' arguments</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">“{0}”方法没有采用“{1}”个参数的重载</target>
        </trans-unit>
        <trans-unit id="BadArgTypes" translate="yes" xml:space="preserve">
          <source>The best overloaded method match for '{0}' has some invalid arguments</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">与“{0}”最匹配的重载方法具有一些无效参数</target>
        </trans-unit>
        <trans-unit id="BadArgType" translate="yes" xml:space="preserve">
          <source>Argument '{0}': cannot convert from '{1}' to '{2}'</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">参数“{0}”: 无法从“{1}”转换为“{2}”</target>
        </trans-unit>
        <trans-unit id="RefLvalueExpected" translate="yes" xml:space="preserve">
          <source>A ref or out argument must be an assignable variable</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">ref 或 out 参数必须是可以赋值的变量</target>
        </trans-unit>
        <trans-unit id="BadProtectedAccess" translate="yes" xml:space="preserve">
          <source>Cannot access protected member '{0}' via a qualifier of type '{1}'; the qualifier must be of type '{2}' (or derived from it)</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">无法通过“{1}”类型的限定符访问受保护的成员“{0}”；限定符必须是“{2}”类型(或者从该类型派生)</target>
        </trans-unit>
        <trans-unit id="BindToBogusProp2" translate="yes" xml:space="preserve">
          <source>Property, indexer, or event '{0}' is not supported by the language; try directly calling accessor methods '{1}' or '{2}'</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">属性、索引器或事件“{0}”不受现用语言支持；请尝试直接调用访问器方法“{1}”或“{2}”</target>
        </trans-unit>
        <trans-unit id="BindToBogusProp1" translate="yes" xml:space="preserve">
          <source>Property, indexer, or event '{0}' is not supported by the language; try directly calling accessor method '{1}'</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">属性、索引器或事件“{0}”不受现用语言支持；请尝试直接调用访问器方法“{1}”</target>
        </trans-unit>
        <trans-unit id="BadDelArgCount" translate="yes" xml:space="preserve">
          <source>Delegate '{0}' does not take '{1}' arguments</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">委托“{0}”未采用“{1}”个参数</target>
        </trans-unit>
        <trans-unit id="BadDelArgTypes" translate="yes" xml:space="preserve">
          <source>Delegate '{0}' has some invalid arguments</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">委托“{0}”有一些无效参数</target>
        </trans-unit>
        <trans-unit id="AssgReadonlyLocal" translate="yes" xml:space="preserve">
          <source>Cannot assign to '{0}' because it is read-only</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">无法为“{0}”赋值，因为它是只读的</target>
        </trans-unit>
        <trans-unit id="RefReadonlyLocal" translate="yes" xml:space="preserve">
          <source>Cannot pass '{0}' as a ref or out argument because it is read-only</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">无法将“{0}”作为 ref 或 out 参数传递，因为它是只读的</target>
        </trans-unit>
        <trans-unit id="ReturnNotLValue" translate="yes" xml:space="preserve">
          <source>Cannot modify the return value of '{0}' because it is not a variable</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">无法修改“{0}”的返回值，因为它不是变量</target>
        </trans-unit>
        <trans-unit id="BadArgExtraRef" translate="yes" xml:space="preserve">
          <source>Argument '{0}' should not be passed with the '{1}' keyword</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">参数“{0}”不应使用关键字“{1}”传递</target>
        </trans-unit>
        <trans-unit id="BadArgRef" translate="yes" xml:space="preserve">
          <source>Argument '{0}' must be passed with the '{1}' keyword</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">参数“{0}”必须使用关键字“{1}”传递</target>
        </trans-unit>
        <trans-unit id="AssgReadonly2" translate="yes" xml:space="preserve">
          <source>Members of readonly field '{0}' cannot be modified (except in a constructor or a variable initializer)</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">无法修改只读字段“{0}”的成员(在构造函数或变量初始值设定项中除外)</target>
        </trans-unit>
        <trans-unit id="RefReadonly2" translate="yes" xml:space="preserve">
          <source>Members of readonly field '{0}' cannot be passed ref or out (except in a constructor)</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">无法为只读字段“{0}”的成员传递 ref 或 out (在构造函数中除外)</target>
        </trans-unit>
        <trans-unit id="AssgReadonlyStatic2" translate="yes" xml:space="preserve">
          <source>Fields of static readonly field '{0}' cannot be assigned to (except in a static constructor or a variable initializer)</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">无法为静态只读字段“{0}”的字段赋值(在静态构造函数或变量初始值设定项中除外)</target>
        </trans-unit>
        <trans-unit id="RefReadonlyStatic2" translate="yes" xml:space="preserve">
          <source>Fields of static readonly field '{0}' cannot be passed ref or out (except in a static constructor)</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">无法为静态只读字段“{0}”的字段传递 ref 或 out (在静态构造函数中除外)</target>
        </trans-unit>
        <trans-unit id="AssgReadonlyLocalCause" translate="yes" xml:space="preserve">
          <source>Cannot assign to '{0}' because it is a '{1}'</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">无法为“{0}”赋值，因为它是“{1}”</target>
        </trans-unit>
        <trans-unit id="RefReadonlyLocalCause" translate="yes" xml:space="preserve">
          <source>Cannot pass '{0}' as a ref or out argument because it is a '{1}'</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">“{0}”是一个“{1}”，无法作为 ref 或 out 参数进行传递</target>
        </trans-unit>
        <trans-unit id="DelegateOnNullable" translate="yes" xml:space="preserve">
          <source>Cannot bind delegate to '{0}' because it is a member of 'System.Nullable<it id="1" pos="open">&lt;T&gt;</it>'</source>
          <target state="needs-review-translation" state-qualifier="mt-suggestion">不能将委托绑定到 '{0}'，因为它是 'System.Nullable<it id="1" pos="open">&lt;T&gt;</it>' 成员</target>
        </trans-unit>
        <trans-unit id="BadCtorArgCount" translate="yes" xml:space="preserve">
          <source>'{0}' does not contain a constructor that takes '{1}' arguments</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">“{0}”不包含采用“{1}”个参数的构造函数</target>
        </trans-unit>
        <trans-unit id="BadExtensionArgTypes" translate="yes" xml:space="preserve">
          <source>'{0}' does not contain a definition for '{1}' and the best extension method overload '{2}' has some invalid arguments</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">“{0}”不包含“{1}”的定义，并且最佳扩展方法重载“{2}”具有一些无效参数</target>
        </trans-unit>
        <trans-unit id="BadInstanceArgType" translate="yes" xml:space="preserve">
          <source>Instance argument: cannot convert from '{0}' to '{1}'</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">实例参数: 无法从“{0}”转换为“{1}”</target>
        </trans-unit>
        <trans-unit id="NonInvocableMemberCalled" translate="yes" xml:space="preserve">
          <source>Non-invocable member '{0}' cannot be used like a method.</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">不可调用的成员“{0}”不能像方法一样使用。</target>
        </trans-unit>
        <trans-unit id="NamedArgumentSpecificationBeforeFixedArgument" translate="yes" xml:space="preserve">
          <source>Named argument specifications must appear after all fixed arguments have been specified</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">命名参数规范必须出现在所有指定的固定参数后</target>
        </trans-unit>
        <trans-unit id="BadNamedArgument" translate="yes" xml:space="preserve">
          <source>The best overload for '{0}' does not have a parameter named '{1}'</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">“{0}”的最佳重载没有名为“{1}”的参数</target>
        </trans-unit>
        <trans-unit id="BadNamedArgumentForDelegateInvoke" translate="yes" xml:space="preserve">
          <source>The delegate '{0}' does not have a parameter named '{1}'</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">委托“{0}”没有名为“{1}”的参数</target>
        </trans-unit>
        <trans-unit id="DuplicateNamedArgument" translate="yes" xml:space="preserve">
          <source>Named argument '{0}' cannot be specified multiple times</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">不能多次指定所命名的参数“{0}”。</target>
        </trans-unit>
        <trans-unit id="NamedArgumentUsedInPositional" translate="yes" xml:space="preserve">
          <source>Named argument '{0}' specifies a parameter for which a positional argument has already been given</source>
          <target state="needs-review-translation" state-qualifier="tm-suggestion">命名实参“{0}”指定的形参已被赋予位置实参</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
