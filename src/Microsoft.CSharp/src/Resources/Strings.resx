<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="InternalCompilerError" xml:space="preserve">
    <value>An unexpected exception occurred while binding a dynamic operation</value>
  </data>
  <data name="BindRequireArguments" xml:space="preserve">
    <value>Cannot bind call with no calling object</value>
  </data>
  <data name="BindCallFailedOverloadResolution" xml:space="preserve">
    <value>Overload resolution failed</value>
  </data>
  <data name="BindBinaryOperatorRequireTwoArguments" xml:space="preserve">
    <value>Binary operators must be invoked with two arguments</value>
  </data>
  <data name="BindUnaryOperatorRequireOneArgument" xml:space="preserve">
    <value>Unary operators must be invoked with one argument</value>
  </data>
  <data name="BindPropertyFailedMethodGroup" xml:space="preserve">
    <value>The name '{0}' is bound to a method and cannot be used like a property</value>
  </data>
  <data name="BindPropertyFailedEvent" xml:space="preserve">
    <value>The event '{0}' can only appear on the left hand side of +</value>
  </data>
  <data name="BindInvokeFailedNonDelegate" xml:space="preserve">
    <value>Cannot invoke a non-delegate type</value>
  </data>
  <data name="BindImplicitConversionRequireOneArgument" xml:space="preserve">
    <value>Implicit conversion takes exactly one argument</value>
  </data>
  <data name="BindExplicitConversionRequireOneArgument" xml:space="preserve">
    <value>Explicit conversion takes exactly one argument</value>
  </data>
  <data name="BindBinaryAssignmentRequireTwoArguments" xml:space="preserve">
    <value>Binary operators cannot be invoked with one argument</value>
  </data>
  <data name="BindBinaryAssignmentFailedNullReference" xml:space="preserve">
    <value>Cannot perform member assignment on a null reference</value>
  </data>
  <data name="NullReferenceOnMemberException" xml:space="preserve">
    <value>Cannot perform runtime binding on a null reference</value>
  </data>
  <data name="BindCallToConditionalMethod" xml:space="preserve">
    <value>Cannot dynamically invoke method '{0}' because it has a Conditional attribute</value>
  </data>
  <data name="BindToVoidMethodButExpectResult" xml:space="preserve">
    <value>Cannot implicitly convert type 'void' to 'object'</value>
  </data>
  <data name="BadBinaryOps" xml:space="preserve">
    <value>Operator '{0}' cannot be applied to operands of type '{1}' and '{2}'</value>
  </data>
  <data name="IntDivByZero" xml:space="preserve">
    <value>Division by constant zero</value>
  </data>
  <data name="BadIndexLHS" xml:space="preserve">
    <value>Cannot apply indexing with [] to an expression of type '{0}'</value>
  </data>
  <data name="BadIndexCount" xml:space="preserve">
    <value>Wrong number of indices inside []; expected '{0}'</value>
  </data>
  <data name="BadUnaryOp" xml:space="preserve">
    <value>Operator '{0}' cannot be applied to operand of type '{1}'</value>
  </data>
  <data name="NoImplicitConv" xml:space="preserve">
    <value>Cannot implicitly convert type '{0}' to '{1}'</value>
  </data>
  <data name="NoExplicitConv" xml:space="preserve">
    <value>Cannot convert type '{0}' to '{1}'</value>
  </data>
  <data name="ConstOutOfRange" xml:space="preserve">
    <value>Constant value '{0}' cannot be converted to a '{1}'</value>
  </data>
  <data name="AmbigBinaryOps" xml:space="preserve">
    <value>Operator '{0}' is ambiguous on operands of type '{1}' and '{2}'</value>
  </data>
  <data name="AmbigUnaryOp" xml:space="preserve">
    <value>Operator '{0}' is ambiguous on an operand of type '{1}'</value>
  </data>
  <data name="ValueCantBeNull" xml:space="preserve">
    <value>Cannot convert null to '{0}' because it is a non-nullable value type</value>
  </data>
  <data name="WrongNestedThis" xml:space="preserve">
    <value>Cannot access a non-static member of outer type '{0}' via nested type '{1}'</value>
  </data>
  <data name="NoSuchMember" xml:space="preserve">
    <value>'{0}' does not contain a definition for '{1}'</value>
  </data>
  <data name="ObjectRequired" xml:space="preserve">
    <value>An object reference is required for the non-static field, method, or property '{0}'</value>
  </data>
  <data name="AmbigCall" xml:space="preserve">
    <value>The call is ambiguous between the following methods or properties: '{0}' and '{1}'</value>
  </data>
  <data name="BadAccess" xml:space="preserve">
    <value>'{0}' is inaccessible due to its protection level</value>
  </data>
  <data name="MethDelegateMismatch" xml:space="preserve">
    <value>No overload for '{0}' matches delegate '{1}'</value>
  </data>
  <data name="AssgLvalueExpected" xml:space="preserve">
    <value>The left-hand side of an assignment must be a variable, property or indexer</value>
  </data>
  <data name="NoConstructors" xml:space="preserve">
    <value>The type '{0}' has no constructors defined</value>
  </data>
  <data name="BadDelegateConstructor" xml:space="preserve">
    <value>The delegate '{0}' does not have a valid constructor</value>
  </data>
  <data name="PropertyLacksGet" xml:space="preserve">
    <value>The property or indexer '{0}' cannot be used in this context because it lacks the get accessor</value>
  </data>
  <data name="ObjectProhibited" xml:space="preserve">
    <value>Member '{0}' cannot be accessed with an instance reference; qualify it with a type name instead</value>
  </data>
  <data name="AssgReadonly" xml:space="preserve">
    <value>A readonly field cannot be assigned to (except in a constructor or a variable initializer)</value>
  </data>
  <data name="RefReadonly" xml:space="preserve">
    <value>A readonly field cannot be passed ref or out (except in a constructor)</value>
  </data>
  <data name="AssgReadonlyStatic" xml:space="preserve">
    <value>A static readonly field cannot be assigned to (except in a static constructor or a variable initializer)</value>
  </data>
  <data name="RefReadonlyStatic" xml:space="preserve">
    <value>A static readonly field cannot be passed ref or out (except in a static constructor)</value>
  </data>
  <data name="AssgReadonlyProp" xml:space="preserve">
    <value>Property or indexer '{0}' cannot be assigned to -- it is read only</value>
  </data>
  <data name="AbstractBaseCall" xml:space="preserve">
    <value>Cannot call an abstract base member: '{0}'</value>
  </data>
  <data name="RefProperty" xml:space="preserve">
    <value>A property or indexer may not be passed as an out or ref parameter</value>
  </data>
  <data name="ManagedAddr" xml:space="preserve">
    <value>Cannot take the address of, get the size of, or declare a pointer to a managed type ('{0}')</value>
  </data>
  <data name="FixedNotNeeded" xml:space="preserve">
    <value>You cannot use the fixed statement to take the address of an already fixed expression</value>
  </data>
  <data name="UnsafeNeeded" xml:space="preserve">
    <value>Dynamic calls cannot be used in conjunction with pointers</value>
  </data>
  <data name="BadBoolOp" xml:space="preserve">
    <value>In order to be applicable as a short circuit operator a user-defined logical operator ('{0}') must have the same return type as the type of its 2 parameters</value>
  </data>
  <data name="MustHaveOpTF" xml:space="preserve">
    <value>The type ('{0}') must contain declarations of operator true and operator false</value>
  </data>
  <data name="CheckedOverflow" xml:space="preserve">
    <value>The operation overflows at compile time in checked mode</value>
  </data>
  <data name="ConstOutOfRangeChecked" xml:space="preserve">
    <value>Constant value '{0}' cannot be converted to a '{1}' (use 'unchecked' syntax to override)</value>
  </data>
  <data name="AmbigMember" xml:space="preserve">
    <value>Ambiguity between '{0}' and '{1}'</value>
  </data>
  <data name="SizeofUnsafe" xml:space="preserve">
    <value>'{0}' does not have a predefined size, therefore sizeof can only be used in an unsafe context (consider using System.Runtime.InteropServices.Marshal.SizeOf)</value>
  </data>
  <data name="FieldInitRefNonstatic" xml:space="preserve">
    <value>A field initializer cannot reference the non-static field, method, or property '{0}'</value>
  </data>
  <data name="CallingFinalizeDepracated" xml:space="preserve">
    <value>Destructors and object.Finalize cannot be called directly. Consider calling IDisposable.Dispose if available.</value>
  </data>
  <data name="CallingBaseFinalizeDeprecated" xml:space="preserve">
    <value>Do not directly call your base class Finalize method. It is called automatically from your destructor.</value>
  </data>
  <data name="BadCastInFixed" xml:space="preserve">
    <value>The right hand side of a fixed statement assignment may not be a cast expression</value>
  </data>
  <data name="NoImplicitConvCast" xml:space="preserve">
    <value>Cannot implicitly convert type '{0}' to '{1}'. An explicit conversion exists (are you missing a cast?)</value>
  </data>
  <data name="InaccessibleGetter" xml:space="preserve">
    <value>The property or indexer '{0}' cannot be used in this context because the get accessor is inaccessible</value>
  </data>
  <data name="InaccessibleSetter" xml:space="preserve">
    <value>The property or indexer '{0}' cannot be used in this context because the set accessor is inaccessible</value>
  </data>
  <data name="BadArity" xml:space="preserve">
    <value>Using the generic {1} '{0}' requires '{2}' type arguments</value>
  </data>
  <data name="BadTypeArgument" xml:space="preserve">
    <value>The type '{0}' may not be used as a type argument</value>
  </data>
  <data name="TypeArgsNotAllowed" xml:space="preserve">
    <value>The {1} '{0}' cannot be used with type arguments</value>
  </data>
  <data name="HasNoTypeVars" xml:space="preserve">
    <value>The non-generic {1} '{0}' cannot be used with type arguments</value>
  </data>
  <data name="NewConstraintNotSatisfied" xml:space="preserve">
    <value>'{2}' must be a non-abstract type with a public parameterless constructor in order to use it as parameter '{1}' in the generic type or method '{0}'</value>
  </data>
  <data name="GenericConstraintNotSatisfiedRefType" xml:space="preserve">
    <value>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. There is no implicit reference conversion from '{3}' to '{1}'.</value>
  </data>
  <data name="GenericConstraintNotSatisfiedNullableEnum" xml:space="preserve">
    <value>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. The nullable type '{3}' does not satisfy the constraint of '{1}'.</value>
  </data>
  <data name="GenericConstraintNotSatisfiedNullableInterface" xml:space="preserve">
    <value>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. The nullable type '{3}' does not satisfy the constraint of '{1}'. Nullable types can not satisfy any interface constraints.</value>
  </data>
  <data name="GenericConstraintNotSatisfiedTyVar" xml:space="preserve">
    <value>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. There is no boxing conversion or type parameter conversion from '{3}' to '{1}'.</value>
  </data>
  <data name="GenericConstraintNotSatisfiedValType" xml:space="preserve">
    <value>The type '{3}' cannot be used as type parameter '{2}' in the generic type or method '{0}'. There is no boxing conversion from '{3}' to '{1}'.</value>
  </data>
  <data name="TypeVarCantBeNull" xml:space="preserve">
    <value>Cannot convert null to type parameter '{0}' because it could be a non-nullable value type. Consider using 'default({0})' instead.</value>
  </data>
  <data name="BadRetType" xml:space="preserve">
    <value>'{1} {0}' has the wrong return type</value>
  </data>
  <data name="CantInferMethTypeArgs" xml:space="preserve">
    <value>The type arguments for method '{0}' cannot be inferred from the usage. Try specifying the type arguments explicitly.</value>
  </data>
  <data name="MethGrpToNonDel" xml:space="preserve">
    <value>Cannot convert method group '{0}' to non-delegate type '{1}'. Did you intend to invoke the method?</value>
  </data>
  <data name="RefConstraintNotSatisfied" xml:space="preserve">
    <value>The type '{2}' must be a reference type in order to use it as parameter '{1}' in the generic type or method '{0}'</value>
  </data>
  <data name="ValConstraintNotSatisfied" xml:space="preserve">
    <value>The type '{2}' must be a non-nullable value type in order to use it as parameter '{1}' in the generic type or method '{0}'</value>
  </data>
  <data name="CircularConstraint" xml:space="preserve">
    <value>Circular constraint dependency involving '{0}' and '{1}'</value>
  </data>
  <data name="BaseConstraintConflict" xml:space="preserve">
    <value>Type parameter '{0}' inherits conflicting constraints '{1}' and '{2}'</value>
  </data>
  <data name="ConWithValCon" xml:space="preserve">
    <value>Type parameter '{1}' has the 'struct' constraint so '{1}' cannot be used as a constraint for '{0}'</value>
  </data>
  <data name="AmbigUDConv" xml:space="preserve">
    <value>Ambiguous user defined conversions '{0}' and '{1}' when converting from '{2}' to '{3}'</value>
  </data>
  <data name="PredefinedTypeNotFound" xml:space="preserve">
    <value>Predefined type '{0}' is not defined or imported</value>
  </data>
  <data name="PredefinedTypeBadType" xml:space="preserve">
    <value>Predefined type '{0}' is declared incorrectly</value>
  </data>
  <data name="BindToBogus" xml:space="preserve">
    <value>'{0}' is not supported by the language</value>
  </data>
  <data name="CantCallSpecialMethod" xml:space="preserve">
    <value>'{0}': cannot explicitly call operator or accessor</value>
  </data>
  <data name="BogusType" xml:space="preserve">
    <value>'{0}' is a type not supported by the language</value>
  </data>
  <data name="MissingPredefinedMember" xml:space="preserve">
    <value>Missing compiler required member '{0}.{1}'</value>
  </data>
  <data name="LiteralDoubleCast" xml:space="preserve">
    <value>Literal of type double cannot be implicitly converted to type '{1}'; use an '{0}' suffix to create a literal of this type</value>
  </data>
  <data name="UnifyingInterfaceInstantiations" xml:space="preserve">
    <value>'{0}' cannot implement both '{1}' and '{2}' because they may unify for some type parameter substitutions</value>
  </data>
  <data name="ConvertToStaticClass" xml:space="preserve">
    <value>Cannot convert to static type '{0}'</value>
  </data>
  <data name="GenericArgIsStaticClass" xml:space="preserve">
    <value>'{0}': static types cannot be used as type arguments</value>
  </data>
  <data name="PartialMethodToDelegate" xml:space="preserve">
    <value>Cannot create delegate from method '{0}' because it is a partial method without an implementing declaration</value>
  </data>
  <data name="IncrementLvalueExpected" xml:space="preserve">
    <value>The operand of an increment or decrement operator must be a variable, property or indexer</value>
  </data>
  <data name="NoSuchMemberOrExtension" xml:space="preserve">
    <value>'{0}' does not contain a definition for '{1}' and no extension method '{1}' accepting a first argument of type '{0}' could be found (are you missing a using directive or an assembly reference?)</value>
  </data>
  <data name="ValueTypeExtDelegate" xml:space="preserve">
    <value>Extension methods '{0}' defined on value type '{1}' cannot be used to create delegates</value>
  </data>
  <data name="BadArgCount" xml:space="preserve">
    <value>No overload for method '{0}' takes '{1}' arguments</value>
  </data>
  <data name="BadArgTypes" xml:space="preserve">
    <value>The best overloaded method match for '{0}' has some invalid arguments</value>
  </data>
  <data name="BadArgType" xml:space="preserve">
    <value>Argument '{0}': cannot convert from '{1}' to '{2}'</value>
  </data>
  <data name="RefLvalueExpected" xml:space="preserve">
    <value>A ref or out argument must be an assignable variable</value>
  </data>
  <data name="BadProtectedAccess" xml:space="preserve">
    <value>Cannot access protected member '{0}' via a qualifier of type '{1}'; the qualifier must be of type '{2}' (or derived from it)</value>
  </data>
  <data name="BindToBogusProp2" xml:space="preserve">
    <value>Property, indexer, or event '{0}' is not supported by the language; try directly calling accessor methods '{1}' or '{2}'</value>
  </data>
  <data name="BindToBogusProp1" xml:space="preserve">
    <value>Property, indexer, or event '{0}' is not supported by the language; try directly calling accessor method '{1}'</value>
  </data>
  <data name="BadDelArgCount" xml:space="preserve">
    <value>Delegate '{0}' does not take '{1}' arguments</value>
  </data>
  <data name="BadDelArgTypes" xml:space="preserve">
    <value>Delegate '{0}' has some invalid arguments</value>
  </data>
  <data name="AssgReadonlyLocal" xml:space="preserve">
    <value>Cannot assign to '{0}' because it is read-only</value>
  </data>
  <data name="RefReadonlyLocal" xml:space="preserve">
    <value>Cannot pass '{0}' as a ref or out argument because it is read-only</value>
  </data>
  <data name="ReturnNotLValue" xml:space="preserve">
    <value>Cannot modify the return value of '{0}' because it is not a variable</value>
  </data>
  <data name="BadArgExtraRef" xml:space="preserve">
    <value>Argument '{0}' should not be passed with the '{1}' keyword</value>
  </data>
  <data name="BadArgRef" xml:space="preserve">
    <value>Argument '{0}' must be passed with the '{1}' keyword</value>
  </data>
  <data name="AssgReadonly2" xml:space="preserve">
    <value>Members of readonly field '{0}' cannot be modified (except in a constructor or a variable initializer)</value>
  </data>
  <data name="RefReadonly2" xml:space="preserve">
    <value>Members of readonly field '{0}' cannot be passed ref or out (except in a constructor)</value>
  </data>
  <data name="AssgReadonlyStatic2" xml:space="preserve">
    <value>Fields of static readonly field '{0}' cannot be assigned to (except in a static constructor or a variable initializer)</value>
  </data>
  <data name="RefReadonlyStatic2" xml:space="preserve">
    <value>Fields of static readonly field '{0}' cannot be passed ref or out (except in a static constructor)</value>
  </data>
  <data name="AssgReadonlyLocalCause" xml:space="preserve">
    <value>Cannot assign to '{0}' because it is a '{1}'</value>
  </data>
  <data name="RefReadonlyLocalCause" xml:space="preserve">
    <value>Cannot pass '{0}' as a ref or out argument because it is a '{1}'</value>
  </data>
  <data name="ThisStructNotInAnonMeth" xml:space="preserve">
    <value>Anonymous methods, lambda expressions, and query expressions inside structs cannot access instance members of 'this'. Consider copying 'this' to a local variable outside the anonymous method, lambda expression or query expression and using the local instead.</value>
  </data>
  <data name="DelegateOnNullable" xml:space="preserve">
    <value>Cannot bind delegate to '{0}' because it is a member of 'System.Nullable&lt;T&gt;'</value>
  </data>
  <data name="BadCtorArgCount" xml:space="preserve">
    <value>'{0}' does not contain a constructor that takes '{1}' arguments</value>
  </data>
  <data name="BadExtensionArgTypes" xml:space="preserve">
    <value>'{0}' does not contain a definition for '{1}' and the best extension method overload '{2}' has some invalid arguments</value>
  </data>
  <data name="BadInstanceArgType" xml:space="preserve">
    <value>Instance argument: cannot convert from '{0}' to '{1}'</value>
  </data>
  <data name="BadArgTypesForCollectionAdd" xml:space="preserve">
    <value>The best overloaded Add method '{0}' for the collection initializer has some invalid arguments</value>
  </data>
  <data name="InitializerAddHasParamModifiers" xml:space="preserve">
    <value>The best overloaded method match '{0}' for the collection initializer element cannot be used. Collection initializer 'Add' methods cannot have ref or out parameters.</value>
  </data>
  <data name="NonInvocableMemberCalled" xml:space="preserve">
    <value>Non-invocable member '{0}' cannot be used like a method.</value>
  </data>
  <data name="NamedArgumentSpecificationBeforeFixedArgument" xml:space="preserve">
    <value>Named argument specifications must appear after all fixed arguments have been specified</value>
  </data>
  <data name="BadNamedArgument" xml:space="preserve">
    <value>The best overload for '{0}' does not have a parameter named '{1}'</value>
  </data>
  <data name="BadNamedArgumentForDelegateInvoke" xml:space="preserve">
    <value>The delegate '{0}' does not have a parameter named '{1}'</value>
  </data>
  <data name="DuplicateNamedArgument" xml:space="preserve">
    <value>Named argument '{0}' cannot be specified multiple times</value>
  </data>
  <data name="NamedArgumentUsedInPositional" xml:space="preserve">
    <value>Named argument '{0}' specifies a parameter for which a positional argument has already been given</value>
  </data>
</root>