<?xml version="1.0" encoding="utf-8"?>
<root>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="InternalCompilerError" xml:space="preserve">
    <value>Une exception inattendue s'est produite lors de la liaison d'une opération dynamique</value>
  </data>
  <data name="BindRequireArguments" xml:space="preserve">
    <value>Impossible de lier l'appel sans objet appelant</value>
  </data>
  <data name="BindCallFailedOverloadResolution" xml:space="preserve">
    <value>Échec de la résolution de surcharge</value>
  </data>
  <data name="BindBinaryOperatorRequireTwoArguments" xml:space="preserve">
    <value>Les opérateurs binaires doivent être appelés avec deux arguments</value>
  </data>
  <data name="BindUnaryOperatorRequireOneArgument" xml:space="preserve">
    <value>Les opérateurs unaires doivent être appelés à l'aide d'un seul argument</value>
  </data>
  <data name="BindPropertyFailedMethodGroup" xml:space="preserve">
    <value>Le nom '{0}' est lié à une méthode et ne peut pas être utilisé comme une propriété</value>
  </data>
  <data name="BindPropertyFailedEvent" xml:space="preserve">
    <value>L'événement « {0} » ne peut apparaître sur le côté gauche de +</value>
  </data>
  <data name="BindInvokeFailedNonDelegate" xml:space="preserve">
    <value>Impossible d'appeler un type non-délégué</value>
  </data>
  <data name="BindBinaryAssignmentRequireTwoArguments" xml:space="preserve">
    <value>Impossible d'appeler les opérateurs binaires avec un argument</value>
  </data>
  <data name="BindBinaryAssignmentFailedNullReference" xml:space="preserve">
    <value>Impossible d'effectuer une assignation de membre sur une référence null</value>
  </data>
  <data name="NullReferenceOnMemberException" xml:space="preserve">
    <value>Impossible d'effectuer une liaison au moment de l'exécution sur une référence null</value>
  </data>
  <data name="BindCallToConditionalMethod" xml:space="preserve">
    <value>Impossible d'appeler dynamiquement la méthode '{0}' car elle a un attribut Conditional</value>
  </data>
  <data name="BindToVoidMethodButExpectResult" xml:space="preserve">
    <value>Impossible de convertir implicitement le type 'void' en 'object'</value>
  </data>
  <data name="BadBinaryOps" xml:space="preserve">
    <value>Impossible d'appliquer l'opérateur '{0}' aux opérandes de type '{1}' et '{2}'</value>
  </data>
  <data name="BadIndexLHS" xml:space="preserve">
    <value>Impossible d'appliquer l'indexation à l'aide de [] à une expression de type '{0}'</value>
  </data>
  <data name="BadIndexCount" xml:space="preserve">
    <value>Nombre d'index incorrects dans [], '{0}' attendu</value>
  </data>
  <data name="BadUnaryOp" xml:space="preserve">
    <value>Impossible d'appliquer l'opérateur '{0}' à un opérande de type '{1}'</value>
  </data>
  <data name="NoImplicitConv" xml:space="preserve">
    <value>Impossible de convertir implicitement le type '{0}' en '{1}'</value>
  </data>
  <data name="NoExplicitConv" xml:space="preserve">
    <value>Impossible de convertir le type « {0} » pour « {1} »</value>
  </data>
  <data name="ConstOutOfRange" xml:space="preserve">
    <value>Impossible de convertir la valeur de constante '{0}' en '{1}'</value>
  </data>
  <data name="AmbigBinaryOps" xml:space="preserve">
    <value>L'opérateur '{0}' est ambigu pour des opérandes de type '{1}' et '{2}'</value>
  </data>
  <data name="AmbigUnaryOp" xml:space="preserve">
    <value>L'opérateur '{0}' est ambigu pour un opérande de type '{1}'</value>
  </data>
  <data name="ValueCantBeNull" xml:space="preserve">
    <value>Impossible de convertir null en '{0}', car il s'agit d'un type valeur qui n'autorise pas les valeurs null</value>
  </data>
  <data name="WrongNestedThis" xml:space="preserve">
    <value>Impossible d'accéder à un membre non statique de type externe '{0}' par l'intermédiaire du type imbriqué '{1}'</value>
  </data>
  <data name="NoSuchMember" xml:space="preserve">
    <value>'{0}' ne contient pas de définition pour '{1}'</value>
  </data>
  <data name="ObjectRequired" xml:space="preserve">
    <value>Une référence d'objet est requise pour la propriété, la méthode ou le champ non statique '{0}'</value>
  </data>
  <data name="AmbigCall" xml:space="preserve">
    <value>L'appel est ambigu entre les méthodes ou propriétés suivantes : '{0}' et '{1}'</value>
  </data>
  <data name="BadAccess" xml:space="preserve">
    <value>'{0}' est inaccessible en raison de son niveau de protection</value>
  </data>
  <data name="MethDelegateMismatch" xml:space="preserve">
    <value>Aucune surcharge pour '{0}' ne correspond au délégué '{1}'</value>
  </data>
  <data name="AssgLvalueExpected" xml:space="preserve">
    <value>La partie gauche d'une assignation doit être une variable, une propriété ou un indexeur</value>
  </data>
  <data name="NoConstructors" xml:space="preserve">
    <value>Aucun constructeur n'est défini pour le type '{0}'</value>
  </data>
  <data name="PropertyLacksGet" xml:space="preserve">
    <value>Impossible d'utiliser la propriété ou l'indexeur '{0}' dans ce contexte, car il lui manque l'accesseur get</value>
  </data>
  <data name="ObjectProhibited" xml:space="preserve">
    <value>Le membre '{0}' est inaccessible avec une référence d'instance ; qualifiez-le avec un nom de type</value>
  </data>
  <data name="AssgReadonly" xml:space="preserve">
    <value>Un champ readonly ne peut pas être assigné (sauf s'il appartient à un constructeur ou un initialiseur de variable)</value>
  </data>
  <data name="RefReadonly" xml:space="preserve">
    <value>Un champ readonly ne peut pas être passé en ref ou out (sauf s'il appartient à un constructeur)</value>
  </data>
  <data name="AssgReadonlyStatic" xml:space="preserve">
    <value>Un champ readonly statique ne peut pas être assigné (sauf s'il appartient à un constructeur statique ou un initialiseur de variable)</value>
  </data>
  <data name="RefReadonlyStatic" xml:space="preserve">
    <value>Un champ readonly statique ne peut pas être passé en ref ou out (sauf s'il appartient à un constructeur statique)</value>
  </data>
  <data name="AssgReadonlyProp" xml:space="preserve">
    <value>Impossible d'assigner la propriété ou l'indexeur '{0}' -- il est en lecture seule</value>
  </data>
  <data name="RefProperty" xml:space="preserve">
    <value>Une propriété ou un indexeur ne peut pas être passé en tant que paramètre de sortie (out) ni de référence (ref)</value>
  </data>
  <data name="UnsafeNeeded" xml:space="preserve">
    <value>Impossible d'utiliser des appels dynamiques avec des pointeurs</value>
  </data>
  <data name="BadBoolOp" xml:space="preserve">
    <value>Pour être applicable en tant qu'opérateur de court-circuit, un opérateur logique défini par l'utilisateur '{0}') doit avoir le même type de retour que le type de ses 2 paramètres</value>
  </data>
  <data name="MustHaveOpTF" xml:space="preserve">
    <value>Le type ('{0}') doit contenir les déclarations de l'opérateur true et de l'opérateur false</value>
  </data>
  <data name="ConstOutOfRangeChecked" xml:space="preserve">
    <value>Impossible de convertir la valeur de constante '{0}' en '{1}' (utilisez la syntaxe 'unchecked)</value>
  </data>
  <data name="AmbigMember" xml:space="preserve">
    <value>Ambiguïté entre '{0}' et '{1}'</value>
  </data>
  <data name="NoImplicitConvCast" xml:space="preserve">
    <value>Impossible de convertir implicitement le type '{0}' en '{1}'. Une conversion explicite existe (un cast est-il manquant ?)</value>
  </data>
  <data name="InaccessibleGetter" xml:space="preserve">
    <value>Impossible d'utiliser la propriété ou l'indexeur '{0}' dans ce contexte, car l'accesseur get n'est pas accessible</value>
  </data>
  <data name="InaccessibleSetter" xml:space="preserve">
    <value>Impossible d'utiliser la propriété ou l'indexeur '{0}' dans ce contexte, car l'accesseur set n'est pas accessible</value>
  </data>
  <data name="BadArity" xml:space="preserve">
    <value>L'utilisation du {1} '{0}' générique requiert les arguments de type '{2}'</value>
  </data>
  <data name="TypeArgsNotAllowed" xml:space="preserve">
    <value>Impossible d'utiliser le {1} '{0}' avec des arguments de type</value>
  </data>
  <data name="HasNoTypeVars" xml:space="preserve">
    <value>Impossible d'utiliser le {1} '{0}' non générique avec des arguments de type</value>
  </data>
  <data name="NewConstraintNotSatisfied" xml:space="preserve">
    <value>'{2}' doit être un type non abstrait avec un constructeur sans paramètre public afin de l'utiliser comme paramètre '{1}' dans le type ou la méthode générique '{0}'</value>
  </data>
  <data name="GenericConstraintNotSatisfiedRefType" xml:space="preserve">
    <value>Impossible d'utiliser le type '{3}' comme paramètre de type '{2}' dans le type ou la méthode générique '{0}'. Il n'y a pas de conversion de référence implicite de '{3}' en '{1}'.</value>
  </data>
  <data name="GenericConstraintNotSatisfiedNullableEnum" xml:space="preserve">
    <value>Impossible d'utiliser le type '{3}' comme paramètre de type '{2}' dans le type ou la méthode générique '{0}'. Le type Nullable '{3}' ne satisfait pas la contrainte de '{1}'.</value>
  </data>
  <data name="GenericConstraintNotSatisfiedNullableInterface" xml:space="preserve">
    <value>Impossible d'utiliser le type '{3}' comme paramètre de type '{2}' dans le type ou la méthode générique '{0}'. Le type Nullable '{3}' ne satisfait pas la contrainte de '{1}'. Les types Nullable ne peuvent pas satisfaire les contraintes d'interface.</value>
  </data>
  <data name="GenericConstraintNotSatisfiedValType" xml:space="preserve">
    <value>Impossible d'utiliser le type '{3}' comme paramètre de type '{2}' dans le type ou la méthode générique '{0}'. Il n'y a pas de conversion boxing de '{3}' en '{1}'.</value>
  </data>
  <data name="CantInferMethTypeArgs" xml:space="preserve">
    <value>Impossible de déduire les arguments de type pour la méthode '{0}' à partir de l'utilisation. Essayez de spécifier les arguments de type de façon explicite.</value>
  </data>
  <data name="RefConstraintNotSatisfied" xml:space="preserve">
    <value>Le type '{2}' doit être un type référence afin d'être utilisé comme paramètre '{1}' dans le type ou la méthode générique '{0}'</value>
  </data>
  <data name="ValConstraintNotSatisfied" xml:space="preserve">
    <value>Le type '{2}' doit être un type valeur non Nullable afin d'être utilisé comme paramètre '{1}' dans le type ou la méthode générique '{0}'</value>
  </data>
  <data name="AmbigUDConv" xml:space="preserve">
    <value>Conversions définies par l'utilisateur ambiguës '{0}' et '{1}' lors de la conversion de '{2}' en '{3}'</value>
  </data>
  <data name="BindToBogus" xml:space="preserve">
    <value>'{0}' n'est pas pris en charge par le langage</value>
  </data>
  <data name="CantCallSpecialMethod" xml:space="preserve">
    <value>'{0}' : impossible d'appeler explicitement un opérateur ou un accesseur</value>
  </data>
  <data name="ConvertToStaticClass" xml:space="preserve">
    <value>Impossible de convertir en type static '{0}'</value>
  </data>
  <data name="IncrementLvalueExpected" xml:space="preserve">
    <value>L'opérande d'un opérateur d'incrémentation ou de décrémentation doit être une variable, une propriété ou un indexeur</value>
  </data>
  <data name="BadArgCount" xml:space="preserve">
    <value>Aucune surcharge pour la méthode '{0}' ne prend d'arguments '{1}'</value>
  </data>
  <data name="BadArgTypes" xml:space="preserve">
    <value>La méthode surchargée correspondant le mieux à '{0}' a des arguments non valides</value>
  </data>
  <data name="RefLvalueExpected" xml:space="preserve">
    <value>Un argument ref ou out doit être une variable qui peut être assignée</value>
  </data>
  <data name="BadProtectedAccess" xml:space="preserve">
    <value>Impossible d'accéder au membre protégé '{0}' par l'intermédiaire d'un qualificateur de type '{1}' ; le qualificateur doit être de type '{2}' (ou dérivé de celui-ci)</value>
  </data>
  <data name="BindToBogusProp2" xml:space="preserve">
    <value>La propriété, l'indexeur ou l'événement '{0}' n'est pas pris en charge par le langage ; essayez d'appeler directement les méthodes d'accesseur '{1}' ou '{2}'</value>
  </data>
  <data name="BindToBogusProp1" xml:space="preserve">
    <value>La propriété, l'indexeur ou l'événement '{0}' n'est pas pris en charge par le langage ; essayez d'appeler directement la méthode d'accesseur '{1}'</value>
  </data>
  <data name="BadDelArgCount" xml:space="preserve">
    <value>Le délégué '{0}' ne prend pas les arguments '{1}'</value>
  </data>
  <data name="BadDelArgTypes" xml:space="preserve">
    <value>Le délégué '{0}' utilise des arguments non valides</value>
  </data>
  <data name="AssgReadonlyLocal" xml:space="preserve">
    <value>Impossible d'assigner à '{0}', car il est en lecture seule</value>
  </data>
  <data name="RefReadonlyLocal" xml:space="preserve">
    <value>Impossible de passer '{0}' comme argument ref ou out, car il est en lecture seule</value>
  </data>
  <data name="ReturnNotLValue" xml:space="preserve">
    <value>Impossible de modifier la valeur de retour de '{0}' car il ne s'agit pas d'une variable</value>
  </data>
  <data name="AssgReadonly2" xml:space="preserve">
    <value>Impossible de modifier les membres d'un champ readonly '{0}' (sauf s'ils appartiennent à un constructeur ou un initialiseur de variable)</value>
  </data>
  <data name="RefReadonly2" xml:space="preserve">
    <value>Impossible de passer les membres d'un champ readonly '{0}' en ref ou out (sauf s'ils appartiennent à un constructeur)</value>
  </data>
  <data name="AssgReadonlyStatic2" xml:space="preserve">
    <value>Impossible d'assigner les champs du champ readonly statique '{0}' (sauf s'ils appartiennent à un constructeur statique ou un initialiseur de variable)</value>
  </data>
  <data name="RefReadonlyStatic2" xml:space="preserve">
    <value>Impossible de passer les champs d'un champ readonly statique '{0}' en ref ou out (sauf s'ils appartiennent à un constructeur statique)</value>
  </data>
  <data name="AssgReadonlyLocalCause" xml:space="preserve">
    <value>Impossible d'assigner à '{0}', car il s'agit d'un '{1}'</value>
  </data>
  <data name="RefReadonlyLocalCause" xml:space="preserve">
    <value>Impossible de passer '{0}' en tant qu'argument ref ou out, car il s'agit d'un '{1}'</value>
  </data>
  <data name="BadCtorArgCount" xml:space="preserve">
    <value>'{0}' ne contient pas de constructeur qui accepte des arguments '{1}'</value>
  </data>
  <data name="NonInvocableMemberCalled" xml:space="preserve">
    <value>Impossible d'utiliser un membre '{0}' ne pouvant pas être appelé comme une méthode.</value>
  </data>
  <data name="NamedArgumentSpecificationBeforeFixedArgument" xml:space="preserve">
    <value>Les spécifications d'argument nommé doivent s'afficher après la spécification de tous les arguments fixes</value>
  </data>
  <data name="BadNamedArgument" xml:space="preserve">
    <value>La meilleure surcharge pour '{0}' n'a pas de paramètre nommé '{1}'</value>
  </data>
  <data name="BadNamedArgumentForDelegateInvoke" xml:space="preserve">
    <value>Le délégué '{0}' n'a pas de paramètre nommé '{1}'</value>
  </data>
  <data name="DuplicateNamedArgument" xml:space="preserve">
    <value>Impossible de spécifier plusieurs fois l'argument nommé '{0}'</value>
  </data>
  <data name="NamedArgumentUsedInPositional" xml:space="preserve">
    <value>L'argument nommé '{0}' spécifie un paramètre pour lequel un paramètre positionnel a déjà été donné</value>
  </data>
</root>
