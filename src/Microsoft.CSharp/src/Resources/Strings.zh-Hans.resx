<?xml version="1.0" encoding="utf-8"?>
<root>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="InternalCompilerError" xml:space="preserve">
    <value>绑定动态操作时出现异常</value>
  </data>
  <data name="BindRequireArguments" xml:space="preserve">
    <value>无法在没有调用对象的情况下绑定调用</value>
  </data>
  <data name="BindCallFailedOverloadResolution" xml:space="preserve">
    <value>重载决策失败</value>
  </data>
  <data name="BindBinaryOperatorRequireTwoArguments" xml:space="preserve">
    <value>必须使用两个参数调用二元运算符</value>
  </data>
  <data name="BindUnaryOperatorRequireOneArgument" xml:space="preserve">
    <value>必须使用一个参数调用一元运算符</value>
  </data>
  <data name="BindPropertyFailedMethodGroup" xml:space="preserve">
    <value>名称“{0}”已绑定到某个方法，无法像属性一样使用</value>
  </data>
  <data name="BindPropertyFailedEvent" xml:space="preserve">
    <value>事件 '{0}' 只能出现在左边的 +</value>
  </data>
  <data name="BindInvokeFailedNonDelegate" xml:space="preserve">
    <value>无法调用非委托类型</value>
  </data>
  <data name="BindBinaryAssignmentRequireTwoArguments" xml:space="preserve">
    <value>无法使用一个参数调用二元运算符</value>
  </data>
  <data name="BindBinaryAssignmentFailedNullReference" xml:space="preserve">
    <value>无法对 null 引用执行成员赋值</value>
  </data>
  <data name="NullReferenceOnMemberException" xml:space="preserve">
    <value>无法对 null 引用执行运行时绑定</value>
  </data>
  <data name="BindCallToConditionalMethod" xml:space="preserve">
    <value>无法动态调用方法“{0}”，因为它具有 Conditional 特性</value>
  </data>
  <data name="BindToVoidMethodButExpectResult" xml:space="preserve">
    <value>无法将类型“void”隐式转换为“object”</value>
  </data>
  <data name="BadBinaryOps" xml:space="preserve">
    <value>运算符“{0}”无法应用于“{1}”和“{2}”类型的操作数</value>
  </data>
  <data name="BadIndexLHS" xml:space="preserve">
    <value>无法将带 [] 的索引应用于“{0}”类型的表达式</value>
  </data>
  <data name="BadIndexCount" xml:space="preserve">
    <value>[] 内的索引数错误；应为“{0}”</value>
  </data>
  <data name="BadUnaryOp" xml:space="preserve">
    <value>运算符“{0}”无法应用于“{1}”类型的操作数</value>
  </data>
  <data name="NoImplicitConv" xml:space="preserve">
    <value>无法将类型“{0}”隐式转换为“{1}”</value>
  </data>
  <data name="NoExplicitConv" xml:space="preserve">
    <value>不能转换类型 '{0}' 到 '{1}'</value>
  </data>
  <data name="ConstOutOfRange" xml:space="preserve">
    <value>常量值“{0}”无法转换为“{1}”</value>
  </data>
  <data name="AmbigBinaryOps" xml:space="preserve">
    <value>运算符“{0}”对于“{1}”和“{2}”类型的操作数具有二义性</value>
  </data>
  <data name="AmbigUnaryOp" xml:space="preserve">
    <value>运算符“{0}”对于“{1}”类型的操作数具有二义性</value>
  </data>
  <data name="ValueCantBeNull" xml:space="preserve">
    <value>无法将 null 转换为“{0}”，因为后者是不可以为 null 的值类型</value>
  </data>
  <data name="WrongNestedThis" xml:space="preserve">
    <value>无法通过嵌套类型“{1}”来访问外部类型“{0}”的非静态成员</value>
  </data>
  <data name="NoSuchMember" xml:space="preserve">
    <value>“{0}”未包含“{1}”的定义</value>
  </data>
  <data name="ObjectRequired" xml:space="preserve">
    <value>对象引用对于非静态的字段、方法或属性“{0}”是必需的</value>
  </data>
  <data name="AmbigCall" xml:space="preserve">
    <value>以下方法或属性之间的调用具有二义性:“{0}”和“{1}”</value>
  </data>
  <data name="BadAccess" xml:space="preserve">
    <value>“{0}”不可访问，因为它具有一定的保护级别</value>
  </data>
  <data name="MethDelegateMismatch" xml:space="preserve">
    <value>“{0}”没有与委托“{1}”匹配的重载</value>
  </data>
  <data name="AssgLvalueExpected" xml:space="preserve">
    <value>赋值号左边必须是变量、属性或索引器</value>
  </data>
  <data name="NoConstructors" xml:space="preserve">
    <value>类型“{0}”未定义构造函数</value>
  </data>
  <data name="BadDelegateConstructor" xml:space="preserve">
    <value>委托“{0}”没有有效的构造函数</value>
  </data>
  <data name="PropertyLacksGet" xml:space="preserve">
    <value>属性或索引器“{0}”不能用在此上下文中，因为它缺少 get 访问器</value>
  </data>
  <data name="ObjectProhibited" xml:space="preserve">
    <value>无法使用实例引用来访问成员“{0}”；请改用类型名来限定它</value>
  </data>
  <data name="AssgReadonly" xml:space="preserve">
    <value>无法对只读的字段赋值(构造函数或变量初始值指定项中除外)</value>
  </data>
  <data name="RefReadonly" xml:space="preserve">
    <value>对只读字段无法传递 ref 或 out 参数(构造函数中除外)</value>
  </data>
  <data name="AssgReadonlyStatic" xml:space="preserve">
    <value>无法对静态只读字段赋值(静态构造函数或变量初始值设定项中除外)</value>
  </data>
  <data name="RefReadonlyStatic" xml:space="preserve">
    <value>无法向静态只读字段传递 ref 或 out 参数(静态构造函数中除外)</value>
  </data>
  <data name="AssgReadonlyProp" xml:space="preserve">
    <value>无法为属性或索引器“{0}”赋值 - 它是只读的</value>
  </data>
  <data name="RefProperty" xml:space="preserve">
    <value>属性或索引器不得作为 out 或 ref 参数传递</value>
  </data>
  <data name="UnsafeNeeded" xml:space="preserve">
    <value>动态调用不能与指针一起使用</value>
  </data>
  <data name="BadBoolOp" xml:space="preserve">
    <value>为了可以像短路运算符一样应用，用户定义的逻辑运算符(“{0}”)的返回类型必须与它的两个参数的类型相同</value>
  </data>
  <data name="MustHaveOpTF" xml:space="preserve">
    <value>类型(“{0}”)必须包含运算符 True 和运算符 False 的声明</value>
  </data>
  <data name="ConstOutOfRangeChecked" xml:space="preserve">
    <value>常量值“{0}”无法转换为“{1}”(使用“unchecked”语法重写)</value>
  </data>
  <data name="AmbigMember" xml:space="preserve">
    <value>在“{0}”和“{1}”之间具有二义性</value>
  </data>
  <data name="NoImplicitConvCast" xml:space="preserve">
    <value>无法将类型“{0}”隐式转换为“{1}”。存在一个显式转换(是否缺少强制转换?)</value>
  </data>
  <data name="InaccessibleGetter" xml:space="preserve">
    <value>属性或索引器“{0}”不能用在此上下文中，因为 get 访问器不可访问</value>
  </data>
  <data name="InaccessibleSetter" xml:space="preserve">
    <value>属性或索引器“{0}”不能用在此上下文中，因为 set 访问器不可访问</value>
  </data>
  <data name="BadArity" xml:space="preserve">
    <value>使用泛型 {1}“{0}”需要“{2}”个类型参数</value>
  </data>
  <data name="BadTypeArgument" xml:space="preserve">
    <value>类型"{0}"不可能用作类型参数</value>
  </data>
  <data name="TypeArgsNotAllowed" xml:space="preserve">
    <value>{1}“{0}”不能与类型参数一起使用</value>
  </data>
  <data name="HasNoTypeVars" xml:space="preserve">
    <value>非泛型 {1}“{0}”不能与类型参数一起使用</value>
  </data>
  <data name="NewConstraintNotSatisfied" xml:space="preserve">
    <value>“{2}”必须是具有公共的无参数构造函数的非抽象类型，才能用作泛型类型或方法“{0}”中的参数“{1}”</value>
  </data>
  <data name="GenericConstraintNotSatisfiedRefType" xml:space="preserve">
    <value>类型“{3}”不能用作泛型类型或方法“{0}”中的类型参数“{2}”。没有从“{3}”到“{1}”的隐式引用转换。</value>
  </data>
  <data name="GenericConstraintNotSatisfiedNullableEnum" xml:space="preserve">
    <value>类型“{3}”不能用作泛型类型或方法“{0}”中的类型参数“{2}”。可以为 null 的类型“{3}”不满足“{1}”的约束。</value>
  </data>
  <data name="GenericConstraintNotSatisfiedNullableInterface" xml:space="preserve">
    <value>类型“{3}”不能用作泛型类型或方法“{0}”中的类型参数“{2}”。可以为 null 的类型“{3}”不满足“{1}”的约束。可以为 null 的类型不能满足任何接口约束。</value>
  </data>
  <data name="GenericConstraintNotSatisfiedTyVar" xml:space="preserve">
    <value>类型“{3}”不能用作泛型类型或方法“{0}”中的类型参数“{2}”。没有从“{3}”到“{1}”的装箱转换或类型参数转换。</value>
  </data>
  <data name="GenericConstraintNotSatisfiedValType" xml:space="preserve">
    <value>类型“{3}”不能用作泛型类型或方法“{0}”中的类型参数“{2}”。没有从“{3}”到“{1}”的装箱转换。</value>
  </data>
  <data name="TypeVarCantBeNull" xml:space="preserve">
    <value>无法将 null 转换为类型参数“{0}”，因为它可能是不可以为 null 的值类型。请考虑改用“default({0})”。</value>
  </data>
  <data name="BadRetType" xml:space="preserve">
    <value>“{1} {0}”的返回类型错误</value>
  </data>
  <data name="CantInferMethTypeArgs" xml:space="preserve">
    <value>无法从用法中推断出方法“{0}”的类型参数。请尝试显式指定类型参数。</value>
  </data>
  <data name="MethGrpToNonDel" xml:space="preserve">
    <value>无法将方法组“{0}”转换为非委托类型“{1}”。是否希望调用此方法?</value>
  </data>
  <data name="RefConstraintNotSatisfied" xml:space="preserve">
    <value>类型“{2}”必须是引用类型才能用作泛型类型或方法“{0}”中的参数“{1}”</value>
  </data>
  <data name="ValConstraintNotSatisfied" xml:space="preserve">
    <value>类型“{2}”必须是不可以为 null 值的类型，才能用作泛型类型或方法“{0}”中的参数“{1}”</value>
  </data>
  <data name="AmbigUDConv" xml:space="preserve">
    <value>从“{2}”转换为“{3}”时，用户定义的转换“{0}”和“{1}”具有二义性</value>
  </data>
  <data name="BindToBogus" xml:space="preserve">
    <value>现用语言不支持“{0}”</value>
  </data>
  <data name="CantCallSpecialMethod" xml:space="preserve">
    <value>“{0}”: 无法显式调用运算符或访问器</value>
  </data>
  <data name="ConvertToStaticClass" xml:space="preserve">
    <value>无法转换为静态类型“{0}”</value>
  </data>
  <data name="GenericArgIsStaticClass" xml:space="preserve">
    <value>“{0}”: 静态类型不能用作类型参数</value>
  </data>
  <data name="IncrementLvalueExpected" xml:space="preserve">
    <value>递增或递减运算符的操作数必须是变量、属性或索引器</value>
  </data>
  <data name="NoSuchMemberOrExtension" xml:space="preserve">
    <value>“{0}”未包含“{1}”的定义，并且找不到可接受第一个“{0}”类型参数的扩展方法“{1}”(是否缺少 using 指令或程序集引用?)</value>
  </data>
  <data name="ValueTypeExtDelegate" xml:space="preserve">
    <value>无法使用值类型“{1}”定义的扩展方法“{0}”来创建委托</value>
  </data>
  <data name="BadArgCount" xml:space="preserve">
    <value>“{0}”方法没有采用“{1}”个参数的重载</value>
  </data>
  <data name="BadArgTypes" xml:space="preserve">
    <value>与“{0}”最匹配的重载方法具有一些无效参数</value>
  </data>
  <data name="BadArgType" xml:space="preserve">
    <value>参数“{0}”: 无法从“{1}”转换为“{2}”</value>
  </data>
  <data name="RefLvalueExpected" xml:space="preserve">
    <value>ref 或 out 参数必须是可以赋值的变量</value>
  </data>
  <data name="BadProtectedAccess" xml:space="preserve">
    <value>无法通过“{1}”类型的限定符访问受保护的成员“{0}”；限定符必须是“{2}”类型(或者从该类型派生)</value>
  </data>
  <data name="BindToBogusProp2" xml:space="preserve">
    <value>属性、索引器或事件“{0}”不受现用语言支持；请尝试直接调用访问器方法“{1}”或“{2}”</value>
  </data>
  <data name="BindToBogusProp1" xml:space="preserve">
    <value>属性、索引器或事件“{0}”不受现用语言支持；请尝试直接调用访问器方法“{1}”</value>
  </data>
  <data name="BadDelArgCount" xml:space="preserve">
    <value>委托“{0}”未采用“{1}”个参数</value>
  </data>
  <data name="BadDelArgTypes" xml:space="preserve">
    <value>委托“{0}”有一些无效参数</value>
  </data>
  <data name="AssgReadonlyLocal" xml:space="preserve">
    <value>无法为“{0}”赋值，因为它是只读的</value>
  </data>
  <data name="RefReadonlyLocal" xml:space="preserve">
    <value>无法将“{0}”作为 ref 或 out 参数传递，因为它是只读的</value>
  </data>
  <data name="ReturnNotLValue" xml:space="preserve">
    <value>无法修改“{0}”的返回值，因为它不是变量</value>
  </data>
  <data name="BadArgExtraRef" xml:space="preserve">
    <value>参数“{0}”不应使用关键字“{1}”传递</value>
  </data>
  <data name="BadArgRef" xml:space="preserve">
    <value>参数“{0}”必须使用关键字“{1}”传递</value>
  </data>
  <data name="AssgReadonly2" xml:space="preserve">
    <value>无法修改只读字段“{0}”的成员(在构造函数或变量初始值设定项中除外)</value>
  </data>
  <data name="RefReadonly2" xml:space="preserve">
    <value>无法为只读字段“{0}”的成员传递 ref 或 out (在构造函数中除外)</value>
  </data>
  <data name="AssgReadonlyStatic2" xml:space="preserve">
    <value>无法为静态只读字段“{0}”的字段赋值(在静态构造函数或变量初始值设定项中除外)</value>
  </data>
  <data name="RefReadonlyStatic2" xml:space="preserve">
    <value>无法为静态只读字段“{0}”的字段传递 ref 或 out (在静态构造函数中除外)</value>
  </data>
  <data name="AssgReadonlyLocalCause" xml:space="preserve">
    <value>无法为“{0}”赋值，因为它是“{1}”</value>
  </data>
  <data name="RefReadonlyLocalCause" xml:space="preserve">
    <value>“{0}”是一个“{1}”，无法作为 ref 或 out 参数进行传递</value>
  </data>
  <data name="DelegateOnNullable" xml:space="preserve">
    <value>不能将委托绑定到 '{0}'，因为它是 'System.Nullable&lt;T&gt;' 成员</value>
  </data>
  <data name="BadCtorArgCount" xml:space="preserve">
    <value>“{0}”不包含采用“{1}”个参数的构造函数</value>
  </data>
  <data name="BadExtensionArgTypes" xml:space="preserve">
    <value>“{0}”不包含“{1}”的定义，并且最佳扩展方法重载“{2}”具有一些无效参数</value>
  </data>
  <data name="BadInstanceArgType" xml:space="preserve">
    <value>实例参数: 无法从“{0}”转换为“{1}”</value>
  </data>
  <data name="NonInvocableMemberCalled" xml:space="preserve">
    <value>不可调用的成员“{0}”不能像方法一样使用。</value>
  </data>
  <data name="NamedArgumentSpecificationBeforeFixedArgument" xml:space="preserve">
    <value>命名参数规范必须出现在所有指定的固定参数后</value>
  </data>
  <data name="BadNamedArgument" xml:space="preserve">
    <value>“{0}”的最佳重载没有名为“{1}”的参数</value>
  </data>
  <data name="BadNamedArgumentForDelegateInvoke" xml:space="preserve">
    <value>委托“{0}”没有名为“{1}”的参数</value>
  </data>
  <data name="DuplicateNamedArgument" xml:space="preserve">
    <value>不能多次指定所命名的参数“{0}”。</value>
  </data>
  <data name="NamedArgumentUsedInPositional" xml:space="preserve">
    <value>命名实参“{0}”指定的形参已被赋予位置实参</value>
  </data>
</root>
