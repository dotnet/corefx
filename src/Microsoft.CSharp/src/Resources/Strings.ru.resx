<?xml version="1.0" encoding="utf-8"?>
<root>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="InternalCompilerError" xml:space="preserve">
    <value>Возникло непредвиденное исключение при выполнении привязки динамической операции</value>
  </data>
  <data name="BindRequireArguments" xml:space="preserve">
    <value>Невозможно выполнить привязку вызова к невызывающему объекту</value>
  </data>
  <data name="BindCallFailedOverloadResolution" xml:space="preserve">
    <value>Сбой при разрешении перегрузки</value>
  </data>
  <data name="BindBinaryOperatorRequireTwoArguments" xml:space="preserve">
    <value>Бинарные операторы должны вызываться с использованием двух аргументов</value>
  </data>
  <data name="BindUnaryOperatorRequireOneArgument" xml:space="preserve">
    <value>Унарные операторы должны быть вызваны с использованием одного аргумента</value>
  </data>
  <data name="BindPropertyFailedMethodGroup" xml:space="preserve">
    <value>Для имени "{0}" выполнена привязка к методу. Невозможно использовать его как свойство</value>
  </data>
  <data name="BindPropertyFailedEvent" xml:space="preserve">
    <value>Событие «{0}» может появляться только на стороне левой руки +</value>
  </data>
  <data name="BindInvokeFailedNonDelegate" xml:space="preserve">
    <value>Не удалось вызвать тип, не являющийся делегатом</value>
  </data>
  <data name="BindImplicitConversionRequireOneArgument" xml:space="preserve">
    <value>Для неявного преобразования нужен строго один аргумент</value>
  </data>
  <data name="BindExplicitConversionRequireOneArgument" xml:space="preserve">
    <value>Для явного преобразования нужен строго один аргумент</value>
  </data>
  <data name="BindBinaryAssignmentRequireTwoArguments" xml:space="preserve">
    <value>Невозможно вызвать бинарные операторы с использованием одного аргумента</value>
  </data>
  <data name="BindBinaryAssignmentFailedNullReference" xml:space="preserve">
    <value>Не удается выполнить присваивание члена по нулевой ссылке</value>
  </data>
  <data name="NullReferenceOnMemberException" xml:space="preserve">
    <value>Не удается выполнить привязки исполняющей среды по нулевой ссылке</value>
  </data>
  <data name="BindCallToConditionalMethod" xml:space="preserve">
    <value>Не удается динамически вызвать метод "{0}", так как у него есть условный атрибут</value>
  </data>
  <data name="BindToVoidMethodButExpectResult" xml:space="preserve">
    <value>Нельзя неявно преобразовать тип "void" to "object"</value>
  </data>
  <data name="BadBinaryOps" xml:space="preserve">
    <value>Не удается применить оператор "{0}" к операндам типа "{1}" и "{2}"</value>
  </data>
  <data name="IntDivByZero" xml:space="preserve">
    <value>Деление на ноль постоянной</value>
  </data>
  <data name="BadIndexLHS" xml:space="preserve">
    <value>Невозможно применить индексирование через [] к выражению типа "{0}"</value>
  </data>
  <data name="BadIndexCount" xml:space="preserve">
    <value>Неверное количество индексов внутри []; ожидалось "{0}"</value>
  </data>
  <data name="BadUnaryOp" xml:space="preserve">
    <value>Не удается применить операнд "{0}" типа "{1}"</value>
  </data>
  <data name="NoImplicitConv" xml:space="preserve">
    <value>Не удается неявно преобразовать тип "{0}" в "{1}"</value>
  </data>
  <data name="NoExplicitConv" xml:space="preserve">
    <value>Невозможно преобразовать тип "{0}" в "{1}"</value>
  </data>
  <data name="ConstOutOfRange" xml:space="preserve">
    <value>Постоянное значение "{0}" не может быть преобразовано в "{1}"</value>
  </data>
  <data name="AmbigBinaryOps" xml:space="preserve">
    <value>Оператор "{0}" является неоднозначным по отношению к операндам типа "{1}" и "{2}"</value>
  </data>
  <data name="AmbigUnaryOp" xml:space="preserve">
    <value>Оператор "{0}" является неоднозначным по отношению к операнду типа "{1}"</value>
  </data>
  <data name="ValueCantBeNull" xml:space="preserve">
    <value>Cannot convert null to "{0}" because it is a non-nullable value type</value>
  </data>
  <data name="WrongNestedThis" xml:space="preserve">
    <value>Невозможно получить доступ к нестатическому члену внешнего типа "{0}" через вложенный тип "{1}"</value>
  </data>
  <data name="NoSuchMember" xml:space="preserve">
    <value>"{0}" не содержит определения для "{1}"</value>
  </data>
  <data name="ObjectRequired" xml:space="preserve">
    <value>Для нестатического поля, метода или свойства "{0}" требуется ссылка на объект</value>
  </data>
  <data name="AmbigCall" xml:space="preserve">
    <value>Понятие "вызов" трактуется неоднозначно в следующих методах или свойствах: "{0}" и "{1}"</value>
  </data>
  <data name="BadAccess" xml:space="preserve">
    <value>"{0}" недоступен из-за его уровня защиты</value>
  </data>
  <data name="MethDelegateMismatch" xml:space="preserve">
    <value>Нет перегрузки для "{0}", соответствующей делегату "{1}"</value>
  </data>
  <data name="AssgLvalueExpected" xml:space="preserve">
    <value>Левая часть выражения присваивания должна быть переменной, свойством или индексатором</value>
  </data>
  <data name="NoConstructors" xml:space="preserve">
    <value>Для типа "{0}" нет определенных конструкторов</value>
  </data>
  <data name="BadDelegateConstructor" xml:space="preserve">
    <value>Делегат "{0}" не имеет допустимого конструктора</value>
  </data>
  <data name="PropertyLacksGet" xml:space="preserve">
    <value>The property or indexer "{0}" cannot be used in this context because it lacks the get accessor</value>
  </data>
  <data name="ObjectProhibited" xml:space="preserve">
    <value>Доступ к члену "{0}" через ссылку на экземпляр невозможен; вместо этого уточните его, указав имя типа</value>
  </data>
  <data name="AssgReadonly" xml:space="preserve">
    <value>Присваивание значений доступному только для чтения полю допускается только в конструкторе и в инициализаторе переменных</value>
  </data>
  <data name="RefReadonly" xml:space="preserve">
    <value>Доступное только для чтения поле может передаваться как параметр с ключевым словом ref или out только в конструкторе</value>
  </data>
  <data name="AssgReadonlyStatic" xml:space="preserve">
    <value>Присваивание значений доступному только для чтения статическому полю допускается только в статическом конструкторе и в инициализаторе переменных</value>
  </data>
  <data name="RefReadonlyStatic" xml:space="preserve">
    <value>Доступное только для чтения статическое поле может передаваться как параметр с ключевым словом ref или out только в статическом конструкторе</value>
  </data>
  <data name="AssgReadonlyProp" xml:space="preserve">
    <value>Невозможно присвоить значение свойству или индексатору "{0}" -- доступ только для чтения</value>
  </data>
  <data name="AbstractBaseCall" xml:space="preserve">
    <value>Не удается вызвать абстрактный член базового класса: "{0}"</value>
  </data>
  <data name="RefProperty" xml:space="preserve">
    <value>Свойства и индексаторы не могут передаваться как параметры с ключевыми словами out и ref</value>
  </data>
  <data name="ManagedAddr" xml:space="preserve">
    <value>Невозможно получить адрес, определить размер или объявить указатель на управляемый тип ("{0}")</value>
  </data>
  <data name="FixedNotNeeded" xml:space="preserve">
    <value>Получить адрес фиксированного выражения с помощью оператора fixed невозможно</value>
  </data>
  <data name="UnsafeNeeded" xml:space="preserve">
    <value>Динамические вызовы нельзя использовать в сопряжении с указателями</value>
  </data>
  <data name="BadBoolOp" xml:space="preserve">
    <value>Для использования в качестве логического оператора краткой записи тип возвращаемого значения пользовательского логического оператора ("{0}") должен быть аналогичен типам двух его параметров</value>
  </data>
  <data name="MustHaveOpTF" xml:space="preserve">
    <value>Тип ("{0}") должен содержать объявления оператора true и оператора false</value>
  </data>
  <data name="CheckedOverflow" xml:space="preserve">
    <value>Операция вызывает переполнение во время компиляции в проверяемом режиме</value>
  </data>
  <data name="ConstOutOfRangeChecked" xml:space="preserve">
    <value>Постоянное значение "{0}" не может быть преобразовано в "{1}" (для обхода используйте синтаксис "unchecked")</value>
  </data>
  <data name="AmbigMember" xml:space="preserve">
    <value>Неоднозначность между "{0}" и "{1}"</value>
  </data>
  <data name="SizeofUnsafe" xml:space="preserve">
    <value>"{0}" does not have a predefined size, therefore sizeof can only be used in an unsafe context (consider using System.Runtime.InteropServices.Marshal.SizeOf)</value>
  </data>
  <data name="FieldInitRefNonstatic" xml:space="preserve">
    <value>Инициализатор поля не может обращаться к нестатическому полю, методу или свойству "{0}"</value>
  </data>
  <data name="CallingFinalizeDepracated" xml:space="preserve">
    <value>Непосредственный вызов деструкторов и функций object.Finalize запрещен. Рекомендуется вызов IDisposable.Dispose, если она доступна.</value>
  </data>
  <data name="CallingBaseFinalizeDeprecated" xml:space="preserve">
    <value>Не вызывайте метод Finalize базового класса напрямую. Он вызывается автоматически из деструктора.</value>
  </data>
  <data name="BadCastInFixed" xml:space="preserve">
    <value>Правая часть присваивания оператора fixed не может быть выражением приведения типа</value>
  </data>
  <data name="NoImplicitConvCast" xml:space="preserve">
    <value>Не удается неявно преобразовать тип "{0}" в "{1}". Существует явное преобразование (требуется приведение типа?)</value>
  </data>
  <data name="InaccessibleGetter" xml:space="preserve">
    <value>Свойство или индексатор "{0}" невозможно использовать в данном контексте, поскольку метод доступа get недоступен</value>
  </data>
  <data name="InaccessibleSetter" xml:space="preserve">
    <value>Свойство или индексатор "{0}" невозможно использовать в данном контексте, поскольку метод доступа set недоступен</value>
  </data>
  <data name="BadArity" xml:space="preserve">
    <value>Использование универсального {1} "{0}" требует аргументов типа "{2}"</value>
  </data>
  <data name="BadTypeArgument" xml:space="preserve">
    <value>Тип '{0}' не может использоваться в качестве аргумента типа</value>
  </data>
  <data name="TypeArgsNotAllowed" xml:space="preserve">
    <value>{1} "{0}" не может использоваться с аргументами типа</value>
  </data>
  <data name="HasNoTypeVars" xml:space="preserve">
    <value>Неуниверсальный {1} "{0}" не может использоваться с аргументами типа</value>
  </data>
  <data name="NewConstraintNotSatisfied" xml:space="preserve">
    <value>"Для использования в качестве параметра "{1}" в универсальном типе или методе "{0}" тип "{2}" должен быть неабстрактным и иметь открытый конструктор без параметров</value>
  </data>
  <data name="GenericConstraintNotSatisfiedRefType" xml:space="preserve">
    <value>Невозможно использовать тип "{3}" в качестве параметра типа "{2}" в универсальном типе или методе "{0}". Нет неявного преобразования ссылки из "{3}" в "{1}".</value>
  </data>
  <data name="GenericConstraintNotSatisfiedNullableEnum" xml:space="preserve">
    <value>Невозможно использовать тип "{3}" в качестве параметра типа "{2}" в универсальном типе или методе "{0}". Для типа "{3}", допускающего значение null, не выполняется ограничение "{1}".</value>
  </data>
  <data name="GenericConstraintNotSatisfiedNullableInterface" xml:space="preserve">
    <value>Невозможно использовать тип "{3}" в качестве параметра типа "{2}" в универсальном типе или методе "{0}". Для типа "{3}", допускающего значение null, не выполняется ограничение "{1}". Типы, допускающие значение null, не могут удовлетворять ни одному интерфейсному ограничению.</value>
  </data>
  <data name="GenericConstraintNotSatisfiedTyVar" xml:space="preserve">
    <value>Невозможно использовать тип "{3}" в качестве параметра типа "{2}" в универсальном типе или методе "{0}". Нет преобразования-упаковки или преобразования типа параметра из "{3}" в "{1}".</value>
  </data>
  <data name="GenericConstraintNotSatisfiedValType" xml:space="preserve">
    <value>Невозможно использовать тип "{3}" в качестве параметра типа "{2}" в универсальном типе или методе "{0}". Нет преобразования-упаковки из "{3}" в "{1}".</value>
  </data>
  <data name="TypeVarCantBeNull" xml:space="preserve">
    <value>Cannot convert null to type parameter "{0}" because it could be a non-nullable value type. Вместо этого рекомендуется использовать "default({0})".</value>
  </data>
  <data name="BadRetType" xml:space="preserve">
    <value>"{1} {0}" имеет неправильный возвращаемый тип</value>
  </data>
  <data name="CantInferMethTypeArgs" xml:space="preserve">
    <value>The type arguments for method "{0}" cannot be inferred from the usage. Попытайтесь явно определить аргументы-типы.</value>
  </data>
  <data name="MethGrpToNonDel" xml:space="preserve">
    <value>Не удается преобразовать группу методов "{0}" в тип, не являющийся делегатом "{1}". Предполагается ли вызывать этот метод?</value>
  </data>
  <data name="RefConstraintNotSatisfied" xml:space="preserve">
    <value>Для использования в качестве параметра "{1}" в универсальном типе или методе "{0}" тип "{2}" должен быть ссылочным типом</value>
  </data>
  <data name="ValConstraintNotSatisfied" xml:space="preserve">
    <value>Для использования в качестве параметра "{1}" в универсальном типе или методе "{0}" тип "{2}" должен быть типом значения, не допускающим значения NULL</value>
  </data>
  <data name="CircularConstraint" xml:space="preserve">
    <value>Циклическая зависимость ограничения, включающая "{0}" и "{1}"</value>
  </data>
  <data name="BaseConstraintConflict" xml:space="preserve">
    <value>Параметр типа "{0}" наследует конфликтующие ограничения "{1}" и "{2}"</value>
  </data>
  <data name="ConWithValCon" xml:space="preserve">
    <value>Параметр типа "{1}" имеет ограничение "struct", поэтому "{1}" не может использоваться в качестве ограничения для "{0}"</value>
  </data>
  <data name="AmbigUDConv" xml:space="preserve">
    <value>Неоднозначные пользовательские преобразования "{0}" и "{1}" при преобразовании из "{2}" в "{3}"</value>
  </data>
  <data name="PredefinedTypeNotFound" xml:space="preserve">
    <value>Предопределенный тип "{0}" не определен и не импортирован</value>
  </data>
  <data name="PredefinedTypeBadType" xml:space="preserve">
    <value>Предопределенный тип "{0}" объявлен неправильно</value>
  </data>
  <data name="BindToBogus" xml:space="preserve">
    <value>"{0}" не поддерживается языком</value>
  </data>
  <data name="CantCallSpecialMethod" xml:space="preserve">
    <value>"{0}": явный вызов оператора или метода доступа невозможен</value>
  </data>
  <data name="BogusType" xml:space="preserve">
    <value>"{0}" является типом, который не поддерживается в данном языке</value>
  </data>
  <data name="MissingPredefinedMember" xml:space="preserve">
    <value>Отсутствует обязательный для компилятора член "{0}.{1}"</value>
  </data>
  <data name="LiteralDoubleCast" xml:space="preserve">
    <value>Литерал с типом double не может быть неявно преобразован к типу "{1}"; для создания литерала этого типа следует воспользоваться суффиксом "{0}"</value>
  </data>
  <data name="UnifyingInterfaceInstantiations" xml:space="preserve">
    <value>"{0}" не в состоянии реализовать как "{1}", так и "{2}", поскольку они могут быть идентичными для некоторых подстановок параметров-типов</value>
  </data>
  <data name="ConvertToStaticClass" xml:space="preserve">
    <value>Не удается выполнить преобразование к статическому типу "{0}"</value>
  </data>
  <data name="GenericArgIsStaticClass" xml:space="preserve">
    <value>"{0}": нельзя использовать статические типы в качестве аргументов-типов</value>
  </data>
  <data name="PartialMethodToDelegate" xml:space="preserve">
    <value>Невозможно создать делегат на основе метода "{0}", поскольку он является разделяемым методом без реализующего объявления</value>
  </data>
  <data name="IncrementLvalueExpected" xml:space="preserve">
    <value>Операндом оператора инкремента или декремента должна быть переменная, свойство или индексатор</value>
  </data>
  <data name="NoSuchMemberOrExtension" xml:space="preserve">
    <value>"{0}" не содержит определения для "{1}", а найти метод расширения "{1}", принимающий первый аргумент типа "{0}", не удалось (возможно, пропущена директива using или ссылка на сборку)</value>
  </data>
  <data name="ValueTypeExtDelegate" xml:space="preserve">
    <value>Методы расширения "{0}", определенные для типа значения "{1}", не могут применяться для создания делегатов</value>
  </data>
  <data name="BadArgCount" xml:space="preserve">
    <value>Отсутствие перегрузки для метода "{0}" принимает"{1}" аргументы</value>
  </data>
  <data name="BadArgTypes" xml:space="preserve">
    <value>Наиболее подходящий перегруженный метод для "{0}" имеет несколько недопустимых аргументов</value>
  </data>
  <data name="BadArgType" xml:space="preserve">
    <value>Аргумент "{0}": невозможно преобразовать из "{1}" в "{2}"</value>
  </data>
  <data name="RefLvalueExpected" xml:space="preserve">
    <value>Аргумент с ключевым словом ref или out должен быть переменной, которой можно присвоить значение</value>
  </data>
  <data name="BadProtectedAccess" xml:space="preserve">
    <value>Не удается получить доступ к защищенному члену "{0}" через квалификатор типа "{1}"; квалификатор должен иметь тип "{2}" (или производный от него)</value>
  </data>
  <data name="BindToBogusProp2" xml:space="preserve">
    <value>Свойство, индексатор или событие "{0}" не поддерживается в данном языке; попробуйте вызвать метод доступа "{1}" или "{2}"</value>
  </data>
  <data name="BindToBogusProp1" xml:space="preserve">
    <value>Свойство, индексатор или событие "{0}" не поддерживается в данном языке; попробуйте вызвать метод доступа "{1}" или "{2}"</value>
  </data>
  <data name="BadDelArgCount" xml:space="preserve">
    <value>Делегат "{0}" не принимает аргументы "{1}"</value>
  </data>
  <data name="BadDelArgTypes" xml:space="preserve">
    <value>Делегат "{0}" имеет недопустимые аргументы</value>
  </data>
  <data name="AssgReadonlyLocal" xml:space="preserve">
    <value>Не удается выполнить присвоение параметру "{0}", так как он доступен только для чтения</value>
  </data>
  <data name="RefReadonlyLocal" xml:space="preserve">
    <value>Cannot pass "{0}" as a ref or out argument because it is read-only</value>
  </data>
  <data name="ReturnNotLValue" xml:space="preserve">
    <value>Cannot modify the return value of "{0}" because it is not a variable</value>
  </data>
  <data name="BadArgExtraRef" xml:space="preserve">
    <value>Аргумент "{0}" должен быть передан с ключевым словом "{1}"</value>
  </data>
  <data name="BadArgRef" xml:space="preserve">
    <value>Аргумент "{0}" должен быть передан с ключевым словом "{1}"</value>
  </data>
  <data name="AssgReadonly2" xml:space="preserve">
    <value>Члены поля "{0}", предназначенного только для чтения, могут быть изменены только в конструкторе или инициализаторе переменных</value>
  </data>
  <data name="RefReadonly2" xml:space="preserve">
    <value>Members of readonly field "{0}" cannot be passed ref or out (except in a constructor)</value>
  </data>
  <data name="AssgReadonlyStatic2" xml:space="preserve">
    <value>Присваивание значений полям доступного только для чтения статического поля "{0}" допускается только в статическом конструкторе и в инициализаторе переменных</value>
  </data>
  <data name="RefReadonlyStatic2" xml:space="preserve">
    <value>Fields of static readonly field "{0}" cannot be passed ref or out (except in a static constructor)</value>
  </data>
  <data name="AssgReadonlyLocalCause" xml:space="preserve">
    <value>Не удается выполнить присвоение параметру "{0}", так как он является "{1}"</value>
  </data>
  <data name="RefReadonlyLocalCause" xml:space="preserve">
    <value>Не удалось передать "{0}" как ссылку или аргумент out, так как это "{1}"</value>
  </data>
  <data name="ThisStructNotInAnonMeth" xml:space="preserve">
    <value>Анонимные методы, лямбда-выражения и выражения запроса внутри структуры не имеет доступа к членам экземпляра "this". Возможно, следует скопировать "this" в локальную переменную за пределами анонимного метода, лямбда-выражения или выражения запроса и использовать эту локальную переменную.</value>
  </data>
  <data name="DelegateOnNullable" xml:space="preserve">
    <value>Не удается привязать делегат '{0}', потому что он является членом «System.Nullable&lt;T&gt;»</value>
  </data>
  <data name="BadCtorArgCount" xml:space="preserve">
    <value>"{0}" не содержит конструктор, принимающий аргументов: {1}</value>
  </data>
  <data name="BadExtensionArgTypes" xml:space="preserve">
    <value>"{0}" не содержит определения для "{1}", наилучшая перегрузка метода расширения "{2}" имеет такие же недопустимые аргументы</value>
  </data>
  <data name="BadInstanceArgType" xml:space="preserve">
    <value>Instance argument: невозможно преобразовать из "{0}" в "{1}"</value>
  </data>
  <data name="BadArgTypesForCollectionAdd" xml:space="preserve">
    <value>Наиболее подходящий перегруженный метод Add "{0}" для инициализатора коллекции содержит недопустимые аргументы</value>
  </data>
  <data name="InitializerAddHasParamModifiers" xml:space="preserve">
    <value>Наиболее подходящий перегруженный метод, соответствующий "{0}" для элемента инициализации коллекции не может быть использован. Методы инициализации коллекции "Add" не имеют ссылочных и выходных параметров.</value>
  </data>
  <data name="NonInvocableMemberCalled" xml:space="preserve">
    <value>Невызываемый член "{0}" не может использоваться как метод.</value>
  </data>
  <data name="NamedArgumentSpecificationBeforeFixedArgument" xml:space="preserve">
    <value>Спецификации именованного аргумента должны появляться во всех указанных фиксированных аргументах</value>
  </data>
  <data name="BadNamedArgument" xml:space="preserve">
    <value>Наиболее подходящий перегруженный метод для "{0}" не имеет параметра "{1}"</value>
  </data>
  <data name="BadNamedArgumentForDelegateInvoke" xml:space="preserve">
    <value>Делегат "{0}" не имеет параметра "{1}"</value>
  </data>
  <data name="DuplicateNamedArgument" xml:space="preserve">
    <value>Не удается задать именованный аргумент "{0}" несколько раз</value>
  </data>
  <data name="NamedArgumentUsedInPositional" xml:space="preserve">
    <value>Именованный аргумент "{0}" задает параметр, для которого уже был установлен позиционный аргумент.</value>
  </data>
</root>