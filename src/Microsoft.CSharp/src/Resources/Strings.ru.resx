<root>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="InternalCompilerError" xml:space="preserve">
    <value>Возникло непредвиденное исключение при выполнении привязки динамической операции</value>
  </data>
  <data name="BindRequireArguments" xml:space="preserve">
    <value>Невозможно выполнить привязку вызова к невызывающему объекту</value>
  </data>
  <data name="BindCallFailedOverloadResolution" xml:space="preserve">
    <value>Сбой при разрешении перегрузки</value>
  </data>
  <data name="BindBinaryOperatorRequireTwoArguments" xml:space="preserve">
    <value>Бинарные операторы должны вызываться с использованием двух аргументов</value>
  </data>
  <data name="BindUnaryOperatorRequireOneArgument" xml:space="preserve">
    <value>Унарные операторы должны быть вызваны с использованием одного аргумента</value>
  </data>
  <data name="BindPropertyFailedMethodGroup" xml:space="preserve">
    <value>Для имени "{0}" выполнена привязка к методу. Невозможно использовать его как свойство</value>
  </data>
  <data name="BindPropertyFailedEvent" xml:space="preserve">
    <value>Событие «{0}» может появляться только на стороне левой руки +</value>
  </data>
  <data name="BindInvokeFailedNonDelegate" xml:space="preserve">
    <value>Не удалось вызвать тип, не являющийся делегатом</value>
  </data>
  <data name="BindBinaryAssignmentRequireTwoArguments" xml:space="preserve">
    <value>Невозможно вызвать бинарные операторы с использованием одного аргумента</value>
  </data>
  <data name="BindBinaryAssignmentFailedNullReference" xml:space="preserve">
    <value>Не удается выполнить присваивание члена по нулевой ссылке</value>
  </data>
  <data name="NullReferenceOnMemberException" xml:space="preserve">
    <value>Не удается выполнить привязки исполняющей среды по нулевой ссылке</value>
  </data>
  <data name="BindCallToConditionalMethod" xml:space="preserve">
    <value>Не удается динамически вызвать метод "{0}", так как у него есть условный атрибут</value>
  </data>
  <data name="BindToVoidMethodButExpectResult" xml:space="preserve">
    <value>Нельзя неявно преобразовать тип "void" to "object"</value>
  </data>
  <data name="BadBinaryOps" xml:space="preserve">
    <value>Не удается применить оператор "{0}" к операндам типа "{1}" и "{2}"</value>
  </data>
  <data name="BadIndexLHS" xml:space="preserve">
    <value>Невозможно применить индексирование через [] к выражению типа "{0}"</value>
  </data>
  <data name="BadIndexCount" xml:space="preserve">
    <value>Неверное количество индексов внутри []; ожидалось "{0}"</value>
  </data>
  <data name="BadUnaryOp" xml:space="preserve">
    <value>Не удается применить операнд "{0}" типа "{1}"</value>
  </data>
  <data name="NoImplicitConv" xml:space="preserve">
    <value>Не удается неявно преобразовать тип "{0}" в "{1}"</value>
  </data>
  <data name="NoExplicitConv" xml:space="preserve">
    <value>Невозможно преобразовать тип "{0}" в "{1}"</value>
  </data>
  <data name="ConstOutOfRange" xml:space="preserve">
    <value>Постоянное значение "{0}" не может быть преобразовано в "{1}"</value>
  </data>
  <data name="AmbigBinaryOps" xml:space="preserve">
    <value>Оператор "{0}" является неоднозначным по отношению к операндам типа "{1}" и "{2}"</value>
  </data>
  <data name="AmbigUnaryOp" xml:space="preserve">
    <value>Оператор "{0}" является неоднозначным по отношению к операнду типа "{1}"</value>
  </data>
  <data name="ValueCantBeNull" xml:space="preserve">
    <value>Cannot convert null to "{0}" because it is a non-nullable value type</value>
  </data>
  <data name="NoSuchMember" xml:space="preserve">
    <value>"{0}" не содержит определения для "{1}"</value>
  </data>
  <data name="ObjectRequired" xml:space="preserve">
    <value>Для нестатического поля, метода или свойства "{0}" требуется ссылка на объект</value>
  </data>
  <data name="AmbigCall" xml:space="preserve">
    <value>Понятие "вызов" трактуется неоднозначно в следующих методах или свойствах: "{0}" и "{1}"</value>
  </data>
  <data name="BadAccess" xml:space="preserve">
    <value>"{0}" недоступен из-за его уровня защиты</value>
  </data>
  <data name="MethDelegateMismatch" xml:space="preserve">
    <value>Нет перегрузки для "{0}", соответствующей делегату "{1}"</value>
  </data>
  <data name="AssgLvalueExpected" xml:space="preserve">
    <value>Левая часть выражения присваивания должна быть переменной, свойством или индексатором</value>
  </data>
  <data name="NoConstructors" xml:space="preserve">
    <value>Для типа "{0}" нет определенных конструкторов</value>
  </data>
  <data name="PropertyLacksGet" xml:space="preserve">
    <value>The property or indexer "{0}" cannot be used in this context because it lacks the get accessor</value>
  </data>
  <data name="ObjectProhibited" xml:space="preserve">
    <value>Доступ к члену "{0}" через ссылку на экземпляр невозможен; вместо этого уточните его, указав имя типа</value>
  </data>
  <data name="AssgReadonly" xml:space="preserve">
    <value>Присваивание значений доступному только для чтения полю допускается только в конструкторе и в инициализаторе переменных</value>
  </data>
  <data name="RefReadonly" xml:space="preserve">
    <value>Доступное только для чтения поле может передаваться как параметр с ключевым словом ref или out только в конструкторе</value>
  </data>
  <data name="AssgReadonlyStatic" xml:space="preserve">
    <value>Присваивание значений доступному только для чтения статическому полю допускается только в статическом конструкторе и в инициализаторе переменных</value>
  </data>
  <data name="RefReadonlyStatic" xml:space="preserve">
    <value>Доступное только для чтения статическое поле может передаваться как параметр с ключевым словом ref или out только в статическом конструкторе</value>
  </data>
  <data name="AssgReadonlyProp" xml:space="preserve">
    <value>Невозможно присвоить значение свойству или индексатору "{0}" -- доступ только для чтения</value>
  </data>
  <data name="RefProperty" xml:space="preserve">
    <value>Свойства и индексаторы не могут передаваться как параметры с ключевыми словами out и ref</value>
  </data>
  <data name="UnsafeNeeded" xml:space="preserve">
    <value>Динамические вызовы нельзя использовать в сопряжении с указателями</value>
  </data>
  <data name="BadBoolOp" xml:space="preserve">
    <value>Для использования в качестве логического оператора краткой записи тип возвращаемого значения пользовательского логического оператора ("{0}") должен быть аналогичен типам двух его параметров</value>
  </data>
  <data name="MustHaveOpTF" xml:space="preserve">
    <value>Тип ("{0}") должен содержать объявления оператора true и оператора false</value>
  </data>
  <data name="ConstOutOfRangeChecked" xml:space="preserve">
    <value>Постоянное значение "{0}" не может быть преобразовано в "{1}" (для обхода используйте синтаксис "unchecked")</value>
  </data>
  <data name="AmbigMember" xml:space="preserve">
    <value>Неоднозначность между "{0}" и "{1}"</value>
  </data>
  <data name="NoImplicitConvCast" xml:space="preserve">
    <value>Не удается неявно преобразовать тип "{0}" в "{1}". Существует явное преобразование (требуется приведение типа?)</value>
  </data>
  <data name="InaccessibleGetter" xml:space="preserve">
    <value>Свойство или индексатор "{0}" невозможно использовать в данном контексте, поскольку метод доступа get недоступен</value>
  </data>
  <data name="InaccessibleSetter" xml:space="preserve">
    <value>Свойство или индексатор "{0}" невозможно использовать в данном контексте, поскольку метод доступа set недоступен</value>
  </data>
  <data name="BadArity" xml:space="preserve">
    <value>Использование универсального {1} "{0}" требует аргументов типа "{2}"</value>
  </data>
  <data name="TypeArgsNotAllowed" xml:space="preserve">
    <value>{1} "{0}" не может использоваться с аргументами типа</value>
  </data>
  <data name="HasNoTypeVars" xml:space="preserve">
    <value>Неуниверсальный {1} "{0}" не может использоваться с аргументами типа</value>
  </data>
  <data name="NewConstraintNotSatisfied" xml:space="preserve">
    <value>"Для использования в качестве параметра "{1}" в универсальном типе или методе "{0}" тип "{2}" должен быть неабстрактным и иметь открытый конструктор без параметров</value>
  </data>
  <data name="GenericConstraintNotSatisfiedRefType" xml:space="preserve">
    <value>Невозможно использовать тип "{3}" в качестве параметра типа "{2}" в универсальном типе или методе "{0}". Нет неявного преобразования ссылки из "{3}" в "{1}".</value>
  </data>
  <data name="GenericConstraintNotSatisfiedNullableEnum" xml:space="preserve">
    <value>Невозможно использовать тип "{3}" в качестве параметра типа "{2}" в универсальном типе или методе "{0}". Для типа "{3}", допускающего значение null, не выполняется ограничение "{1}".</value>
  </data>
  <data name="GenericConstraintNotSatisfiedNullableInterface" xml:space="preserve">
    <value>Невозможно использовать тип "{3}" в качестве параметра типа "{2}" в универсальном типе или методе "{0}". Для типа "{3}", допускающего значение null, не выполняется ограничение "{1}". Типы, допускающие значение null, не могут удовлетворять ни одному интерфейсному ограничению.</value>
  </data>
  <data name="GenericConstraintNotSatisfiedValType" xml:space="preserve">
    <value>Невозможно использовать тип "{3}" в качестве параметра типа "{2}" в универсальном типе или методе "{0}". Нет преобразования-упаковки из "{3}" в "{1}".</value>
  </data>
  <data name="CantInferMethTypeArgs" xml:space="preserve">
    <value>The type arguments for method "{0}" cannot be inferred from the usage. Попытайтесь явно определить аргументы-типы.</value>
  </data>
  <data name="RefConstraintNotSatisfied" xml:space="preserve">
    <value>Для использования в качестве параметра "{1}" в универсальном типе или методе "{0}" тип "{2}" должен быть ссылочным типом</value>
  </data>
  <data name="ValConstraintNotSatisfied" xml:space="preserve">
    <value>Для использования в качестве параметра "{1}" в универсальном типе или методе "{0}" тип "{2}" должен быть типом значения, не допускающим значения NULL</value>
  </data>
  <data name="AmbigUDConv" xml:space="preserve">
    <value>Неоднозначные пользовательские преобразования "{0}" и "{1}" при преобразовании из "{2}" в "{3}"</value>
  </data>
  <data name="BindToBogus" xml:space="preserve">
    <value>"{0}" не поддерживается языком</value>
  </data>
  <data name="CantCallSpecialMethod" xml:space="preserve">
    <value>"{0}": явный вызов оператора или метода доступа невозможен</value>
  </data>
  <data name="ConvertToStaticClass" xml:space="preserve">
    <value>Не удается выполнить преобразование к статическому типу "{0}"</value>
  </data>
  <data name="IncrementLvalueExpected" xml:space="preserve">
    <value>Операндом оператора инкремента или декремента должна быть переменная, свойство или индексатор</value>
  </data>
  <data name="BadArgCount" xml:space="preserve">
    <value>Отсутствие перегрузки для метода "{0}" принимает"{1}" аргументы</value>
  </data>
  <data name="BadArgTypes" xml:space="preserve">
    <value>Наиболее подходящий перегруженный метод для "{0}" имеет несколько недопустимых аргументов</value>
  </data>
  <data name="RefLvalueExpected" xml:space="preserve">
    <value>Аргумент с ключевым словом ref или out должен быть переменной, которой можно присвоить значение</value>
  </data>
  <data name="BadProtectedAccess" xml:space="preserve">
    <value>Не удается получить доступ к защищенному члену "{0}" через квалификатор типа "{1}"; квалификатор должен иметь тип "{2}" (или производный от него)</value>
  </data>
  <data name="BindToBogusProp2" xml:space="preserve">
    <value>Свойство, индексатор или событие "{0}" не поддерживается в данном языке; попробуйте вызвать метод доступа "{1}" или "{2}"</value>
  </data>
  <data name="BindToBogusProp1" xml:space="preserve">
    <value>Свойство, индексатор или событие "{0}" не поддерживается в данном языке; попробуйте вызвать метод доступа "{1}" или "{2}"</value>
  </data>
  <data name="BadDelArgCount" xml:space="preserve">
    <value>Делегат "{0}" не принимает аргументы "{1}"</value>
  </data>
  <data name="BadDelArgTypes" xml:space="preserve">
    <value>Делегат "{0}" имеет недопустимые аргументы</value>
  </data>
  <data name="AssgReadonlyLocal" xml:space="preserve">
    <value>Не удается выполнить присвоение параметру "{0}", так как он доступен только для чтения</value>
  </data>
  <data name="RefReadonlyLocal" xml:space="preserve">
    <value>Cannot pass "{0}" as a ref or out argument because it is read-only</value>
  </data>
  <data name="ReturnNotLValue" xml:space="preserve">
    <value>Cannot modify the return value of "{0}" because it is not a variable</value>
  </data>
  <data name="AssgReadonly2" xml:space="preserve">
    <value>Члены поля "{0}", предназначенного только для чтения, могут быть изменены только в конструкторе или инициализаторе переменных</value>
  </data>
  <data name="RefReadonly2" xml:space="preserve">
    <value>Members of readonly field "{0}" cannot be passed ref or out (except in a constructor)</value>
  </data>
  <data name="AssgReadonlyStatic2" xml:space="preserve">
    <value>Присваивание значений полям доступного только для чтения статического поля "{0}" допускается только в статическом конструкторе и в инициализаторе переменных</value>
  </data>
  <data name="RefReadonlyStatic2" xml:space="preserve">
    <value>Fields of static readonly field "{0}" cannot be passed ref or out (except in a static constructor)</value>
  </data>
  <data name="AssgReadonlyLocalCause" xml:space="preserve">
    <value>Не удается выполнить присвоение параметру "{0}", так как он является "{1}"</value>
  </data>
  <data name="RefReadonlyLocalCause" xml:space="preserve">
    <value>Не удалось передать "{0}" как ссылку или аргумент out, так как это "{1}"</value>
  </data>
  <data name="BadCtorArgCount" xml:space="preserve">
    <value>"{0}" не содержит конструктор, принимающий аргументов: {1}</value>
  </data>
  <data name="NonInvocableMemberCalled" xml:space="preserve">
    <value>Невызываемый член "{0}" не может использоваться как метод.</value>
  </data>
  <data name="NamedArgumentSpecificationBeforeFixedArgument" xml:space="preserve">
    <value>Спецификации именованного аргумента должны появляться во всех указанных фиксированных аргументах</value>
  </data>
  <data name="BadNamedArgument" xml:space="preserve">
    <value>Наиболее подходящий перегруженный метод для "{0}" не имеет параметра "{1}"</value>
  </data>
  <data name="BadNamedArgumentForDelegateInvoke" xml:space="preserve">
    <value>Делегат "{0}" не имеет параметра "{1}"</value>
  </data>
  <data name="DuplicateNamedArgument" xml:space="preserve">
    <value>Не удается задать именованный аргумент "{0}" несколько раз</value>
  </data>
  <data name="NamedArgumentUsedInPositional" xml:space="preserve">
    <value>Именованный аргумент "{0}" задает параметр, для которого уже был установлен позиционный аргумент.</value>
  </data>
</root>
