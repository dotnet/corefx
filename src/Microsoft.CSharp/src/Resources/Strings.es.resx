<?xml version="1.0" encoding="utf-8"?>
<root>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="InternalCompilerError" xml:space="preserve">
    <value>Excepción inesperada al enlazar una operación dinámica.</value>
  </data>
  <data name="BindRequireArguments" xml:space="preserve">
    <value>No se puede enlazar la llamada sin un objeto de llamada.</value>
  </data>
  <data name="BindCallFailedOverloadResolution" xml:space="preserve">
    <value>Error en la resolución de sobrecarga.</value>
  </data>
  <data name="BindBinaryOperatorRequireTwoArguments" xml:space="preserve">
    <value>No se pueden invocar operadores binarios con dos argumentos.</value>
  </data>
  <data name="BindUnaryOperatorRequireOneArgument" xml:space="preserve">
    <value>Los operadores unarios deben invocarse con un argumento.</value>
  </data>
  <data name="BindPropertyFailedMethodGroup" xml:space="preserve">
    <value>El nombre '{0}' está enlazado a un método y no se puede usar como propiedad.</value>
  </data>
  <data name="BindPropertyFailedEvent" xml:space="preserve">
    <value>El evento '{0}' sólo puede aparecer en el lado izquierdo de +</value>
  </data>
  <data name="BindInvokeFailedNonDelegate" xml:space="preserve">
    <value>No se puede invocar un tipo no delegado.</value>
  </data>
  <data name="BindImplicitConversionRequireOneArgument" xml:space="preserve">
    <value>La conversión implícita toma exactamente un argumento.</value>
  </data>
  <data name="BindExplicitConversionRequireOneArgument" xml:space="preserve">
    <value>La conversión explícita toma exactamente un argumento.</value>
  </data>
  <data name="BindBinaryAssignmentRequireTwoArguments" xml:space="preserve">
    <value>No se pueden invocar operadores binarios con un argumento.</value>
  </data>
  <data name="BindBinaryAssignmentFailedNullReference" xml:space="preserve">
    <value>No se puede realizar la asignación de miembros en una referencia NULL.</value>
  </data>
  <data name="NullReferenceOnMemberException" xml:space="preserve">
    <value>No se puede realizar enlace en tiempo de ejecución en una referencia NULL.</value>
  </data>
  <data name="BindCallToConditionalMethod" xml:space="preserve">
    <value>No se puede invocar dinámicamente el método '{0}' porque tiene un atributo Conditional.</value>
  </data>
  <data name="BindToVoidMethodButExpectResult" xml:space="preserve">
    <value>No se puede convertir implícitamente el tipo 'void' en 'object'.</value>
  </data>
  <data name="BadBinaryOps" xml:space="preserve">
    <value>El operador '{0}' no se puede aplicar a operandos del tipo '{1}' y '{2}'</value>
  </data>
  <data name="IntDivByZero" xml:space="preserve">
    <value>División por cero constante</value>
  </data>
  <data name="BadIndexLHS" xml:space="preserve">
    <value>No se puede aplicar la indización con [] a una expresión del tipo '{0}'</value>
  </data>
  <data name="BadIndexCount" xml:space="preserve">
    <value>Número incorrecto de índices dentro de []; se esperaba '{0}'</value>
  </data>
  <data name="BadUnaryOp" xml:space="preserve">
    <value>El operador '{0}' no se puede aplicar al operando del tipo '{1}'</value>
  </data>
  <data name="NoImplicitConv" xml:space="preserve">
    <value>No se puede convertir implícitamente el tipo '{0}' en '{1}'.</value>
  </data>
  <data name="NoExplicitConv" xml:space="preserve">
    <value>No se puede convertir el tipo '{0}' en '{1}'</value>
  </data>
  <data name="ConstOutOfRange" xml:space="preserve">
    <value>El valor constante '{0}' no se puede convertir en '{1}'</value>
  </data>
  <data name="AmbigBinaryOps" xml:space="preserve">
    <value>El operador '{0}' es ambiguo en operandos del tipo '{1}' y '{2}'</value>
  </data>
  <data name="AmbigUnaryOp" xml:space="preserve">
    <value>El operador '{0}' es ambiguo con un operando del tipo '{1}'</value>
  </data>
  <data name="ValueCantBeNull" xml:space="preserve">
    <value>No se puede convertir NULL en '{0}' porque es un tipo de valor que no acepta valores NULL.</value>
  </data>
  <data name="WrongNestedThis" xml:space="preserve">
    <value>No se puede obtener acceso a un miembro no estático de tipo externo '{0}' mediante el tipo anidado '{1}'.</value>
  </data>
  <data name="NoSuchMember" xml:space="preserve">
    <value>'{0}' no contiene una definición para '{1}'.</value>
  </data>
  <data name="ObjectRequired" xml:space="preserve">
    <value>Se requiere una referencia de objeto para el campo, método o propiedad no estáticos '{0}'.</value>
  </data>
  <data name="AmbigCall" xml:space="preserve">
    <value>La llamada es ambigua entre los métodos o propiedades siguientes: '{0}' y '{1}'</value>
  </data>
  <data name="BadAccess" xml:space="preserve">
    <value>'{0}' no es accesible debido a su nivel de protección</value>
  </data>
  <data name="MethDelegateMismatch" xml:space="preserve">
    <value>Ninguna sobrecarga correspondiente a '{0}' coincide con el '{1}' delegado</value>
  </data>
  <data name="AssgLvalueExpected" xml:space="preserve">
    <value>La parte izquierda de una asignación debe ser una variable, una propiedad o un indizador</value>
  </data>
  <data name="NoConstructors" xml:space="preserve">
    <value>El tipo '{0}' no tiene constructores definidos.</value>
  </data>
  <data name="BadDelegateConstructor" xml:space="preserve">
    <value>El delegado '{0}' no tiene un constructor válido</value>
  </data>
  <data name="PropertyLacksGet" xml:space="preserve">
    <value>La propiedad o el indizador '{0}' no se puede usar en este contexto porque carece del descriptor de acceso get.</value>
  </data>
  <data name="ObjectProhibited" xml:space="preserve">
    <value>No se puede obtener acceso al miembro '{0}' con una referencia de instancia; califíquelo con un nombre de tipo en su lugar.</value>
  </data>
  <data name="AssgReadonly" xml:space="preserve">
    <value>No se puede asignar un campo de sólo lectura (excepto en un constructor o inicializador de variable)</value>
  </data>
  <data name="RefReadonly" xml:space="preserve">
    <value>No se puede pasar out o ref a un campo de sólo lectura (excepto en un constructor)</value>
  </data>
  <data name="AssgReadonlyStatic" xml:space="preserve">
    <value>No se puede asignar un campo de sólo lectura estático (excepto en un constructor estático o inicializador de variable)</value>
  </data>
  <data name="RefReadonlyStatic" xml:space="preserve">
    <value>No se puede pasar out o ref a un campo estático de sólo lectura (excepto en un constructor estático)</value>
  </data>
  <data name="AssgReadonlyProp" xml:space="preserve">
    <value>No se puede asignar a la propiedad o el indizador '{0}' porque es de solo lectura</value>
  </data>
  <data name="AbstractBaseCall" xml:space="preserve">
    <value>No se puede llamar a un miembro base abstracto: '{0}'</value>
  </data>
  <data name="RefProperty" xml:space="preserve">
    <value>Una propiedad o un indizador no se puede pasar como parámetro out o ref</value>
  </data>
  <data name="ManagedAddr" xml:space="preserve">
    <value>No se puede adquirir la dirección, obtener el tamaño ni declarar un puntero a un tipo administrado ('{0}')</value>
  </data>
  <data name="FixedNotNeeded" xml:space="preserve">
    <value>No se puede utilizar la instrucción fixed para adquirir la dirección de una expresión de tipo fixed</value>
  </data>
  <data name="UnsafeNeeded" xml:space="preserve">
    <value>No se pueden usar llamadas dinámicas en combinación con los punteros.</value>
  </data>
  <data name="BadBoolOp" xml:space="preserve">
    <value>Para que se pueda aplicar un operador de cortocircuito, el operador lógico definido por el usuario ('{0}') debe tener el mismo tipo de valor devuelto que sus dos parámetros</value>
  </data>
  <data name="MustHaveOpTF" xml:space="preserve">
    <value>El tipo ('{0}') debe incluir declaraciones de operador true y operador false.</value>
  </data>
  <data name="CheckedOverflow" xml:space="preserve">
    <value>La operación se desborda en tiempo de compilación en modo comprobado</value>
  </data>
  <data name="ConstOutOfRangeChecked" xml:space="preserve">
    <value>El valor constante '{0}' no se puede convertir en '{1}' (use la sintaxis 'unchecked' para invalidar el valor)</value>
  </data>
  <data name="AmbigMember" xml:space="preserve">
    <value>Ambigüedad entre '{0}' y '{1}'</value>
  </data>
  <data name="SizeofUnsafe" xml:space="preserve">
    <value>'{0}' no tiene un tamaño predefinido; por tanto, sizeof sólo se puede usar en un contexto no seguro (use System.Runtime.InteropServices.Marshal.SizeOf).</value>
  </data>
  <data name="FieldInitRefNonstatic" xml:space="preserve">
    <value>Un inicializador de campo no puede hacer referencia al campo, método o propiedad no estáticos '{0}'</value>
  </data>
  <data name="CallingFinalizeDepracated" xml:space="preserve">
    <value>Los destructores y object.Finalize no se pueden llamar directamente. Llame a IDisposable.Dispose si está disponible.</value>
  </data>
  <data name="CallingBaseFinalizeDeprecated" xml:space="preserve">
    <value>No llame directamente al método Finalize de la clase base. Se llama automáticamente desde el destructor.</value>
  </data>
  <data name="BadCastInFixed" xml:space="preserve">
    <value>El lado derecho de una asignación de instrucción fixed puede no ser una expresión de conversión</value>
  </data>
  <data name="NoImplicitConvCast" xml:space="preserve">
    <value>No se puede convertir implícitamente el tipo '{0}' en '{1}'. Ya existe una conversión explícita (compruebe si le falta una conversión).</value>
  </data>
  <data name="InaccessibleGetter" xml:space="preserve">
    <value>La propiedad o indizador '{0}' no se puede usar en este contexto porque el descriptor de acceso get es inaccesible</value>
  </data>
  <data name="InaccessibleSetter" xml:space="preserve">
    <value>La propiedad o indizador '{0}' no se puede usar en este contexto porque el descriptor de acceso set es inaccesible</value>
  </data>
  <data name="BadArity" xml:space="preserve">
    <value>Uso de {1} de tipo genérico ('{0}'): requiere '{2}' argumentos de tipo</value>
  </data>
  <data name="BadTypeArgument" xml:space="preserve">
    <value>El tipo '{0}' no se puede usar como argumento de tipo</value>
  </data>
  <data name="TypeArgsNotAllowed" xml:space="preserve">
    <value>{1} '{0}' no se puede usar con argumentos de tipo.</value>
  </data>
  <data name="HasNoTypeVars" xml:space="preserve">
    <value>Uso de {1} '{0}' de tipo no genérico: no se puede usar con argumentos de tipo</value>
  </data>
  <data name="NewConstraintNotSatisfied" xml:space="preserve">
    <value>'{2}' debe ser un tipo no abstracto con un constructor público sin parámetros para poder usarlo como parámetro '{1}' en el tipo o método genérico '{0}'.</value>
  </data>
  <data name="GenericConstraintNotSatisfiedRefType" xml:space="preserve">
    <value>El tipo '{3}' no se puede usar como parámetro de tipo '{2}' en el tipo o método genérico '{0}'. No hay ninguna conversión de referencia implícita de '{3}' a '{1}'.</value>
  </data>
  <data name="GenericConstraintNotSatisfiedNullableEnum" xml:space="preserve">
    <value>El tipo '{3}' no se puede usar como parámetro de tipo '{2}' en el tipo o método genérico '{0}'. El tipo que acepta valores NULL '{3}' no cumple la restricción de '{1}'.</value>
  </data>
  <data name="GenericConstraintNotSatisfiedNullableInterface" xml:space="preserve">
    <value>El tipo '{3}' no se puede usar como parámetro de tipo '{2}' en el tipo o método genérico '{0}'. El tipo que acepta valores NULL '{3}' no cumple la restricción de '{1}'. Los tipos que aceptan valores NULL no pueden cumplir restricciones de interfaz.</value>
  </data>
  <data name="GenericConstraintNotSatisfiedTyVar" xml:space="preserve">
    <value>El tipo '{3}' no se puede usar como parámetro de tipo '{2}' en el tipo o método genérico '{0}'. No hay conversión boxing ni conversión de parámetro de tipo de '{3}' a '{1}'.</value>
  </data>
  <data name="GenericConstraintNotSatisfiedValType" xml:space="preserve">
    <value>El tipo '{3}' no se puede usar como parámetro de tipo '{2}' en el tipo o método genérico '{0}'. No hay conversión boxing de '{3}' a '{1}'.</value>
  </data>
  <data name="TypeVarCantBeNull" xml:space="preserve">
    <value>No se puede convertir NULL en el parámetro de tipo '{0}' porque podría ser un tipo de valor que no acepta valores NULL. Use 'default({0})' en su lugar.</value>
  </data>
  <data name="BadRetType" xml:space="preserve">
    <value>'{1} {0}' es un tipo de valor devuelto equivocado</value>
  </data>
  <data name="CantInferMethTypeArgs" xml:space="preserve">
    <value>Los argumentos de tipo para el método '{0}' no se pueden inferir a partir del uso. Intente especificar los argumentos de tipo explícitamente.</value>
  </data>
  <data name="MethGrpToNonDel" xml:space="preserve">
    <value>No se puede convertir el grupo de métodos '{0}' en tipo no delegado '{1}'. ¿Intentó invocar el método?</value>
  </data>
  <data name="RefConstraintNotSatisfied" xml:space="preserve">
    <value>El tipo '{2}' debe ser un tipo de referencia para poder usarlo como parámetro '{1}' en el tipo o método genérico '{0}'.</value>
  </data>
  <data name="ValConstraintNotSatisfied" xml:space="preserve">
    <value>El tipo '{2}' debe ser un tipo de valor que no acepte valores NULL para poder usarlo como parámetro '{1}' en el tipo o método genérico '{0}'.</value>
  </data>
  <data name="CircularConstraint" xml:space="preserve">
    <value>Dependencia de restricción circular que implica '{0}' y '{1}'</value>
  </data>
  <data name="BaseConstraintConflict" xml:space="preserve">
    <value>El parámetro de tipo '{0}' hereda las restricciones conflictivas '{1}' y '{2}'</value>
  </data>
  <data name="ConWithValCon" xml:space="preserve">
    <value>El parámetro de tipo '{1}' tiene la restricción 'struct'; por tanto,  '{1}' no se puede usar como restricción para  '{0}'</value>
  </data>
  <data name="AmbigUDConv" xml:space="preserve">
    <value>Conversiones ambiguas definidas por el usuario '{0}' y '{1}' al convertir de '{2}' a '{3}'</value>
  </data>
  <data name="PredefinedTypeNotFound" xml:space="preserve">
    <value>El tipo predefinido '{0}' no está definido ni importado.</value>
  </data>
  <data name="PredefinedTypeBadType" xml:space="preserve">
    <value>Tipo predefinido '{0}' declarado incorrectamente.</value>
  </data>
  <data name="BindToBogus" xml:space="preserve">
    <value>'{0}' no es compatible con el lenguaje</value>
  </data>
  <data name="CantCallSpecialMethod" xml:space="preserve">
    <value>'{0}': no se puede llamar explícitamente al operador o al descriptor de acceso</value>
  </data>
  <data name="BogusType" xml:space="preserve">
    <value>No se admite el tipo '{0}' para este lenguaje</value>
  </data>
  <data name="MissingPredefinedMember" xml:space="preserve">
    <value>Falta el miembro '{0}.{1}' que requiere el compilador.</value>
  </data>
  <data name="LiteralDoubleCast" xml:space="preserve">
    <value>El literal de tipo double no se puede convertir implícitamente en el tipo '{1}'; use un sufijo '{0}' para crear un literal de este tipo</value>
  </data>
  <data name="UnifyingInterfaceInstantiations" xml:space="preserve">
    <value>'{0}' no puede implementar tanto '{1}' como '{2}' porque se pueden unificar para algunas sustituciones de parámetros de tipo.</value>
  </data>
  <data name="ConvertToStaticClass" xml:space="preserve">
    <value>No se puede convertir en el tipo estático '{0}'</value>
  </data>
  <data name="GenericArgIsStaticClass" xml:space="preserve">
    <value>'{0}': los tipos estáticos no se pueden usar como argumentos de tipo</value>
  </data>
  <data name="PartialMethodToDelegate" xml:space="preserve">
    <value>No se puede crear un delegado a partir del método '{0}' porque es un método parcial sin una declaración de implementación.</value>
  </data>
  <data name="IncrementLvalueExpected" xml:space="preserve">
    <value>El operando de un operador de incremento o decremento debe ser una variable, una propiedad o un indizador</value>
  </data>
  <data name="NoSuchMemberOrExtension" xml:space="preserve">
    <value>'{0}' no contiene una definición para '{1}' ni se encuentra ningún método de extensión '{1}' que acepte un primer argumento del tipo '{0}' (¿falta una directiva de uso o una referencia de ensamblado?).</value>
  </data>
  <data name="ValueTypeExtDelegate" xml:space="preserve">
    <value>Los métodos de extensión '{0}' definidos en el tipo de valor '{1}' no se pueden usar para crear delegados.</value>
  </data>
  <data name="BadArgCount" xml:space="preserve">
    <value>Ninguna sobrecarga del método '{0}' toma argumentos '{1}'</value>
  </data>
  <data name="BadArgTypes" xml:space="preserve">
    <value>La mejor coincidencia de método sobrecargado para '{0}' tiene algunos argumentos no válidos</value>
  </data>
  <data name="BadArgType" xml:space="preserve">
    <value>Argumento '{0}': no se puede convertir de '{1}' a '{2}'</value>
  </data>
  <data name="RefLvalueExpected" xml:space="preserve">
    <value>Un argumento out o ref debe ser una variable asignable</value>
  </data>
  <data name="BadProtectedAccess" xml:space="preserve">
    <value>No se puede obtener acceso al miembro protegido '{0}' mediante un calificador del tipo '{1}'; el calificador debe ser del tipo '{2}' (o derivado de éste)</value>
  </data>
  <data name="BindToBogusProp2" xml:space="preserve">
    <value>El lenguaje no admite la propiedad, el indizador o el evento '{0}'; intente llamar directamente a los métodos de descriptor de acceso '{1}' o '{2}'</value>
  </data>
  <data name="BindToBogusProp1" xml:space="preserve">
    <value>El lenguaje no admite la propiedad, el indizador o el evento '{0}'; intente llamar directamente al método de descriptor de acceso '{1}'</value>
  </data>
  <data name="BadDelArgCount" xml:space="preserve">
    <value>El delegado '{0}' no toma '{1}' argumentos</value>
  </data>
  <data name="BadDelArgTypes" xml:space="preserve">
    <value>El delegado '{0}' tiene algunos argumentos no válidos</value>
  </data>
  <data name="AssgReadonlyLocal" xml:space="preserve">
    <value>No se puede asignar a '{0}' porque es de solo lectura</value>
  </data>
  <data name="RefReadonlyLocal" xml:space="preserve">
    <value>No se puede pasar '{0}' como argumento out o ref porque es de solo lectura.</value>
  </data>
  <data name="ReturnNotLValue" xml:space="preserve">
    <value>No se puede modificar el valor devuelto de '{0}' porque no es una variable.</value>
  </data>
  <data name="BadArgExtraRef" xml:space="preserve">
    <value>No se debe pasar el argumento '{0}' con la palabra clave '{1}'</value>
  </data>
  <data name="BadArgRef" xml:space="preserve">
    <value>El argumento '{0}' se debe pasar con la palabra clave '{1}'</value>
  </data>
  <data name="AssgReadonly2" xml:space="preserve">
    <value>Los miembros del campo de solo lectura '{0}' no se pueden modificar (excepto en un constructor o inicializador de variable)</value>
  </data>
  <data name="RefReadonly2" xml:space="preserve">
    <value>No se puede pasar out o ref a los miembros del campo de solo lectura '{0}' (excepto en un constructor).</value>
  </data>
  <data name="AssgReadonlyStatic2" xml:space="preserve">
    <value>No se puede asignar a los campos del campo estático de solo lectura '{0}' (excepto en un constructor estático o un inicializador de variable)</value>
  </data>
  <data name="RefReadonlyStatic2" xml:space="preserve">
    <value>No se puede pasar out o ref a los campos del campo estático de solo lectura '{0}' (excepto en un constructor estático).</value>
  </data>
  <data name="AssgReadonlyLocalCause" xml:space="preserve">
    <value>No se puede asignar a '{0}' porque es '{1}'</value>
  </data>
  <data name="RefReadonlyLocalCause" xml:space="preserve">
    <value>No se puede pasar '{0}' como argumento out o ref porque es '{1}'.</value>
  </data>
  <data name="ThisStructNotInAnonMeth" xml:space="preserve">
    <value>Los métodos anónimos, las expresiones lambda y las expresiones de consulta incluidos en structs no pueden obtener acceso a miembros de instancia de 'this'. Copie 'this' en una variable local fuera del método anónimo, la expresión lambda o la expresión de consulta y use la variable local en su lugar.</value>
  </data>
  <data name="DelegateOnNullable" xml:space="preserve">
    <value>No se puede enlazar el delegado para '{0}' porque es un miembro de 'System.Nullable&lt;T&gt;'</value>
  </data>
  <data name="BadCtorArgCount" xml:space="preserve">
    <value>'{0}' no contiene un constructor que tome '{1}' argumentos</value>
  </data>
  <data name="BadExtensionArgTypes" xml:space="preserve">
    <value>'{0}' no contiene una definición para '{1}' y la mejor sobrecarga del método de extensión '{2}' tiene algunos argumentos no válidos</value>
  </data>
  <data name="BadInstanceArgType" xml:space="preserve">
    <value>Argumento de instancia: no se puede convertir de '{0}' a '{1}'</value>
  </data>
  <data name="BadArgTypesForCollectionAdd" xml:space="preserve">
    <value>El mejor método Add sobrecargado '{0}' del inicializador de colección tiene algunos argumentos no válidos</value>
  </data>
  <data name="InitializerAddHasParamModifiers" xml:space="preserve">
    <value>La mejor coincidencia de método sobrecargado '{0}' para el elemento inicializador de la colección no se puede usar. Los métodos 'Add' inicializadores de colección no pueden tener parámetros out o ref.</value>
  </data>
  <data name="NonInvocableMemberCalled" xml:space="preserve">
    <value>No se puede usar como método el miembro '{0}' no invocable.</value>
  </data>
  <data name="NamedArgumentSpecificationBeforeFixedArgument" xml:space="preserve">
    <value>Las especificaciones de argumento con nombre deben aparecer después de haber especificado todos los argumentos fijos.</value>
  </data>
  <data name="BadNamedArgument" xml:space="preserve">
    <value>La mejor sobrecarga para '{0}' no tiene un parámetro denominado '{1}'</value>
  </data>
  <data name="BadNamedArgumentForDelegateInvoke" xml:space="preserve">
    <value>El delegado '{0}' no tiene un parámetro denominado '{1}'</value>
  </data>
  <data name="DuplicateNamedArgument" xml:space="preserve">
    <value>El argumento con nombre '{0}' no se puede especificar varias veces</value>
  </data>
  <data name="NamedArgumentUsedInPositional" xml:space="preserve">
    <value>El argumento con nombre '{0}' especifica un parámetro para el que ya se ha proporcionado un argumento posicional.</value>
  </data>
</root>