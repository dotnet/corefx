<?xml version="1.0" encoding="utf-8"?>
<root>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="InternalCompilerError" xml:space="preserve">
    <value>Excepción inesperada al enlazar una operación dinámica.</value>
  </data>
  <data name="BindRequireArguments" xml:space="preserve">
    <value>No se puede enlazar la llamada sin un objeto de llamada.</value>
  </data>
  <data name="BindCallFailedOverloadResolution" xml:space="preserve">
    <value>Error en la resolución de sobrecarga.</value>
  </data>
  <data name="BindBinaryOperatorRequireTwoArguments" xml:space="preserve">
    <value>No se pueden invocar operadores binarios con dos argumentos.</value>
  </data>
  <data name="BindUnaryOperatorRequireOneArgument" xml:space="preserve">
    <value>Los operadores unarios deben invocarse con un argumento.</value>
  </data>
  <data name="BindPropertyFailedMethodGroup" xml:space="preserve">
    <value>El nombre '{0}' está enlazado a un método y no se puede usar como propiedad.</value>
  </data>
  <data name="BindPropertyFailedEvent" xml:space="preserve">
    <value>El evento '{0}' sólo puede aparecer en el lado izquierdo de +</value>
  </data>
  <data name="BindInvokeFailedNonDelegate" xml:space="preserve">
    <value>No se puede invocar un tipo no delegado.</value>
  </data>
  <data name="BindBinaryAssignmentRequireTwoArguments" xml:space="preserve">
    <value>No se pueden invocar operadores binarios con un argumento.</value>
  </data>
  <data name="BindBinaryAssignmentFailedNullReference" xml:space="preserve">
    <value>No se puede realizar la asignación de miembros en una referencia NULL.</value>
  </data>
  <data name="NullReferenceOnMemberException" xml:space="preserve">
    <value>No se puede realizar enlace en tiempo de ejecución en una referencia NULL.</value>
  </data>
  <data name="BindCallToConditionalMethod" xml:space="preserve">
    <value>No se puede invocar dinámicamente el método '{0}' porque tiene un atributo Conditional.</value>
  </data>
  <data name="BindToVoidMethodButExpectResult" xml:space="preserve">
    <value>No se puede convertir implícitamente el tipo 'void' en 'object'.</value>
  </data>
  <data name="BadBinaryOps" xml:space="preserve">
    <value>El operador '{0}' no se puede aplicar a operandos del tipo '{1}' y '{2}'</value>
  </data>
  <data name="BadIndexLHS" xml:space="preserve">
    <value>No se puede aplicar la indización con [] a una expresión del tipo '{0}'</value>
  </data>
  <data name="BadIndexCount" xml:space="preserve">
    <value>Número incorrecto de índices dentro de []; se esperaba '{0}'</value>
  </data>
  <data name="BadUnaryOp" xml:space="preserve">
    <value>El operador '{0}' no se puede aplicar al operando del tipo '{1}'</value>
  </data>
  <data name="NoImplicitConv" xml:space="preserve">
    <value>No se puede convertir implícitamente el tipo '{0}' en '{1}'.</value>
  </data>
  <data name="NoExplicitConv" xml:space="preserve">
    <value>No se puede convertir el tipo '{0}' en '{1}'</value>
  </data>
  <data name="ConstOutOfRange" xml:space="preserve">
    <value>El valor constante '{0}' no se puede convertir en '{1}'</value>
  </data>
  <data name="AmbigBinaryOps" xml:space="preserve">
    <value>El operador '{0}' es ambiguo en operandos del tipo '{1}' y '{2}'</value>
  </data>
  <data name="AmbigUnaryOp" xml:space="preserve">
    <value>El operador '{0}' es ambiguo con un operando del tipo '{1}'</value>
  </data>
  <data name="ValueCantBeNull" xml:space="preserve">
    <value>No se puede convertir NULL en '{0}' porque es un tipo de valor que no acepta valores NULL.</value>
  </data>
  <data name="WrongNestedThis" xml:space="preserve">
    <value>No se puede obtener acceso a un miembro no estático de tipo externo '{0}' mediante el tipo anidado '{1}'.</value>
  </data>
  <data name="NoSuchMember" xml:space="preserve">
    <value>'{0}' no contiene una definición para '{1}'.</value>
  </data>
  <data name="ObjectRequired" xml:space="preserve">
    <value>Se requiere una referencia de objeto para el campo, método o propiedad no estáticos '{0}'.</value>
  </data>
  <data name="AmbigCall" xml:space="preserve">
    <value>La llamada es ambigua entre los métodos o propiedades siguientes: '{0}' y '{1}'</value>
  </data>
  <data name="BadAccess" xml:space="preserve">
    <value>'{0}' no es accesible debido a su nivel de protección</value>
  </data>
  <data name="MethDelegateMismatch" xml:space="preserve">
    <value>Ninguna sobrecarga correspondiente a '{0}' coincide con el '{1}' delegado</value>
  </data>
  <data name="AssgLvalueExpected" xml:space="preserve">
    <value>La parte izquierda de una asignación debe ser una variable, una propiedad o un indizador</value>
  </data>
  <data name="NoConstructors" xml:space="preserve">
    <value>El tipo '{0}' no tiene constructores definidos.</value>
  </data>
  <data name="PropertyLacksGet" xml:space="preserve">
    <value>La propiedad o el indizador '{0}' no se puede usar en este contexto porque carece del descriptor de acceso get.</value>
  </data>
  <data name="ObjectProhibited" xml:space="preserve">
    <value>No se puede obtener acceso al miembro '{0}' con una referencia de instancia; califíquelo con un nombre de tipo en su lugar.</value>
  </data>
  <data name="AssgReadonly" xml:space="preserve">
    <value>No se puede asignar un campo de sólo lectura (excepto en un constructor o inicializador de variable)</value>
  </data>
  <data name="RefReadonly" xml:space="preserve">
    <value>No se puede pasar out o ref a un campo de sólo lectura (excepto en un constructor)</value>
  </data>
  <data name="AssgReadonlyStatic" xml:space="preserve">
    <value>No se puede asignar un campo de sólo lectura estático (excepto en un constructor estático o inicializador de variable)</value>
  </data>
  <data name="RefReadonlyStatic" xml:space="preserve">
    <value>No se puede pasar out o ref a un campo estático de sólo lectura (excepto en un constructor estático)</value>
  </data>
  <data name="AssgReadonlyProp" xml:space="preserve">
    <value>No se puede asignar a la propiedad o el indizador '{0}' porque es de solo lectura</value>
  </data>
  <data name="RefProperty" xml:space="preserve">
    <value>Una propiedad o un indizador no se puede pasar como parámetro out o ref</value>
  </data>
  <data name="UnsafeNeeded" xml:space="preserve">
    <value>No se pueden usar llamadas dinámicas en combinación con los punteros.</value>
  </data>
  <data name="BadBoolOp" xml:space="preserve">
    <value>Para que se pueda aplicar un operador de cortocircuito, el operador lógico definido por el usuario ('{0}') debe tener el mismo tipo de valor devuelto que sus dos parámetros</value>
  </data>
  <data name="MustHaveOpTF" xml:space="preserve">
    <value>El tipo ('{0}') debe incluir declaraciones de operador true y operador false.</value>
  </data>
  <data name="ConstOutOfRangeChecked" xml:space="preserve">
    <value>El valor constante '{0}' no se puede convertir en '{1}' (use la sintaxis 'unchecked' para invalidar el valor)</value>
  </data>
  <data name="AmbigMember" xml:space="preserve">
    <value>Ambigüedad entre '{0}' y '{1}'</value>
  </data>
  <data name="NoImplicitConvCast" xml:space="preserve">
    <value>No se puede convertir implícitamente el tipo '{0}' en '{1}'. Ya existe una conversión explícita (compruebe si le falta una conversión).</value>
  </data>
  <data name="InaccessibleGetter" xml:space="preserve">
    <value>La propiedad o indizador '{0}' no se puede usar en este contexto porque el descriptor de acceso get es inaccesible</value>
  </data>
  <data name="InaccessibleSetter" xml:space="preserve">
    <value>La propiedad o indizador '{0}' no se puede usar en este contexto porque el descriptor de acceso set es inaccesible</value>
  </data>
  <data name="BadArity" xml:space="preserve">
    <value>Uso de {1} de tipo genérico ('{0}'): requiere '{2}' argumentos de tipo</value>
  </data>
  <data name="TypeArgsNotAllowed" xml:space="preserve">
    <value>{1} '{0}' no se puede usar con argumentos de tipo.</value>
  </data>
  <data name="HasNoTypeVars" xml:space="preserve">
    <value>Uso de {1} '{0}' de tipo no genérico: no se puede usar con argumentos de tipo</value>
  </data>
  <data name="NewConstraintNotSatisfied" xml:space="preserve">
    <value>'{2}' debe ser un tipo no abstracto con un constructor público sin parámetros para poder usarlo como parámetro '{1}' en el tipo o método genérico '{0}'.</value>
  </data>
  <data name="GenericConstraintNotSatisfiedRefType" xml:space="preserve">
    <value>El tipo '{3}' no se puede usar como parámetro de tipo '{2}' en el tipo o método genérico '{0}'. No hay ninguna conversión de referencia implícita de '{3}' a '{1}'.</value>
  </data>
  <data name="GenericConstraintNotSatisfiedNullableEnum" xml:space="preserve">
    <value>El tipo '{3}' no se puede usar como parámetro de tipo '{2}' en el tipo o método genérico '{0}'. El tipo que acepta valores NULL '{3}' no cumple la restricción de '{1}'.</value>
  </data>
  <data name="GenericConstraintNotSatisfiedNullableInterface" xml:space="preserve">
    <value>El tipo '{3}' no se puede usar como parámetro de tipo '{2}' en el tipo o método genérico '{0}'. El tipo que acepta valores NULL '{3}' no cumple la restricción de '{1}'. Los tipos que aceptan valores NULL no pueden cumplir restricciones de interfaz.</value>
  </data>
  <data name="GenericConstraintNotSatisfiedValType" xml:space="preserve">
    <value>El tipo '{3}' no se puede usar como parámetro de tipo '{2}' en el tipo o método genérico '{0}'. No hay conversión boxing de '{3}' a '{1}'.</value>
  </data>
  <data name="CantInferMethTypeArgs" xml:space="preserve">
    <value>Los argumentos de tipo para el método '{0}' no se pueden inferir a partir del uso. Intente especificar los argumentos de tipo explícitamente.</value>
  </data>
  <data name="RefConstraintNotSatisfied" xml:space="preserve">
    <value>El tipo '{2}' debe ser un tipo de referencia para poder usarlo como parámetro '{1}' en el tipo o método genérico '{0}'.</value>
  </data>
  <data name="ValConstraintNotSatisfied" xml:space="preserve">
    <value>El tipo '{2}' debe ser un tipo de valor que no acepte valores NULL para poder usarlo como parámetro '{1}' en el tipo o método genérico '{0}'.</value>
  </data>
  <data name="AmbigUDConv" xml:space="preserve">
    <value>Conversiones ambiguas definidas por el usuario '{0}' y '{1}' al convertir de '{2}' a '{3}'</value>
  </data>
  <data name="BindToBogus" xml:space="preserve">
    <value>'{0}' no es compatible con el lenguaje</value>
  </data>
  <data name="CantCallSpecialMethod" xml:space="preserve">
    <value>'{0}': no se puede llamar explícitamente al operador o al descriptor de acceso</value>
  </data>
  <data name="ConvertToStaticClass" xml:space="preserve">
    <value>No se puede convertir en el tipo estático '{0}'</value>
  </data>
  <data name="IncrementLvalueExpected" xml:space="preserve">
    <value>El operando de un operador de incremento o decremento debe ser una variable, una propiedad o un indizador</value>
  </data>
  <data name="BadArgCount" xml:space="preserve">
    <value>Ninguna sobrecarga del método '{0}' toma argumentos '{1}'</value>
  </data>
  <data name="BadArgTypes" xml:space="preserve">
    <value>La mejor coincidencia de método sobrecargado para '{0}' tiene algunos argumentos no válidos</value>
  </data>
  <data name="RefLvalueExpected" xml:space="preserve">
    <value>Un argumento out o ref debe ser una variable asignable</value>
  </data>
  <data name="BadProtectedAccess" xml:space="preserve">
    <value>No se puede obtener acceso al miembro protegido '{0}' mediante un calificador del tipo '{1}'; el calificador debe ser del tipo '{2}' (o derivado de éste)</value>
  </data>
  <data name="BindToBogusProp2" xml:space="preserve">
    <value>El lenguaje no admite la propiedad, el indizador o el evento '{0}'; intente llamar directamente a los métodos de descriptor de acceso '{1}' o '{2}'</value>
  </data>
  <data name="BindToBogusProp1" xml:space="preserve">
    <value>El lenguaje no admite la propiedad, el indizador o el evento '{0}'; intente llamar directamente al método de descriptor de acceso '{1}'</value>
  </data>
  <data name="BadDelArgCount" xml:space="preserve">
    <value>El delegado '{0}' no toma '{1}' argumentos</value>
  </data>
  <data name="BadDelArgTypes" xml:space="preserve">
    <value>El delegado '{0}' tiene algunos argumentos no válidos</value>
  </data>
  <data name="AssgReadonlyLocal" xml:space="preserve">
    <value>No se puede asignar a '{0}' porque es de solo lectura</value>
  </data>
  <data name="RefReadonlyLocal" xml:space="preserve">
    <value>No se puede pasar '{0}' como argumento out o ref porque es de solo lectura.</value>
  </data>
  <data name="ReturnNotLValue" xml:space="preserve">
    <value>No se puede modificar el valor devuelto de '{0}' porque no es una variable.</value>
  </data>
  <data name="AssgReadonly2" xml:space="preserve">
    <value>Los miembros del campo de solo lectura '{0}' no se pueden modificar (excepto en un constructor o inicializador de variable)</value>
  </data>
  <data name="RefReadonly2" xml:space="preserve">
    <value>No se puede pasar out o ref a los miembros del campo de solo lectura '{0}' (excepto en un constructor).</value>
  </data>
  <data name="AssgReadonlyStatic2" xml:space="preserve">
    <value>No se puede asignar a los campos del campo estático de solo lectura '{0}' (excepto en un constructor estático o un inicializador de variable)</value>
  </data>
  <data name="RefReadonlyStatic2" xml:space="preserve">
    <value>No se puede pasar out o ref a los campos del campo estático de solo lectura '{0}' (excepto en un constructor estático).</value>
  </data>
  <data name="AssgReadonlyLocalCause" xml:space="preserve">
    <value>No se puede asignar a '{0}' porque es '{1}'</value>
  </data>
  <data name="RefReadonlyLocalCause" xml:space="preserve">
    <value>No se puede pasar '{0}' como argumento out o ref porque es '{1}'.</value>
  </data>
  <data name="BadCtorArgCount" xml:space="preserve">
    <value>'{0}' no contiene un constructor que tome '{1}' argumentos</value>
  </data>
  <data name="NonInvocableMemberCalled" xml:space="preserve">
    <value>No se puede usar como método el miembro '{0}' no invocable.</value>
  </data>
  <data name="NamedArgumentSpecificationBeforeFixedArgument" xml:space="preserve">
    <value>Las especificaciones de argumento con nombre deben aparecer después de haber especificado todos los argumentos fijos.</value>
  </data>
  <data name="BadNamedArgument" xml:space="preserve">
    <value>La mejor sobrecarga para '{0}' no tiene un parámetro denominado '{1}'</value>
  </data>
  <data name="BadNamedArgumentForDelegateInvoke" xml:space="preserve">
    <value>El delegado '{0}' no tiene un parámetro denominado '{1}'</value>
  </data>
  <data name="DuplicateNamedArgument" xml:space="preserve">
    <value>El argumento con nombre '{0}' no se puede especificar varias veces</value>
  </data>
  <data name="NamedArgumentUsedInPositional" xml:space="preserve">
    <value>El argumento con nombre '{0}' especifica un parámetro para el que ya se ha proporcionado un argumento posicional.</value>
  </data>
</root>
