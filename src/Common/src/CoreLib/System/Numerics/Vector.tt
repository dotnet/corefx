<#@ template debug="true" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ Assembly Name="System.Core.dll" #>
<#@ Assembly Name="System.Xml.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Runtime.InteropServices" #>
<#@ include file="GenerationConfig.ttinclude" #><# GenerateCopyrightHeader(); #>

#nullable enable
#if netcoreapp
using Internal.Runtime.CompilerServices;
#endif
using System.Globalization;
using System.Numerics.Hashing;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;

namespace System.Numerics
{
    /* Note: The following patterns are used throughout the code here and are described here
    *
    * PATTERN:
    *    if (typeof(T) == typeof(int)) { ... }
    *    else if (typeof(T) == typeof(float)) { ... }
    * EXPLANATION:
    *    At runtime, each instantiation of Vector<T> will be type-specific, and each of these typeof blocks will be eliminated,
    *    as typeof(T) is a (JIT) compile-time constant for each instantiation. This design was chosen to eliminate any overhead from
    *    delegates and other patterns.
    *
    * PATTERN:
    *    if (Vector.IsHardwareAccelerated) { ... }
    *    else { ... }
    * EXPLANATION
    *    This pattern solves two problems:
    *        1. Allows us to unroll loops when we know the size (when no hardware acceleration is present)
    *        2. Allows reflection to work:
    *            - If a method is called via reflection, it will not be "intrinsified", which would cause issues if we did
    *              not provide an implementation for that case (i.e. if it only included a case which assumed 16-byte registers)
    *    (NOTE: It is assumed that Vector.IsHardwareAccelerated will be a compile-time constant, eliminating these checks
    *        from the JIT'd code.)
    *
    * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

    /// <summary>
    /// A structure that represents a single Vector. The count of this Vector is fixed but CPU register dependent.
    /// This struct only supports numerical types. This type is intended to be used as a building block for vectorizing
    /// large algorithms. This type is immutable, individual elements cannot be modified.
    /// </summary>
    [Intrinsic]
    public struct Vector<T> : IEquatable<Vector<T>>, IFormattable where T : struct
    {
        #region Fields
        private Register register;
        #endregion Fields

        #region Static Members
        /// <summary>
        /// Returns the number of elements stored in the vector. This value is hardware dependent.
        /// </summary>
        public static int Count
        {
            [Intrinsic]
            get
            {
                ThrowHelper.ThrowForUnsupportedVectorBaseType<T>();
                return Unsafe.SizeOf<Vector<T>>() / Unsafe.SizeOf<T>();
            }
        }

        /// <summary>
        /// Returns a vector containing all zeroes.
        /// </summary>
        public static Vector<T> Zero
        {
            [Intrinsic]
            get
            {
                return s_zero;
            }
        }
        private static readonly Vector<T> s_zero = new Vector<T>();

        /// <summary>
        /// Returns a vector containing all ones.
        /// </summary>
        public static Vector<T> One
        {
            [Intrinsic]
            get
            {
                return s_one;
            }
        }
        private static readonly Vector<T> s_one = new Vector<T>(GetOneValue());

        internal static Vector<T> AllOnes
        {
            [Intrinsic]
            get
            {
                return s_allOnes;
            }
        }
        private static readonly Vector<T> s_allOnes = new Vector<T>(GetAllBitsSetValue());
        #endregion Static Members

        #region Constructors
        /// <summary>
        /// Constructs a vector whose components are all <code>value</code>
        /// </summary>
        [Intrinsic]
        public unsafe Vector(T value)
            : this()
        {
            if (Vector.IsHardwareAccelerated)
            {
<#
    foreach (Type type in supportedTypes)
    {
#>
                <#=GenerateIfStatementHeader(type)#>
                {
                    fixed (<#=typeAliases[type]#>* basePtr = &this.<#=GetRegisterFieldName(type, 0)#>)
                    {
                        for (int g = 0; g < Count; g++)
                        {
                            *(basePtr + g) = (<#=typeAliases[type]#>)(object)value;
                        }
                    }
                }
<#
    }
#>
            }
            else
            {
<#
    foreach (Type type in supportedTypes)
    {
#>
                <#=GenerateIfStatementHeader(type)#>
                {
<#
        for (int g = 0; g < totalSize / Marshal.SizeOf(type); g++)
        {
#>
                    <#=GetRegisterFieldName(type, g)#> = (<#=typeAliases[type]#>)(object)value;
<#
        }
#>
                }
<#
    }
#>
            }
        }

        /// <summary>
        /// Constructs a vector from the given array. The size of the given array must be at least Vector'T.Count.
        /// </summary>
        [Intrinsic]
        public unsafe Vector(T[] values) : this(values, 0) { }

        /// <summary>
        /// Constructs a vector from the given array, starting from the given index.
        /// The array must contain at least Vector'T.Count from the given index.
        /// </summary>
        [Intrinsic]
        public unsafe Vector(T[] values, int index)
            : this()
        {
            if (values == null)
            {
                // Match the JIT's exception type here. For perf, a NullReference is thrown instead of an ArgumentNull.
                throw new NullReferenceException(SR.Arg_NullArgumentNullRef);
            }
            if (index < 0 || (values.Length - index) < Count)
            {
                throw new IndexOutOfRangeException(SR.Format(SR.Arg_InsufficientNumberOfElements, Vector<T>.Count, nameof(values)));
            }

            if (Vector.IsHardwareAccelerated)
            {
<#
    foreach (Type type in supportedTypes)
    {
#>
                <#=GenerateIfStatementHeader(type)#>
                {
                    fixed (<#=typeAliases[type]#>* basePtr = &this.<#=GetRegisterFieldName(type, 0)#>)
                    {
                        for (int g = 0; g < Count; g++)
                        {
                            *(basePtr + g) = (<#=typeAliases[type]#>)(object)values[g + index];
                        }
                    }
                }
<#
    }
#>
            }
            else
            {
<#
    foreach (Type type in supportedTypes)
    {
#>
                <#=GenerateIfStatementHeader(type)#>
                {
                    fixed (<#=typeAliases[type]#>* basePtr = &this.<#=GetRegisterFieldName(type, 0)#>)
                    {
<#
        for (int g = 0; g < GetNumFields(type, totalSize); g++)
        {
#>
                        *(basePtr + <#=g#>) = (<#=typeAliases[type]#>)(object)values[<#=g#> + index];
<#
        }
#>
                    }
                }
<#
    }
#>
            }
        }

#pragma warning disable 3001 // void* is not a CLS-Compliant argument type
        internal unsafe Vector(void* dataPointer) : this(dataPointer, 0) { }
#pragma warning restore 3001 // void* is not a CLS-Compliant argument type

#pragma warning disable 3001 // void* is not a CLS-Compliant argument type
        // Implemented with offset if this API ever becomes public; an offset of 0 is used internally.
        internal unsafe Vector(void* dataPointer, int offset)
            : this()
        {
<#
    foreach (Type type in supportedTypes)
    {
#>
            <#=GenerateIfStatementHeader(type)#>
            {
                <#=typeAliases[type]#>* castedPtr = (<#=typeAliases[type]#>*)dataPointer;
                castedPtr += offset;
                fixed (<#=typeAliases[type]#>* registerBase = &this.<#=GetRegisterFieldName(type, 0)#>)
                {
                    for (int g = 0; g < Count; g++)
                    {
                        registerBase[g] = castedPtr[g];
                    }
                }
            }
<#
    }
#>
            else
            {
                throw new NotSupportedException(SR.Arg_TypeNotSupported);
            }
        }
#pragma warning restore 3001 // void* is not a CLS-Compliant argument type

        private Vector(ref Register existingRegister)
        {
            this.register = existingRegister;
        }

#if netcoreapp
        /// <summary>
        /// Constructs a vector from the given <see cref="ReadOnlySpan{Byte}"/>. The span must contain at least <see cref="Vector{Byte}.Count"/> elements.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Vector(ReadOnlySpan<byte> values)
            : this()
        {
            ThrowHelper.ThrowForUnsupportedVectorBaseType<T>();
            if (values.Length < Vector<byte>.Count)
            {
                Vector.ThrowInsufficientNumberOfElementsException(Vector<byte>.Count);
            }
            this = Unsafe.ReadUnaligned<Vector<T>>(ref MemoryMarshal.GetReference(values));
        }
        
        /// <summary>
        /// Constructs a vector from the given <see cref="ReadOnlySpan{T}"/>. The span must contain at least <see cref="Vector{T}.Count"/> elements.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Vector(ReadOnlySpan<T> values)
            : this()
        {
            if (values.Length < Count)
            {
                Vector.ThrowInsufficientNumberOfElementsException(Vector<T>.Count);
            }
            this = Unsafe.ReadUnaligned<Vector<T>>(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(values)));
        }

        /// <summary>
        /// Constructs a vector from the given <see cref="Span{T}"/>. The span must contain at least <see cref="Vector{T}.Count"/> elements.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Vector(Span<T> values)
            : this()
        {
            if (values.Length < Count)
            {
                Vector.ThrowInsufficientNumberOfElementsException(Vector<T>.Count);
            }
            this = Unsafe.ReadUnaligned<Vector<T>>(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(values)));
        }
#endif
        #endregion Constructors

        #region Public Instance Methods
        /// <summary>
        /// Copies the vector to the given <see cref="Span{Byte}"/>. The destination span must be at least size <see cref="Vector{Byte}.Count"/>.
        /// </summary>
        /// <param name="destination">The destination span which the values are copied into</param>
        /// <exception cref="ArgumentException">If number of elements in source vector is greater than those available in destination span</exception>
        public readonly void CopyTo(Span<byte> destination)
        {
            ThrowHelper.ThrowForUnsupportedVectorBaseType<T>();
            if ((uint)destination.Length < (uint)Vector<byte>.Count)
            {
                ThrowHelper.ThrowArgumentException_DestinationTooShort();
            }
            Unsafe.WriteUnaligned<Vector<T>>(ref MemoryMarshal.GetReference(destination), this);
        }

        /// <summary>
        /// Copies the vector to the given <see cref="Span{T}"/>. The destination span must be at least size <see cref="Vector{T}.Count"/>.
        /// </summary>
        /// <param name="destination">The destination span which the values are copied into</param>
        /// <exception cref="ArgumentException">If number of elements in source vector is greater than those available in destination span</exception>
        public readonly void CopyTo(Span<T> destination)
        {
            if ((uint)destination.Length < (uint)Count)
            {
                ThrowHelper.ThrowArgumentException_DestinationTooShort();
            }

            Unsafe.WriteUnaligned<Vector<T>>(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(destination)), this);
        }

        /// <summary>
        /// Copies the vector to the given destination array. The destination array must be at least size Vector'T.Count.
        /// </summary>
        /// <param name="destination">The destination array which the values are copied into</param>
        /// <exception cref="ArgumentNullException">If the destination array is null</exception>
        /// <exception cref="ArgumentException">If number of elements in source vector is greater than those available in destination array</exception>
        [Intrinsic]
        public unsafe readonly void CopyTo(T[] destination)
        {
            CopyTo(destination, 0);
        }

        /// <summary>
        /// Copies the vector to the given destination array. The destination array must be at least size Vector'T.Count.
        /// </summary>
        /// <param name="destination">The destination array which the values are copied into</param>
        /// <param name="startIndex">The index to start copying to</param>
        /// <exception cref="ArgumentNullException">If the destination array is null</exception>
        /// <exception cref="ArgumentOutOfRangeException">If index is greater than end of the array or index is less than zero</exception>
        /// <exception cref="ArgumentException">If number of elements in source vector is greater than those available in destination array</exception>
        [Intrinsic]
        public unsafe readonly void CopyTo(T[] destination, int startIndex)
        {
            if (destination == null)
            {
                // Match the JIT's exception type here. For perf, a NullReference is thrown instead of an ArgumentNull.
                throw new NullReferenceException(SR.Arg_NullArgumentNullRef);
            }
            if (startIndex < 0 || startIndex >= destination.Length)
            {
                throw new ArgumentOutOfRangeException(nameof(startIndex), SR.Format(SR.Arg_ArgumentOutOfRangeException, startIndex));
            }
            if ((destination.Length - startIndex) < Count)
            {
                throw new ArgumentException(SR.Format(SR.Arg_ElementsInSourceIsGreaterThanDestination, startIndex));
            }

            if (Vector.IsHardwareAccelerated)
            {
<#
    foreach (Type type in supportedTypes)
    {
#>
                <#=GenerateIfStatementHeader(type)#>
                {
                    <#=typeAliases[type]#>[] <#=type.Name.ToLowerInvariant()#>Array = (<#=typeAliases[type]#>[])(object)destination;
                    fixed (<#=typeAliases[type]#>* destinationBase = <#=type.Name.ToLowerInvariant()#>Array)
                    {
                        for (int g = 0; g < Count; g++)
                        {
                            destinationBase[startIndex + g] = (<#=typeAliases[type]#>)(object)this[g];
                        }
                    }
                }
<#
    }
#>
            }
            else
            {
<#
    foreach (Type type in supportedTypes)
    {
#>
                <#=GenerateIfStatementHeader(type)#>
                {
                    <#=typeAliases[type]#>[] <#=type.Name.ToLowerInvariant()#>Array = (<#=typeAliases[type]#>[])(object)destination;
                    fixed (<#=typeAliases[type]#>* destinationBase = <#=type.Name.ToLowerInvariant()#>Array)
                    {
<#
        for (int g = 0; g < GetNumFields(type, totalSize); g++)
        {
#>
                        destinationBase[startIndex + <#=g#>] = this.<#=GetRegisterFieldName(type, g)#>;
<#
        }
#>
                    }
                }
<#
    }
#>
            }
        }

        /// <summary>
        /// Returns the element at the given index.
        /// </summary>
        public unsafe readonly T this[int index]
        {
            [Intrinsic]
            get
            {
                if (index >= Count || index < 0)
                {
                    throw new IndexOutOfRangeException(SR.Format(SR.Arg_ArgumentOutOfRangeException, index));
                }
<#
    foreach (Type type in supportedTypes)
    {
#>
                <#=GenerateIfStatementHeader(type)#>
                {
                    fixed (<#=typeAliases[type]#>* basePtr = &this.<#=GetRegisterFieldName(type, 0)#>)
                    {
                        return (T)(object)*(basePtr + index);
                    }
                }
<#
    }
#>
                else
                {
                    throw new NotSupportedException(SR.Arg_TypeNotSupported);
                }
            }
        }

        /// <summary>
        /// Returns a boolean indicating whether the given Object is equal to this vector instance.
        /// </summary>
        /// <param name="obj">The Object to compare against.</param>
        /// <returns>True if the Object is equal to this vector; False otherwise.</returns>
        [MethodImplAttribute(MethodImplOptions.AggressiveInlining)]
        public override readonly bool Equals(object? obj)
        {
            if (!(obj is Vector<T>))
            {
                return false;
            }
            return Equals((Vector<T>)obj);
        }

        /// <summary>
        /// Returns a boolean indicating whether the given vector is equal to this vector instance.
        /// </summary>
        /// <param name="other">The vector to compare this instance to.</param>
        /// <returns>True if the other vector is equal to this instance; False otherwise.</returns>
        [Intrinsic]
        public readonly bool Equals(Vector<T> other)
        {
            if (Vector.IsHardwareAccelerated)
            {
                for (int g = 0; g < Count; g++)
                {
                    if (!ScalarEquals(this[g], other[g]))
                    {
                        return false;
                    }
                }
                return true;
            }
            else
            {
<#
    foreach (Type type in supportedTypes)
    {
#>
                <#=GenerateIfStatementHeader(type)#>
                {
                    return
<#
        for (int g = 0; g < GetNumFields(type, totalSize); g++)
        {
#>
<#
            if (g == 0)
            {
#>
                        this.<#=GetRegisterFieldName(type, g)#> == other.<#=GetRegisterFieldName(type, g)#>
<#
            }
            else
            {
#>
                        && this.<#=GetRegisterFieldName(type, g)#> == other.<#=GetRegisterFieldName(type, g)#><#=(g == (GetNumFields(type, totalSize) -1)) ? ";" : ""#>
<#
            }
#>
<#
        }
#>
                }
<#
    }
#>
                else
                {
                    throw new NotSupportedException(SR.Arg_TypeNotSupported);
                }
            }
        }

        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>The hash code.</returns>
        public override readonly int GetHashCode()
        {
            int hash = 0;

            if (Vector.IsHardwareAccelerated)
            {
<#
    foreach (Type type in supportedTypes)
    {
#>
                <#=GenerateIfStatementHeader(type)#>
                {
                    for (int g = 0; g < Count; g++)
                    {
                        hash = HashHelpers.Combine(hash, ((<#=typeAliases[type]#>)(object)this[g]).GetHashCode());
                    }
                    return hash;
                }
<#
    }
#>
                else
                {
                    throw new NotSupportedException(SR.Arg_TypeNotSupported);
                }
            }
            else
            {
<#
    foreach (Type type in supportedTypes)
    {
#>
                <#=GenerateIfStatementHeader(type)#>
                {
<#
        for (int g = 0; g < GetNumFields(type, totalSize); g++)
        {
#>
                    hash = HashHelpers.Combine(hash, this.<#=GetRegisterFieldName(type, g)#>.GetHashCode());
<#
        }
#>
                    return hash;
                }
<#
    }
#>
                else
                {
                    throw new NotSupportedException(SR.Arg_TypeNotSupported);
                }
            }
        }

        /// <summary>
        /// Returns a String representing this vector.
        /// </summary>
        /// <returns>The string representation.</returns>
        public override readonly string ToString()
        {
            return ToString("G", CultureInfo.CurrentCulture);
        }

        /// <summary>
        /// Returns a String representing this vector, using the specified format string to format individual elements.
        /// </summary>
        /// <param name="format">The format of individual elements.</param>
        /// <returns>The string representation.</returns>
        public readonly string ToString(string? format)
        {
            return ToString(format, CultureInfo.CurrentCulture);
        }

        /// <summary>
        /// Returns a String representing this vector, using the specified format string to format individual elements
        /// and the given IFormatProvider.
        /// </summary>
        /// <param name="format">The format of individual elements.</param>
        /// <param name="formatProvider">The format provider to use when formatting elements.</param>
        /// <returns>The string representation.</returns>
        public readonly string ToString(string? format, IFormatProvider? formatProvider)
        {
            StringBuilder sb = new StringBuilder();
            string separator = NumberFormatInfo.GetInstance(formatProvider).NumberGroupSeparator;
            sb.Append('<');
            for (int g = 0; g < Count - 1; g++)
            {
                sb.Append(((IFormattable)this[g]).ToString(format, formatProvider));
                sb.Append(separator);
                sb.Append(' ');
            }
            // Append last element w/out separator
            sb.Append(((IFormattable)this[Count - 1]).ToString(format, formatProvider));
            sb.Append('>');
            return sb.ToString();
        }

        /// <summary>
        /// Attempts to copy the vector to the given <see cref="Span{Byte}"/>. The destination span must be at least size <see cref="Vector{Byte}.Count"/>.
        /// </summary>
        /// <param name="destination">The destination span which the values are copied into</param>
        /// <returns>True if the source vector was successfully copied to <paramref name="destination"/>. False if
        /// <paramref name="destination"/> is not large enough to hold the source vector.</returns>
        public readonly bool TryCopyTo(Span<byte> destination)
        {
            ThrowHelper.ThrowForUnsupportedVectorBaseType<T>();
            if ((uint)destination.Length < (uint)Vector<byte>.Count)
            {
                return false;
            }

            Unsafe.WriteUnaligned<Vector<T>>(ref MemoryMarshal.GetReference(destination), this);
            return true;
        }

        /// <summary>
        /// Attempts to copy the vector to the given <see cref="Span{T}"/>. The destination span must be at least size <see cref="Vector{T}.Count"/>.
        /// </summary>
        /// <param name="destination">The destination span which the values are copied into</param>
        /// <returns>True if the source vector was successfully copied to <paramref name="destination"/>. False if
        /// <paramref name="destination"/> is not large enough to hold the source vector.</returns>
        public readonly bool TryCopyTo(Span<T> destination)
        {
            if ((uint)destination.Length < (uint)Count)
            {
                return false;
            }

            Unsafe.WriteUnaligned<Vector<T>>(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(destination)), this);
            return true;
        }
        #endregion Public Instance Methods

        #region Arithmetic Operators
        /// <summary>
        /// Adds two vectors together.
        /// </summary>
        /// <param name="left">The first source vector.</param>
        /// <param name="right">The second source vector.</param>
        /// <returns>The summed vector.</returns>
        [Intrinsic]
        public static unsafe Vector<T> operator +(Vector<T> left, Vector<T> right)
        {
            unchecked
            {
                if (Vector.IsHardwareAccelerated)
                {
<#
    foreach (Type type in supportedTypes)
    {
#>
                    <#=GenerateIfStatementHeader(type)#>
                    {
                        <#=typeAliases[type]#>* dataPtr = stackalloc <#=typeAliases[type]#>[Count];
                        for (int g = 0; g < Count; g++)
                        {
                            dataPtr[g] = (<#=typeAliases[type]#>)(object)ScalarAdd(left[g], right[g]);
                        }
                        return new Vector<T>(dataPtr);
                    }
<#
    }
#>
                    else
                    {
                        throw new NotSupportedException(SR.Arg_TypeNotSupported);
                    }
                }
                else
                {
                    Vector<T> sum = new Vector<T>();
<#
    foreach (Type type in supportedTypes)
    {
#>
                    <#=GenerateIfStatementHeader(type)#>
                    {
<#
                for (int g = 0; g < GetNumFields(type, totalSize); g++)
                {
#>
                        sum.<#= GetRegisterFieldName(type, g) #> = (<#=typeAliases[type]#>)(left.<#= GetRegisterFieldName(type, g) #> + right.<#= GetRegisterFieldName(type, g) #>);
<#
                }
#>
                    }
<#
    }
#>
                    return sum;
                }
            }
        }

        /// <summary>
        /// Subtracts the second vector from the first.
        /// </summary>
        /// <param name="left">The first source vector.</param>
        /// <param name="right">The second source vector.</param>
        /// <returns>The difference vector.</returns>
        [Intrinsic]
        public static unsafe Vector<T> operator -(Vector<T> left, Vector<T> right)
        {
            unchecked
            {
                if (Vector.IsHardwareAccelerated)
                {
<#
    foreach (Type type in supportedTypes)
    {
#>
                    <#=GenerateIfStatementHeader(type)#>
                    {
                        <#=typeAliases[type]#>* dataPtr = stackalloc <#=typeAliases[type]#>[Count];
                        for (int g = 0; g < Count; g++)
                        {
                            dataPtr[g] = (<#=typeAliases[type]#>)(object)ScalarSubtract(left[g], right[g]);
                        }
                        return new Vector<T>(dataPtr);
                    }
<#
    }
#>
                    else
                    {
                        throw new NotSupportedException(SR.Arg_TypeNotSupported);
                    }
                }
                else
                {
                    Vector<T> difference = new Vector<T>();
<#
    foreach (Type type in supportedTypes)
    {
#>
                    <#=GenerateIfStatementHeader(type)#>
                    {
<#
        for (int g = 0; g < GetNumFields(type, totalSize); g++)
        {
#>
                        difference.<#= GetRegisterFieldName(type, g) #> = (<#=typeAliases[type]#>)(left.<#= GetRegisterFieldName(type, g) #> - right.<#= GetRegisterFieldName(type, g) #>);
<#
        }
#>
                    }
<#
    }
#>
                    return difference;
                }
            }
        }

        // This method is intrinsic only for certain types. It cannot access fields directly unless we are sure the context is unaccelerated.
        /// <summary>
        /// Multiplies two vectors together.
        /// </summary>
        /// <param name="left">The first source vector.</param>
        /// <param name="right">The second source vector.</param>
        /// <returns>The product vector.</returns>
        [Intrinsic]
        public static unsafe Vector<T> operator *(Vector<T> left, Vector<T> right)
        {
            unchecked
            {
                if (Vector.IsHardwareAccelerated)
                {
<#
    foreach (Type type in supportedTypes)
    {
#>
                    <#=GenerateIfStatementHeader(type)#>
                    {
                        <#=typeAliases[type]#>* dataPtr = stackalloc <#=typeAliases[type]#>[Count];
                        for (int g = 0; g < Count; g++)
                        {
                            dataPtr[g] = (<#=typeAliases[type]#>)(object)ScalarMultiply(left[g], right[g]);
                        }
                        return new Vector<T>(dataPtr);
                    }
<#
    }
#>
                    else
                    {
                        throw new NotSupportedException(SR.Arg_TypeNotSupported);
                    }
                }
                else
                {
                    Vector<T> product = new Vector<T>();
<#
    foreach (Type type in supportedTypes)
    {
#>
                    <#=GenerateIfStatementHeader(type)#>
                    {
<#
        for (int g = 0; g < GetNumFields(type, totalSize); g++)
        {
#>
                        product.<#= GetRegisterFieldName(type, g) #> = (<#=typeAliases[type]#>)(left.<#= GetRegisterFieldName(type, g) #> * right.<#= GetRegisterFieldName(type, g) #>);
<#
        }
#>
                    }
<#
    }
#>
                    return product;
                }
            }
        }

        /// <summary>
        /// Multiplies a vector by the given scalar.
        /// </summary>
        /// <param name="value">The source vector.</param>
        /// <param name="factor">The scalar value.</param>
        /// <returns>The scaled vector.</returns>
        [MethodImplAttribute(MethodImplOptions.AggressiveInlining)]
        public static Vector<T> operator *(Vector<T> value, T factor)
        {
            return new Vector<T>(factor) * value;
        }

        /// <summary>
        /// Multiplies a vector by the given scalar.
        /// </summary>
        /// <param name="factor">The scalar value.</param>
        /// <param name="value">The source vector.</param>
        /// <returns>The scaled vector.</returns>
        [MethodImplAttribute(MethodImplOptions.AggressiveInlining)]
        public static Vector<T> operator *(T factor, Vector<T> value)
        {
            return new Vector<T>(factor) * value;
        }

        // This method is intrinsic only for certain types. It cannot access fields directly unless we are sure the context is unaccelerated.
        /// <summary>
        /// Divides the first vector by the second.
        /// </summary>
        /// <param name="left">The first source vector.</param>
        /// <param name="right">The second source vector.</param>
        /// <returns>The vector resulting from the division.</returns>
        [Intrinsic]
        public static unsafe Vector<T> operator /(Vector<T> left, Vector<T> right)
        {
            unchecked
            {
                if (Vector.IsHardwareAccelerated)
                {
<#
    foreach (Type type in supportedTypes)
    {
#>
                    <#=GenerateIfStatementHeader(type)#>
                    {
                        <#=typeAliases[type]#>* dataPtr = stackalloc <#=typeAliases[type]#>[Count];
                        for (int g = 0; g < Count; g++)
                        {
                            dataPtr[g] = (<#=typeAliases[type]#>)(object)ScalarDivide(left[g], right[g]);
                        }
                        return new Vector<T>(dataPtr);
                    }
<#
    }
#>
                    else
                    {
                        throw new NotSupportedException(SR.Arg_TypeNotSupported);
                    }
                }
                else
                {
                    Vector<T> quotient = new Vector<T>();
<#
    foreach (Type type in supportedTypes)
    {
#>
                    <#=GenerateIfStatementHeader(type)#>
                    {
<#
        for (int g = 0; g < GetNumFields(type, totalSize); g++)
        {
#>
                        quotient.<#= GetRegisterFieldName(type, g) #> = (<#=typeAliases[type]#>)(left.<#= GetRegisterFieldName(type, g) #> / right.<#= GetRegisterFieldName(type, g) #>);
<#
        }
#>
                    }
<#
    }
#>
                    return quotient;
                }
            }
        }

        /// <summary>
        /// Negates a given vector.
        /// </summary>
        /// <param name="value">The source vector.</param>
        /// <returns>The negated vector.</returns>
        public static Vector<T> operator -(Vector<T> value)
        {
            return Zero - value;
        }
        #endregion Arithmetic Operators

        #region Bitwise Operators
        /// <summary>
        /// Returns a new vector by performing a bitwise-and operation on each of the elements in the given vectors.
        /// </summary>
        /// <param name="left">The first source vector.</param>
        /// <param name="right">The second source vector.</param>
        /// <returns>The resultant vector.</returns>
        [Intrinsic]
        public static unsafe Vector<T> operator &(Vector<T> left, Vector<T> right)
        {
            Vector<T> result = new Vector<T>();
            unchecked
            {
                if (Vector.IsHardwareAccelerated)
                {
                    long* resultBase = &result.register.int64_0;
                    long* leftBase = &left.register.int64_0;
                    long* rightBase = &right.register.int64_0;
                    for (int g = 0; g < Vector<long>.Count; g++)
                    {
                        resultBase[g] = leftBase[g] & rightBase[g];
                    }
                }
                else
                {
                    result.<#=GetRegisterFieldName(typeof(long), 0)#> = left.<#=GetRegisterFieldName(typeof(long), 0)#> & right.<#=GetRegisterFieldName(typeof(long), 0)#>;
                    result.<#=GetRegisterFieldName(typeof(long), 1)#> = left.<#=GetRegisterFieldName(typeof(long), 1)#> & right.<#=GetRegisterFieldName(typeof(long), 1)#>;
                }
            }
            return result;
        }

        /// <summary>
        /// Returns a new vector by performing a bitwise-or operation on each of the elements in the given vectors.
        /// </summary>
        /// <param name="left">The first source vector.</param>
        /// <param name="right">The second source vector.</param>
        /// <returns>The resultant vector.</returns>
        [Intrinsic]
        public static unsafe Vector<T> operator |(Vector<T> left, Vector<T> right)
        {
            Vector<T> result = new Vector<T>();
            unchecked
            {
                if (Vector.IsHardwareAccelerated)
                {
                    long* resultBase = &result.register.int64_0;
                    long* leftBase = &left.register.int64_0;
                    long* rightBase = &right.register.int64_0;
                    for (int g = 0; g < Vector<long>.Count; g++)
                    {
                        resultBase[g] = leftBase[g] | rightBase[g];
                    }
                }
                else
                {
                    result.<#=GetRegisterFieldName(typeof(long), 0)#> = left.<#=GetRegisterFieldName(typeof(long), 0)#> | right.<#=GetRegisterFieldName(typeof(long), 0)#>;
                    result.<#=GetRegisterFieldName(typeof(long), 1)#> = left.<#=GetRegisterFieldName(typeof(long), 1)#> | right.<#=GetRegisterFieldName(typeof(long), 1)#>;
                }
            }
            return result;
        }

        /// <summary>
        /// Returns a new vector by performing a bitwise-exclusive-or operation on each of the elements in the given vectors.
        /// </summary>
        /// <param name="left">The first source vector.</param>
        /// <param name="right">The second source vector.</param>
        /// <returns>The resultant vector.</returns>
        [Intrinsic]
        public static unsafe Vector<T> operator ^(Vector<T> left, Vector<T> right)
        {
            Vector<T> result = new Vector<T>();
            unchecked
            {
                if (Vector.IsHardwareAccelerated)
                {
                    long* resultBase = &result.register.int64_0;
                    long* leftBase = &left.register.int64_0;
                    long* rightBase = &right.register.int64_0;
                    for (int g = 0; g < Vector<long>.Count; g++)
                    {
                        resultBase[g] = leftBase[g] ^ rightBase[g];
                    }
                }
                else
                {
                    result.<#=GetRegisterFieldName(typeof(long), 0)#> = left.<#=GetRegisterFieldName(typeof(long), 0)#> ^ right.<#=GetRegisterFieldName(typeof(long), 0)#>;
                    result.<#=GetRegisterFieldName(typeof(long), 1)#> = left.<#=GetRegisterFieldName(typeof(long), 1)#> ^ right.<#=GetRegisterFieldName(typeof(long), 1)#>;
                }
            }
            return result;
        }

        /// <summary>
        /// Returns a new vector whose elements are obtained by taking the one's complement of the given vector's elements.
        /// </summary>
        /// <param name="value">The source vector.</param>
        /// <returns>The one's complement vector.</returns>
        [MethodImplAttribute(MethodImplOptions.AggressiveInlining)]
        public static Vector<T> operator ~(Vector<T> value)
        {
            return s_allOnes ^ value;
        }
        #endregion Bitwise Operators

        #region Logical Operators
        /// <summary>
        /// Returns a boolean indicating whether each pair of elements in the given vectors are equal.
        /// </summary>
        /// <param name="left">The first vector to compare.</param>
        /// <param name="right">The first vector to compare.</param>
        /// <returns>True if all elements are equal; False otherwise.</returns>
        [Intrinsic]
        [MethodImplAttribute(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Vector<T> left, Vector<T> right)
        {
            return left.Equals(right);
        }

        /// <summary>
        /// Returns a boolean indicating whether any single pair of elements in the given vectors are not equal.
        /// </summary>
        /// <param name="left">The first vector to compare.</param>
        /// <param name="right">The second vector to compare.</param>
        /// <returns>True if left and right are not equal; False otherwise.</returns>
        [Intrinsic]
        [MethodImplAttribute(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Vector<T> left, Vector<T> right)
        {
            return !(left == right);
        }
        #endregion Logical Operators

        #region Conversions
<#
    foreach (Type type in supportedTypes)
    {
#>
        /// <summary>
        /// Reinterprets the bits of the given vector into those of another type.
        /// </summary>
        /// <param name="value">The source vector</param>
        /// <returns>The reinterpreted vector.</returns>
<#
        if (nonClsCompliantTypes.Contains(type))
        {
#>
        [CLSCompliant(false)]
<#
        }
#>
        [Intrinsic]
        public static explicit operator Vector<<#=typeAliases[type]#>>(Vector<T> value)
        {
            return new Vector<<#=typeAliases[type]#>>(ref value.register);
        }

<#
    }
#>
        #endregion Conversions

        #region Internal Comparison Methods
        [Intrinsic]
        [MethodImplAttribute(MethodImplOptions.AggressiveInlining)]
        internal static unsafe Vector<T> Equals(Vector<T> left, Vector<T> right)
        {
            if (Vector.IsHardwareAccelerated)
            {
<#
    foreach (Type type in supportedTypes)
    {
#>
                <#=GenerateIfStatementHeader(type)#>
                {
                    <#=typeAliases[type]#>* dataPtr = stackalloc <#=typeAliases[type]#>[Count];
                    for (int g = 0; g < Count; g++)
                    {
                        dataPtr[g] = ScalarEquals(left[g], right[g]) ? ConstantHelper.Get<#=type.Name#>WithAllBitsSet() : (<#=typeAliases[type]#>)0;
                    }
                    return new Vector<T>(dataPtr);
                }
<#
    }
#>
                else
                {
                    throw new NotSupportedException(SR.Arg_TypeNotSupported);
                }
            }
            else
            {
                Register register = new Register();
<#
    foreach (Type type in supportedTypes)
    {
#>
                <#=GenerateIfStatementHeader(type)#>
                {
<#
        for (int g = 0; g < GetNumFields(type, totalSize); g++)
        {
#>
                    <#= GetRegisterFieldName(type, g) #> = left.<#= GetRegisterFieldName(type, g) #> == right.<#= GetRegisterFieldName(type, g) #> ? ConstantHelper.Get<#=type.Name#>WithAllBitsSet() : (<#=typeAliases[type]#>)0;
<#
        }
#>
                    return new Vector<T>(ref register);
                }
<#
    }
#>
                else
                {
                    throw new NotSupportedException(SR.Arg_TypeNotSupported);
                }
            }
        }

        [Intrinsic]
        [MethodImplAttribute(MethodImplOptions.AggressiveInlining)]
        internal static unsafe Vector<T> LessThan(Vector<T> left, Vector<T> right)
        {
            if (Vector.IsHardwareAccelerated)
            {
<#
    foreach (Type type in supportedTypes)
    {
#>
                <#=GenerateIfStatementHeader(type)#>
                {
                    <#=typeAliases[type]#>* dataPtr = stackalloc <#=typeAliases[type]#>[Count];
                    for (int g = 0; g < Count; g++)
                    {
                        dataPtr[g] = ScalarLessThan(left[g], right[g]) ? ConstantHelper.Get<#=type.Name#>WithAllBitsSet() : (<#=typeAliases[type]#>)0;
                    }
                    return new Vector<T>(dataPtr);
                }
<#
    }
#>
                else
                {
                    throw new NotSupportedException(SR.Arg_TypeNotSupported);
                }
            }
            else
            {
                Register register = new Register();
<#
    foreach (Type type in supportedTypes)
    {
#>
                <#=GenerateIfStatementHeader(type)#>
                {
<#
                for (int g = 0; g < GetNumFields(type, totalSize); g++)
                {
#>
                    <#= GetRegisterFieldName(type, g) #> = left.<#= GetRegisterFieldName(type, g) #> < right.<#= GetRegisterFieldName(type, g) #> ? ConstantHelper.Get<#=type.Name#>WithAllBitsSet() : (<#=typeAliases[type]#>)0;
<#
                }
#>
                    return new Vector<T>(ref register);
                }
<#
    }
#>
                else
                {
                    throw new NotSupportedException(SR.Arg_TypeNotSupported);
                }
            }
        }

        [Intrinsic]
        [MethodImplAttribute(MethodImplOptions.AggressiveInlining)]
        internal static unsafe Vector<T> GreaterThan(Vector<T> left, Vector<T> right)
        {
            if (Vector.IsHardwareAccelerated)
            {
<#
    foreach (Type type in supportedTypes)
    {
#>
                <#=GenerateIfStatementHeader(type)#>
                {
                    <#=typeAliases[type]#>* dataPtr = stackalloc <#=typeAliases[type]#>[Count];
                    for (int g = 0; g < Count; g++)
                    {
                        dataPtr[g] = ScalarGreaterThan(left[g], right[g]) ? ConstantHelper.Get<#=type.Name#>WithAllBitsSet() : (<#=typeAliases[type]#>)0;
                    }
                    return new Vector<T>(dataPtr);
                }
<#
    }
#>
                else
                {
                    throw new NotSupportedException(SR.Arg_TypeNotSupported);
                }
            }
            else
            {
                Register register = new Register();
<#
    foreach (Type type in supportedTypes)
    {
#>
                <#=GenerateIfStatementHeader(type)#>
                {
<#
        for (int g = 0; g < GetNumFields(type, totalSize); g++)
        {
#>
                    <#= GetRegisterFieldName(type, g) #> = left.<#= GetRegisterFieldName(type, g) #> > right.<#= GetRegisterFieldName(type, g) #> ? ConstantHelper.Get<#=type.Name#>WithAllBitsSet() : (<#=typeAliases[type]#>)0;
<#
        }
#>
                    return new Vector<T>(ref register);
                }
<#
    }
#>
                else
                {
                    throw new NotSupportedException(SR.Arg_TypeNotSupported);
                }
            }
        }

        [Intrinsic]
        internal static Vector<T> GreaterThanOrEqual(Vector<T> left, Vector<T> right)
        {
            return Equals(left, right) | GreaterThan(left, right);
        }

        [Intrinsic]
        internal static Vector<T> LessThanOrEqual(Vector<T> left, Vector<T> right)
        {
            return Equals(left, right) | LessThan(left, right);
        }

        [Intrinsic]
        internal static Vector<T> ConditionalSelect(Vector<T> condition, Vector<T> left, Vector<T> right)
        {
            return (left & condition) | (Vector.AndNot(right, condition));
        }
        #endregion Comparison Methods

        #region Internal Math Methods
        [Intrinsic]
        internal static unsafe Vector<T> Abs(Vector<T> value)
        {
<#
    foreach (Type type in supportedTypes)
    {
        if (unsignedTypes.Contains(type))
        {
#>
            <#=GenerateIfStatementHeader(type, unsignedTypes)#>
            {
                return value;
            }
<#
        }
    }
#>
            if (Vector.IsHardwareAccelerated)
            {
<#
    foreach (Type type in supportedTypes.Except(unsignedTypes))
    {
#>
                <#=GenerateIfStatementHeader(type, supportedTypes.Except(unsignedTypes))#>
                {
                    <#=typeAliases[type]#>* dataPtr = stackalloc <#=typeAliases[type]#>[Count];
                    for (int g = 0; g < Count; g++)
                    {
                        dataPtr[g] = (<#=typeAliases[type]#>)(object)(Math.Abs((<#=typeAliases[type]#>)(object)value[g]));
                    }
                    return new Vector<T>(dataPtr);
                }
<#
    }
#>
                else
                {
                    throw new NotSupportedException(SR.Arg_TypeNotSupported);
                }
            }
            else
            {
<#
    foreach (Type type in supportedTypes.Except(unsignedTypes))
    {
#>
                <#=GenerateIfStatementHeader(type, supportedTypes.Except(unsignedTypes))#>
                {
<#
        for (int g = 0; g < GetNumFields(type, totalSize); g++)
        {
#>
                    value.<#=GetRegisterFieldName(type, g)#> = (<#=typeAliases[type]#>)(Math.Abs(value.<#=GetRegisterFieldName(type, g)#>));
<#
        }
#>
                    return value;
                }
<#
    }
#>
                else
                {
                    throw new NotSupportedException(SR.Arg_TypeNotSupported);
                }
            }
        }

        [Intrinsic]
        internal static unsafe Vector<T> Min(Vector<T> left, Vector<T> right)
        {
            if (Vector.IsHardwareAccelerated)
            {
<#
    foreach (Type type in supportedTypes)
    {
#>
                <#=GenerateIfStatementHeader(type)#>
                {
                    <#=typeAliases[type]#>* dataPtr = stackalloc <#=typeAliases[type]#>[Count];
                    for (int g = 0; g < Count; g++)
                    {
                        dataPtr[g] = ScalarLessThan(left[g], right[g]) ? (<#=typeAliases[type]#>)(object)left[g] : (<#=typeAliases[type]#>)(object)right[g];
                    }
                    return new Vector<T>(dataPtr);
                }
<#
    }
#>
                else
                {
                    throw new NotSupportedException(SR.Arg_TypeNotSupported);
                }
            }
            else
            {
                Vector<T> vec = new Vector<T>();
<#
    foreach (Type type in supportedTypes)
    {
#>
                <#=GenerateIfStatementHeader(type)#>
                {
<#
        for (int g = 0; g < GetNumFields(type, totalSize); g++)
        {
#>
                    vec.<#=GetRegisterFieldName(type, g)#> = left.<#=GetRegisterFieldName(type, g)#> < right.<#=GetRegisterFieldName(type, g)#> ? left.<#=GetRegisterFieldName(type, g)#> : right.<#=GetRegisterFieldName(type, g)#>;
<#
        }
#>
                    return vec;
                }
<#
    }
#>
                else
                {
                    throw new NotSupportedException(SR.Arg_TypeNotSupported);
                }
            }
        }

        [Intrinsic]
        internal static unsafe Vector<T> Max(Vector<T> left, Vector<T> right)
        {
            if (Vector.IsHardwareAccelerated)
            {
<#
    foreach (Type type in supportedTypes)
    {
#>
                <#=GenerateIfStatementHeader(type)#>
                {
                    <#=typeAliases[type]#>* dataPtr = stackalloc <#=typeAliases[type]#>[Count];
                    for (int g = 0; g < Count; g++)
                    {
                        dataPtr[g] = ScalarGreaterThan(left[g], right[g]) ? (<#=typeAliases[type]#>)(object)left[g] : (<#=typeAliases[type]#>)(object)right[g];
                    }
                    return new Vector<T>(dataPtr);
                }
<#
    }
#>
                else
                {
                    throw new NotSupportedException(SR.Arg_TypeNotSupported);
                }
            }
            else
            {
                Vector<T> vec = new Vector<T>();
<#
    foreach (Type type in supportedTypes)
    {
#>
                <#=GenerateIfStatementHeader(type)#>
                {
<#
        for (int g = 0; g < GetNumFields(type, totalSize); g++)
        {
#>
                    vec.<#=GetRegisterFieldName(type, g)#> = left.<#=GetRegisterFieldName(type, g)#> > right.<#=GetRegisterFieldName(type, g)#> ? left.<#=GetRegisterFieldName(type, g)#> : right.<#=GetRegisterFieldName(type, g)#>;
<#
        }
#>
                    return vec;
                }
<#
    }
#>
                else
                {
                    throw new NotSupportedException(SR.Arg_TypeNotSupported);
                }
            }
        }

        [Intrinsic]
        internal static T Dot(Vector<T> left, Vector<T> right)
        {
            if (Vector.IsHardwareAccelerated)
            {
                T product = default;
                for (int g = 0; g < Count; g++)
                {
                    product = ScalarAdd(product, ScalarMultiply(left[g], right[g]));
                }
                return product;
            }
            else
            {
<#
    foreach (Type type in supportedTypes)
    {
#>
                <#=GenerateIfStatementHeader(type)#>
                {
                    <#=typeAliases[type]#> product = 0;
<#
        for (int g = 0; g < GetNumFields(type, totalSize); g++)
        {
#>
                    product += (<#=typeAliases[type]#>)(left.<#=GetRegisterFieldName(type, g)#> * right.<#=GetRegisterFieldName(type, g)#>);
<#
        }
#>
                    return (T)(object)product;
                }
<#
    }
#>
                else
                {
                    throw new NotSupportedException(SR.Arg_TypeNotSupported);
                }
            }
        }

        [Intrinsic]
        internal static unsafe Vector<T> SquareRoot(Vector<T> value)
        {
            if (Vector.IsHardwareAccelerated)
            {
<#
    foreach (Type type in supportedTypes)
    {
#>
                <#=GenerateIfStatementHeader(type)#>
                {
                    <#=typeAliases[type]#>* dataPtr = stackalloc <#=typeAliases[type]#>[Count];
                    for (int g = 0; g < Count; g++)
                    {
                        dataPtr[g] = unchecked((<#=typeAliases[type]#>)Math.Sqrt((<#=typeAliases[type]#>)(object)value[g]));
                    }
                    return new Vector<T>(dataPtr);
                }
<#
    }
#>
                else
                {
                    throw new NotSupportedException(SR.Arg_TypeNotSupported);
                }
            }
            else
            {
<#
    foreach (Type type in supportedTypes)
    {
#>
                <#=GenerateIfStatementHeader(type)#>
                {
<#
        for (int g = 0; g < GetNumFields(type, totalSize); g++)
        {
#>
                    value.<#=GetRegisterFieldName(type, g)#> = (<#=typeAliases[type]#>)Math.Sqrt(value.<#=GetRegisterFieldName(type, g)#>);
<#
        }
#>
                    return value;
                }
<#
    }
#>
                else
                {
                    throw new NotSupportedException(SR.Arg_TypeNotSupported);
                }
            }
        }
        #endregion Internal Math Methods

        #region Helper Methods
        [MethodImplAttribute(MethodImplOptions.AggressiveInlining)]
        private static bool ScalarEquals(T left, T right)
        {
<#
    foreach (Type type in supportedTypes)
    {
#>
            <#=GenerateIfStatementHeader(type)#>
            {
                return (<#=typeAliases[type]#>)(object)left == (<#=typeAliases[type]#>)(object)right;
            }
<#
    }
#>
            else
            {
                throw new NotSupportedException(SR.Arg_TypeNotSupported);
            }
        }

        [MethodImplAttribute(MethodImplOptions.AggressiveInlining)]
        private static bool ScalarLessThan(T left, T right)
        {
<#
    foreach (Type type in supportedTypes)
    {
#>
            <#=GenerateIfStatementHeader(type)#>
            {
                return (<#=typeAliases[type]#>)(object)left < (<#=typeAliases[type]#>)(object)right;
            }
<#
    }
#>
            else
            {
                throw new NotSupportedException(SR.Arg_TypeNotSupported);
            }
        }

        [MethodImplAttribute(MethodImplOptions.AggressiveInlining)]
        private static bool ScalarGreaterThan(T left, T right)
        {
<#
    foreach (Type type in supportedTypes)
    {
#>
            <#=GenerateIfStatementHeader(type)#>
            {
                return (<#=typeAliases[type]#>)(object)left > (<#=typeAliases[type]#>)(object)right;
            }
<#
    }
#>
            else
            {
                throw new NotSupportedException(SR.Arg_TypeNotSupported);
            }
        }

        [MethodImplAttribute(MethodImplOptions.AggressiveInlining)]
        private static T ScalarAdd(T left, T right)
        {
<#
    foreach (Type type in supportedTypes)
    {
#>
            <#=GenerateIfStatementHeader(type)#>
            {
                return (T)(object)unchecked((<#=typeAliases[type]#>)((<#=typeAliases[type]#>)(object)left + (<#=typeAliases[type]#>)(object)right));
            }
<#
    }
#>
            else
            {
                throw new NotSupportedException(SR.Arg_TypeNotSupported);
            }
        }

        [MethodImplAttribute(MethodImplOptions.AggressiveInlining)]
        private static T ScalarSubtract(T left, T right)
        {
<#
    foreach (Type type in supportedTypes)
    {
#>
            <#=GenerateIfStatementHeader(type)#>
            {
                return (T)(object)(<#=typeAliases[type]#>)((<#=typeAliases[type]#>)(object)left - (<#=typeAliases[type]#>)(object)right);
            }
<#
    }
#>
            else
            {
                throw new NotSupportedException(SR.Arg_TypeNotSupported);
            }
        }

        [MethodImplAttribute(MethodImplOptions.AggressiveInlining)]
        private static T ScalarMultiply(T left, T right)
        {
<#
    foreach (Type type in supportedTypes)
    {
#>
            <#=GenerateIfStatementHeader(type)#>
            {
                return (T)(object)unchecked((<#=typeAliases[type]#>)((<#=typeAliases[type]#>)(object)left * (<#=typeAliases[type]#>)(object)right));
            }
<#
    }
#>
            else
            {
                throw new NotSupportedException(SR.Arg_TypeNotSupported);
            }
        }

        [MethodImplAttribute(MethodImplOptions.AggressiveInlining)]
        private static T ScalarDivide(T left, T right)
        {
<#
    foreach (Type type in supportedTypes)
    {
#>
            <#=GenerateIfStatementHeader(type)#>
            {
                return (T)(object)(<#=typeAliases[type]#>)((<#=typeAliases[type]#>)(object)left / (<#=typeAliases[type]#>)(object)right);
            }
<#
    }
#>
            else
            {
                throw new NotSupportedException(SR.Arg_TypeNotSupported);
            }
        }

        [MethodImplAttribute(MethodImplOptions.AggressiveInlining)]
        private static T GetOneValue()
        {
<#
    foreach (Type type in supportedTypes)
    {
#>
            <#=GenerateIfStatementHeader(type)#>
            {
                <#=typeAliases[type]#> value = 1;
                return (T)(object)value;
            }
<#
    }
#>
            else
            {
                throw new NotSupportedException(SR.Arg_TypeNotSupported);
            }
        }

        [MethodImplAttribute(MethodImplOptions.AggressiveInlining)]
        private static T GetAllBitsSetValue()
        {
<#
    foreach (Type type in supportedTypes)
    {
#>
            <#=GenerateIfStatementHeader(type)#>
            {
                return (T)(object)ConstantHelper.Get<#=type.Name#>WithAllBitsSet();
            }
<#
    }
#>
            else
            {
                throw new NotSupportedException(SR.Arg_TypeNotSupported);
            }
        }
        #endregion
    }

    [Intrinsic]
    public static partial class Vector
    {
        #region Widen/Narrow
<#
    foreach (Type type in WidenableTypes)
    {
        Type widenTarget = GetWidenTarget(type);
#>
        /// <summary>
        /// Widens a Vector{<#=type.Name#>} into two Vector{<#=widenTarget.Name#>}'s.
        /// <param name="source">The source vector whose elements are widened into the outputs.</param>
        /// <param name="low">The first output vector, whose elements will contain the widened elements from lower indices in the source vector.</param>
        /// <param name="high">The second output vector, whose elements will contain the widened elements from higher indices in the source vector.</param>
        /// </summary>
<#
        if (nonClsCompliantTypes.Contains(type) || nonClsCompliantTypes.Contains(widenTarget))
        {
#>
        [CLSCompliant(false)]
<#
        }
#>
        [Intrinsic]
        public static unsafe void Widen(Vector<<#=typeAliases[type]#>> source, out Vector<<#=typeAliases[widenTarget]#>> low, out Vector<<#=typeAliases[widenTarget]#>> high)
        {
            int elements = Vector<<#=typeAliases[type]#>>.Count;
            <#=typeAliases[widenTarget]#>* lowPtr = stackalloc <#=typeAliases[widenTarget]#>[elements / 2];
            for (int i = 0; i < elements / 2; i++)
            {
                lowPtr[i] = (<#=typeAliases[widenTarget]#>)source[i];
            }
            <#=typeAliases[widenTarget]#>* highPtr = stackalloc <#=typeAliases[widenTarget]#>[elements / 2];
            for (int i = 0; i < elements / 2; i++)
            {
                highPtr[i] = (<#=typeAliases[widenTarget]#>)source[i + (elements / 2)];
            }

            low = new Vector<<#=typeAliases[widenTarget]#>>(lowPtr);
            high = new Vector<<#=typeAliases[widenTarget]#>>(highPtr);
        }

<#
    }

    foreach (Type narrowSource in NarrowableTypes)
    {
        Type narrowTarget = GetNarrowTarget(narrowSource);
#>
        /// <summary>
        /// Narrows two Vector{<#=narrowSource.Name#>}'s into one Vector{<#=narrowTarget.Name#>}.
        /// <param name="low">The first source vector, whose elements become the lower-index elements of the return value.</param>
        /// <param name="high">The second source vector, whose elements become the higher-index elements of the return value.</param>
        /// <returns>A Vector{<#=narrowTarget.Name#>} containing elements narrowed from the source vectors.</returns>
        /// </summary>
<#
        if (nonClsCompliantTypes.Contains(narrowSource) || nonClsCompliantTypes.Contains(narrowTarget))
        {
#>
        [CLSCompliant(false)]
<#
        }
#>
        [Intrinsic]
        public static unsafe Vector<<#=typeAliases[narrowTarget]#>> Narrow(Vector<<#=typeAliases[narrowSource]#>> low, Vector<<#=typeAliases[narrowSource]#>> high)
        {
            unchecked
            {
                int elements = Vector<<#=typeAliases[narrowTarget]#>>.Count;
                <#=typeAliases[narrowTarget]#>* retPtr = stackalloc <#=typeAliases[narrowTarget]#>[elements];
                for (int i = 0; i < elements / 2; i++)
                {
                    retPtr[i] = (<#=typeAliases[narrowTarget]#>)low[i];
                }
                for (int i = 0; i < elements / 2; i++)
                {
                    retPtr[i + (elements / 2)] = (<#=typeAliases[narrowTarget]#>)high[i];
                }

                return new Vector<<#=typeAliases[narrowTarget]#>>(retPtr);
            }
        }

<#
    }
#>
        #endregion Widen/Narrow

        #region Same-Size Conversion
<#
    foreach (var pair in SameSizeConversionPairs)
    {
#>
        /// <summary>
        /// Converts a Vector{<#=pair.Key.Name#>} to a Vector{<#=pair.Value.Name#>}.
        /// </summary>
        /// <param name="value">The source vector.</param>
        /// <returns>The converted vector.</returns>
<#
        if (nonClsCompliantTypes.Contains(pair.Key) || nonClsCompliantTypes.Contains(pair.Value))
        {
#>
        [CLSCompliant(false)]
<#
        }
#>
        [Intrinsic]
        public static unsafe Vector<<#=typeAliases[pair.Value]#>> ConvertTo<#=pair.Value.Name#>(Vector<<#=typeAliases[pair.Key]#>> value)
        {
            unchecked
            {
                int elements = Vector<<#=typeAliases[pair.Value]#>>.Count;
                <#=typeAliases[pair.Value]#>* retPtr = stackalloc <#=typeAliases[pair.Value]#>[elements];
                for (int i = 0; i < elements; i++)
                {
                    retPtr[i] = (<#=typeAliases[pair.Value]#>)value[i];
                }

                return new Vector<<#=typeAliases[pair.Value]#>>(retPtr);
            }
        }

<#
    }
#>
        #endregion Same-Size Conversion

        #region Throw Helpers
        [DoesNotReturn]
        internal static void ThrowInsufficientNumberOfElementsException(int requiredElementCount)
        {
            throw new IndexOutOfRangeException(SR.Format(SR.Arg_InsufficientNumberOfElements, requiredElementCount, "values"));
        }
        #endregion
    }
}
