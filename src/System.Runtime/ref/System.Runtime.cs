// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.
// ------------------------------------------------------------------------------
// Changes to this file must follow the http://aka.ms/api-review process.
// ------------------------------------------------------------------------------


namespace System
{
    /// <summary>
    /// Encapsulates a method that has no parameters and does not return a value.
    /// </summary>
    public delegate void Action();
    /// <summary>
    /// Encapsulates a method that has a single parameter and does not return a value.To browse the
    /// .NET Framework source code for this type, see the Reference Source.
    /// </summary>
    /// <param name="obj">The parameter of the method that this delegate encapsulates.</param>
    /// <typeparam name="T">The type of the parameter of the method that this delegate encapsulates.</typeparam>
    public delegate void Action<in T>(T obj);
    /// <summary>
    /// Encapsulates a method that has 10 parameters and does not return a value.
    /// </summary>
    /// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
    /// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates.</typeparam>
    public delegate void Action<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10);
    /// <summary>
    /// Encapsulates a method that has 11 parameters and does not return a value.
    /// </summary>
    /// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
    /// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates.</typeparam>
    public delegate void Action<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11);
    /// <summary>
    /// Encapsulates a method that has 12 parameters and does not return a value.
    /// </summary>
    /// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg12">The twelfth parameter of the method that this delegate encapsulates.</param>
    /// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T12">The type of the twelfth parameter of the method that this delegate encapsulates.</typeparam>
    public delegate void Action<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, in T12>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12);
    /// <summary>
    /// Encapsulates a method that has 13 parameters and does not return a value.
    /// </summary>
    /// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg12">The twelfth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg13">The thirteenth parameter of the method that this delegate encapsulates.</param>
    /// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T12">The type of the twelfth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T13">The type of the thirteenth parameter of the method that this delegate encapsulates.</typeparam>
    public delegate void Action<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, in T12, in T13>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13);
    /// <summary>
    /// Encapsulates a method that has 14 parameters and does not return a value.
    /// </summary>
    /// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg12">The twelfth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg13">The thirteenth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg14">The fourteenth parameter of the method that this delegate encapsulates.</param>
    /// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T12">The type of the twelfth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T13">The type of the thirteenth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T14">The type of the fourteenth parameter of the method that this delegate encapsulates.</typeparam>
    public delegate void Action<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, in T12, in T13, in T14>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14);
    /// <summary>
    /// Encapsulates a method that has 15 parameters and does not return a value.
    /// </summary>
    /// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg12">The twelfth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg13">The thirteenth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg14">The fourteenth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg15">The fifteenth parameter of the method that this delegate encapsulates.</param>
    /// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T12">The type of the twelfth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T13">The type of the thirteenth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T14">The type of the fourteenth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T15">The type of the fifteenth parameter of the method that this delegate encapsulates.</typeparam>
    public delegate void Action<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, in T12, in T13, in T14, in T15>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15);
    /// <summary>
    /// Encapsulates a method that has 16 parameters and does not return a value.
    /// </summary>
    /// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg12">The twelfth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg13">The thirteenth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg14">The fourteenth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg15">The fifteenth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg16">The sixteenth parameter of the method that this delegate encapsulates.</param>
    /// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T12">The type of the twelfth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T13">The type of the thirteenth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T14">The type of the fourteenth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T15">The type of the fifteenth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T16">The type of the sixteenth parameter of the method that this delegate encapsulates.</typeparam>
    public delegate void Action<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, in T12, in T13, in T14, in T15, in T16>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16);
    /// <summary>
    /// Encapsulates a method that has two parameters and does not return a value.
    /// </summary>
    /// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
    /// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
    public delegate void Action<in T1, in T2>(T1 arg1, T2 arg2);
    /// <summary>
    /// Encapsulates a method that has three parameters and does not return a value.
    /// </summary>
    /// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
    /// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
    public delegate void Action<in T1, in T2, in T3>(T1 arg1, T2 arg2, T3 arg3);
    /// <summary>
    /// Encapsulates a method that has four parameters and does not return a value.
    /// </summary>
    /// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
    /// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
    public delegate void Action<in T1, in T2, in T3, in T4>(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    /// <summary>
    /// Encapsulates a method that has five parameters and does not return a value.
    /// </summary>
    /// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
    /// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
    public delegate void Action<in T1, in T2, in T3, in T4, in T5>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    /// <summary>
    /// Encapsulates a method that has six parameters and does not return a value.
    /// </summary>
    /// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
    /// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
    public delegate void Action<in T1, in T2, in T3, in T4, in T5, in T6>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    /// <summary>
    /// Encapsulates a method that has seven parameters and does not return a value.
    /// </summary>
    /// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
    /// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
    public delegate void Action<in T1, in T2, in T3, in T4, in T5, in T6, in T7>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    /// <summary>
    /// Encapsulates a method that has eight parameters and does not return a value.
    /// </summary>
    /// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
    /// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
    public delegate void Action<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    /// <summary>
    /// Encapsulates a method that has nine parameters and does not return a value.
    /// </summary>
    /// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
    /// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
    public delegate void Action<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
    /// <summary>
    /// Contains methods to create types of objects locally or remotely, or obtain references to existing
    /// remote objects. This class cannot be inherited.
    /// </summary>
    public static partial class Activator
    {
        /// <summary>
        /// Creates an instance of the specified type using that type's default constructor.
        /// </summary>
        /// <param name="type">The type of object to create.</param>
        /// <returns>
        /// A reference to the newly created object.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type" /> is null.</exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="type" /> is not a RuntimeType. -or-<paramref name="type" /> is an open generic
        /// type (that is, the <see cref="Type.ContainsGenericParameters" /> property returns
        /// true).
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <paramref name="type" /> cannot be a <see cref="Reflection.Emit.TypeBuilder" />.-or-
        /// Creation of <see cref="TypedReference" />, <see cref="ArgIterator" />, <see cref="Void" />,
        /// and <see cref="RuntimeArgumentHandle" /> types, or arrays
        /// of those types, is not supported.-or-The assembly that contains <paramref name="type" /> is
        /// a dynamic assembly that was created with <see cref="Reflection.Emit.AssemblyBuilderAccess.Save" />.
        /// </exception>
        /// <exception cref="Reflection.TargetInvocationException">
        /// The constructor being called throws an exception.
        /// </exception>
        /// <exception cref="MethodAccessException">
        /// In the .NET for Windows Store apps or the Portable Class Library, catch the base class exception,
        /// <see cref="MemberAccessException" />, instead.The caller does not have permission
        /// to call this constructor.
        /// </exception>
        /// <exception cref="MemberAccessException">
        /// Cannot create an instance of an abstract class, or this member was invoked with a late-binding
        /// mechanism.
        /// </exception>
        /// <exception cref="Runtime.InteropServices.InvalidComObjectException">
        /// The COM type was not obtained through <see cref="Overload:System.Type.GetTypeFromProgID" />
        /// or <see cref="Overload:System.Type.GetTypeFromCLSID" />.
        /// </exception>
        /// <exception cref="MissingMethodException">
        /// In the .NET for Windows Store apps or the Portable Class Library, catch the base class exception,
        /// <see cref="MissingMemberException" />, instead.No matching public constructor was
        /// found.
        /// </exception>
        /// <exception cref="Runtime.InteropServices.COMException">
        /// <paramref name="type" /> is a COM object but the class identifier used to obtain the type
        /// is invalid, or the identified class is not registered.
        /// </exception>
        /// <exception cref="TypeLoadException"><paramref name="type" /> is not a valid type.</exception>
        public static object CreateInstance(System.Type type) { return default(object); }
        /// <summary>
        /// Creates an instance of the specified type using that type's default constructor.
        /// </summary>
        /// <param name="type">The type of object to create.</param>
        /// <param name="nonPublic">
        /// true if a public or nonpublic default constructor can match; false if only a public default
        /// constructor can match.
        /// </param>
        /// <returns>
        /// A reference to the newly created object.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type" /> is null.</exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="type" /> is not a RuntimeType. -or-<paramref name="type" /> is an open generic
        /// type (that is, the <see cref="Type.ContainsGenericParameters" /> property returns
        /// true).
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <paramref name="type" /> cannot be a <see cref="Reflection.Emit.TypeBuilder" />.-or-
        /// Creation of <see cref="TypedReference" />, <see cref="ArgIterator" />, <see cref="Void" />,
        /// and <see cref="RuntimeArgumentHandle" /> types, or arrays
        /// of those types, is not supported. -or-The assembly that contains <paramref name="type" />
        /// is a dynamic assembly that was created with <see cref="Reflection.Emit.AssemblyBuilderAccess.Save" />.
        /// </exception>
        /// <exception cref="Reflection.TargetInvocationException">
        /// The constructor being called throws an exception.
        /// </exception>
        /// <exception cref="MethodAccessException">
        /// The caller does not have permission to call this constructor.
        /// </exception>
        /// <exception cref="MemberAccessException">
        /// Cannot create an instance of an abstract class, or this member was invoked with a late-binding
        /// mechanism.
        /// </exception>
        /// <exception cref="Runtime.InteropServices.InvalidComObjectException">
        /// The COM type was not obtained through <see cref="Overload:System.Type.GetTypeFromProgID" />
        /// or <see cref="Overload:System.Type.GetTypeFromCLSID" />.
        /// </exception>
        /// <exception cref="MissingMethodException">No matching public constructor was found.</exception>
        /// <exception cref="Runtime.InteropServices.COMException">
        /// <paramref name="type" /> is a COM object but the class identifier used to obtain the type
        /// is invalid, or the identified class is not registered.
        /// </exception>
        /// <exception cref="TypeLoadException"><paramref name="type" /> is not a valid type.</exception>
        public static object CreateInstance(System.Type type, System.Boolean nonPublic) { return default(object); }
        /// <summary>
        /// Creates an instance of the specified type using the constructor that best matches the specified
        /// parameters.
        /// </summary>
        /// <param name="type">The type of object to create.</param>
        /// <param name="args">
        /// An array of arguments that match in number, order, and type the parameters of the constructor
        /// to invoke. If <paramref name="args" /> is an empty array or null, the constructor that takes
        /// no parameters (the default constructor) is invoked.
        /// </param>
        /// <returns>
        /// A reference to the newly created object.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="type" /> is null.</exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="type" /> is not a RuntimeType. -or-<paramref name="type" /> is an open generic
        /// type (that is, the <see cref="Type.ContainsGenericParameters" /> property returns
        /// true).
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <paramref name="type" /> cannot be a <see cref="Reflection.Emit.TypeBuilder" />.-or-
        /// Creation of <see cref="TypedReference" />, <see cref="ArgIterator" />, <see cref="Void" />,
        /// and <see cref="RuntimeArgumentHandle" /> types, or arrays
        /// of those types, is not supported. -or-The assembly that contains <paramref name="type" />
        /// is a dynamic assembly that was created with <see cref="Reflection.Emit.AssemblyBuilderAccess.Save" />.
        /// -or-The constructor that best matches <paramref name="args" /> has varargs arguments.
        /// </exception>
        /// <exception cref="Reflection.TargetInvocationException">
        /// The constructor being called throws an exception.
        /// </exception>
        /// <exception cref="MethodAccessException">
        /// In the .NET for Windows Store apps or the Portable Class Library, catch the base class exception,
        /// <see cref="MemberAccessException" />, instead.The caller does not have permission
        /// to call this constructor.
        /// </exception>
        /// <exception cref="MemberAccessException">
        /// Cannot create an instance of an abstract class, or this member was invoked with a late-binding
        /// mechanism.
        /// </exception>
        /// <exception cref="Runtime.InteropServices.InvalidComObjectException">
        /// The COM type was not obtained through <see cref="Overload:System.Type.GetTypeFromProgID" />
        /// or <see cref="Overload:System.Type.GetTypeFromCLSID" />.
        /// </exception>
        /// <exception cref="MissingMethodException">
        /// In the .NET for Windows Store apps or the Portable Class Library, catch the base class exception,
        /// <see cref="MissingMemberException" />, instead.No matching public constructor was
        /// found.
        /// </exception>
        /// <exception cref="Runtime.InteropServices.COMException">
        /// <paramref name="type" /> is a COM object but the class identifier used to obtain the type
        /// is invalid, or the identified class is not registered.
        /// </exception>
        /// <exception cref="TypeLoadException"><paramref name="type" /> is not a valid type.</exception>
        public static object CreateInstance(System.Type type, params object[] args) { return default(object); }
        /// <summary>
        /// Creates an instance of the type designated by the specified generic type parameter, using the
        /// parameterless constructor.
        /// </summary>
        /// <typeparam name="T">The type to create.</typeparam>
        /// <returns>
        /// A reference to the newly created object.
        /// </returns>
        /// <exception cref="MissingMethodException">
        /// In the .NET for Windows Store apps or the Portable Class Library, catch the base class exception,
        /// <see cref="MissingMemberException" />, instead.The type that is specified for <paramref name="T" />
        /// does not have a parameterless constructor.
        /// </exception>
        public static T CreateInstance<T>() { return default(T); }
    }
    /// <summary>
    /// The exception that is thrown when one of the arguments provided to a method is not valid.
    /// </summary>
    public partial class ArgumentException : System.Exception
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ArgumentException" /> class.
        /// </summary>
        public ArgumentException() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ArgumentException" /> class with a specified
        /// error message.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        public ArgumentException(string message) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ArgumentException" /> class with a specified
        /// error message and a reference to the inner exception that is the cause of this exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="innerException">
        /// The exception that is the cause of the current exception. If the <paramref name="innerException" />
        /// parameter is not a null reference, the current exception is raised in a catch block that
        /// handles the inner exception.
        /// </param>
        public ArgumentException(string message, System.Exception innerException) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ArgumentException" /> class with a specified
        /// error message and the name of the parameter that causes this exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="paramName">The name of the parameter that caused the current exception.</param>
        public ArgumentException(string message, string paramName) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ArgumentException" /> class with a specified
        /// error message, the parameter name, and a reference to the inner exception that is the cause
        /// of this exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="paramName">The name of the parameter that caused the current exception.</param>
        /// <param name="innerException">
        /// The exception that is the cause of the current exception. If the <paramref name="innerException" />
        /// parameter is not a null reference, the current exception is raised in a catch block that
        /// handles the inner exception.
        /// </param>
        public ArgumentException(string message, string paramName, System.Exception innerException) { }
        /// <summary>
        /// Gets the error message and the parameter name, or only the error message if no parameter name
        /// is set.
        /// </summary>
        /// <returns>
        /// A text string describing the details of the exception. The value of this property takes one
        /// of two forms: Condition Value The <paramref name="paramName" /> is a null reference (Nothing
        /// in Visual Basic) or of zero length. The <paramref name="message" /> string passed to the constructor.
        /// The <paramref name="paramName" /> is not null reference (Nothing in Visual Basic) and it has
        /// a length greater than zero. The <paramref name="message" /> string appended with the name
        /// of the invalid parameter.
        /// </returns>
        public override string Message { get { return default(string); } }
        /// <summary>
        /// Gets the name of the parameter that causes this exception.
        /// </summary>
        /// <returns>
        /// The parameter name.
        /// </returns>
        public virtual string ParamName { get { return default(string); } }
    }
    /// <summary>
    /// The exception that is thrown when a null reference (Nothing in Visual Basic) is passed to a
    /// method that does not accept it as a valid argument.
    /// </summary>
    public partial class ArgumentNullException : System.ArgumentException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ArgumentNullException" /> class.
        /// </summary>
        public ArgumentNullException() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ArgumentNullException" /> class with
        /// the name of the parameter that causes this exception.
        /// </summary>
        /// <param name="paramName">The name of the parameter that caused the exception.</param>
        public ArgumentNullException(string paramName) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ArgumentNullException" /> class with
        /// a specified error message and the exception that is the cause of this exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for this exception.</param>
        /// <param name="innerException">
        /// The exception that is the cause of the current exception, or a null reference (Nothing in Visual
        /// Basic) if no inner exception is specified.
        /// </param>
        public ArgumentNullException(string message, System.Exception innerException) { }
        /// <summary>
        /// Initializes an instance of the <see cref="ArgumentNullException" /> class with a
        /// specified error message and the name of the parameter that causes this exception.
        /// </summary>
        /// <param name="paramName">The name of the parameter that caused the exception.</param>
        /// <param name="message">A message that describes the error.</param>
        public ArgumentNullException(string paramName, string message) { }
    }
    /// <summary>
    /// The exception that is thrown when the value of an argument is outside the allowable range of
    /// values as defined by the invoked method.
    /// </summary>
    public partial class ArgumentOutOfRangeException : System.ArgumentException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ArgumentOutOfRangeException" /> class.
        /// </summary>
        public ArgumentOutOfRangeException() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ArgumentOutOfRangeException" /> class
        /// with the name of the parameter that causes this exception.
        /// </summary>
        /// <param name="paramName">The name of the parameter that causes this exception.</param>
        public ArgumentOutOfRangeException(string paramName) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ArgumentOutOfRangeException" /> class
        /// with a specified error message and the exception that is the cause of this exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for this exception.</param>
        /// <param name="innerException">
        /// The exception that is the cause of the current exception, or a null reference (Nothing in Visual
        /// Basic) if no inner exception is specified.
        /// </param>
        public ArgumentOutOfRangeException(string message, System.Exception innerException) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ArgumentOutOfRangeException" /> class
        /// with the parameter name, the value of the argument, and a specified error message.
        /// </summary>
        /// <param name="paramName">The name of the parameter that caused the exception.</param>
        /// <param name="actualValue">The value of the argument that causes this exception.</param>
        /// <param name="message">The message that describes the error.</param>
        public ArgumentOutOfRangeException(string paramName, object actualValue, string message) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ArgumentOutOfRangeException" /> class
        /// with the name of the parameter that causes this exception and a specified error message.
        /// </summary>
        /// <param name="paramName">The name of the parameter that caused the exception.</param>
        /// <param name="message">The message that describes the error.</param>
        public ArgumentOutOfRangeException(string paramName, string message) { }
        /// <summary>
        /// Gets the argument value that causes this exception.
        /// </summary>
        /// <returns>
        /// An Object that contains the value of the parameter that caused the current <see cref="Exception" />.
        /// </returns>
        public virtual object ActualValue { get { return default(object); } }
        /// <summary>
        /// Gets the error message and the string representation of the invalid argument value, or only
        /// the error message if the argument value is null.
        /// </summary>
        /// <returns>
        /// The text message for this exception. The value of this property takes one of two forms, as
        /// follows.Condition Value The <paramref name="actualValue" /> is null. The <paramref name="message" />
        /// string passed to the constructor. The <paramref name="actualValue" /> is not null. The
        /// <paramref name="message" /> string appended with the string representation of the invalid
        /// argument value.
        /// </returns>
        public override string Message { get { return default(string); } }
    }
    /// <summary>
    /// The exception that is thrown for errors in an arithmetic, casting, or conversion operation.
    /// </summary>
    public partial class ArithmeticException : System.Exception
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ArithmeticException" /> class.
        /// </summary>
        public ArithmeticException() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ArithmeticException" /> class with a
        /// specified error message.
        /// </summary>
        /// <param name="message">A <see cref="String" /> that describes the error.</param>
        public ArithmeticException(string message) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ArithmeticException" /> class with a
        /// specified error message and a reference to the inner exception that is the cause of this exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="innerException">
        /// The exception that is the cause of the current exception. If the <paramref name="innerException" />
        /// parameter is not a null reference, the current exception is raised in a catch block that
        /// handles the inner exception.
        /// </param>
        public ArithmeticException(string message, System.Exception innerException) { }
    }
    /// <summary>
    /// Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving
    /// as the base class for all arrays in the common language runtime.To browse the .NET Framework source
    /// code for this type, see the Reference Source.
    /// </summary>
    public abstract partial class Array : System.Collections.ICollection, System.Collections.IEnumerable, System.Collections.IList, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable
    {
        internal Array() { }
        /// <summary>
        /// Gets the total number of elements in all the dimensions of the <see cref="Array" />.
        /// </summary>
        /// <returns>
        /// The total number of elements in all the dimensions of the <see cref="Array" />; zero
        /// if there are no elements in the array.
        /// </returns>
        /// <exception cref="OverflowException">
        /// The array is multidimensional and contains more than <see cref="Int32.MaxValue" />
        /// elements.
        /// </exception>
        public int Length { get { return default(int); } }
        /// <summary>
        /// Gets the rank (number of dimensions) of the <see cref="Array" />. For example, a
        /// one-dimensional array returns 1, a two-dimensional array returns 2, and so on.
        /// </summary>
        /// <returns>
        /// The rank (number of dimensions) of the <see cref="Array" />.
        /// </returns>
        public int Rank { get { return default(int); } }
        int System.Collections.ICollection.Count { get { return default(int); } }
        bool System.Collections.ICollection.IsSynchronized { get { return default(bool); } }
        object System.Collections.ICollection.SyncRoot { get { return default(object); } }
        bool System.Collections.IList.IsFixedSize { get { return default(bool); } }
        bool System.Collections.IList.IsReadOnly { get { return default(bool); } }
        object System.Collections.IList.this[int index] { get { return default(object); } set { } }
        /// <summary>
        /// Searches a range of elements in a one-dimensional sorted array for a value, using the
        /// <see cref="IComparable" /> interface implemented by each element of the array and by the
        /// specified value.
        /// </summary>
        /// <param name="array">The sorted one-dimensional <see cref="Array" /> to search.</param>
        /// <param name="index">The starting index of the range to search.</param>
        /// <param name="length">The length of the range to search.</param>
        /// <param name="value">The object to search for.</param>
        /// <returns>
        /// The index of the specified <paramref name="value" /> in the specified <paramref name="array" />,
        /// if <paramref name="value" /> is found; otherwise, a negative number. If <paramref name="value" />
        /// is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />,
        /// the negative number returned is the bitwise complement of the index of the
        /// first element that is larger than <paramref name="value" />. If <paramref name="value" />
        /// is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />,
        /// the negative number returned is the bitwise complement of (the index of the last element
        /// plus 1). If this method is called with a non-sorted <paramref name="array" />, the return
        /// value can be incorrect and a negative number could be returned, even if <paramref name="value" />
        /// is present in <paramref name="array" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="array" /> is null.</exception>
        /// <exception cref="RankException"><paramref name="array" /> is multidimensional.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than the lower bound of <paramref name="array" />.-or-
        /// <paramref name="length" /> is less than zero.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in
        /// <paramref name="array" />.-or-<paramref name="value" /> is of a type that is not compatible with the
        /// elements of <paramref name="array" />.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// <paramref name="value" /> does not implement the <see cref="IComparable" /> interface,
        /// and the search encounters an element that does not implement the <see cref="IComparable" />
        /// interface.
        /// </exception>
        public static int BinarySearch(System.Array array, int index, int length, object value) { return default(int); }
        /// <summary>
        /// Searches a range of elements in a one-dimensional sorted array for a value, using the specified
        /// <see cref="Collections.IComparer" /> interface.
        /// </summary>
        /// <param name="array">The sorted one-dimensional <see cref="Array" /> to search.</param>
        /// <param name="index">The starting index of the range to search.</param>
        /// <param name="length">The length of the range to search.</param>
        /// <param name="value">The object to search for.</param>
        /// <param name="comparer">
        /// The <see cref="Collections.IComparer" /> implementation to use when comparing elements.-or-
        /// null to use the <see cref="IComparable" /> implementation of each element.
        /// </param>
        /// <returns>
        /// The index of the specified <paramref name="value" /> in the specified <paramref name="array" />,
        /// if <paramref name="value" /> is found; otherwise, a negative number. If <paramref name="value" />
        /// is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />,
        /// the negative number returned is the bitwise complement of the index of the
        /// first element that is larger than <paramref name="value" />. If <paramref name="value" />
        /// is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />,
        /// the negative number returned is the bitwise complement of (the index of the last element
        /// plus 1). If this method is called with a non-sorted <paramref name="array" />, the return
        /// value can be incorrect and a negative number could be returned, even if <paramref name="value" />
        /// is present in <paramref name="array" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="array" /> is null.</exception>
        /// <exception cref="RankException"><paramref name="array" /> is multidimensional.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than the lower bound of <paramref name="array" />.-or-
        /// <paramref name="length" /> is less than zero.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in
        /// <paramref name="array" />.-or-<paramref name="comparer" /> is null, and <paramref name="value" /> is
        /// of a type that is not compatible with the elements of <paramref name="array" />.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// <paramref name="comparer" /> is null, <paramref name="value" /> does not implement the
        /// <see cref="IComparable" /> interface, and the search encounters an element that does not
        /// implement the <see cref="IComparable" /> interface.
        /// </exception>
        public static int BinarySearch(System.Array array, int index, int length, object value, System.Collections.IComparer comparer) { return default(int); }
        /// <summary>
        /// Searches an entire one-dimensional sorted array for a specific element, using the
        /// <see cref="IComparable" /> interface implemented by each element of the array and by the specified object.
        /// </summary>
        /// <param name="array">The sorted one-dimensional <see cref="Array" /> to search.</param>
        /// <param name="value">The object to search for.</param>
        /// <returns>
        /// The index of the specified <paramref name="value" /> in the specified <paramref name="array" />,
        /// if <paramref name="value" /> is found; otherwise, a negative number. If <paramref name="value" />
        /// is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />,
        /// the negative number returned is the bitwise complement of the index of the
        /// first element that is larger than <paramref name="value" />. If <paramref name="value" />
        /// is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />,
        /// the negative number returned is the bitwise complement of (the index of the last element
        /// plus 1). If this method is called with a non-sorted <paramref name="array" />, the return
        /// value can be incorrect and a negative number could be returned, even if <paramref name="value" />
        /// is present in <paramref name="array" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="array" /> is null.</exception>
        /// <exception cref="RankException"><paramref name="array" /> is multidimensional.</exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="value" /> is of a type that is not compatible with the elements of <paramref name="array" />.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// <paramref name="value" /> does not implement the <see cref="IComparable" /> interface,
        /// and the search encounters an element that does not implement the <see cref="IComparable" />
        /// interface.
        /// </exception>
        public static int BinarySearch(System.Array array, object value) { return default(int); }
        /// <summary>
        /// Searches an entire one-dimensional sorted array for a value using the specified
        /// <see cref="Collections.IComparer" /> interface.
        /// </summary>
        /// <param name="array">The sorted one-dimensional <see cref="Array" /> to search.</param>
        /// <param name="value">The object to search for.</param>
        /// <param name="comparer">
        /// The <see cref="Collections.IComparer" /> implementation to use when comparing elements.-or-
        /// null to use the <see cref="IComparable" /> implementation of each element.
        /// </param>
        /// <returns>
        /// The index of the specified <paramref name="value" /> in the specified <paramref name="array" />,
        /// if <paramref name="value" /> is found; otherwise, a negative number. If <paramref name="value" />
        /// is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />,
        /// the negative number returned is the bitwise complement of the index of the
        /// first element that is larger than <paramref name="value" />. If <paramref name="value" />
        /// is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />,
        /// the negative number returned is the bitwise complement of (the index of the last element
        /// plus 1). If this method is called with a non-sorted <paramref name="array" />, the return
        /// value can be incorrect and a negative number could be returned, even if <paramref name="value" />
        /// is present in <paramref name="array" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="array" /> is null.</exception>
        /// <exception cref="RankException"><paramref name="array" /> is multidimensional.</exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="comparer" /> is null, and <paramref name="value" /> is of a type that is not
        /// compatible with the elements of <paramref name="array" />.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// <paramref name="comparer" /> is null, <paramref name="value" /> does not implement the
        /// <see cref="IComparable" /> interface, and the search encounters an element that does not
        /// implement the <see cref="IComparable" /> interface.
        /// </exception>
        public static int BinarySearch(System.Array array, object value, System.Collections.IComparer comparer) { return default(int); }
        /// <summary>
        /// Searches an entire one-dimensional sorted array for a specific element, using the
        /// <see cref="IComparable`1" /> generic interface implemented by each element of the <see cref="Array" /> and
        /// by the specified object.
        /// </summary>
        /// <param name="array">The sorted one-dimensional, zero-based <see cref="Array" /> to search.</param>
        /// <param name="value">The object to search for.</param>
        /// <typeparam name="T">The type of the elements of the array.</typeparam>
        /// <returns>
        /// The index of the specified <paramref name="value" /> in the specified <paramref name="array" />,
        /// if <paramref name="value" /> is found; otherwise, a negative number. If <paramref name="value" />
        /// is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />,
        /// the negative number returned is the bitwise complement of the index of the
        /// first element that is larger than <paramref name="value" />. If <paramref name="value" />
        /// is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />,
        /// the negative number returned is the bitwise complement of (the index of the last element
        /// plus 1). If this method is called with a non-sorted <paramref name="array" />, the return
        /// value can be incorrect and a negative number could be returned, even if <paramref name="value" />
        /// is present in <paramref name="array" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="array" /> is null.</exception>
        /// <exception cref="InvalidOperationException">
        /// <paramref name="T" /> does not implement the <see cref="IComparable`1" /> generic
        /// interface.
        /// </exception>
        public static int BinarySearch<T>(T[] array, T value) { return default(int); }
        /// <summary>
        /// Searches an entire one-dimensional sorted array for a value using the specified
        /// <see cref="Collections.Generic.IComparer`1" /> generic interface.
        /// </summary>
        /// <param name="array">The sorted one-dimensional, zero-based <see cref="Array" /> to search.</param>
        /// <param name="value">The object to search for.</param>
        /// <param name="comparer">
        /// The <see cref="Collections.Generic.IComparer`1" /> implementation to use when comparing
        /// elements.-or- null to use the <see cref="IComparable`1" /> implementation of each
        /// element.
        /// </param>
        /// <typeparam name="T">The type of the elements of the array.</typeparam>
        /// <returns>
        /// The index of the specified <paramref name="value" /> in the specified <paramref name="array" />,
        /// if <paramref name="value" /> is found; otherwise, a negative number. If <paramref name="value" />
        /// is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />,
        /// the negative number returned is the bitwise complement of the index of the
        /// first element that is larger than <paramref name="value" />. If <paramref name="value" />
        /// is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />,
        /// the negative number returned is the bitwise complement of (the index of the last element
        /// plus 1). If this method is called with a non-sorted <paramref name="array" />, the return
        /// value can be incorrect and a negative number could be returned, even if <paramref name="value" />
        /// is present in <paramref name="array" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="array" /> is null.</exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="comparer" /> is null, and <paramref name="value" /> is of a type that is not
        /// compatible with the elements of <paramref name="array" />.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// <paramref name="comparer" /> is null, and <paramref name="T" /> does not implement the
        /// <see cref="IComparable`1" /> generic interface
        /// </exception>
        public static int BinarySearch<T>(T[] array, T value, System.Collections.Generic.IComparer<T> comparer) { return default(int); }
        /// <summary>
        /// Searches a range of elements in a one-dimensional sorted array for a value, using the
        /// <see cref="IComparable`1" /> generic interface implemented by each element of the <see cref="Array" />
        /// and by the specified value.
        /// </summary>
        /// <param name="array">The sorted one-dimensional, zero-based <see cref="Array" /> to search.</param>
        /// <param name="index">The starting index of the range to search.</param>
        /// <param name="length">The length of the range to search.</param>
        /// <param name="value">The object to search for.</param>
        /// <typeparam name="T">The type of the elements of the array.</typeparam>
        /// <returns>
        /// The index of the specified <paramref name="value" /> in the specified <paramref name="array" />,
        /// if <paramref name="value" /> is found; otherwise, a negative number. If <paramref name="value" />
        /// is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />,
        /// the negative number returned is the bitwise complement of the index of the
        /// first element that is larger than <paramref name="value" />. If <paramref name="value" />
        /// is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />,
        /// the negative number returned is the bitwise complement of (the index of the last element
        /// plus 1). If this method is called with a non-sorted <paramref name="array" />, the return
        /// value can be incorrect and a negative number could be returned, even if <paramref name="value" />
        /// is present in <paramref name="array" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="array" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than the lower bound of <paramref name="array" />.-or-
        /// <paramref name="length" /> is less than zero.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in
        /// <paramref name="array" />.-or-<paramref name="value" /> is of a type that is not compatible with the
        /// elements of <paramref name="array" />.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// <paramref name="T" /> does not implement the <see cref="IComparable`1" /> generic
        /// interface.
        /// </exception>
        public static int BinarySearch<T>(T[] array, int index, int length, T value) { return default(int); }
        /// <summary>
        /// Searches a range of elements in a one-dimensional sorted array for a value, using the specified
        /// <see cref="Collections.Generic.IComparer`1" /> generic interface.
        /// </summary>
        /// <param name="array">The sorted one-dimensional, zero-based <see cref="Array" /> to search.</param>
        /// <param name="index">The starting index of the range to search.</param>
        /// <param name="length">The length of the range to search.</param>
        /// <param name="value">The object to search for.</param>
        /// <param name="comparer">
        /// The <see cref="Collections.Generic.IComparer`1" /> implementation to use when comparing
        /// elements.-or- null to use the <see cref="IComparable`1" /> implementation of each
        /// element.
        /// </param>
        /// <typeparam name="T">The type of the elements of the array.</typeparam>
        /// <returns>
        /// The index of the specified <paramref name="value" /> in the specified <paramref name="array" />,
        /// if <paramref name="value" /> is found; otherwise, a negative number. If <paramref name="value" />
        /// is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />,
        /// the negative number returned is the bitwise complement of the index of the
        /// first element that is larger than <paramref name="value" />. If <paramref name="value" />
        /// is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />,
        /// the negative number returned is the bitwise complement of (the index of the last element
        /// plus 1). If this method is called with a non-sorted <paramref name="array" />, the return
        /// value can be incorrect and a negative number could be returned, even if <paramref name="value" />
        /// is present in <paramref name="array" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="array" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than the lower bound of <paramref name="array" />.-or-
        /// <paramref name="length" /> is less than zero.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in
        /// <paramref name="array" />.-or-<paramref name="comparer" /> is null, and <paramref name="value" /> is
        /// of a type that is not compatible with the elements of <paramref name="array" />.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// <paramref name="comparer" /> is null, and <paramref name="T" /> does not implement the
        /// <see cref="IComparable`1" /> generic interface.
        /// </exception>
        public static int BinarySearch<T>(T[] array, int index, int length, T value, System.Collections.Generic.IComparer<T> comparer) { return default(int); }
        /// <summary>
        /// Sets a range of elements in an array to the default value of each element type.
        /// </summary>
        /// <param name="array">The array whose elements need to be cleared.</param>
        /// <param name="index">The starting index of the range of elements to clear.</param>
        /// <param name="length">The number of elements to clear.</param>
        /// <exception cref="ArgumentNullException"><paramref name="array" /> is null.</exception>
        /// <exception cref="IndexOutOfRangeException">
        /// <paramref name="index" /> is less than the lower bound of <paramref name="array" />.-or-
        /// <paramref name="length" /> is less than zero.-or-The sum of <paramref name="index" /> and <paramref name="length" />
        /// is greater than the size of <paramref name="array" />.
        /// </exception>
        public static void Clear(System.Array array, int index, int length) { }
        /// <summary>
        /// Creates a shallow copy of the <see cref="Array" />.
        /// </summary>
        /// <returns>
        /// A shallow copy of the <see cref="Array" />.
        /// </returns>
        public object Clone() { return default(object); }
        /// <summary>
        /// Copies a range of elements from an <see cref="Array" /> starting at the specified
        /// source index and pastes them to another <see cref="Array" /> starting at the specified
        /// destination index.  Guarantees that all changes are undone if the copy does not succeed completely.
        /// </summary>
        /// <param name="sourceArray">The <see cref="Array" /> that contains the data to copy.</param>
        /// <param name="sourceIndex">
        /// A 32-bit integer that represents the index in the <paramref name="sourceArray" /> at which
        /// copying begins.
        /// </param>
        /// <param name="destinationArray">The <see cref="Array" /> that receives the data.</param>
        /// <param name="destinationIndex">
        /// A 32-bit integer that represents the index in the <paramref name="destinationArray" /> at
        /// which storing begins.
        /// </param>
        /// <param name="length">A 32-bit integer that represents the number of elements to copy.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="sourceArray" /> is null.-or-<paramref name="destinationArray" /> is null.
        /// </exception>
        /// <exception cref="RankException">
        /// <paramref name="sourceArray" /> and <paramref name="destinationArray" /> have different ranks.
        /// </exception>
        /// <exception cref="ArrayTypeMismatchException">
        /// The <paramref name="sourceArray" /> type is neither the same as nor derived from the
        /// <paramref name="destinationArray" /> type.
        /// </exception>
        /// <exception cref="InvalidCastException">
        /// At least one element in <paramref name="sourceArray" /> cannot be cast to the type of
        /// <paramref name="destinationArray" />.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="sourceIndex" /> is less than the lower bound of the first dimension of
        /// <paramref name="sourceArray" />.-or-<paramref name="destinationIndex" /> is less than the lower bound
        /// of the first dimension of <paramref name="destinationArray" />.-or-<paramref name="length" />
        /// is less than zero.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="length" /> is greater than the number of elements from <paramref name="sourceIndex" />
        /// to the end of <paramref name="sourceArray" />.-or-<paramref name="length" /> is greater
        /// than the number of elements from <paramref name="destinationIndex" /> to the end of <paramref name="destinationArray" />.
        /// </exception>
        public static void ConstrainedCopy(System.Array sourceArray, int sourceIndex, System.Array destinationArray, int destinationIndex, int length) { }
        /// <summary>
        /// Copies a range of elements from an <see cref="Array" /> starting at the first element
        /// and pastes them into another <see cref="Array" /> starting at the first element.
        /// The length is specified as a 32-bit integer.
        /// </summary>
        /// <param name="sourceArray">The <see cref="Array" /> that contains the data to copy.</param>
        /// <param name="destinationArray">The <see cref="Array" /> that receives the data.</param>
        /// <param name="length">A 32-bit integer that represents the number of elements to copy.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="sourceArray" /> is null.-or-<paramref name="destinationArray" /> is null.
        /// </exception>
        /// <exception cref="RankException">
        /// <paramref name="sourceArray" /> and <paramref name="destinationArray" /> have different ranks.
        /// </exception>
        /// <exception cref="ArrayTypeMismatchException">
        /// <paramref name="sourceArray" /> and <paramref name="destinationArray" /> are of incompatible
        /// types.
        /// </exception>
        /// <exception cref="InvalidCastException">
        /// At least one element in <paramref name="sourceArray" /> cannot be cast to the type of
        /// <paramref name="destinationArray" />.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="length" /> is less than zero.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="length" /> is greater than the number of elements in <paramref name="sourceArray" />.
        /// -or-<paramref name="length" /> is greater than the number of elements in <paramref name="destinationArray" />.
        /// </exception>
        public static void Copy(System.Array sourceArray, System.Array destinationArray, int length) { }
        /// <summary>
        /// Copies a range of elements from an <see cref="Array" /> starting at the specified
        /// source index and pastes them to another <see cref="Array" /> starting at the specified
        /// destination index. The length and the indexes are specified as 32-bit integers.
        /// </summary>
        /// <param name="sourceArray">The <see cref="Array" /> that contains the data to copy.</param>
        /// <param name="sourceIndex">
        /// A 32-bit integer that represents the index in the <paramref name="sourceArray" /> at which
        /// copying begins.
        /// </param>
        /// <param name="destinationArray">The <see cref="Array" /> that receives the data.</param>
        /// <param name="destinationIndex">
        /// A 32-bit integer that represents the index in the <paramref name="destinationArray" /> at
        /// which storing begins.
        /// </param>
        /// <param name="length">A 32-bit integer that represents the number of elements to copy.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="sourceArray" /> is null.-or-<paramref name="destinationArray" /> is null.
        /// </exception>
        /// <exception cref="RankException">
        /// <paramref name="sourceArray" /> and <paramref name="destinationArray" /> have different ranks.
        /// </exception>
        /// <exception cref="ArrayTypeMismatchException">
        /// <paramref name="sourceArray" /> and <paramref name="destinationArray" /> are of incompatible
        /// types.
        /// </exception>
        /// <exception cref="InvalidCastException">
        /// At least one element in <paramref name="sourceArray" /> cannot be cast to the type of
        /// <paramref name="destinationArray" />.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="sourceIndex" /> is less than the lower bound of the first dimension of
        /// <paramref name="sourceArray" />.-or-<paramref name="destinationIndex" /> is less than the lower bound
        /// of the first dimension of <paramref name="destinationArray" />.-or-<paramref name="length" />
        /// is less than zero.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="length" /> is greater than the number of elements from <paramref name="sourceIndex" />
        /// to the end of <paramref name="sourceArray" />.-or-<paramref name="length" /> is greater
        /// than the number of elements from <paramref name="destinationIndex" /> to the end of <paramref name="destinationArray" />.
        /// </exception>
        public static void Copy(System.Array sourceArray, int sourceIndex, System.Array destinationArray, int destinationIndex, int length) { }
        /// <summary>
        /// Copies all the elements of the current one-dimensional array to the specified one-dimensional
        /// array starting at the specified destination array index. The index is specified as a 32-bit integer.
        /// </summary>
        /// <param name="array">
        /// The one-dimensional array that is the destination of the elements copied from the current array.
        /// </param>
        /// <param name="index">
        /// A 32-bit integer that represents the index in <paramref name="array" /> at which copying begins.
        /// </param>
        /// <exception cref="ArgumentNullException"><paramref name="array" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than the lower bound of <paramref name="array" />.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="array" /> is multidimensional.-or-The number of elements in the source array
        /// is greater than the available number of elements from <paramref name="index" /> to the end
        /// of the destination <paramref name="array" />.
        /// </exception>
        /// <exception cref="ArrayTypeMismatchException">
        /// The type of the source <see cref="Array" /> cannot be cast automatically to the type
        /// of the destination <paramref name="array" />.
        /// </exception>
        /// <exception cref="RankException">The source array is multidimensional.</exception>
        /// <exception cref="InvalidCastException">
        /// At least one element in the source <see cref="Array" /> cannot be cast to the type
        /// of destination <paramref name="array" />.
        /// </exception>
        public void CopyTo(System.Array array, int index) { }
        /// <summary>
        /// Creates a one-dimensional <see cref="Array" /> of the specified <see cref="Type" />
        /// and length, with zero-based indexing.
        /// </summary>
        /// <param name="elementType">The <see cref="Type" /> of the <see cref="Array" /> to create.</param>
        /// <param name="length">The size of the <see cref="Array" /> to create.</param>
        /// <returns>
        /// A new one-dimensional <see cref="Array" /> of the specified <see cref="Type" />
        /// with the specified length, using zero-based indexing.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="elementType" /> is null.</exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="elementType" /> is not a valid <see cref="Type" />.
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <paramref name="elementType" /> is not supported. For example, <see cref="Void" />
        /// is not supported.-or-<paramref name="elementType" /> is an open generic type.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="length" /> is less than zero.
        /// </exception>
        public static System.Array CreateInstance(System.Type elementType, int length) { return default(System.Array); }
        /// <summary>
        /// Creates a multidimensional <see cref="Array" /> of the specified <see cref="Type" />
        /// and dimension lengths, with zero-based indexing. The dimension lengths are specified in
        /// an array of 32-bit integers.
        /// </summary>
        /// <param name="elementType">The <see cref="Type" /> of the <see cref="Array" /> to create.</param>
        /// <param name="lengths">
        /// An array of 32-bit integers that represent the size of each dimension of the <see cref="Array" />
        /// to create.
        /// </param>
        /// <returns>
        /// A new multidimensional <see cref="Array" /> of the specified <see cref="Type" />
        /// with the specified length for each dimension, using zero-based indexing.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="elementType" /> is null.-or-<paramref name="lengths" /> is null.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="elementType" /> is not a valid <see cref="Type" />.-or-The <paramref name="lengths" />
        /// array contains less than one element.
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <paramref name="elementType" /> is not supported. For example, <see cref="Void" />
        /// is not supported. -or-<paramref name="elementType" /> is an open generic type.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// Any value in <paramref name="lengths" /> is less than zero.
        /// </exception>
        public static System.Array CreateInstance(System.Type elementType, params int[] lengths) { return default(System.Array); }
        /// <summary>
        /// Creates a multidimensional <see cref="Array" /> of the specified <see cref="Type" />
        /// and dimension lengths, with the specified lower bounds.
        /// </summary>
        /// <param name="elementType">The <see cref="Type" /> of the <see cref="Array" /> to create.</param>
        /// <param name="lengths">
        /// A one-dimensional array that contains the size of each dimension of the <see cref="Array" />
        /// to create.
        /// </param>
        /// <param name="lowerBounds">
        /// A one-dimensional array that contains the lower bound (starting index) of each dimension of
        /// the <see cref="Array" /> to create.
        /// </param>
        /// <returns>
        /// A new multidimensional <see cref="Array" /> of the specified <see cref="Type" />
        /// with the specified length and lower bound for each dimension.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="elementType" /> is null.-or-<paramref name="lengths" /> is null.-or-
        /// <paramref name="lowerBounds" /> is null.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="elementType" /> is not a valid <see cref="Type" />.-or-The <paramref name="lengths" />
        /// array contains less than one element.-or-The <paramref name="lengths" />
        /// and <paramref name="lowerBounds" /> arrays do not contain the same number of elements.
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <paramref name="elementType" /> is not supported. For example, <see cref="Void" />
        /// is not supported. -or-<paramref name="elementType" /> is an open generic type.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// Any value in <paramref name="lengths" /> is less than zero.-or-Any value in <paramref name="lowerBounds" />
        /// is very large, such that the sum of a dimension's lower bound and length is greater than
        /// <see cref="Int32.MaxValue" />.
        /// </exception>
        public static System.Array CreateInstance(System.Type elementType, int[] lengths, int[] lowerBounds) { return default(System.Array); }
        /// <summary>
        /// Returns an empty array.
        /// </summary>
        /// <typeparam name="T">The type of the elements of the array.</typeparam>
        /// <returns>
        /// Returns an empty <see cref="Array" />.
        /// </returns>
        public static T[] Empty<T>() { return default(T[]); }
        /// <summary>
        /// Determines whether the specified array contains elements that match the conditions defined
        /// by the specified predicate.
        /// </summary>
        /// <param name="array">The one-dimensional, zero-based <see cref="Array" /> to search.</param>
        /// <param name="match">
        /// The <see cref="System.Predicate`1" /> that defines the conditions of the elements to search
        /// for.
        /// </param>
        /// <typeparam name="T">The type of the elements of the array.</typeparam>
        /// <returns>
        /// true if <paramref name="array" /> contains one or more elements that match the conditions
        /// defined by the specified predicate; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="array" /> is null.-or-<paramref name="match" /> is null.
        /// </exception>
        public static bool Exists<T>(T[] array, System.Predicate<T> match) { return default(bool); }
        /// <summary>
        /// Searches for an element that matches the conditions defined by the specified predicate, and
        /// returns the first occurrence within the entire <see cref="Array" />.
        /// </summary>
        /// <param name="array">The one-dimensional, zero-based array to search.</param>
        /// <param name="match">The predicate that defines the conditions of the element to search for.</param>
        /// <typeparam name="T">The type of the elements of the array.</typeparam>
        /// <returns>
        /// The first element that matches the conditions defined by the specified predicate, if found;
        /// otherwise, the default value for type <paramref name="T" />.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="array" /> is null.-or-<paramref name="match" /> is null.
        /// </exception>
        public static T Find<T>(T[] array, System.Predicate<T> match) { return default(T); }
        /// <summary>
        /// Retrieves all the elements that match the conditions defined by the specified predicate.
        /// </summary>
        /// <param name="array">The one-dimensional, zero-based <see cref="Array" /> to search.</param>
        /// <param name="match">
        /// The <see cref="System.Predicate`1" /> that defines the conditions of the elements to search
        /// for.
        /// </param>
        /// <typeparam name="T">The type of the elements of the array.</typeparam>
        /// <returns>
        /// An <see cref="Array" /> containing all the elements that match the conditions defined
        /// by the specified predicate, if found; otherwise, an empty <see cref="Array" />.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="array" /> is null.-or-<paramref name="match" /> is null.
        /// </exception>
        public static T[] FindAll<T>(T[] array, System.Predicate<T> match) { return default(T[]); }
        /// <summary>
        /// Searches for an element that matches the conditions defined by the specified predicate, and
        /// returns the zero-based index of the first occurrence within the range of elements in the <see cref="Array" />
        /// that starts at the specified index and contains the specified number
        /// of elements.
        /// </summary>
        /// <param name="array">The one-dimensional, zero-based <see cref="Array" /> to search.</param>
        /// <param name="startIndex">The zero-based starting index of the search.</param>
        /// <param name="count">The number of elements in the section to search.</param>
        /// <param name="match">
        /// The <see cref="System.Predicate`1" /> that defines the conditions of the element to search
        /// for.
        /// </param>
        /// <typeparam name="T">The type of the elements of the array.</typeparam>
        /// <returns>
        /// The zero-based index of the first occurrence of an element that matches the conditions defined
        /// by <paramref name="match" />, if found; otherwise, 1.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="array" /> is null.-or-<paramref name="match" /> is null.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.
        /// -or-<paramref name="count" /> is less than zero.-or-<paramref name="startIndex" /> and
        /// <paramref name="count" /> do not specify a valid section in <paramref name="array" />.
        /// </exception>
        public static int FindIndex<T>(T[] array, int startIndex, int count, System.Predicate<T> match) { return default(int); }
        /// <summary>
        /// Searches for an element that matches the conditions defined by the specified predicate, and
        /// returns the zero-based index of the first occurrence within the range of elements in the <see cref="Array" />
        /// that extends from the specified index to the last element.
        /// </summary>
        /// <param name="array">The one-dimensional, zero-based <see cref="Array" /> to search.</param>
        /// <param name="startIndex">The zero-based starting index of the search.</param>
        /// <param name="match">
        /// The <see cref="System.Predicate`1" /> that defines the conditions of the element to search
        /// for.
        /// </param>
        /// <typeparam name="T">The type of the elements of the array.</typeparam>
        /// <returns>
        /// The zero-based index of the first occurrence of an element that matches the conditions defined
        /// by <paramref name="match" />, if found; otherwise, 1.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="array" /> is null.-or-<paramref name="match" /> is null.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.
        /// </exception>
        public static int FindIndex<T>(T[] array, int startIndex, System.Predicate<T> match) { return default(int); }
        /// <summary>
        /// Searches for an element that matches the conditions defined by the specified predicate, and
        /// returns the zero-based index of the first occurrence within the entire <see cref="Array" />.
        /// </summary>
        /// <param name="array">The one-dimensional, zero-based <see cref="Array" /> to search.</param>
        /// <param name="match">
        /// The <see cref="System.Predicate`1" /> that defines the conditions of the element to search
        /// for.
        /// </param>
        /// <typeparam name="T">The type of the elements of the array.</typeparam>
        /// <returns>
        /// The zero-based index of the first occurrence of an element that matches the conditions defined
        /// by <paramref name="match" />, if found; otherwise, 1.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="array" /> is null.-or-<paramref name="match" /> is null.
        /// </exception>
        public static int FindIndex<T>(T[] array, System.Predicate<T> match) { return default(int); }
        /// <summary>
        /// Searches for an element that matches the conditions defined by the specified predicate, and
        /// returns the last occurrence within the entire <see cref="Array" />.
        /// </summary>
        /// <param name="array">The one-dimensional, zero-based <see cref="Array" /> to search.</param>
        /// <param name="match">
        /// The <see cref="System.Predicate`1" /> that defines the conditions of the element to search
        /// for.
        /// </param>
        /// <typeparam name="T">The type of the elements of the array.</typeparam>
        /// <returns>
        /// The last element that matches the conditions defined by the specified predicate, if found;
        /// otherwise, the default value for type <paramref name="T" />.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="array" /> is null.-or-<paramref name="match" /> is null.
        /// </exception>
        public static T FindLast<T>(T[] array, System.Predicate<T> match) { return default(T); }
        /// <summary>
        /// Searches for an element that matches the conditions defined by the specified predicate, and
        /// returns the zero-based index of the last occurrence within the range of elements in the <see cref="Array" />
        /// that contains the specified number of elements and ends at the specified
        /// index.
        /// </summary>
        /// <param name="array">The one-dimensional, zero-based <see cref="Array" /> to search.</param>
        /// <param name="startIndex">The zero-based starting index of the backward search.</param>
        /// <param name="count">The number of elements in the section to search.</param>
        /// <param name="match">
        /// The <see cref="System.Predicate`1" /> that defines the conditions of the element to search
        /// for.
        /// </param>
        /// <typeparam name="T">The type of the elements of the array.</typeparam>
        /// <returns>
        /// The zero-based index of the last occurrence of an element that matches the conditions defined
        /// by <paramref name="match" />, if found; otherwise, 1.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="array" /> is null.-or-<paramref name="match" /> is null.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.
        /// -or-<paramref name="count" /> is less than zero.-or-<paramref name="startIndex" /> and
        /// <paramref name="count" /> do not specify a valid section in <paramref name="array" />.
        /// </exception>
        public static int FindLastIndex<T>(T[] array, int startIndex, int count, System.Predicate<T> match) { return default(int); }
        /// <summary>
        /// Searches for an element that matches the conditions defined by the specified predicate, and
        /// returns the zero-based index of the last occurrence within the range of elements in the <see cref="Array" />
        /// that extends from the first element to the specified index.
        /// </summary>
        /// <param name="array">The one-dimensional, zero-based <see cref="Array" /> to search.</param>
        /// <param name="startIndex">The zero-based starting index of the backward search.</param>
        /// <param name="match">
        /// The <see cref="System.Predicate`1" /> that defines the conditions of the element to search
        /// for.
        /// </param>
        /// <typeparam name="T">The type of the elements of the array.</typeparam>
        /// <returns>
        /// The zero-based index of the last occurrence of an element that matches the conditions defined
        /// by <paramref name="match" />, if found; otherwise, 1.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="array" /> is null.-or-<paramref name="match" /> is null.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.
        /// </exception>
        public static int FindLastIndex<T>(T[] array, int startIndex, System.Predicate<T> match) { return default(int); }
        /// <summary>
        /// Searches for an element that matches the conditions defined by the specified predicate, and
        /// returns the zero-based index of the last occurrence within the entire <see cref="Array" />.
        /// </summary>
        /// <param name="array">The one-dimensional, zero-based <see cref="Array" /> to search.</param>
        /// <param name="match">
        /// The <see cref="System.Predicate`1" /> that defines the conditions of the element to search
        /// for.
        /// </param>
        /// <typeparam name="T">The type of the elements of the array.</typeparam>
        /// <returns>
        /// The zero-based index of the last occurrence of an element that matches the conditions defined
        /// by <paramref name="match" />, if found; otherwise, 1.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="array" /> is null.-or-<paramref name="match" /> is null.
        /// </exception>
        public static int FindLastIndex<T>(T[] array, System.Predicate<T> match) { return default(int); }
        /// <summary>
        /// Returns an <see cref="Collections.IEnumerator" /> for the <see cref="Array" />.
        /// </summary>
        /// <returns>
        /// An <see cref="Collections.IEnumerator" /> for the <see cref="Array" />.
        /// </returns>
        public System.Collections.IEnumerator GetEnumerator() { return default(System.Collections.IEnumerator); }
        /// <summary>
        /// Gets a 32-bit integer that represents the number of elements in the specified dimension of
        /// the <see cref="Array" />.
        /// </summary>
        /// <param name="dimension">
        /// A zero-based dimension of the <see cref="Array" /> whose length needs to be determined.
        /// </param>
        /// <returns>
        /// A 32-bit integer that represents the number of elements in the specified dimension.
        /// </returns>
        /// <exception cref="IndexOutOfRangeException">
        /// <paramref name="dimension" /> is less than zero.-or-<paramref name="dimension" /> is equal
        /// to or greater than <see cref="Rank" />.
        /// </exception>
        public int GetLength(int dimension) { return default(int); }
        /// <summary>
        /// Gets the index of the first element of the specified dimension in the array.
        /// </summary>
        /// <param name="dimension">A zero-based dimension of the array whose starting index needs to be determined.</param>
        /// <returns>
        /// The index of the first element of the specified dimension in the array.
        /// </returns>
        /// <exception cref="IndexOutOfRangeException">
        /// <paramref name="dimension" /> is less than zero.-or-<paramref name="dimension" /> is equal
        /// to or greater than <see cref="Rank" />.
        /// </exception>
        public int GetLowerBound(int dimension) { return default(int); }
        /// <summary>
        /// Gets the index of the last element of the specified dimension in the array.
        /// </summary>
        /// <param name="dimension">A zero-based dimension of the array whose upper bound needs to be determined.</param>
        /// <returns>
        /// The index of the last element of the specified dimension in the array, or -1 if the specified
        /// dimension is empty.
        /// </returns>
        /// <exception cref="IndexOutOfRangeException">
        /// <paramref name="dimension" /> is less than zero.-or-<paramref name="dimension" /> is equal
        /// to or greater than <see cref="Rank" />.
        /// </exception>
        public int GetUpperBound(int dimension) { return default(int); }
        /// <summary>
        /// Gets the value at the specified position in the one-dimensional <see cref="Array" />.
        /// The index is specified as a 32-bit integer.
        /// </summary>
        /// <param name="index">
        /// A 32-bit integer that represents the position of the <see cref="Array" /> element
        /// to get.
        /// </param>
        /// <returns>
        /// The value at the specified position in the one-dimensional <see cref="Array" />.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// The current <see cref="Array" /> does not have exactly one dimension.
        /// </exception>
        /// <exception cref="IndexOutOfRangeException">
        /// <paramref name="index" /> is outside the range of valid indexes for the current <see cref="Array" />.
        /// </exception>
        public object GetValue(int index) { return default(object); }
        /// <summary>
        /// Gets the value at the specified position in the multidimensional <see cref="Array" />.
        /// The indexes are specified as an array of 32-bit integers.
        /// </summary>
        /// <param name="indices">
        /// A one-dimensional array of 32-bit integers that represent the indexes specifying the position
        /// of the <see cref="Array" /> element to get.
        /// </param>
        /// <returns>
        /// The value at the specified position in the multidimensional <see cref="Array" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="indices" /> is null.</exception>
        /// <exception cref="ArgumentException">
        /// The number of dimensions in the current <see cref="Array" /> is not equal to the
        /// number of elements in <paramref name="indices" />.
        /// </exception>
        /// <exception cref="IndexOutOfRangeException">
        /// Any element in <paramref name="indices" /> is outside the range of valid indexes for the corresponding
        /// dimension of the current <see cref="Array" />.
        /// </exception>
        public object GetValue(params int[] indices) { return default(object); }
        /// <summary>
        /// Searches for the specified object and returns the index of its first occurrence in a one-dimensional
        /// array.
        /// </summary>
        /// <param name="array">The one-dimensional array to search.</param>
        /// <param name="value">The object to locate in <paramref name="array" />.</param>
        /// <returns>
        /// The index of the first occurrence of <paramref name="value" /> in <paramref name="array" />,
        /// if found; otherwise, the lower bound of the array minus 1.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="array" /> is null.</exception>
        /// <exception cref="RankException"><paramref name="array" /> is multidimensional.</exception>
        public static int IndexOf(System.Array array, object value) { return default(int); }
        /// <summary>
        /// Searches for the specified object in a range of elements of a one-dimensional array, and returns
        /// the index of its first occurrence. The range extends from a specified index to the end of the
        /// array.
        /// </summary>
        /// <param name="array">The one-dimensional array to search.</param>
        /// <param name="value">The object to locate in <paramref name="array" />.</param>
        /// <param name="startIndex">The starting index of the search. 0 (zero) is valid in an empty array.</param>
        /// <returns>
        /// The index of the first occurrence of <paramref name="value" />, if its found, within the
        /// range of elements in <paramref name="array" /> that extends from <paramref name="startIndex" />
        /// to the last element; otherwise, the lower bound of the array minus 1.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="array" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.
        /// </exception>
        /// <exception cref="RankException"><paramref name="array" /> is multidimensional.</exception>
        public static int IndexOf(System.Array array, object value, int startIndex) { return default(int); }
        /// <summary>
        /// Searches for the specified object in a range of elements of a one-dimensional array, and returns
        /// the index of ifs first occurrence. The range extends from a specified index for a specified number
        /// of elements.
        /// </summary>
        /// <param name="array">The one-dimensional array to search.</param>
        /// <param name="value">The object to locate in <paramref name="array" />.</param>
        /// <param name="startIndex">The starting index of the search. 0 (zero) is valid in an empty array.</param>
        /// <param name="count">The number of elements to search.</param>
        /// <returns>
        /// The index of the first occurrence of <paramref name="value" />, if its found in the <paramref name="array" />
        /// from index <paramref name="startIndex" /> to <paramref name="startIndex" />
        /// + <paramref name="count" /> - 1; otherwise, the lower bound of the array minus 1.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="array" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.
        /// -or-<paramref name="count" /> is less than zero.-or-<paramref name="startIndex" /> and
        /// <paramref name="count" /> do not specify a valid section in <paramref name="array" />.
        /// </exception>
        /// <exception cref="RankException"><paramref name="array" /> is multidimensional.</exception>
        public static int IndexOf(System.Array array, object value, int startIndex, int count) { return default(int); }
        /// <summary>
        /// Searches for the specified object and returns the index of its first occurrence in a one-dimensional
        /// array.
        /// </summary>
        /// <param name="array">The one-dimensional, zero-based array to search.</param>
        /// <param name="value">The object to locate in <paramref name="array" />.</param>
        /// <typeparam name="T">The type of the elements of the array.</typeparam>
        /// <returns>
        /// The zero-based index of the first occurrence of <paramref name="value" /> in the entire
        /// <paramref name="array" />, if found; otherwise, 1.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="array" /> is null.</exception>
        public static int IndexOf<T>(T[] array, T value) { return default(int); }
        /// <summary>
        /// Searches for the specified object in a range of elements of a one dimensional array, and returns
        /// the index of its first occurrence. The range extends from a specified index to the end of the
        /// array.
        /// </summary>
        /// <param name="array">The one-dimensional, zero-based array to search.</param>
        /// <param name="value">The object to locate in <paramref name="array" />.</param>
        /// <param name="startIndex">The zero-based starting index of the search. 0 (zero) is valid in an empty array.</param>
        /// <typeparam name="T">The type of the elements of the array.</typeparam>
        /// <returns>
        /// The zero-based index of the first occurrence of <paramref name="value" /> within the range
        /// of elements in <paramref name="array" /> that extends from <paramref name="startIndex" />
        /// to the last element, if found; otherwise, 1.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="array" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.
        /// </exception>
        public static int IndexOf<T>(T[] array, T value, int startIndex) { return default(int); }
        /// <summary>
        /// Searches for the specified object in a range of elements of a one-dimensional array, and returns
        /// the index of its first occurrence. The range extends from a specified index for a specified number
        /// of elements.
        /// </summary>
        /// <param name="array">The one-dimensional, zero-based array to search.</param>
        /// <param name="value">The object to locate in <paramref name="array" />.</param>
        /// <param name="startIndex">The zero-based starting index of the search. 0 (zero) is valid in an empty array.</param>
        /// <param name="count">The number of elements in the section to search.</param>
        /// <typeparam name="T">The type of the elements of the array.</typeparam>
        /// <returns>
        /// The zero-based index of the first occurrence of <paramref name="value" /> within the range
        /// of elements in <paramref name="array" /> that starts at <paramref name="startIndex" /> and
        /// contains the number of elements specified in <paramref name="count" />, if found; otherwise,
        /// 1.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="array" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.
        /// -or-<paramref name="count" /> is less than zero.-or-<paramref name="startIndex" /> and
        /// <paramref name="count" /> do not specify a valid section in <paramref name="array" />.
        /// </exception>
        public static int IndexOf<T>(T[] array, T value, int startIndex, int count) { return default(int); }
        /// <summary>
        /// Initializes every element of the value-type <see cref="Array" /> by calling the default
        /// constructor of the value type.
        /// </summary>
        public void Initialize() { }
        /// <summary>
        /// Searches for the specified object and returns the index of the last occurrence within the
        /// entire one-dimensional <see cref="Array" />.
        /// </summary>
        /// <param name="array">The one-dimensional <see cref="Array" /> to search.</param>
        /// <param name="value">The object to locate in <paramref name="array" />.</param>
        /// <returns>
        /// The index of the last occurrence of <paramref name="value" /> within the entire <paramref name="array" />,
        /// if found; otherwise, the lower bound of the array minus 1.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="array" /> is null.</exception>
        /// <exception cref="RankException"><paramref name="array" /> is multidimensional.</exception>
        public static int LastIndexOf(System.Array array, object value) { return default(int); }
        /// <summary>
        /// Searches for the specified object and returns the index of the last occurrence within the
        /// range of elements in the one-dimensional <see cref="Array" /> that extends from the
        /// first element to the specified index.
        /// </summary>
        /// <param name="array">The one-dimensional <see cref="Array" /> to search.</param>
        /// <param name="value">The object to locate in <paramref name="array" />.</param>
        /// <param name="startIndex">The starting index of the backward search.</param>
        /// <returns>
        /// The index of the last occurrence of <paramref name="value" /> within the range of elements
        /// in <paramref name="array" /> that extends from the first element to <paramref name="startIndex" />,
        /// if found; otherwise, the lower bound of the array minus 1.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="array" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.
        /// </exception>
        /// <exception cref="RankException"><paramref name="array" /> is multidimensional.</exception>
        public static int LastIndexOf(System.Array array, object value, int startIndex) { return default(int); }
        /// <summary>
        /// Searches for the specified object and returns the index of the last occurrence within the
        /// range of elements in the one-dimensional <see cref="Array" /> that contains the specified
        /// number of elements and ends at the specified index.
        /// </summary>
        /// <param name="array">The one-dimensional <see cref="Array" /> to search.</param>
        /// <param name="value">The object to locate in <paramref name="array" />.</param>
        /// <param name="startIndex">The starting index of the backward search.</param>
        /// <param name="count">The number of elements in the section to search.</param>
        /// <returns>
        /// The index of the last occurrence of <paramref name="value" /> within the range of elements
        /// in <paramref name="array" /> that contains the number of elements specified in <paramref name="count" />
        /// and ends at <paramref name="startIndex" />, if found; otherwise, the lower bound of the
        /// array minus 1.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="array" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.
        /// -or-<paramref name="count" /> is less than zero.-or-<paramref name="startIndex" /> and
        /// <paramref name="count" /> do not specify a valid section in <paramref name="array" />.
        /// </exception>
        /// <exception cref="RankException"><paramref name="array" /> is multidimensional.</exception>
        public static int LastIndexOf(System.Array array, object value, int startIndex, int count) { return default(int); }
        /// <summary>
        /// Searches for the specified object and returns the index of the last occurrence within the
        /// entire <see cref="Array" />.
        /// </summary>
        /// <param name="array">The one-dimensional, zero-based <see cref="Array" /> to search.</param>
        /// <param name="value">The object to locate in <paramref name="array" />.</param>
        /// <typeparam name="T">The type of the elements of the array.</typeparam>
        /// <returns>
        /// The zero-based index of the last occurrence of <paramref name="value" /> within the entire
        /// <paramref name="array" />, if found; otherwise, 1.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="array" /> is null.</exception>
        public static int LastIndexOf<T>(T[] array, T value) { return default(int); }
        /// <summary>
        /// Searches for the specified object and returns the index of the last occurrence within the
        /// range of elements in the <see cref="Array" /> that extends from the first element
        /// to the specified index.
        /// </summary>
        /// <param name="array">The one-dimensional, zero-based <see cref="Array" /> to search.</param>
        /// <param name="value">The object to locate in <paramref name="array" />.</param>
        /// <param name="startIndex">The zero-based starting index of the backward search.</param>
        /// <typeparam name="T">The type of the elements of the array.</typeparam>
        /// <returns>
        /// The zero-based index of the last occurrence of <paramref name="value" /> within the range
        /// of elements in <paramref name="array" /> that extends from the first element to <paramref name="startIndex" />,
        /// if found; otherwise, 1.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="array" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.
        /// </exception>
        public static int LastIndexOf<T>(T[] array, T value, int startIndex) { return default(int); }
        /// <summary>
        /// Searches for the specified object and returns the index of the last occurrence within the
        /// range of elements in the <see cref="Array" /> that contains the specified number
        /// of elements and ends at the specified index.
        /// </summary>
        /// <param name="array">The one-dimensional, zero-based <see cref="Array" /> to search.</param>
        /// <param name="value">The object to locate in <paramref name="array" />.</param>
        /// <param name="startIndex">The zero-based starting index of the backward search.</param>
        /// <param name="count">The number of elements in the section to search.</param>
        /// <typeparam name="T">The type of the elements of the array.</typeparam>
        /// <returns>
        /// The zero-based index of the last occurrence of <paramref name="value" /> within the range
        /// of elements in <paramref name="array" /> that contains the number of elements specified in
        /// <paramref name="count" /> and ends at <paramref name="startIndex" />, if found; otherwise,
        /// 1.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="array" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.
        /// -or-<paramref name="count" /> is less than zero.-or-<paramref name="startIndex" /> and
        /// <paramref name="count" /> do not specify a valid section in <paramref name="array" />.
        /// </exception>
        public static int LastIndexOf<T>(T[] array, T value, int startIndex, int count) { return default(int); }
        /// <summary>
        /// Changes the number of elements of a one-dimensional array to the specified new size.
        /// </summary>
        /// <param name="array">
        /// The one-dimensional, zero-based array to resize, or null to create a new array with the specified
        /// size.
        /// </param>
        /// <param name="newSize">The size of the new array.</param>
        /// <typeparam name="T">The type of the elements of the array.</typeparam>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="newSize" /> is less than zero.
        /// </exception>
        public static void Resize<T>(ref T[] array, int newSize) { }
        /// <summary>
        /// Reverses the sequence of the elements in the entire one-dimensional <see cref="Array" />.
        /// </summary>
        /// <param name="array">The one-dimensional <see cref="Array" /> to reverse.</param>
        /// <exception cref="ArgumentNullException"><paramref name="array" /> is null.</exception>
        /// <exception cref="RankException"><paramref name="array" /> is multidimensional.</exception>
        public static void Reverse(System.Array array) { }
        /// <summary>
        /// Reverses the sequence of the elements in a range of elements in the one-dimensional
        /// <see cref="Array" />.
        /// </summary>
        /// <param name="array">The one-dimensional <see cref="Array" /> to reverse.</param>
        /// <param name="index">The starting index of the section to reverse.</param>
        /// <param name="length">The number of elements in the section to reverse.</param>
        /// <exception cref="ArgumentNullException"><paramref name="array" /> is null.</exception>
        /// <exception cref="RankException"><paramref name="array" /> is multidimensional.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than the lower bound of <paramref name="array" />.-or-
        /// <paramref name="length" /> is less than zero.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in
        /// <paramref name="array" />.
        /// </exception>
        public static void Reverse(System.Array array, int index, int length) { }
        /// <summary>
        /// Sets a value to the element at the specified position in the one-dimensional <see cref="Array" />.
        /// The index is specified as a 32-bit integer.
        /// </summary>
        /// <param name="value">The new value for the specified element.</param>
        /// <param name="index">
        /// A 32-bit integer that represents the position of the <see cref="Array" /> element
        /// to set.
        /// </param>
        /// <exception cref="ArgumentException">
        /// The current <see cref="Array" /> does not have exactly one dimension.
        /// </exception>
        /// <exception cref="InvalidCastException">
        /// <paramref name="value" /> cannot be cast to the element type of the current <see cref="Array" />.
        /// </exception>
        /// <exception cref="IndexOutOfRangeException">
        /// <paramref name="index" /> is outside the range of valid indexes for the current <see cref="Array" />.
        /// </exception>
        public void SetValue(object value, int index) { }
        /// <summary>
        /// Sets a value to the element at the specified position in the multidimensional <see cref="Array" />.
        /// The indexes are specified as an array of 32-bit integers.
        /// </summary>
        /// <param name="value">The new value for the specified element.</param>
        /// <param name="indices">
        /// A one-dimensional array of 32-bit integers that represent the indexes specifying the position
        /// of the element to set.
        /// </param>
        /// <exception cref="ArgumentNullException"><paramref name="indices" /> is null.</exception>
        /// <exception cref="ArgumentException">
        /// The number of dimensions in the current <see cref="Array" /> is not equal to the
        /// number of elements in <paramref name="indices" />.
        /// </exception>
        /// <exception cref="InvalidCastException">
        /// <paramref name="value" /> cannot be cast to the element type of the current <see cref="Array" />.
        /// </exception>
        /// <exception cref="IndexOutOfRangeException">
        /// Any element in <paramref name="indices" /> is outside the range of valid indexes for the corresponding
        /// dimension of the current <see cref="Array" />.
        /// </exception>
        public void SetValue(object value, params int[] indices) { }
        /// <summary>
        /// Sorts the elements in an entire one-dimensional <see cref="Array" /> using the
        /// <see cref="IComparable" /> implementation of each element of the <see cref="Array" />.
        /// </summary>
        /// <param name="array">The one-dimensional <see cref="Array" /> to sort.</param>
        /// <exception cref="ArgumentNullException"><paramref name="array" /> is null.</exception>
        /// <exception cref="RankException"><paramref name="array" /> is multidimensional.</exception>
        /// <exception cref="InvalidOperationException">
        /// One or more elements in <paramref name="array" /> do not implement the <see cref="IComparable" />
        /// interface.
        /// </exception>
        public static void Sort(System.Array array) { }
        /// <summary>
        /// Sorts a pair of one-dimensional <see cref="Array" /> objects (one contains the keys
        /// and the other contains the corresponding items) based on the keys in the first <see cref="Array" />
        /// using the <see cref="IComparable" /> implementation of each key.
        /// </summary>
        /// <param name="keys">The one-dimensional <see cref="Array" /> that contains the keys to sort.</param>
        /// <param name="items">
        /// The one-dimensional <see cref="Array" /> that contains the items that correspond
        /// to each of the keys in the <paramref name="keys" /><see cref="Array" />.-or-null
        /// to sort only the <paramref name="keys" /><see cref="Array" />.
        /// </param>
        /// <exception cref="ArgumentNullException"><paramref name="keys" /> is null.</exception>
        /// <exception cref="RankException">
        /// The <paramref name="keys" /><see cref="Array" /> is multidimensional.-or-The <paramref name="items" />
        /// <see cref="Array" /> is multidimensional.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="items" /> is not null, and the length of <paramref name="keys" /> is greater
        /// than the length of <paramref name="items" />.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// One or more elements in the <paramref name="keys" /><see cref="Array" /> do not implement
        /// the <see cref="IComparable" /> interface.
        /// </exception>
        public static void Sort(System.Array keys, System.Array items) { }
        /// <summary>
        /// Sorts a pair of one-dimensional <see cref="Array" /> objects (one contains the keys
        /// and the other contains the corresponding items) based on the keys in the first <see cref="Array" />
        /// using the specified <see cref="Collections.IComparer" />.
        /// </summary>
        /// <param name="keys">The one-dimensional <see cref="Array" /> that contains the keys to sort.</param>
        /// <param name="items">
        /// The one-dimensional <see cref="Array" /> that contains the items that correspond
        /// to each of the keys in the <paramref name="keys" /><see cref="Array" />.-or-null
        /// to sort only the <paramref name="keys" /><see cref="Array" />.
        /// </param>
        /// <param name="comparer">
        /// The <see cref="Collections.IComparer" /> implementation to use when comparing elements.-or-null
        /// to use the <see cref="IComparable" /> implementation of each element.
        /// </param>
        /// <exception cref="ArgumentNullException"><paramref name="keys" /> is null.</exception>
        /// <exception cref="RankException">
        /// The <paramref name="keys" /><see cref="Array" /> is multidimensional.-or-The <paramref name="items" />
        /// <see cref="Array" /> is multidimensional.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="items" /> is not null, and the length of <paramref name="keys" /> is greater
        /// than the length of <paramref name="items" />. -or-The implementation of <paramref name="comparer" />
        /// caused an error during the sort. For example, <paramref name="comparer" /> might not return
        /// 0 when comparing an item with itself.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// <paramref name="comparer" /> is null, and one or more elements in the <paramref name="keys" />
        /// <see cref="Array" /> do not implement the <see cref="IComparable" /> interface.
        /// </exception>
        public static void Sort(System.Array keys, System.Array items, System.Collections.IComparer comparer) { }
        /// <summary>
        /// Sorts a range of elements in a pair of one-dimensional <see cref="Array" /> objects
        /// (one contains the keys and the other contains the corresponding items) based on the keys in
        /// the first <see cref="Array" /> using the <see cref="IComparable" /> implementation
        /// of each key.
        /// </summary>
        /// <param name="keys">The one-dimensional <see cref="Array" /> that contains the keys to sort.</param>
        /// <param name="items">
        /// The one-dimensional <see cref="Array" /> that contains the items that correspond
        /// to each of the keys in the <paramref name="keys" /><see cref="Array" />.-or-null
        /// to sort only the <paramref name="keys" /><see cref="Array" />.
        /// </param>
        /// <param name="index">The starting index of the range to sort.</param>
        /// <param name="length">The number of elements in the range to sort.</param>
        /// <exception cref="ArgumentNullException"><paramref name="keys" /> is null.</exception>
        /// <exception cref="RankException">
        /// The <paramref name="keys" /><see cref="Array" /> is multidimensional.-or-The <paramref name="items" />
        /// <see cref="Array" /> is multidimensional.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than the lower bound of <paramref name="keys" />.-or-
        /// <paramref name="length" /> is less than zero.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="items" /> is not null, and the length of <paramref name="keys" /> is greater
        /// than the length of <paramref name="items" />.-or-<paramref name="index" /> and <paramref name="length" />
        /// do not specify a valid range in the <paramref name="keys" /><see cref="Array" />.
        /// -or-<paramref name="items" /> is not null, and <paramref name="index" /> and <paramref name="length" />
        /// do not specify a valid range in the <paramref name="items" /><see cref="Array" />.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// One or more elements in the <paramref name="keys" /><see cref="Array" /> do not implement
        /// the <see cref="IComparable" /> interface.
        /// </exception>
        public static void Sort(System.Array keys, System.Array items, int index, int length) { }
        /// <summary>
        /// Sorts a range of elements in a pair of one-dimensional <see cref="Array" /> objects
        /// (one contains the keys and the other contains the corresponding items) based on the keys in
        /// the first <see cref="Array" /> using the specified <see cref="Collections.IComparer" />.
        /// </summary>
        /// <param name="keys">The one-dimensional <see cref="Array" /> that contains the keys to sort.</param>
        /// <param name="items">
        /// The one-dimensional <see cref="Array" /> that contains the items that correspond
        /// to each of the keys in the <paramref name="keys" /><see cref="Array" />.-or-null
        /// to sort only the <paramref name="keys" /><see cref="Array" />.
        /// </param>
        /// <param name="index">The starting index of the range to sort.</param>
        /// <param name="length">The number of elements in the range to sort.</param>
        /// <param name="comparer">
        /// The <see cref="Collections.IComparer" /> implementation to use when comparing elements.-or-null
        /// to use the <see cref="IComparable" /> implementation of each element.
        /// </param>
        /// <exception cref="ArgumentNullException"><paramref name="keys" /> is null.</exception>
        /// <exception cref="RankException">
        /// The <paramref name="keys" /><see cref="Array" /> is multidimensional.-or-The <paramref name="items" />
        /// <see cref="Array" /> is multidimensional.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than the lower bound of <paramref name="keys" />.-or-
        /// <paramref name="length" /> is less than zero.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="items" /> is not null, and the lower bound of <paramref name="keys" /> does
        /// not match the lower bound of <paramref name="items" />.-or-<paramref name="items" /> is not
        /// null, and the length of <paramref name="keys" /> is greater than the length of <paramref name="items" />.
        /// -or-<paramref name="index" /> and <paramref name="length" /> do not specify a valid range
        /// in the <paramref name="keys" /><see cref="Array" />.-or-<paramref name="items" />
        /// is not null, and <paramref name="index" /> and <paramref name="length" /> do not specify a
        /// valid range in the <paramref name="items" /><see cref="Array" />. -or-The implementation
        /// of <paramref name="comparer" /> caused an error during the sort. For example, <paramref name="comparer" />
        /// might not return 0 when comparing an item with itself.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// <paramref name="comparer" /> is null, and one or more elements in the <paramref name="keys" />
        /// <see cref="Array" /> do not implement the <see cref="IComparable" /> interface.
        /// </exception>
        public static void Sort(System.Array keys, System.Array items, int index, int length, System.Collections.IComparer comparer) { }
        /// <summary>
        /// Sorts the elements in a one-dimensional <see cref="Array" /> using the specified
        /// <see cref="Collections.IComparer" />.
        /// </summary>
        /// <param name="array">The one-dimensional array to sort.</param>
        /// <param name="comparer">
        /// The implementation to use when comparing elements.-or-null to use the <see cref="IComparable" />
        /// implementation of each element.
        /// </param>
        /// <exception cref="ArgumentNullException"><paramref name="array" /> is null.</exception>
        /// <exception cref="RankException"><paramref name="array" /> is multidimensional.</exception>
        /// <exception cref="InvalidOperationException">
        /// <paramref name="comparer" /> is null, and one or more elements in <paramref name="array" />
        /// do not implement the <see cref="IComparable" /> interface.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// The implementation of <paramref name="comparer" /> caused an error during the sort. For example,
        /// <paramref name="comparer" /> might not return 0 when comparing an item with itself.
        /// </exception>
        public static void Sort(System.Array array, System.Collections.IComparer comparer) { }
        /// <summary>
        /// Sorts the elements in a range of elements in a one-dimensional <see cref="Array" />
        /// using the <see cref="IComparable" /> implementation of each element of the <see cref="Array" />.
        /// </summary>
        /// <param name="array">The one-dimensional <see cref="Array" /> to sort.</param>
        /// <param name="index">The starting index of the range to sort.</param>
        /// <param name="length">The number of elements in the range to sort.</param>
        /// <exception cref="ArgumentNullException"><paramref name="array" /> is null.</exception>
        /// <exception cref="RankException"><paramref name="array" /> is multidimensional.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than the lower bound of <paramref name="array" />.-or-
        /// <paramref name="length" /> is less than zero.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in
        /// <paramref name="array" />.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// One or more elements in <paramref name="array" /> do not implement the <see cref="IComparable" />
        /// interface.
        /// </exception>
        public static void Sort(System.Array array, int index, int length) { }
        /// <summary>
        /// Sorts the elements in a range of elements in a one-dimensional <see cref="Array" />
        /// using the specified <see cref="Collections.IComparer" />.
        /// </summary>
        /// <param name="array">The one-dimensional <see cref="Array" /> to sort.</param>
        /// <param name="index">The starting index of the range to sort.</param>
        /// <param name="length">The number of elements in the range to sort.</param>
        /// <param name="comparer">
        /// The <see cref="Collections.IComparer" /> implementation to use when comparing elements.-or-null
        /// to use the <see cref="IComparable" /> implementation of each element.
        /// </param>
        /// <exception cref="ArgumentNullException"><paramref name="array" /> is null.</exception>
        /// <exception cref="RankException"><paramref name="array" /> is multidimensional.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than the lower bound of <paramref name="array" />.-or-
        /// <paramref name="length" /> is less than zero.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in
        /// <paramref name="array" />. -or-The implementation of <paramref name="comparer" /> caused an error during
        /// the sort. For example, <paramref name="comparer" /> might not return 0 when comparing an item
        /// with itself.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// <paramref name="comparer" /> is null, and one or more elements in <paramref name="array" />
        /// do not implement the <see cref="IComparable" /> interface.
        /// </exception>
        public static void Sort(System.Array array, int index, int length, System.Collections.IComparer comparer) { }
        /// <summary>
        /// Sorts the elements in an entire <see cref="Array" /> using the <see cref="IComparable`1" />
        /// generic interface implementation of each element of the <see cref="Array" />.
        /// </summary>
        /// <param name="array">The one-dimensional, zero-based <see cref="Array" /> to sort.</param>
        /// <typeparam name="T">The type of the elements of the array.</typeparam>
        /// <exception cref="ArgumentNullException"><paramref name="array" /> is null.</exception>
        /// <exception cref="InvalidOperationException">
        /// One or more elements in <paramref name="array" /> do not implement the <see cref="IComparable`1" />
        /// generic interface.
        /// </exception>
        public static void Sort<T>(T[] array) { }
        /// <summary>
        /// Sorts the elements in an <see cref="Array" /> using the specified
        /// <see cref="Collections.Generic.IComparer`1" /> generic interface.
        /// </summary>
        /// <param name="array">The one-dimensional, zero-base <see cref="Array" /> to sort</param>
        /// <param name="comparer">
        /// The <see cref="Collections.Generic.IComparer`1" /> generic interface implementation
        /// to use when comparing elements, or null to use the <see cref="IComparable`1" /> generic
        /// interface implementation of each element.
        /// </param>
        /// <typeparam name="T">The type of the elements of the array.</typeparam>
        /// <exception cref="ArgumentNullException"><paramref name="array" /> is null.</exception>
        /// <exception cref="InvalidOperationException">
        /// <paramref name="comparer" /> is null, and one or more elements in <paramref name="array" />
        /// do not implement the <see cref="IComparable`1" /> generic interface.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// The implementation of <paramref name="comparer" /> caused an error during the sort. For example,
        /// <paramref name="comparer" /> might not return 0 when comparing an item with itself.
        /// </exception>
        public static void Sort<T>(T[] array, System.Collections.Generic.IComparer<T> comparer) { }
        /// <summary>
        /// Sorts the elements in an <see cref="Array" /> using the specified <see cref="System.Comparison`1" />.
        /// </summary>
        /// <param name="array">The one-dimensional, zero-based <see cref="Array" /> to sort</param>
        /// <param name="comparison">The <see cref="System.Comparison`1" /> to use when comparing elements.</param>
        /// <typeparam name="T">The type of the elements of the array.</typeparam>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="array" /> is null.-or-<paramref name="comparison" /> is null.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// The implementation of <paramref name="comparison" /> caused an error during the sort. For
        /// example, <paramref name="comparison" /> might not return 0 when comparing an item with itself.
        /// </exception>
        public static void Sort<T>(T[] array, System.Comparison<T> comparison) { }
        /// <summary>
        /// Sorts the elements in a range of elements in an <see cref="Array" /> using the
        /// <see cref="IComparable`1" /> generic interface implementation of each element of the <see cref="Array" />.
        /// </summary>
        /// <param name="array">The one-dimensional, zero-based <see cref="Array" /> to sort</param>
        /// <param name="index">The starting index of the range to sort.</param>
        /// <param name="length">The number of elements in the range to sort.</param>
        /// <typeparam name="T">The type of the elements of the array.</typeparam>
        /// <exception cref="ArgumentNullException"><paramref name="array" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than the lower bound of <paramref name="array" />.-or-
        /// <paramref name="length" /> is less than zero.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in
        /// <paramref name="array" />.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// One or more elements in <paramref name="array" /> do not implement the <see cref="IComparable`1" />
        /// generic interface.
        /// </exception>
        public static void Sort<T>(T[] array, int index, int length) { }
        /// <summary>
        /// Sorts the elements in a range of elements in an <see cref="Array" /> using the specified
        /// <see cref="Collections.Generic.IComparer`1" /> generic interface.
        /// </summary>
        /// <param name="array">The one-dimensional, zero-based <see cref="Array" /> to sort.</param>
        /// <param name="index">The starting index of the range to sort.</param>
        /// <param name="length">The number of elements in the range to sort.</param>
        /// <param name="comparer">
        /// The <see cref="Collections.Generic.IComparer`1" /> generic interface implementation
        /// to use when comparing elements, or null to use the <see cref="IComparable`1" /> generic
        /// interface implementation of each element.
        /// </param>
        /// <typeparam name="T">The type of the elements of the array.</typeparam>
        /// <exception cref="ArgumentNullException"><paramref name="array" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than the lower bound of <paramref name="array" />.-or-
        /// <paramref name="length" /> is less than zero.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in
        /// <paramref name="array" />. -or-The implementation of <paramref name="comparer" /> caused an error during
        /// the sort. For example, <paramref name="comparer" /> might not return 0 when comparing an item
        /// with itself.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// <paramref name="comparer" /> is null, and one or more elements in <paramref name="array" />
        /// do not implement the <see cref="IComparable`1" /> generic interface.
        /// </exception>
        public static void Sort<T>(T[] array, int index, int length, System.Collections.Generic.IComparer<T> comparer) { }
        /// <summary>
        /// Sorts a pair of <see cref="Array" /> objects (one contains the keys and the other
        /// contains the corresponding items) based on the keys in the first <see cref="Array" />
        /// using the <see cref="IComparable`1" /> generic interface implementation of each
        /// key.
        /// </summary>
        /// <param name="keys">
        /// The one-dimensional, zero-based <see cref="Array" /> that contains the keys to sort.
        /// </param>
        /// <param name="items">
        /// The one-dimensional, zero-based <see cref="Array" /> that contains the items that
        /// correspond to the keys in <paramref name="keys" />, or null to sort only <paramref name="keys" />.
        /// </param>
        /// <typeparam name="TKey">The type of the elements of the key array.</typeparam>
        /// <typeparam name="TValue">The type of the elements of the items array.</typeparam>
        /// <exception cref="ArgumentNullException"><paramref name="keys" /> is null.</exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="items" /> is not null, and the lower bound of <paramref name="keys" /> does
        /// not match the lower bound of <paramref name="items" />.-or-<paramref name="items" /> is not
        /// null, and the length of <paramref name="keys" /> is greater than the length of <paramref name="items" />.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// One or more elements in the <paramref name="keys" /><see cref="Array" /> do not implement
        /// the <see cref="IComparable`1" /> generic interface.
        /// </exception>
        public static void Sort<TKey, TValue>(TKey[] keys, TValue[] items) { }
        /// <summary>
        /// Sorts a pair of <see cref="Array" /> objects (one contains the keys and the other
        /// contains the corresponding items) based on the keys in the first <see cref="Array" />
        /// using the specified <see cref="Collections.Generic.IComparer`1" /> generic interface.
        /// </summary>
        /// <param name="keys">
        /// The one-dimensional, zero-based <see cref="Array" /> that contains the keys to sort.
        /// </param>
        /// <param name="items">
        /// The one-dimensional, zero-based <see cref="Array" /> that contains the items that
        /// correspond to the keys in <paramref name="keys" />, or null to sort only <paramref name="keys" />.
        /// </param>
        /// <param name="comparer">
        /// The <see cref="Collections.Generic.IComparer`1" /> generic interface implementation
        /// to use when comparing elements, or null to use the <see cref="IComparable`1" /> generic
        /// interface implementation of each element.
        /// </param>
        /// <typeparam name="TKey">The type of the elements of the key array.</typeparam>
        /// <typeparam name="TValue">The type of the elements of the items array.</typeparam>
        /// <exception cref="ArgumentNullException"><paramref name="keys" /> is null.</exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="items" /> is not null, and the lower bound of <paramref name="keys" /> does
        /// not match the lower bound of <paramref name="items" />.-or-<paramref name="items" /> is not
        /// null, and the length of <paramref name="keys" /> is greater than the length of <paramref name="items" />.
        /// -or-The implementation of <paramref name="comparer" /> caused an error during the sort.
        /// For example, <paramref name="comparer" /> might not return 0 when comparing an item with itself.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// <paramref name="comparer" /> is null, and one or more elements in the <paramref name="keys" />
        /// <see cref="Array" /> do not implement the <see cref="IComparable`1" />
        /// generic interface.
        /// </exception>
        public static void Sort<TKey, TValue>(TKey[] keys, TValue[] items, System.Collections.Generic.IComparer<TKey> comparer) { }
        /// <summary>
        /// Sorts a range of elements in a pair of <see cref="Array" /> objects (one contains
        /// the keys and the other contains the corresponding items) based on the keys in the first <see cref="Array" />
        /// using the <see cref="IComparable`1" /> generic interface
        /// implementation of each key.
        /// </summary>
        /// <param name="keys">
        /// The one-dimensional, zero-based <see cref="Array" /> that contains the keys to sort.
        /// </param>
        /// <param name="items">
        /// The one-dimensional, zero-based <see cref="Array" /> that contains the items that
        /// correspond to the keys in <paramref name="keys" />, or null to sort only <paramref name="keys" />.
        /// </param>
        /// <param name="index">The starting index of the range to sort.</param>
        /// <param name="length">The number of elements in the range to sort.</param>
        /// <typeparam name="TKey">The type of the elements of the key array.</typeparam>
        /// <typeparam name="TValue">The type of the elements of the items array.</typeparam>
        /// <exception cref="ArgumentNullException"><paramref name="keys" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than the lower bound of <paramref name="keys" />.-or-
        /// <paramref name="length" /> is less than zero.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="items" /> is not null, and the lower bound of <paramref name="keys" /> does
        /// not match the lower bound of <paramref name="items" />.-or-<paramref name="items" /> is not
        /// null, and the length of <paramref name="keys" /> is greater than the length of <paramref name="items" />.
        /// -or-<paramref name="index" /> and <paramref name="length" /> do not specify a valid range
        /// in the <paramref name="keys" /><see cref="Array" />.-or-<paramref name="items" />
        /// is not null, and <paramref name="index" /> and <paramref name="length" /> do not specify a
        /// valid range in the <paramref name="items" /><see cref="Array" />.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// One or more elements in the <paramref name="keys" /><see cref="Array" /> do not implement
        /// the <see cref="IComparable`1" /> generic interface.
        /// </exception>
        public static void Sort<TKey, TValue>(TKey[] keys, TValue[] items, int index, int length) { }
        /// <summary>
        /// Sorts a range of elements in a pair of <see cref="Array" /> objects (one contains
        /// the keys and the other contains the corresponding items) based on the keys in the first <see cref="Array" />
        /// using the specified <see cref="Collections.Generic.IComparer`1" />
        /// generic interface.
        /// </summary>
        /// <param name="keys">
        /// The one-dimensional, zero-based <see cref="Array" /> that contains the keys to sort.
        /// </param>
        /// <param name="items">
        /// The one-dimensional, zero-based <see cref="Array" /> that contains the items that
        /// correspond to the keys in <paramref name="keys" />, or null to sort only <paramref name="keys" />.
        /// </param>
        /// <param name="index">The starting index of the range to sort.</param>
        /// <param name="length">The number of elements in the range to sort.</param>
        /// <param name="comparer">
        /// The <see cref="Collections.Generic.IComparer`1" /> generic interface implementation
        /// to use when comparing elements, or null to use the <see cref="IComparable`1" /> generic
        /// interface implementation of each element.
        /// </param>
        /// <typeparam name="TKey">The type of the elements of the key array.</typeparam>
        /// <typeparam name="TValue">The type of the elements of the items array.</typeparam>
        /// <exception cref="ArgumentNullException"><paramref name="keys" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than the lower bound of <paramref name="keys" />.-or-
        /// <paramref name="length" /> is less than zero.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="items" /> is not null, and the lower bound of <paramref name="keys" /> does
        /// not match the lower bound of <paramref name="items" />.-or-<paramref name="items" /> is not
        /// null, and the length of <paramref name="keys" /> is greater than the length of <paramref name="items" />.
        /// -or-<paramref name="index" /> and <paramref name="length" /> do not specify a valid range
        /// in the <paramref name="keys" /><see cref="Array" />.-or-<paramref name="items" />
        /// is not null, and <paramref name="index" /> and <paramref name="length" /> do not specify a
        /// valid range in the <paramref name="items" /><see cref="Array" />. -or-The implementation
        /// of <paramref name="comparer" /> caused an error during the sort. For example, <paramref name="comparer" />
        /// might not return 0 when comparing an item with itself.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// <paramref name="comparer" /> is null, and one or more elements in the <paramref name="keys" />
        /// <see cref="Array" /> do not implement the <see cref="IComparable`1" />
        /// generic interface.
        /// </exception>
        public static void Sort<TKey, TValue>(TKey[] keys, TValue[] items, int index, int length, System.Collections.Generic.IComparer<TKey> comparer) { }
        int System.Collections.IList.Add(object value) { return default(int); }
        void System.Collections.IList.Clear() { }
        bool System.Collections.IList.Contains(object value) { return default(bool); }
        int System.Collections.IList.IndexOf(object value) { return default(int); }
        void System.Collections.IList.Insert(int index, object value) { }
        void System.Collections.IList.Remove(object value) { }
        void System.Collections.IList.RemoveAt(int index) { }
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer) { return default(int); }
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer) { return default(bool); }
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer) { return default(int); }
        /// <summary>
        /// Determines whether every element in the array matches the conditions defined by the specified
        /// predicate.
        /// </summary>
        /// <param name="array">
        /// The one-dimensional, zero-based <see cref="Array" /> to check against the conditions.
        /// </param>
        /// <param name="match">The predicate that defines the conditions to check against the elements.</param>
        /// <typeparam name="T">The type of the elements of the array.</typeparam>
        /// <returns>
        /// true if every element in <paramref name="array" /> matches the conditions defined by the specified
        /// predicate; otherwise, false. If there are no elements in the array, the return value is true.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="array" /> is null.-or-<paramref name="match" /> is null.
        /// </exception>
        public static bool TrueForAll<T>(T[] array, System.Predicate<T> match) { return default(bool); }
    }
    /// <summary>
    /// Delimits a section of a one-dimensional array.
    /// </summary>
    /// <typeparam name="T">The type of the elements in the array segment.</typeparam>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct ArraySegment<T> : System.Collections.Generic.ICollection<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.Generic.IList<T>, System.Collections.Generic.IReadOnlyCollection<T>, System.Collections.Generic.IReadOnlyList<T>, System.Collections.IEnumerable
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="System.ArraySegment`1" /> structure that delimits
        /// all the elements in the specified array.
        /// </summary>
        /// <param name="array">The array to wrap.</param>
        /// <exception cref="ArgumentNullException"><paramref name="array" /> is null.</exception>
        public ArraySegment(T[] array) { throw new System.NotImplementedException(); }
        /// <summary>
        /// Initializes a new instance of the <see cref="System.ArraySegment`1" /> structure that delimits
        /// the specified range of the elements in the specified array.
        /// </summary>
        /// <param name="array">The array containing the range of elements to delimit.</param>
        /// <param name="offset">The zero-based index of the first element in the range.</param>
        /// <param name="count">The number of elements in the range.</param>
        /// <exception cref="ArgumentNullException"><paramref name="array" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="offset" /> or <paramref name="count" /> is less than 0.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="offset" /> and <paramref name="count" /> do not specify a valid range in
        /// <paramref name="array" />.
        /// </exception>
        public ArraySegment(T[] array, int offset, int count) { throw new System.NotImplementedException(); }
        /// <summary>
        /// Gets the original array containing the range of elements that the array segment delimits.
        /// </summary>
        /// <returns>
        /// The original array that was passed to the constructor, and that contains the range delimited
        /// by the <see cref="System.ArraySegment`1" />.
        /// </returns>
        public T[] Array { get { return default(T[]); } }
        /// <summary>
        /// Gets the number of elements in the range delimited by the array segment.
        /// </summary>
        /// <returns>
        /// The number of elements in the range delimited by the <see cref="System.ArraySegment`1" />.
        /// </returns>
        public int Count { get { return default(int); } }
        /// <summary>
        /// Gets the position of the first element in the range delimited by the array segment, relative
        /// to the start of the original array.
        /// </summary>
        /// <returns>
        /// The position of the first element in the range delimited by the <see cref="System.ArraySegment`1" />,
        /// relative to the start of the original array.
        /// </returns>
        public int Offset { get { return default(int); } }
        bool System.Collections.Generic.ICollection<T>.IsReadOnly { get { return default(bool); } }
        T System.Collections.Generic.IList<T>.this[int index] { get { return default(T); } set { } }
        T System.Collections.Generic.IReadOnlyList<T>.this[int index] { get { return default(T); } }
        /// <summary>
        /// Determines whether the specified <see cref="System.ArraySegment`1" /> structure is equal
        /// to the current instance.
        /// </summary>
        /// <param name="obj">The structure to compare with the current instance.</param>
        /// <returns>
        /// true if the specified <see cref="System.ArraySegment`1" /> structure is equal to the current
        /// instance; otherwise, false.
        /// </returns>
        public bool Equals(System.ArraySegment<T> obj) { return default(bool); }
        /// <summary>
        /// Determines whether the specified object is equal to the current instance.
        /// </summary>
        /// <param name="obj">The object to be compared with the current instance.</param>
        /// <returns>
        /// true if the specified object is a <see cref="System.ArraySegment`1" /> structure and is
        /// equal to the current instance; otherwise, false.
        /// </returns>
        public override bool Equals(object obj) { return default(bool); }
        /// <summary>
        /// Returns the hash code for the current instance.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code.
        /// </returns>
        public override int GetHashCode() { return default(int); }
        /// <summary>
        /// Indicates whether two <see cref="System.ArraySegment`1" /> structures are equal.
        /// </summary>
        /// <param name="a">The  structure on the left side of the equality operator.</param>
        /// <param name="b">The structure on the right side of the equality operator.</param>
        /// <returns>
        /// true if <paramref name="a" /> is equal to <paramref name="b" />; otherwise, false.
        /// </returns>
        public static bool operator ==(System.ArraySegment<T> a, System.ArraySegment<T> b) { return default(bool); }
        /// <summary>
        /// Indicates whether two <see cref="System.ArraySegment`1" /> structures are unequal.
        /// </summary>
        /// <param name="a">The structure on the left side of the inequality operator.</param>
        /// <param name="b">The structure on the right side of the inequality operator.</param>
        /// <returns>
        /// true if <paramref name="a" /> is not equal to <paramref name="b" />; otherwise, false.
        /// </returns>
        public static bool operator !=(System.ArraySegment<T> a, System.ArraySegment<T> b) { return default(bool); }
        void System.Collections.Generic.ICollection<T>.Add(T item) { }
        void System.Collections.Generic.ICollection<T>.Clear() { }
        bool System.Collections.Generic.ICollection<T>.Contains(T item) { return default(bool); }
        void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex) { }
        bool System.Collections.Generic.ICollection<T>.Remove(T item) { return default(bool); }
        System.Collections.Generic.IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator() { return default(System.Collections.Generic.IEnumerator<T>); }
        int System.Collections.Generic.IList<T>.IndexOf(T item) { return default(int); }
        void System.Collections.Generic.IList<T>.Insert(int index, T item) { }
        void System.Collections.Generic.IList<T>.RemoveAt(int index) { }
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { return default(System.Collections.IEnumerator); }
    }
    /// <summary>
    /// The exception that is thrown when an attempt is made to store an element of the wrong type
    /// within an array.
    /// </summary>
    public partial class ArrayTypeMismatchException : System.Exception
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ArrayTypeMismatchException" /> class.
        /// </summary>
        public ArrayTypeMismatchException() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ArrayTypeMismatchException" /> class
        /// with a specified error message.
        /// </summary>
        /// <param name="message">A <see cref="String" /> that describes the error.</param>
        public ArrayTypeMismatchException(string message) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ArrayTypeMismatchException" /> class
        /// with a specified error message and a reference to the inner exception that is the cause of
        /// this exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="innerException">
        /// The exception that is the cause of the current exception. If the <paramref name="innerException" />
        /// parameter is not a null reference, the current exception is raised in a catch block that
        /// handles the inner exception.
        /// </param>
        public ArrayTypeMismatchException(string message, System.Exception innerException) { }
    }
    /// <summary>
    /// References a method to be called when a corresponding asynchronous operation completes.
    /// </summary>
    /// <param name="ar">The result of the asynchronous operation.</param>
    public delegate void AsyncCallback(System.IAsyncResult ar);
    /// <summary>
    /// Represents the base class for custom attributes.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(32767), Inherited = true, AllowMultiple = false)]
    public abstract partial class Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Attribute" /> class.
        /// </summary>
        protected Attribute() { }
        /// <summary>
        /// Returns a value that indicates whether this instance is equal to a specified object.
        /// </summary>
        /// <param name="obj">An <see cref="Object" /> to compare with this instance or null.</param>
        /// <returns>
        /// true if <paramref name="obj" /> equals the type and value of this instance; otherwise, false.
        /// </returns>
        public override bool Equals(object obj) { return default(bool); }
        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code.
        /// </returns>
        public override int GetHashCode() { return default(int); }
    }
    /// <summary>
    /// Specifies the application elements on which it is valid to apply an attribute.
    /// </summary>
    [System.FlagsAttribute]
    public enum AttributeTargets
    {
        /// <summary>
        /// Attribute can be applied to any application element.
        /// </summary>
        All = 32767,
        /// <summary>
        /// Attribute can be applied to an assembly.
        /// </summary>
        Assembly = 1,
        /// <summary>
        /// Attribute can be applied to a class.
        /// </summary>
        Class = 4,
        /// <summary>
        /// Attribute can be applied to a constructor.
        /// </summary>
        Constructor = 32,
        /// <summary>
        /// Attribute can be applied to a delegate.
        /// </summary>
        Delegate = 4096,
        /// <summary>
        /// Attribute can be applied to an enumeration.
        /// </summary>
        Enum = 16,
        /// <summary>
        /// Attribute can be applied to an event.
        /// </summary>
        Event = 512,
        /// <summary>
        /// Attribute can be applied to a field.
        /// </summary>
        Field = 256,
        /// <summary>
        /// Attribute can be applied to a generic parameter.
        /// </summary>
        GenericParameter = 16384,
        /// <summary>
        /// Attribute can be applied to an interface.
        /// </summary>
        Interface = 1024,
        /// <summary>
        /// Attribute can be applied to a method.
        /// </summary>
        Method = 64,
        /// <summary>
        /// Attribute can be applied to a module.
        /// </summary>
        Module = 2,
        /// <summary>
        /// Attribute can be applied to a parameter.
        /// </summary>
        Parameter = 2048,
        /// <summary>
        /// Attribute can be applied to a property.
        /// </summary>
        Property = 128,
        /// <summary>
        /// Attribute can be applied to a return value.
        /// </summary>
        ReturnValue = 8192,
        /// <summary>
        /// Attribute can be applied to a structure; that is, a value type.
        /// </summary>
        Struct = 8,
    }
    /// <summary>
    /// Specifies the usage of another attribute class. This class cannot be inherited.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(4), Inherited = true)]
    public sealed partial class AttributeUsageAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="AttributeUsageAttribute" /> class with
        /// the specified list of <see cref="AttributeTargets" />, the
        /// <see cref="AllowMultiple" /> value, and the <see cref="Inherited" /> value.
        /// </summary>
        /// <param name="validOn">
        /// The set of values combined using a bitwise OR operation to indicate which program elements
        /// are valid.
        /// </param>
        public AttributeUsageAttribute(System.AttributeTargets validOn) { }
        /// <summary>
        /// Gets or sets a Boolean value indicating whether more than one instance of the indicated attribute
        /// can be specified for a single program element.
        /// </summary>
        /// <returns>
        /// true if more than one instance is allowed to be specified; otherwise, false. The default is
        /// false.
        /// </returns>
        public bool AllowMultiple { get { return default(bool); } set { } }
        /// <summary>
        /// Gets or sets a <see cref="Boolean" /> value that determines whether the indicated
        /// attribute is inherited by derived classes and overriding members.
        /// </summary>
        /// <returns>
        /// true if the attribute can be inherited by derived classes and overriding members; otherwise,
        /// false. The default is true.
        /// </returns>
        public bool Inherited { get { return default(bool); } set { } }
        /// <summary>
        /// Gets a set of values identifying which program elements that the indicated attribute can be
        /// applied to.
        /// </summary>
        /// <returns>
        /// One or several <see cref="AttributeTargets" /> values. The default is All.
        /// </returns>
        public System.AttributeTargets ValidOn { get { return default(System.AttributeTargets); } }
    }
    /// <summary>
    /// The exception that is thrown when the file image of a dynamic link library (DLL) or an executable
    /// program is invalid.
    /// </summary>
    public partial class BadImageFormatException : System.Exception
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="BadImageFormatException" /> class.
        /// </summary>
        public BadImageFormatException() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="BadImageFormatException" /> class with
        /// a specified error message.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        public BadImageFormatException(string message) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="BadImageFormatException" /> class with
        /// a specified error message and a reference to the inner exception that is the cause of this
        /// exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="inner">
        /// The exception that is the cause of the current exception. If the <paramref name="inner" />
        /// parameter is not a null reference, the current exception is raised in a catch block that handles
        /// the inner exception.
        /// </param>
        public BadImageFormatException(string message, System.Exception inner) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="BadImageFormatException" /> class with
        /// a specified error message and file name.
        /// </summary>
        /// <param name="message">A message that describes the error.</param>
        /// <param name="fileName">The full name of the file with the invalid image.</param>
        public BadImageFormatException(string message, string fileName) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="BadImageFormatException" /> class with
        /// a specified error message and a reference to the inner exception that is the cause of this
        /// exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="fileName">The full name of the file with the invalid image.</param>
        /// <param name="inner">
        /// The exception that is the cause of the current exception. If the <paramref name="inner" />
        /// parameter is not null, the current exception is raised in a catch block that handles the inner
        /// exception.
        /// </param>
        public BadImageFormatException(string message, string fileName, System.Exception inner) { }
        /// <summary>
        /// Gets the name of the file that causes this exception.
        /// </summary>
        /// <returns>
        /// The name of the file with the invalid image, or a null reference if no file name was passed
        /// to the constructor for the current instance.
        /// </returns>
        public string FileName { get { return default(string); } }
        /// <summary>
        /// Gets the error message and the name of the file that caused this exception.
        /// </summary>
        /// <returns>
        /// A string containing the error message and the name of the file that caused this exception.
        /// </returns>
        public override string Message { get { return default(string); } }
        /// <summary>
        /// Returns the fully qualified name of this exception and possibly the error message, the name
        /// of the inner exception, and the stack trace.
        /// </summary>
        /// <returns>
        /// A string containing the fully qualified name of this exception and possibly the error message,
        /// the name of the inner exception, and the stack trace.
        /// </returns>
        public override string ToString() { return default(string); }
    }
    /// <summary>
    /// Represents a Boolean (true or false) value.
    /// </summary>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct Boolean : System.IComparable, System.IComparable<bool>, System.IConvertible, System.IEquatable<bool>
    {
        /// <summary>
        /// Represents the Boolean value false as a string. This field is read-only.
        /// </summary>
        public static readonly string FalseString;
        /// <summary>
        /// Represents the Boolean value true as a string. This field is read-only.
        /// </summary>
        public static readonly string TrueString;
        /// <summary>
        /// Compares this instance to a specified <see cref="Boolean" /> object and returns an
        /// integer that indicates their relationship to one another.
        /// </summary>
        /// <param name="value">A <see cref="Boolean" /> object to compare to this instance.</param>
        /// <returns>
        /// A signed integer that indicates the relative values of this instance and <paramref name="value" />.
        /// Return Value Condition Less than zero This instance is false and <paramref name="value" />
        /// is true. Zero This instance and <paramref name="value" /> are equal (either both are true
        /// or both are false). Greater than zero This instance is true and <paramref name="value" />
        /// is false.
        /// </returns>
        public int CompareTo(bool value) { return default(int); }
        /// <summary>
        /// Returns a value indicating whether this instance is equal to a specified <see cref="Boolean" />
        /// object.
        /// </summary>
        /// <param name="obj">A <see cref="Boolean" /> value to compare to this instance.</param>
        /// <returns>
        /// true if <paramref name="obj" /> has the same value as this instance; otherwise, false.
        /// </returns>
        public bool Equals(bool obj) { return default(bool); }
        /// <summary>
        /// Returns a value indicating whether this instance is equal to a specified object.
        /// </summary>
        /// <param name="obj">An object to compare to this instance.</param>
        /// <returns>
        /// true if <paramref name="obj" /> is a <see cref="Boolean" /> and has the same value
        /// as this instance; otherwise, false.
        /// </returns>
        public override bool Equals(object obj) { return default(bool); }
        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>
        /// A hash code for the current <see cref="Boolean" />.
        /// </returns>
        public override int GetHashCode() { return default(int); }
        /// <summary>
        /// Converts the specified string representation of a logical value to its <see cref="Boolean" />
        /// equivalent.
        /// </summary>
        /// <param name="value">A string containing the value to convert.</param>
        /// <returns>
        /// true if <paramref name="value" /> is equivalent to <see cref="TrueString" />;
        /// false if <paramref name="value" /> is equivalent to <see cref="FalseString" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="value" /> is null.</exception>
        /// <exception cref="FormatException">
        /// <paramref name="value" /> is not equivalent to <see cref="TrueString" />
        /// or <see cref="FalseString" />.
        /// </exception>
        public static bool Parse(string value) { return default(bool); }
        int System.IComparable.CompareTo(object obj) { return default(int); }
        System.TypeCode System.IConvertible.GetTypeCode() { return default(System.TypeCode); }
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) { return default(bool); }
        byte System.IConvertible.ToByte(System.IFormatProvider provider) { return default(byte); }
        char System.IConvertible.ToChar(System.IFormatProvider provider) { return default(char); }
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) { return default(System.DateTime); }
        decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) { return default(decimal); }
        double System.IConvertible.ToDouble(System.IFormatProvider provider) { return default(double); }
        short System.IConvertible.ToInt16(System.IFormatProvider provider) { return default(short); }
        int System.IConvertible.ToInt32(System.IFormatProvider provider) { return default(int); }
        long System.IConvertible.ToInt64(System.IFormatProvider provider) { return default(long); }
        sbyte System.IConvertible.ToSByte(System.IFormatProvider provider) { return default(sbyte); }
        float System.IConvertible.ToSingle(System.IFormatProvider provider) { return default(float); }
        string System.IConvertible.ToString(System.IFormatProvider provider) { return default(string); }
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) { return default(object); }
        ushort System.IConvertible.ToUInt16(System.IFormatProvider provider) { return default(ushort); }
        uint System.IConvertible.ToUInt32(System.IFormatProvider provider) { return default(uint); }
        ulong System.IConvertible.ToUInt64(System.IFormatProvider provider) { return default(ulong); }
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation (either "True"
        /// or "False").
        /// </summary>
        /// <returns>
        /// "True" (the value of the <see cref="TrueString" /> property) if the value
        /// of this instance is true, or "False" (the value of the <see cref="FalseString" />
        /// property) if the value of this instance is false.
        /// </returns>
        public override string ToString() { return default(string); }
        /// <summary>
        /// Tries to convert the specified string representation of a logical value to its <see cref="Boolean" />
        /// equivalent. A return value indicates whether the conversion succeeded or failed.
        /// </summary>
        /// <param name="value">A string containing the value to convert.</param>
        /// <param name="result">
        /// When this method returns, if the conversion succeeded, contains true if <paramref name="value" />
        /// is equal to <see cref="TrueString" /> or false if <paramref name="value" />
        /// is equal to <see cref="FalseString" />. If the conversion failed, contains
        /// false. The conversion fails if <paramref name="value" /> is null or is not equal to the value
        /// of either the <see cref="TrueString" /> or <see cref="FalseString" />
        /// field.
        /// </param>
        /// <returns>
        /// true if <paramref name="value" /> was converted successfully; otherwise, false.
        /// </returns>
        public static bool TryParse(string value, out bool result) { result = default(bool); return default(bool); }
    }
    /// <summary>
    /// Manipulates arrays of primitive types.
    /// </summary>
    public static partial class Buffer
    {
        /// <summary>
        /// Copies a specified number of bytes from a source array starting at a particular offset to a
        /// destination array starting at a particular offset.
        /// </summary>
        /// <param name="src">The source buffer.</param>
        /// <param name="srcOffset">The zero-based byte offset into <paramref name="src" />.</param>
        /// <param name="dst">The destination buffer.</param>
        /// <param name="dstOffset">The zero-based byte offset into <paramref name="dst" />.</param>
        /// <param name="count">The number of bytes to copy.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="src" /> or <paramref name="dst" /> is null.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="src" /> or <paramref name="dst" /> is not an array of primitives.-or- The
        /// number of bytes in <paramref name="src" /> is less than <paramref name="srcOffset" /> plus
        /// <paramref name="count" />.-or- The number of bytes in <paramref name="dst" /> is less than
        /// <paramref name="dstOffset" /> plus <paramref name="count" />.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="srcOffset" />, <paramref name="dstOffset" />, or <paramref name="count" />
        /// is less than 0.
        /// </exception>
        public static void BlockCopy(System.Array src, int srcOffset, System.Array dst, int dstOffset, int count) { }
        /// <summary>
        /// Returns the number of bytes in the specified array.
        /// </summary>
        /// <param name="array">An array.</param>
        /// <returns>
        /// The number of bytes in the array.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="array" /> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="array" /> is not a primitive.</exception>
        /// <exception cref="OverflowException">
        /// <paramref name="array" /> is larger than 2 gigabytes (GB).
        /// </exception>
        public static int ByteLength(System.Array array) { return default(int); }
        /// <summary>
        /// Retrieves the byte at a specified location in a specified array.
        /// </summary>
        /// <param name="array">An array.</param>
        /// <param name="index">A location in the array.</param>
        /// <returns>
        /// Returns the <paramref name="index" /> byte in the array.
        /// </returns>
        /// <exception cref="ArgumentException"><paramref name="array" /> is not a primitive.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="array" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is negative or greater than the length of <paramref name="array" />.
        /// </exception>
        /// <exception cref="OverflowException">
        /// <paramref name="array" /> is larger than 2 gigabytes (GB).
        /// </exception>
        public static byte GetByte(System.Array array, int index) { return default(byte); }
        /// <summary>
        /// Copies a number of bytes specified as a long integer value from one address in memory to another.
        /// This API is not CLS-compliant.
        /// </summary>
        /// <param name="source">The address of the bytes to copy.</param>
        /// <param name="destination">The target address.</param>
        /// <param name="destinationSizeInBytes">The number of bytes available in the destination memory block.</param>
        /// <param name="sourceBytesToCopy">The number of bytes to copy.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="sourceBytesToCopy" /> is greater than <paramref name="destinationSizeInBytes" />.
        /// </exception>
        [System.CLSCompliantAttribute(false)]
        [System.Security.SecurityCriticalAttribute]
        public unsafe static void MemoryCopy(void* source, void* destination, long destinationSizeInBytes, long sourceBytesToCopy) { }
        /// <summary>
        /// Copies a number of bytes specified as an unsigned long integer value from one address in memory
        /// to another. This API is not CLS-compliant.
        /// </summary>
        /// <param name="source">The address of the bytes to copy.</param>
        /// <param name="destination">The target address.</param>
        /// <param name="destinationSizeInBytes">The number of bytes available in the destination memory block.</param>
        /// <param name="sourceBytesToCopy">The number of bytes to copy.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="sourceBytesToCopy" /> is greater than <paramref name="destinationSizeInBytes" />.
        /// </exception>
        [System.CLSCompliantAttribute(false)]
        [System.Security.SecurityCriticalAttribute]
        public unsafe static void MemoryCopy(void* source, void* destination, ulong destinationSizeInBytes, ulong sourceBytesToCopy) { }
        /// <summary>
        /// Assigns a specified value to a byte at a particular location in a specified array.
        /// </summary>
        /// <param name="array">An array.</param>
        /// <param name="index">A location in the array.</param>
        /// <param name="value">A value to assign.</param>
        /// <exception cref="ArgumentException"><paramref name="array" /> is not a primitive.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="array" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is negative or greater than the length of <paramref name="array" />.
        /// </exception>
        /// <exception cref="OverflowException">
        /// <paramref name="array" /> is larger than 2 gigabytes (GB).
        /// </exception>
        public static void SetByte(System.Array array, int index, byte value) { }
    }
    /// <summary>
    /// Represents an 8-bit unsigned integer.
    /// </summary>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct Byte : System.IComparable, System.IComparable<byte>, System.IConvertible, System.IEquatable<byte>, System.IFormattable
    {
        /// <summary>
        /// Represents the largest possible value of a <see cref="Byte" />. This field is constant.
        /// </summary>
        public const byte MaxValue = (byte)255;
        /// <summary>
        /// Represents the smallest possible value of a <see cref="Byte" />. This field is constant.
        /// </summary>
        public const byte MinValue = (byte)0;
        /// <summary>
        /// Compares this instance to a specified 8-bit unsigned integer and returns an indication of their
        /// relative values.
        /// </summary>
        /// <param name="value">An 8-bit unsigned integer to compare.</param>
        /// <returns>
        /// A signed integer that indicates the relative order of this instance and <paramref name="value" />.
        /// Return Value Description Less than zero This instance is less than <paramref name="value" />.
        /// Zero This instance is equal to <paramref name="value" />. Greater than zero This instance
        /// is greater than <paramref name="value" />.
        /// </returns>
        public int CompareTo(byte value) { return default(int); }
        /// <summary>
        /// Returns a value indicating whether this instance and a specified <see cref="Byte" />
        /// object represent the same value.
        /// </summary>
        /// <param name="obj">An object to compare to this instance.</param>
        /// <returns>
        /// true if <paramref name="obj" /> is equal to this instance; otherwise, false.
        /// </returns>
        public bool Equals(byte obj) { return default(bool); }
        /// <summary>
        /// Returns a value indicating whether this instance is equal to a specified object.
        /// </summary>
        /// <param name="obj">An object to compare with this instance, or null.</param>
        /// <returns>
        /// true if <paramref name="obj" /> is an instance of <see cref="Byte" /> and equals
        /// the value of this instance; otherwise, false.
        /// </returns>
        public override bool Equals(object obj) { return default(bool); }
        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>
        /// A hash code for the current <see cref="Byte" />.
        /// </returns>
        public override int GetHashCode() { return default(int); }
        /// <summary>
        /// Converts the string representation of a number to its <see cref="Byte" /> equivalent.
        /// </summary>
        /// <param name="s">
        /// A string that contains a number to convert. The string is interpreted using the
        /// <see cref="Globalization.NumberStyles.Integer" /> style.
        /// </param>
        /// <returns>
        /// A byte value that is equivalent to the number contained in <paramref name="s" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="FormatException"><paramref name="s" /> is not of the correct format.</exception>
        /// <exception cref="OverflowException">
        /// <paramref name="s" /> represents a number less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />.
        /// </exception>
        public static byte Parse(string s) { return default(byte); }
        /// <summary>
        /// Converts the string representation of a number in a specified style to its <see cref="Byte" />
        /// equivalent.
        /// </summary>
        /// <param name="s">
        /// A string that contains a number to convert. The string is interpreted using the style specified
        /// by <paramref name="style" />.
        /// </param>
        /// <param name="style">
        /// A bitwise combination of enumeration values that indicates the style elements that can be
        /// present in <paramref name="s" />. A typical value to specify is
        /// <see cref="Globalization.NumberStyles.Integer" />.
        /// </param>
        /// <returns>
        /// A byte value that is equivalent to the number contained in <paramref name="s" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="FormatException"><paramref name="s" /> is not of the correct format.</exception>
        /// <exception cref="OverflowException">
        /// <paramref name="s" /> represents a number less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />. -or-<paramref name="s" /> includes
        /// non-zero, fractional digits.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="style" /> is not a <see cref="Globalization.NumberStyles" /> value.
        /// -or-<paramref name="style" /> is not a combination of
        /// <see cref="Globalization.NumberStyles.AllowHexSpecifier" /> and <see cref="Globalization.NumberStyles.HexNumber" /> values.
        /// </exception>
        public static byte Parse(string s, System.Globalization.NumberStyles style) { return default(byte); }
        /// <summary>
        /// Converts the string representation of a number in a specified style and culture-specific format
        /// to its <see cref="Byte" /> equivalent.
        /// </summary>
        /// <param name="s">
        /// A string that contains a number to convert. The string is interpreted using the style specified
        /// by <paramref name="style" />.
        /// </param>
        /// <param name="style">
        /// A bitwise combination of enumeration values that indicates the style elements that can be
        /// present in <paramref name="s" />. A typical value to specify is
        /// <see cref="Globalization.NumberStyles.Integer" />.
        /// </param>
        /// <param name="provider">
        /// An object that supplies culture-specific information about the format of <paramref name="s" />.
        /// If <paramref name="provider" /> is null, the thread current culture is used.
        /// </param>
        /// <returns>
        /// A byte value that is equivalent to the number contained in <paramref name="s" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="FormatException"><paramref name="s" /> is not of the correct format.</exception>
        /// <exception cref="OverflowException">
        /// <paramref name="s" /> represents a number less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />. -or-<paramref name="s" /> includes
        /// non-zero, fractional digits.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="style" /> is not a <see cref="Globalization.NumberStyles" /> value.
        /// -or-<paramref name="style" /> is not a combination of
        /// <see cref="Globalization.NumberStyles.AllowHexSpecifier" /> and <see cref="Globalization.NumberStyles.HexNumber" /> values.
        /// </exception>
        public static byte Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider) { return default(byte); }
        /// <summary>
        /// Converts the string representation of a number in a specified culture-specific format to its
        /// <see cref="Byte" /> equivalent.
        /// </summary>
        /// <param name="s">
        /// A string that contains a number to convert. The string is interpreted using the
        /// <see cref="Globalization.NumberStyles.Integer" /> style.
        /// </param>
        /// <param name="provider">
        /// An object that supplies culture-specific parsing information about <paramref name="s" />.
        /// If <paramref name="provider" /> is null, the thread current culture is used.
        /// </param>
        /// <returns>
        /// A byte value that is equivalent to the number contained in <paramref name="s" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="FormatException"><paramref name="s" /> is not of the correct format.</exception>
        /// <exception cref="OverflowException">
        /// <paramref name="s" /> represents a number less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />.
        /// </exception>
        public static byte Parse(string s, System.IFormatProvider provider) { return default(byte); }
        int System.IComparable.CompareTo(object value) { return default(int); }
        System.TypeCode System.IConvertible.GetTypeCode() { return default(System.TypeCode); }
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) { return default(bool); }
        byte System.IConvertible.ToByte(System.IFormatProvider provider) { return default(byte); }
        char System.IConvertible.ToChar(System.IFormatProvider provider) { return default(char); }
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) { return default(System.DateTime); }
        decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) { return default(decimal); }
        double System.IConvertible.ToDouble(System.IFormatProvider provider) { return default(double); }
        short System.IConvertible.ToInt16(System.IFormatProvider provider) { return default(short); }
        int System.IConvertible.ToInt32(System.IFormatProvider provider) { return default(int); }
        long System.IConvertible.ToInt64(System.IFormatProvider provider) { return default(long); }
        sbyte System.IConvertible.ToSByte(System.IFormatProvider provider) { return default(sbyte); }
        float System.IConvertible.ToSingle(System.IFormatProvider provider) { return default(float); }
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) { return default(object); }
        ushort System.IConvertible.ToUInt16(System.IFormatProvider provider) { return default(ushort); }
        uint System.IConvertible.ToUInt32(System.IFormatProvider provider) { return default(uint); }
        ulong System.IConvertible.ToUInt64(System.IFormatProvider provider) { return default(ulong); }
        /// <summary>
        /// Converts the value of the current <see cref="Byte" /> object to its equivalent string
        /// representation.
        /// </summary>
        /// <returns>
        /// The string representation of the value of this object, which consists of a sequence of digits
        /// that range from 0 to 9 with no leading zeroes.
        /// </returns>
        public override string ToString() { return default(string); }
        /// <summary>
        /// Converts the numeric value of the current <see cref="Byte" /> object to its equivalent
        /// string representation using the specified culture-specific formatting information.
        /// </summary>
        /// <param name="provider">An object that supplies culture-specific formatting information.</param>
        /// <returns>
        /// The string representation of the value of this object in the format specified by the
        /// <paramref name="provider" /> parameter.
        /// </returns>
        public string ToString(System.IFormatProvider provider) { return default(string); }
        /// <summary>
        /// Converts the value of the current <see cref="Byte" /> object to its equivalent string
        /// representation using the specified format.
        /// </summary>
        /// <param name="format">A numeric format string.</param>
        /// <returns>
        /// The string representation of the current <see cref="Byte" /> object, formatted as
        /// specified by the <paramref name="format" /> parameter.
        /// </returns>
        /// <exception cref="FormatException">
        /// <paramref name="format" /> includes an unsupported specifier. Supported format specifiers
        /// are listed in the Remarks section.
        /// </exception>
        public string ToString(string format) { return default(string); }
        /// <summary>
        /// Converts the value of the current <see cref="Byte" /> object to its equivalent string
        /// representation using the specified format and culture-specific formatting information.
        /// </summary>
        /// <param name="format">A standard or custom numeric format string.</param>
        /// <param name="provider">An object that supplies culture-specific formatting information.</param>
        /// <returns>
        /// The string representation of the current <see cref="Byte" /> object, formatted as
        /// specified by the <paramref name="format" /> and <paramref name="provider" /> parameters.
        /// </returns>
        /// <exception cref="FormatException">
        /// <paramref name="format" /> includes an unsupported specifier. Supported format specifiers
        /// are listed in the Remarks section.
        /// </exception>
        public string ToString(string format, System.IFormatProvider provider) { return default(string); }
        /// <summary>
        /// Tries to convert the string representation of a number to its <see cref="Byte" />
        /// equivalent, and returns a value that indicates whether the conversion succeeded.
        /// </summary>
        /// <param name="s">
        /// A string that contains a number to convert. The string is interpreted using the
        /// <see cref="Globalization.NumberStyles.Integer" /> style.
        /// </param>
        /// <param name="result">
        /// When this method returns, contains the <see cref="Byte" /> value equivalent to the
        /// number contained in <paramref name="s" /> if the conversion succeeded, or zero if the conversion
        /// failed. This parameter is passed uninitialized; any value originally supplied in <paramref name="result" />
        /// will be overwritten.
        /// </param>
        /// <returns>
        /// true if <paramref name="s" /> was converted successfully; otherwise, false.
        /// </returns>
        public static bool TryParse(string s, out byte result) { result = default(byte); return default(bool); }
        /// <summary>
        /// Converts the string representation of a number in a specified style and culture-specific format
        /// to its <see cref="Byte" /> equivalent. A return value indicates whether the conversion
        /// succeeded or failed.
        /// </summary>
        /// <param name="s">
        /// A string containing a number to convert. The string is interpreted using the style specified
        /// by <paramref name="style" />.
        /// </param>
        /// <param name="style">
        /// A bitwise combination of enumeration values that indicates the style elements that can be
        /// present in <paramref name="s" />. A typical value to specify is
        /// <see cref="Globalization.NumberStyles.Integer" />.
        /// </param>
        /// <param name="provider">
        /// An object that supplies culture-specific formatting information about <paramref name="s" />.
        /// If <paramref name="provider" /> is null, the thread current culture is used.
        /// </param>
        /// <param name="result">
        /// When this method returns, contains the 8-bit unsigned integer value equivalent to the number
        /// contained in <paramref name="s" /> if the conversion succeeded, or zero if the conversion
        /// failed. The conversion fails if the <paramref name="s" /> parameter is null  or <see cref="String.Empty" />,
        /// is not of the correct format, or represents a number less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />. This parameter is passed uninitialized;
        /// any value originally supplied in <paramref name="result" /> will be overwritten.
        /// </param>
        /// <returns>
        /// true if <paramref name="s" /> was converted successfully; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// <paramref name="style" /> is not a <see cref="Globalization.NumberStyles" /> value.
        /// -or-<paramref name="style" /> is not a combination of
        /// <see cref="Globalization.NumberStyles.AllowHexSpecifier" /> and <see cref="Globalization.NumberStyles.HexNumber" /> values.
        /// </exception>
        public static bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out byte result) { result = default(byte); return default(bool); }
    }
    /// <summary>
    /// Represents a character as a UTF-16 code unit.
    /// </summary>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct Char : System.IComparable, System.IComparable<char>, System.IConvertible, System.IEquatable<char>
    {
        /// <summary>
        /// Represents the largest possible value of a <see cref="Char" />. This field is constant.
        /// </summary>
        public const char MaxValue = '\uFFFF';
        /// <summary>
        /// Represents the smallest possible value of a <see cref="Char" />. This field is constant.
        /// </summary>
        public const char MinValue = '\0';
        /// <summary>
        /// Compares this instance to a specified <see cref="Char" /> object and indicates whether
        /// this instance precedes, follows, or appears in the same position in the sort order as the
        /// specified <see cref="Char" /> object.
        /// </summary>
        /// <param name="value">A <see cref="Char" /> object to compare.</param>
        /// <returns>
        /// A signed number indicating the position of this instance in the sort order in relation to
        /// the <paramref name="value" /> parameter.Return Value Description Less than zero This instance
        /// precedes <paramref name="value" />. Zero This instance has the same position in the sort order
        /// as <paramref name="value" />. Greater than zero This instance follows <paramref name="value" />.
        /// </returns>
        public int CompareTo(char value) { return default(int); }
        /// <summary>
        /// Converts the specified Unicode code point into a UTF-16 encoded string.
        /// </summary>
        /// <param name="utf32">A 21-bit Unicode code point.</param>
        /// <returns>
        /// A string consisting of one <see cref="Char" /> object or a surrogate pair of
        /// <see cref="Char" /> objects equivalent to the code point specified by the <paramref name="utf32" />
        /// parameter.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="utf32" /> is not a valid 21-bit Unicode code point ranging from U+0 through
        /// U+10FFFF, excluding the surrogate pair range from U+D800 through U+DFFF.
        /// </exception>
        public static string ConvertFromUtf32(int utf32) { return default(string); }
        /// <summary>
        /// Converts the value of a UTF-16 encoded surrogate pair into a Unicode code point.
        /// </summary>
        /// <param name="highSurrogate">
        /// A high surrogate code unit (that is, a code unit ranging from U+D800 through U+DBFF).
        /// </param>
        /// <param name="lowSurrogate">
        /// A low surrogate code unit (that is, a code unit ranging from U+DC00 through U+DFFF).
        /// </param>
        /// <returns>
        /// The 21-bit Unicode code point represented by the <paramref name="highSurrogate" /> and
        /// <paramref name="lowSurrogate" /> parameters.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="highSurrogate" /> is not in the range U+D800 through U+DBFF, or
        /// <paramref name="lowSurrogate" /> is not in the range U+DC00 through U+DFFF.
        /// </exception>
        public static int ConvertToUtf32(char highSurrogate, char lowSurrogate) { return default(int); }
        /// <summary>
        /// Converts the value of a UTF-16 encoded character or surrogate pair at a specified position
        /// in a string into a Unicode code point.
        /// </summary>
        /// <param name="s">A string that contains a character or surrogate pair.</param>
        /// <param name="index">The index position of the character or surrogate pair in <paramref name="s" />.</param>
        /// <returns>
        /// The 21-bit Unicode code point represented by the character or surrogate pair at the position
        /// in the <paramref name="s" /> parameter specified by the <paramref name="index" /> parameter.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is not a position within <paramref name="s" />.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// The specified index position contains a surrogate pair, and either the first character in the
        /// pair is not a valid high surrogate or the second character in the pair is not a valid low surrogate.
        /// </exception>
        public static int ConvertToUtf32(string s, int index) { return default(int); }
        /// <summary>
        /// Returns a value that indicates whether this instance is equal to the specified <see cref="Char" />
        /// object.
        /// </summary>
        /// <param name="obj">An object to compare to this instance.</param>
        /// <returns>
        /// true if the <paramref name="obj" /> parameter equals the value of this instance; otherwise,
        /// false.
        /// </returns>
        public bool Equals(char obj) { return default(bool); }
        /// <summary>
        /// Returns a value that indicates whether this instance is equal to a specified object.
        /// </summary>
        /// <param name="obj">An object to compare with this instance or null.</param>
        /// <returns>
        /// true if <paramref name="obj" /> is an instance of <see cref="Char" /> and equals
        /// the value of this instance; otherwise, false.
        /// </returns>
        public override bool Equals(object obj) { return default(bool); }
        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code.
        /// </returns>
        public override int GetHashCode() { return default(int); }
        /// <summary>
        /// Converts the specified numeric Unicode character to a double-precision floating point number.
        /// </summary>
        /// <param name="c">The Unicode character to convert.</param>
        /// <returns>
        /// The numeric value of <paramref name="c" /> if that character represents a number; otherwise,
        /// -1.0.
        /// </returns>
        public static double GetNumericValue(char c) { return default(double); }
        /// <summary>
        /// Converts the numeric Unicode character at the specified position in a specified string to a
        /// double-precision floating point number.
        /// </summary>
        /// <param name="s">A <see cref="String" />.</param>
        /// <param name="index">The character position in <paramref name="s" />.</param>
        /// <returns>
        /// The numeric value of the character at position <paramref name="index" /> in <paramref name="s" />
        /// if that character represents a number; otherwise, -1.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than zero or greater than the last position in <paramref name="s" />.
        /// </exception>
        public static double GetNumericValue(string s, int index) { return default(double); }
        /// <summary>
        /// Indicates whether the specified Unicode character is categorized as a control character.
        /// </summary>
        /// <param name="c">The Unicode character to evaluate.</param>
        /// <returns>
        /// true if <paramref name="c" /> is a control character; otherwise, false.
        /// </returns>
        public static bool IsControl(char c) { return default(bool); }
        /// <summary>
        /// Indicates whether the character at the specified position in a specified string is categorized
        /// as a control character.
        /// </summary>
        /// <param name="s">A string.</param>
        /// <param name="index">The position of the character to evaluate in <paramref name="s" />.</param>
        /// <returns>
        /// true if the character at position <paramref name="index" /> in <paramref name="s" /> is a
        /// control character; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than zero or greater than the last position in <paramref name="s" />.
        /// </exception>
        public static bool IsControl(string s, int index) { return default(bool); }
        /// <summary>
        /// Indicates whether the specified Unicode character is categorized as a decimal digit.
        /// </summary>
        /// <param name="c">The Unicode character to evaluate.</param>
        /// <returns>
        /// true if <paramref name="c" /> is a decimal digit; otherwise, false.
        /// </returns>
        public static bool IsDigit(char c) { return default(bool); }
        /// <summary>
        /// Indicates whether the character at the specified position in a specified string is categorized
        /// as a decimal digit.
        /// </summary>
        /// <param name="s">A string.</param>
        /// <param name="index">The position of the character to evaluate in <paramref name="s" />.</param>
        /// <returns>
        /// true if the character at position <paramref name="index" /> in <paramref name="s" /> is a
        /// decimal digit; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than zero or greater than the last position in <paramref name="s" />.
        /// </exception>
        public static bool IsDigit(string s, int index) { return default(bool); }
        /// <summary>
        /// Indicates whether the specified <see cref="Char" /> object is a high surrogate.
        /// </summary>
        /// <param name="c">The Unicode character to evaluate.</param>
        /// <returns>
        /// true if the numeric value of the <paramref name="c" /> parameter ranges from U+D800 through
        /// U+DBFF; otherwise, false.
        /// </returns>
        public static bool IsHighSurrogate(char c) { return default(bool); }
        /// <summary>
        /// Indicates whether the <see cref="Char" /> object at the specified position in a string
        /// is a high surrogate.
        /// </summary>
        /// <param name="s">A string.</param>
        /// <param name="index">The position of the character to evaluate in <paramref name="s" />.</param>
        /// <returns>
        /// true if the numeric value of the specified character in the <paramref name="s" /> parameter
        /// ranges from U+D800 through U+DBFF; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is not a position within <paramref name="s" />.
        /// </exception>
        public static bool IsHighSurrogate(string s, int index) { return default(bool); }
        /// <summary>
        /// Indicates whether the specified Unicode character is categorized as a Unicode letter.
        /// </summary>
        /// <param name="c">The Unicode character to evaluate.</param>
        /// <returns>
        /// true if <paramref name="c" /> is a letter; otherwise, false.
        /// </returns>
        public static bool IsLetter(char c) { return default(bool); }
        /// <summary>
        /// Indicates whether the character at the specified position in a specified string is categorized
        /// as a Unicode letter.
        /// </summary>
        /// <param name="s">A string.</param>
        /// <param name="index">The position of the character to evaluate in <paramref name="s" />.</param>
        /// <returns>
        /// true if the character at position <paramref name="index" /> in <paramref name="s" /> is a
        /// letter; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than zero or greater than the last position in <paramref name="s" />.
        /// </exception>
        public static bool IsLetter(string s, int index) { return default(bool); }
        /// <summary>
        /// Indicates whether the specified Unicode character is categorized as a letter or a decimal digit.
        /// </summary>
        /// <param name="c">The Unicode character to evaluate.</param>
        /// <returns>
        /// true if <paramref name="c" /> is a letter or a decimal digit; otherwise, false.
        /// </returns>
        public static bool IsLetterOrDigit(char c) { return default(bool); }
        /// <summary>
        /// Indicates whether the character at the specified position in a specified string is categorized
        /// as a letter or a decimal digit.
        /// </summary>
        /// <param name="s">A string.</param>
        /// <param name="index">The position of the character to evaluate in <paramref name="s" />.</param>
        /// <returns>
        /// true if the character at position <paramref name="index" /> in <paramref name="s" /> is a
        /// letter or a decimal digit; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than zero or greater than the last position in <paramref name="s" />.
        /// </exception>
        public static bool IsLetterOrDigit(string s, int index) { return default(bool); }
        /// <summary>
        /// Indicates whether the specified Unicode character is categorized as a lowercase letter.
        /// </summary>
        /// <param name="c">The Unicode character to evaluate.</param>
        /// <returns>
        /// true if <paramref name="c" /> is a lowercase letter; otherwise, false.
        /// </returns>
        public static bool IsLower(char c) { return default(bool); }
        /// <summary>
        /// Indicates whether the character at the specified position in a specified string is categorized
        /// as a lowercase letter.
        /// </summary>
        /// <param name="s">A string.</param>
        /// <param name="index">The position of the character to evaluate in <paramref name="s" />.</param>
        /// <returns>
        /// true if the character at position <paramref name="index" /> in <paramref name="s" /> is a
        /// lowercase letter; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than zero or greater than the last position in <paramref name="s" />.
        /// </exception>
        public static bool IsLower(string s, int index) { return default(bool); }
        /// <summary>
        /// Indicates whether the specified <see cref="Char" /> object is a low surrogate.
        /// </summary>
        /// <param name="c">The character to evaluate.</param>
        /// <returns>
        /// true if the numeric value of the <paramref name="c" /> parameter ranges from U+DC00 through
        /// U+DFFF; otherwise, false.
        /// </returns>
        public static bool IsLowSurrogate(char c) { return default(bool); }
        /// <summary>
        /// Indicates whether the <see cref="Char" /> object at the specified position in a string
        /// is a low surrogate.
        /// </summary>
        /// <param name="s">A string.</param>
        /// <param name="index">The position of the character to evaluate in <paramref name="s" />.</param>
        /// <returns>
        /// true if the numeric value of the specified character in the <paramref name="s" /> parameter
        /// ranges from U+DC00 through U+DFFF; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is not a position within <paramref name="s" />.
        /// </exception>
        public static bool IsLowSurrogate(string s, int index) { return default(bool); }
        /// <summary>
        /// Indicates whether the specified Unicode character is categorized as a number.
        /// </summary>
        /// <param name="c">The Unicode character to evaluate.</param>
        /// <returns>
        /// true if <paramref name="c" /> is a number; otherwise, false.
        /// </returns>
        public static bool IsNumber(char c) { return default(bool); }
        /// <summary>
        /// Indicates whether the character at the specified position in a specified string is categorized
        /// as a number.
        /// </summary>
        /// <param name="s">A string.</param>
        /// <param name="index">The position of the character to evaluate in <paramref name="s" />.</param>
        /// <returns>
        /// true if the character at position <paramref name="index" /> in <paramref name="s" /> is a
        /// number; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than zero or greater than the last position in <paramref name="s" />.
        /// </exception>
        public static bool IsNumber(string s, int index) { return default(bool); }
        /// <summary>
        /// Indicates whether the specified Unicode character is categorized as a punctuation mark.
        /// </summary>
        /// <param name="c">The Unicode character to evaluate.</param>
        /// <returns>
        /// true if <paramref name="c" /> is a punctuation mark; otherwise, false.
        /// </returns>
        public static bool IsPunctuation(char c) { return default(bool); }
        /// <summary>
        /// Indicates whether the character at the specified position in a specified string is categorized
        /// as a punctuation mark.
        /// </summary>
        /// <param name="s">A string.</param>
        /// <param name="index">The position of the character to evaluate in <paramref name="s" />.</param>
        /// <returns>
        /// true if the character at position <paramref name="index" /> in <paramref name="s" /> is a
        /// punctuation mark; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than zero or greater than the last position in <paramref name="s" />.
        /// </exception>
        public static bool IsPunctuation(string s, int index) { return default(bool); }
        /// <summary>
        /// Indicates whether the specified Unicode character is categorized as a separator character.
        /// </summary>
        /// <param name="c">The Unicode character to evaluate.</param>
        /// <returns>
        /// true if <paramref name="c" /> is a separator character; otherwise, false.
        /// </returns>
        public static bool IsSeparator(char c) { return default(bool); }
        /// <summary>
        /// Indicates whether the character at the specified position in a specified string is categorized
        /// as a separator character.
        /// </summary>
        /// <param name="s">A string.</param>
        /// <param name="index">The position of the character to evaluate in <paramref name="s" />.</param>
        /// <returns>
        /// true if the character at position <paramref name="index" /> in <paramref name="s" /> is a
        /// separator character; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than zero or greater than the last position in <paramref name="s" />.
        /// </exception>
        public static bool IsSeparator(string s, int index) { return default(bool); }
        /// <summary>
        /// Indicates whether the specified character has a surrogate code unit.
        /// </summary>
        /// <param name="c">The Unicode character to evaluate.</param>
        /// <returns>
        /// true if <paramref name="c" /> is either a high surrogate or a low surrogate; otherwise, false.
        /// </returns>
        public static bool IsSurrogate(char c) { return default(bool); }
        /// <summary>
        /// Indicates whether the character at the specified position in a specified string has a surrogate
        /// code unit.
        /// </summary>
        /// <param name="s">A string.</param>
        /// <param name="index">The position of the character to evaluate in <paramref name="s" />.</param>
        /// <returns>
        /// true if the character at position <paramref name="index" /> in <paramref name="s" /> is a
        /// either a high surrogate or a low surrogate; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than zero or greater than the last position in <paramref name="s" />.
        /// </exception>
        public static bool IsSurrogate(string s, int index) { return default(bool); }
        /// <summary>
        /// Indicates whether the two specified <see cref="Char" /> objects form a surrogate
        /// pair.
        /// </summary>
        /// <param name="highSurrogate">The character to evaluate as the high surrogate of a surrogate pair.</param>
        /// <param name="lowSurrogate">The character to evaluate as the low surrogate of a surrogate pair.</param>
        /// <returns>
        /// true if the numeric value of the <paramref name="highSurrogate" /> parameter ranges from U+D800
        /// through U+DBFF, and the numeric value of the <paramref name="lowSurrogate" /> parameter ranges
        /// from U+DC00 through U+DFFF; otherwise, false.
        /// </returns>
        public static bool IsSurrogatePair(char highSurrogate, char lowSurrogate) { return default(bool); }
        /// <summary>
        /// Indicates whether two adjacent <see cref="Char" /> objects at a specified position
        /// in a string form a surrogate pair.
        /// </summary>
        /// <param name="s">A string.</param>
        /// <param name="index">
        /// The starting position of the pair of characters to evaluate within <paramref name="s" />.
        /// </param>
        /// <returns>
        /// true if the <paramref name="s" /> parameter includes adjacent characters at positions <paramref name="index" />
        /// and <paramref name="index" /> + 1, and the numeric value of the character
        /// at position <paramref name="index" /> ranges from U+D800 through U+DBFF, and the numeric value
        /// of the character at position <paramref name="index" />+1 ranges from U+DC00 through U+DFFF;
        /// otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is not a position within <paramref name="s" />.
        /// </exception>
        public static bool IsSurrogatePair(string s, int index) { return default(bool); }
        /// <summary>
        /// Indicates whether the specified Unicode character is categorized as a symbol character.
        /// </summary>
        /// <param name="c">The Unicode character to evaluate.</param>
        /// <returns>
        /// true if <paramref name="c" /> is a symbol character; otherwise, false.
        /// </returns>
        public static bool IsSymbol(char c) { return default(bool); }
        /// <summary>
        /// Indicates whether the character at the specified position in a specified string is categorized
        /// as a symbol character.
        /// </summary>
        /// <param name="s">A string.</param>
        /// <param name="index">The position of the character to evaluate in <paramref name="s" />.</param>
        /// <returns>
        /// true if the character at position <paramref name="index" /> in <paramref name="s" /> is a
        /// symbol character; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than zero or greater than the last position in <paramref name="s" />.
        /// </exception>
        public static bool IsSymbol(string s, int index) { return default(bool); }
        /// <summary>
        /// Indicates whether the specified Unicode character is categorized as an uppercase letter.
        /// </summary>
        /// <param name="c">The Unicode character to evaluate.</param>
        /// <returns>
        /// true if <paramref name="c" /> is an uppercase letter; otherwise, false.
        /// </returns>
        public static bool IsUpper(char c) { return default(bool); }
        /// <summary>
        /// Indicates whether the character at the specified position in a specified string is categorized
        /// as an uppercase letter.
        /// </summary>
        /// <param name="s">A string.</param>
        /// <param name="index">The position of the character to evaluate in <paramref name="s" />.</param>
        /// <returns>
        /// true if the character at position <paramref name="index" /> in <paramref name="s" /> is an
        /// uppercase letter; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than zero or greater than the last position in <paramref name="s" />.
        /// </exception>
        public static bool IsUpper(string s, int index) { return default(bool); }
        /// <summary>
        /// Indicates whether the specified Unicode character is categorized as white space.
        /// </summary>
        /// <param name="c">The Unicode character to evaluate.</param>
        /// <returns>
        /// true if <paramref name="c" /> is white space; otherwise, false.
        /// </returns>
        public static bool IsWhiteSpace(char c) { return default(bool); }
        /// <summary>
        /// Indicates whether the character at the specified position in a specified string is categorized
        /// as white space.
        /// </summary>
        /// <param name="s">A string.</param>
        /// <param name="index">The position of the character to evaluate in <paramref name="s" />.</param>
        /// <returns>
        /// true if the character at position <paramref name="index" /> in <paramref name="s" /> is white
        /// space; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than zero or greater than the last position in <paramref name="s" />.
        /// </exception>
        public static bool IsWhiteSpace(string s, int index) { return default(bool); }
        /// <summary>
        /// Converts the value of the specified string to its equivalent Unicode character.
        /// </summary>
        /// <param name="s">A string that contains a single character, or null.</param>
        /// <returns>
        /// A Unicode character equivalent to the sole character in <paramref name="s" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="FormatException">The length of <paramref name="s" /> is not 1.</exception>
        public static char Parse(string s) { return default(char); }
        int System.IComparable.CompareTo(object value) { return default(int); }
        System.TypeCode System.IConvertible.GetTypeCode() { return default(System.TypeCode); }
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) { return default(bool); }
        byte System.IConvertible.ToByte(System.IFormatProvider provider) { return default(byte); }
        char System.IConvertible.ToChar(System.IFormatProvider provider) { return default(char); }
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) { return default(System.DateTime); }
        decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) { return default(decimal); }
        double System.IConvertible.ToDouble(System.IFormatProvider provider) { return default(double); }
        short System.IConvertible.ToInt16(System.IFormatProvider provider) { return default(short); }
        int System.IConvertible.ToInt32(System.IFormatProvider provider) { return default(int); }
        long System.IConvertible.ToInt64(System.IFormatProvider provider) { return default(long); }
        sbyte System.IConvertible.ToSByte(System.IFormatProvider provider) { return default(sbyte); }
        float System.IConvertible.ToSingle(System.IFormatProvider provider) { return default(float); }
        string System.IConvertible.ToString(System.IFormatProvider provider) { return default(string); }
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) { return default(object); }
        ushort System.IConvertible.ToUInt16(System.IFormatProvider provider) { return default(ushort); }
        uint System.IConvertible.ToUInt32(System.IFormatProvider provider) { return default(uint); }
        ulong System.IConvertible.ToUInt64(System.IFormatProvider provider) { return default(ulong); }
        /// <summary>
        /// Converts the value of a Unicode character to its lowercase equivalent.
        /// </summary>
        /// <param name="c">The Unicode character to convert.</param>
        /// <returns>
        /// The lowercase equivalent of <paramref name="c" />, or the unchanged value of <paramref name="c" />,
        /// if <paramref name="c" /> is already lowercase or not alphabetic.
        /// </returns>
        public static char ToLower(char c) { return default(char); }
        /// <summary>
        /// Converts the value of a Unicode character to its lowercase equivalent using the casing rules
        /// of the invariant culture.
        /// </summary>
        /// <param name="c">The Unicode character to convert.</param>
        /// <returns>
        /// The lowercase equivalent of the <paramref name="c" /> parameter, or the unchanged value of
        /// <paramref name="c" />, if <paramref name="c" /> is already lowercase or not alphabetic.
        /// </returns>
        public static char ToLowerInvariant(char c) { return default(char); }
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// The string representation of the value of this instance.
        /// </returns>
        public override string ToString() { return default(string); }
        /// <summary>
        /// Converts the specified Unicode character to its equivalent string representation.
        /// </summary>
        /// <param name="c">The Unicode character to convert.</param>
        /// <returns>
        /// The string representation of the value of <paramref name="c" />.
        /// </returns>
        public static string ToString(char c) { return default(string); }
        /// <summary>
        /// Converts the value of a Unicode character to its uppercase equivalent.
        /// </summary>
        /// <param name="c">The Unicode character to convert.</param>
        /// <returns>
        /// The uppercase equivalent of <paramref name="c" />, or the unchanged value of <paramref name="c" />
        /// if <paramref name="c" /> is already uppercase, has no uppercase equivalent, or is not alphabetic.
        /// </returns>
        public static char ToUpper(char c) { return default(char); }
        /// <summary>
        /// Converts the value of a Unicode character to its uppercase equivalent using the casing rules
        /// of the invariant culture.
        /// </summary>
        /// <param name="c">The Unicode character to convert.</param>
        /// <returns>
        /// The uppercase equivalent of the <paramref name="c" /> parameter, or the unchanged value of
        /// <paramref name="c" />, if <paramref name="c" /> is already uppercase or not alphabetic.
        /// </returns>
        public static char ToUpperInvariant(char c) { return default(char); }
        /// <summary>
        /// Converts the value of the specified string to its equivalent Unicode character. A return code
        /// indicates whether the conversion succeeded or failed.
        /// </summary>
        /// <param name="s">A string that contains a single character, or null.</param>
        /// <param name="result">
        /// When this method returns, contains a Unicode character equivalent to the sole character in
        /// <paramref name="s" />, if the conversion succeeded, or an undefined value if the conversion
        /// failed. The conversion fails if the <paramref name="s" /> parameter is null or the length
        /// of <paramref name="s" /> is not 1. This parameter is passed uninitialized.
        /// </param>
        /// <returns>
        /// true if the <paramref name="s" /> parameter was converted successfully; otherwise, false.
        /// </returns>
        public static bool TryParse(string s, out char result) { result = default(char); return default(bool); }
    }
    /// <summary>
    /// Indicates whether a program element is compliant with the Common Language Specification (CLS).
    /// This class cannot be inherited.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(32767), Inherited = true, AllowMultiple = false)]
    public sealed partial class CLSCompliantAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes an instance of the <see cref="CLSCompliantAttribute" /> class with a
        /// Boolean value indicating whether the indicated program element is CLS-compliant.
        /// </summary>
        /// <param name="isCompliant">true if CLS-compliant; otherwise, false.</param>
        public CLSCompliantAttribute(bool isCompliant) { }
        /// <summary>
        /// Gets the Boolean value indicating whether the indicated program element is CLS-compliant.
        /// </summary>
        /// <returns>
        /// true if the program element is CLS-compliant; otherwise, false.
        /// </returns>
        public bool IsCompliant { get { return default(bool); } }
    }
    /// <summary>
    /// Represents the method that compares two objects of the same type.
    /// </summary>
    /// <param name="x">The first object to compare.</param>
    /// <param name="y">The second object to compare.</param>
    /// <typeparam name="T">The type of the objects to compare.</typeparam>
    /// <returns>
    /// A signed integer that indicates the relative values of <paramref name="x" /> and <paramref name="y" />,
    /// as shown in the following table.Value Meaning Less than 0 <paramref name="x" />
    /// is less than <paramref name="y" />.0 <paramref name="x" /> equals <paramref name="y" />.Greater
    /// than 0 <paramref name="x" /> is greater than <paramref name="y" />.
    /// </returns>
    public delegate int Comparison<in T>(T x, T y);
    /// <summary>
    /// Represents an instant in time, typically expressed as a date and time of day. To browse the
    /// .NET Framework source code for this type, see the Reference Source.
    /// </summary>
    public partial struct DateTime : System.IComparable, System.IComparable<System.DateTime>, System.IConvertible, System.IEquatable<System.DateTime>, System.IFormattable
    {
        /// <summary>
        /// Represents the largest possible value of <see cref="DateTime" />. This field is read-only.
        /// </summary>
        public static readonly System.DateTime MaxValue;
        /// <summary>
        /// Represents the smallest possible value of <see cref="DateTime" />. This field is
        /// read-only.
        /// </summary>
        public static readonly System.DateTime MinValue;
        /// <summary>
        /// Initializes a new instance of the <see cref="DateTime" /> structure to the specified
        /// year, month, and day.
        /// </summary>
        /// <param name="year">The year (1 through 9999).</param>
        /// <param name="month">The month (1 through 12).</param>
        /// <param name="day">The day (1 through the number of days in <paramref name="month" />).</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="year" /> is less than 1 or greater than 9999.-or- <paramref name="month" />
        /// is less than 1 or greater than 12.-or- <paramref name="day" /> is less than 1 or greater than
        /// the number of days in <paramref name="month" />.
        /// </exception>
        public DateTime(int year, int month, int day) { throw new System.NotImplementedException(); }
        /// <summary>
        /// Initializes a new instance of the <see cref="DateTime" /> structure to the specified
        /// year, month, day, hour, minute, and second.
        /// </summary>
        /// <param name="year">The year (1 through 9999).</param>
        /// <param name="month">The month (1 through 12).</param>
        /// <param name="day">The day (1 through the number of days in <paramref name="month" />).</param>
        /// <param name="hour">The hours (0 through 23).</param>
        /// <param name="minute">The minutes (0 through 59).</param>
        /// <param name="second">The seconds (0 through 59).</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="year" /> is less than 1 or greater than 9999. -or- <paramref name="month" />
        /// is less than 1 or greater than 12. -or- <paramref name="day" /> is less than 1 or greater
        /// than the number of days in <paramref name="month" />.-or- <paramref name="hour" /> is less
        /// than 0 or greater than 23. -or- <paramref name="minute" /> is less than 0 or greater than
        /// 59. -or- <paramref name="second" /> is less than 0 or greater than 59.
        /// </exception>
        public DateTime(int year, int month, int day, int hour, int minute, int second) { throw new System.NotImplementedException(); }
        /// <summary>
        /// Initializes a new instance of the <see cref="DateTime" /> structure to the specified
        /// year, month, day, hour, minute, second, and Coordinated Universal Time (UTC) or local time.
        /// </summary>
        /// <param name="year">The year (1 through 9999).</param>
        /// <param name="month">The month (1 through 12).</param>
        /// <param name="day">The day (1 through the number of days in <paramref name="month" />).</param>
        /// <param name="hour">The hours (0 through 23).</param>
        /// <param name="minute">The minutes (0 through 59).</param>
        /// <param name="second">The seconds (0 through 59).</param>
        /// <param name="kind">
        /// One of the enumeration values that indicates whether <paramref name="year" />, <paramref name="month" />,
        /// <paramref name="day" />, <paramref name="hour" />, <paramref name="minute" /> and
        /// <paramref name="second" /> specify a local time, Coordinated Universal Time (UTC), or neither.
        /// </param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="year" /> is less than 1 or greater than 9999. -or- <paramref name="month" />
        /// is less than 1 or greater than 12. -or- <paramref name="day" /> is less than 1 or greater
        /// than the number of days in <paramref name="month" />.-or- <paramref name="hour" /> is less
        /// than 0 or greater than 23. -or- <paramref name="minute" /> is less than 0 or greater than
        /// 59. -or- <paramref name="second" /> is less than 0 or greater than 59.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="kind" /> is not one of the <see cref="DateTimeKind" /> values.
        /// </exception>
        public DateTime(int year, int month, int day, int hour, int minute, int second, System.DateTimeKind kind) { throw new System.NotImplementedException(); }
        /// <summary>
        /// Initializes a new instance of the <see cref="DateTime" /> structure to the specified
        /// year, month, day, hour, minute, second, and millisecond.
        /// </summary>
        /// <param name="year">The year (1 through 9999).</param>
        /// <param name="month">The month (1 through 12).</param>
        /// <param name="day">The day (1 through the number of days in <paramref name="month" />).</param>
        /// <param name="hour">The hours (0 through 23).</param>
        /// <param name="minute">The minutes (0 through 59).</param>
        /// <param name="second">The seconds (0 through 59).</param>
        /// <param name="millisecond">The milliseconds (0 through 999).</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="year" /> is less than 1 or greater than 9999.-or- <paramref name="month" />
        /// is less than 1 or greater than 12.-or- <paramref name="day" /> is less than 1 or greater than
        /// the number of days in <paramref name="month" />.-or- <paramref name="hour" /> is less than
        /// 0 or greater than 23.-or- <paramref name="minute" /> is less than 0 or greater than 59.-or-
        /// <paramref name="second" /> is less than 0 or greater than 59.-or- <paramref name="millisecond" />
        /// is less than 0 or greater than 999.
        /// </exception>
        public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond) { throw new System.NotImplementedException(); }
        /// <summary>
        /// Initializes a new instance of the <see cref="DateTime" /> structure to the specified
        /// year, month, day, hour, minute, second, millisecond, and Coordinated Universal Time (UTC)
        /// or local time.
        /// </summary>
        /// <param name="year">The year (1 through 9999).</param>
        /// <param name="month">The month (1 through 12).</param>
        /// <param name="day">The day (1 through the number of days in <paramref name="month" />).</param>
        /// <param name="hour">The hours (0 through 23).</param>
        /// <param name="minute">The minutes (0 through 59).</param>
        /// <param name="second">The seconds (0 through 59).</param>
        /// <param name="millisecond">The milliseconds (0 through 999).</param>
        /// <param name="kind">
        /// One of the enumeration values that indicates whether <paramref name="year" />, <paramref name="month" />,
        /// <paramref name="day" />, <paramref name="hour" />, <paramref name="minute" />, <paramref name="second" />,
        /// and <paramref name="millisecond" /> specify a local time, Coordinated Universal
        /// Time (UTC), or neither.
        /// </param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="year" /> is less than 1 or greater than 9999.-or- <paramref name="month" />
        /// is less than 1 or greater than 12.-or- <paramref name="day" /> is less than 1 or greater than
        /// the number of days in <paramref name="month" />.-or- <paramref name="hour" /> is less than
        /// 0 or greater than 23.-or- <paramref name="minute" /> is less than 0 or greater than 59.-or-
        /// <paramref name="second" /> is less than 0 or greater than 59.-or- <paramref name="millisecond" />
        /// is less than 0 or greater than 999.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="kind" /> is not one of the <see cref="DateTimeKind" /> values.
        /// </exception>
        public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, System.DateTimeKind kind) { throw new System.NotImplementedException(); }
        /// <summary>
        /// Initializes a new instance of the <see cref="DateTime" /> structure to a specified
        /// number of ticks.
        /// </summary>
        /// <param name="ticks">
        /// A date and time expressed in the number of 100-nanosecond intervals that have elapsed since
        /// January 1, 0001 at 00:00:00.000 in the Gregorian calendar.
        /// </param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="ticks" /> is less than <see cref="MinValue" /> or greater
        /// than <see cref="MaxValue" />.
        /// </exception>
        public DateTime(long ticks) { throw new System.NotImplementedException(); }
        /// <summary>
        /// Initializes a new instance of the <see cref="DateTime" /> structure to a specified
        /// number of ticks and to Coordinated Universal Time (UTC) or local time.
        /// </summary>
        /// <param name="ticks">
        /// A date and time expressed in the number of 100-nanosecond intervals that have elapsed since
        /// January 1, 0001 at 00:00:00.000 in the Gregorian calendar.
        /// </param>
        /// <param name="kind">
        /// One of the enumeration values that indicates whether <paramref name="ticks" /> specifies a
        /// local time, Coordinated Universal Time (UTC), or neither.
        /// </param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="ticks" /> is less than <see cref="MinValue" /> or greater
        /// than <see cref="MaxValue" />.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="kind" /> is not one of the <see cref="DateTimeKind" /> values.
        /// </exception>
        public DateTime(long ticks, System.DateTimeKind kind) { throw new System.NotImplementedException(); }
        /// <summary>
        /// Gets the date component of this instance.
        /// </summary>
        /// <returns>
        /// A new object with the same date as this instance, and the time value set to 12:00:00 midnight
        /// (00:00:00).
        /// </returns>
        public System.DateTime Date { get { return default(System.DateTime); } }
        /// <summary>
        /// Gets the day of the month represented by this instance.
        /// </summary>
        /// <returns>
        /// The day component, expressed as a value between 1 and 31.
        /// </returns>
        public int Day { get { return default(int); } }
        /// <summary>
        /// Gets the day of the week represented by this instance.
        /// </summary>
        /// <returns>
        /// An enumerated constant that indicates the day of the week of this <see cref="DateTime" />
        /// value.
        /// </returns>
        public System.DayOfWeek DayOfWeek { get { return default(System.DayOfWeek); } }
        /// <summary>
        /// Gets the day of the year represented by this instance.
        /// </summary>
        /// <returns>
        /// The day of the year, expressed as a value between 1 and 366.
        /// </returns>
        public int DayOfYear { get { return default(int); } }
        /// <summary>
        /// Gets the hour component of the date represented by this instance.
        /// </summary>
        /// <returns>
        /// The hour component, expressed as a value between 0 and 23.
        /// </returns>
        public int Hour { get { return default(int); } }
        /// <summary>
        /// Gets a value that indicates whether the time represented by this instance is based on local
        /// time, Coordinated Universal Time (UTC), or neither.
        /// </summary>
        /// <returns>
        /// One of the enumeration values that indicates what the current time represents. The default
        /// is <see cref="DateTimeKind.Unspecified" />.
        /// </returns>
        public System.DateTimeKind Kind { get { return default(System.DateTimeKind); } }
        /// <summary>
        /// Gets the milliseconds component of the date represented by this instance.
        /// </summary>
        /// <returns>
        /// The milliseconds component, expressed as a value between 0 and 999.
        /// </returns>
        public int Millisecond { get { return default(int); } }
        /// <summary>
        /// Gets the minute component of the date represented by this instance.
        /// </summary>
        /// <returns>
        /// The minute component, expressed as a value between 0 and 59.
        /// </returns>
        public int Minute { get { return default(int); } }
        /// <summary>
        /// Gets the month component of the date represented by this instance.
        /// </summary>
        /// <returns>
        /// The month component, expressed as a value between 1 and 12.
        /// </returns>
        public int Month { get { return default(int); } }
        /// <summary>
        /// Gets a <see cref="DateTime" /> object that is set to the current date and time on
        /// this computer, expressed as the local time.
        /// </summary>
        /// <returns>
        /// An object whose value is the current local date and time.
        /// </returns>
        public static System.DateTime Now { get { return default(System.DateTime); } }
        /// <summary>
        /// Gets the seconds component of the date represented by this instance.
        /// </summary>
        /// <returns>
        /// The seconds component, expressed as a value between 0 and 59.
        /// </returns>
        public int Second { get { return default(int); } }
        /// <summary>
        /// Gets the number of ticks that represent the date and time of this instance.
        /// </summary>
        /// <returns>
        /// The number of ticks that represent the date and time of this instance. The value is between
        /// DateTime.MinValue.Ticks and DateTime.MaxValue.Ticks.
        /// </returns>
        public long Ticks { get { return default(long); } }
        /// <summary>
        /// Gets the time of day for this instance.
        /// </summary>
        /// <returns>
        /// A time interval that represents the fraction of the day that has elapsed since midnight.
        /// </returns>
        public System.TimeSpan TimeOfDay { get { return default(System.TimeSpan); } }
        /// <summary>
        /// Gets the current date.
        /// </summary>
        /// <returns>
        /// An object that is set to today's date, with the time component set to 00:00:00.
        /// </returns>
        public static System.DateTime Today { get { return default(System.DateTime); } }
        /// <summary>
        /// Gets a <see cref="DateTime" /> object that is set to the current date and time on
        /// this computer, expressed as the Coordinated Universal Time (UTC).
        /// </summary>
        /// <returns>
        /// An object whose value is the current UTC date and time.
        /// </returns>
        public static System.DateTime UtcNow { get { return default(System.DateTime); } }
        /// <summary>
        /// Gets the year component of the date represented by this instance.
        /// </summary>
        /// <returns>
        /// The year, between 1 and 9999.
        /// </returns>
        public int Year { get { return default(int); } }
        /// <summary>
        /// Returns a new <see cref="DateTime" /> that adds the value of the specified
        /// <see cref="TimeSpan" /> to the value of this instance.
        /// </summary>
        /// <param name="value">A positive or negative time interval.</param>
        /// <returns>
        /// An object whose value is the sum of the date and time represented by this instance and the
        /// time interval represented by <paramref name="value" />.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The resulting <see cref="DateTime" /> is less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />.
        /// </exception>
        public System.DateTime Add(System.TimeSpan value) { return default(System.DateTime); }
        /// <summary>
        /// Returns a new <see cref="DateTime" /> that adds the specified number of days to the
        /// value of this instance.
        /// </summary>
        /// <param name="value">
        /// A number of whole and fractional days. The <paramref name="value" /> parameter can be negative
        /// or positive.
        /// </param>
        /// <returns>
        /// An object whose value is the sum of the date and time represented by this instance and the
        /// number of days represented by <paramref name="value" />.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The resulting <see cref="DateTime" /> is less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />.
        /// </exception>
        public System.DateTime AddDays(double value) { return default(System.DateTime); }
        /// <summary>
        /// Returns a new <see cref="DateTime" /> that adds the specified number of hours to
        /// the value of this instance.
        /// </summary>
        /// <param name="value">
        /// A number of whole and fractional hours. The <paramref name="value" /> parameter can be negative
        /// or positive.
        /// </param>
        /// <returns>
        /// An object whose value is the sum of the date and time represented by this instance and the
        /// number of hours represented by <paramref name="value" />.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The resulting <see cref="DateTime" /> is less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />.
        /// </exception>
        public System.DateTime AddHours(double value) { return default(System.DateTime); }
        /// <summary>
        /// Returns a new <see cref="DateTime" /> that adds the specified number of milliseconds
        /// to the value of this instance.
        /// </summary>
        /// <param name="value">
        /// A number of whole and fractional milliseconds. The <paramref name="value" /> parameter can
        /// be negative or positive. Note that this value is rounded to the nearest integer.
        /// </param>
        /// <returns>
        /// An object whose value is the sum of the date and time represented by this instance and the
        /// number of milliseconds represented by <paramref name="value" />.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The resulting <see cref="DateTime" /> is less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />.
        /// </exception>
        public System.DateTime AddMilliseconds(double value) { return default(System.DateTime); }
        /// <summary>
        /// Returns a new <see cref="DateTime" /> that adds the specified number of minutes to
        /// the value of this instance.
        /// </summary>
        /// <param name="value">
        /// A number of whole and fractional minutes. The <paramref name="value" /> parameter can be negative
        /// or positive.
        /// </param>
        /// <returns>
        /// An object whose value is the sum of the date and time represented by this instance and the
        /// number of minutes represented by <paramref name="value" />.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The resulting <see cref="DateTime" /> is less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />.
        /// </exception>
        public System.DateTime AddMinutes(double value) { return default(System.DateTime); }
        /// <summary>
        /// Returns a new <see cref="DateTime" /> that adds the specified number of months to
        /// the value of this instance.
        /// </summary>
        /// <param name="months">
        /// A number of months. The <paramref name="months" /> parameter can be negative or positive.
        /// </param>
        /// <returns>
        /// An object whose value is the sum of the date and time represented by this instance and
        /// <paramref name="months" />.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The resulting <see cref="DateTime" /> is less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />.-or- <paramref name="months" />
        /// is less than -120,000 or greater than 120,000.
        /// </exception>
        public System.DateTime AddMonths(int months) { return default(System.DateTime); }
        /// <summary>
        /// Returns a new <see cref="DateTime" /> that adds the specified number of seconds to
        /// the value of this instance.
        /// </summary>
        /// <param name="value">
        /// A number of whole and fractional seconds. The <paramref name="value" /> parameter can be negative
        /// or positive.
        /// </param>
        /// <returns>
        /// An object whose value is the sum of the date and time represented by this instance and the
        /// number of seconds represented by <paramref name="value" />.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The resulting <see cref="DateTime" /> is less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />.
        /// </exception>
        public System.DateTime AddSeconds(double value) { return default(System.DateTime); }
        /// <summary>
        /// Returns a new <see cref="DateTime" /> that adds the specified number of ticks to
        /// the value of this instance.
        /// </summary>
        /// <param name="value">
        /// A number of 100-nanosecond ticks. The <paramref name="value" /> parameter can be positive
        /// or negative.
        /// </param>
        /// <returns>
        /// An object whose value is the sum of the date and time represented by this instance and the
        /// time represented by <paramref name="value" />.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The resulting <see cref="DateTime" /> is less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />.
        /// </exception>
        public System.DateTime AddTicks(long value) { return default(System.DateTime); }
        /// <summary>
        /// Returns a new <see cref="DateTime" /> that adds the specified number of years to
        /// the value of this instance.
        /// </summary>
        /// <param name="value">A number of years. The <paramref name="value" /> parameter can be negative or positive.</param>
        /// <returns>
        /// An object whose value is the sum of the date and time represented by this instance and the
        /// number of years represented by <paramref name="value" />.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="value" /> or the resulting <see cref="DateTime" /> is less than
        /// <see cref="MinValue" /> or greater than <see cref="MaxValue" />.
        /// </exception>
        public System.DateTime AddYears(int value) { return default(System.DateTime); }
        /// <summary>
        /// Compares two instances of <see cref="DateTime" /> and returns an integer that indicates
        /// whether the first instance is earlier than, the same as, or later than the second instance.
        /// </summary>
        /// <param name="t1">The first object to compare.</param>
        /// <param name="t2">The second object to compare.</param>
        /// <returns>
        /// A signed number indicating the relative values of <paramref name="t1" /> and <paramref name="t2" />.
        /// Value Type Condition Less than zero <paramref name="t1" /> is earlier than <paramref name="t2" />.
        /// Zero <paramref name="t1" /> is the same as <paramref name="t2" />. Greater than zero <paramref name="t1" />
        /// is later than <paramref name="t2" />.
        /// </returns>
        public static int Compare(System.DateTime t1, System.DateTime t2) { return default(int); }
        /// <summary>
        /// Compares the value of this instance to a specified <see cref="DateTime" /> value
        /// and returns an integer that indicates whether this instance is earlier than, the same as,
        /// or later than the specified <see cref="DateTime" /> value.
        /// </summary>
        /// <param name="value">The object to compare to the current instance.</param>
        /// <returns>
        /// A signed number indicating the relative values of this instance and the <paramref name="value" />
        /// parameter.Value Description Less than zero This instance is earlier than <paramref name="value" />.
        /// Zero This instance is the same as <paramref name="value" />. Greater than zero This instance
        /// is later than <paramref name="value" />.
        /// </returns>
        public int CompareTo(System.DateTime value) { return default(int); }
        /// <summary>
        /// Returns the number of days in the specified month and year.
        /// </summary>
        /// <param name="year">The year.</param>
        /// <param name="month">The month (a number ranging from 1 to 12).</param>
        /// <returns>
        /// The number of days in <paramref name="month" /> for the specified <paramref name="year" />.For
        /// example, if <paramref name="month" /> equals 2 for February, the return value is 28 or 29
        /// depending upon whether <paramref name="year" /> is a leap year.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="month" /> is less than 1 or greater than 12.-or-<paramref name="year" /> is
        /// less than 1 or greater than 9999.
        /// </exception>
        public static int DaysInMonth(int year, int month) { return default(int); }
        /// <summary>
        /// Returns a value indicating whether the value of this instance is equal to the value of the
        /// specified <see cref="DateTime" /> instance.
        /// </summary>
        /// <param name="value">The object to compare to this instance.</param>
        /// <returns>
        /// true if the <paramref name="value" /> parameter equals the value of this instance; otherwise,
        /// false.
        /// </returns>
        public bool Equals(System.DateTime value) { return default(bool); }
        /// <summary>
        /// Returns a value indicating whether two <see cref="DateTime" /> instances  have the
        /// same date and time value.
        /// </summary>
        /// <param name="t1">The first object to compare.</param>
        /// <param name="t2">The second object to compare.</param>
        /// <returns>
        /// true if the two values are equal; otherwise, false.
        /// </returns>
        public static bool Equals(System.DateTime t1, System.DateTime t2) { return default(bool); }
        /// <summary>
        /// Returns a value indicating whether this instance is equal to a specified object.
        /// </summary>
        /// <param name="value">The object to compare to this instance.</param>
        /// <returns>
        /// true if <paramref name="value" /> is an instance of <see cref="DateTime" /> and equals
        /// the value of this instance; otherwise, false.
        /// </returns>
        public override bool Equals(object value) { return default(bool); }
        /// <summary>
        /// Deserializes a 64-bit binary value and recreates an original serialized <see cref="DateTime" />
        /// object.
        /// </summary>
        /// <param name="dateData">
        /// A 64-bit signed integer that encodes the <see cref="Kind" /> property in
        /// a 2-bit field and the <see cref="Ticks" /> property in a 62-bit field.
        /// </param>
        /// <returns>
        /// An object that is equivalent to the <see cref="DateTime" /> object that was serialized
        /// by the <see cref="ToBinary" /> method.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// <paramref name="dateData" /> is less than <see cref="MinValue" /> or greater
        /// than <see cref="MaxValue" />.
        /// </exception>
        public static System.DateTime FromBinary(long dateData) { return default(System.DateTime); }
        /// <summary>
        /// Converts the specified Windows file time to an equivalent local time.
        /// </summary>
        /// <param name="fileTime">A Windows file time expressed in ticks.</param>
        /// <returns>
        /// An object that represents the local time equivalent of the date and time represented by the
        /// <paramref name="fileTime" /> parameter.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="fileTime" /> is less than 0 or represents a time greater than
        /// <see cref="MaxValue" />.
        /// </exception>
        public static System.DateTime FromFileTime(long fileTime) { return default(System.DateTime); }
        /// <summary>
        /// Converts the specified Windows file time to an equivalent UTC time.
        /// </summary>
        /// <param name="fileTime">A Windows file time expressed in ticks.</param>
        /// <returns>
        /// An object that represents the UTC time equivalent of the date and time represented by the
        /// <paramref name="fileTime" /> parameter.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="fileTime" /> is less than 0 or represents a time greater than
        /// <see cref="MaxValue" />.
        /// </exception>
        public static System.DateTime FromFileTimeUtc(long fileTime) { return default(System.DateTime); }
        /// <summary>
        /// Converts the value of this instance to all the string representations supported by the standard
        /// date and time format specifiers.
        /// </summary>
        /// <returns>
        /// A string array where each element is the representation of the value of this instance formatted
        /// with one of the standard date and time format specifiers.
        /// </returns>
        public string[] GetDateTimeFormats() { return default(string[]); }
        /// <summary>
        /// Converts the value of this instance to all the string representations supported by the specified
        /// standard date and time format specifier.
        /// </summary>
        /// <param name="format">A standard date and time format string (see Remarks).</param>
        /// <returns>
        /// A string array where each element is the representation of the value of this instance formatted
        /// with the <paramref name="format" /> standard date and time format specifier.
        /// </returns>
        /// <exception cref="FormatException">
        /// <paramref name="format" /> is not a valid standard date and time format specifier character.
        /// </exception>
        public string[] GetDateTimeFormats(char format) { return default(string[]); }
        /// <summary>
        /// Converts the value of this instance to all the string representations supported by the specified
        /// standard date and time format specifier and culture-specific formatting information.
        /// </summary>
        /// <param name="format">A date and time format string (see Remarks).</param>
        /// <param name="provider">An object that supplies culture-specific formatting information about this instance.</param>
        /// <returns>
        /// A string array where each element is the representation of the value of this instance formatted
        /// with one of the standard date and time format specifiers.
        /// </returns>
        /// <exception cref="FormatException">
        /// <paramref name="format" /> is not a valid standard date and time format specifier character.
        /// </exception>
        public string[] GetDateTimeFormats(char format, System.IFormatProvider provider) { return default(string[]); }
        /// <summary>
        /// Converts the value of this instance to all the string representations supported by the standard
        /// date and time format specifiers and the specified culture-specific formatting information.
        /// </summary>
        /// <param name="provider">An object that supplies culture-specific formatting information about this instance.</param>
        /// <returns>
        /// A string array where each element is the representation of the value of this instance formatted
        /// with one of the standard date and time format specifiers.
        /// </returns>
        public string[] GetDateTimeFormats(System.IFormatProvider provider) { return default(string[]); }
        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code.
        /// </returns>
        public override int GetHashCode() { return default(int); }
        /// <summary>
        /// Indicates whether this instance of <see cref="DateTime" /> is within the daylight
        /// saving time range for the current time zone.
        /// </summary>
        /// <returns>
        /// true if the value of the <see cref="Kind" /> property is
        /// <see cref="DateTimeKind.Local" /> or <see cref="DateTimeKind.Unspecified" /> and the value of this instance of
        /// <see cref="DateTime" /> is within the daylight saving time range for the local time zone;
        /// false if <see cref="Kind" /> is <see cref="DateTimeKind.Utc" />.
        /// </returns>
        public bool IsDaylightSavingTime() { return default(bool); }
        /// <summary>
        /// Returns an indication whether the specified year is a leap year.
        /// </summary>
        /// <param name="year">A 4-digit year.</param>
        /// <returns>
        /// true if <paramref name="year" /> is a leap year; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="year" /> is less than 1 or greater than 9999.
        /// </exception>
        public static bool IsLeapYear(int year) { return default(bool); }
        /// <summary>
        /// Adds a specified time interval to a specified date and time, yielding a new date and time.
        /// </summary>
        /// <param name="d">The date and time value to add.</param>
        /// <param name="t">The time interval to add.</param>
        /// <returns>
        /// An object that is the sum of the values of <paramref name="d" /> and <paramref name="t" />.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The resulting <see cref="DateTime" /> is less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />.
        /// </exception>
        public static System.DateTime operator +(System.DateTime d, System.TimeSpan t) { return default(System.DateTime); }
        /// <summary>
        /// Determines whether two specified instances of <see cref="DateTime" /> are equal.
        /// </summary>
        /// <param name="d1">The first object to compare.</param>
        /// <param name="d2">The second object to compare.</param>
        /// <returns>
        /// true if <paramref name="d1" /> and <paramref name="d2" /> represent the same date and time;
        /// otherwise, false.
        /// </returns>
        public static bool operator ==(System.DateTime d1, System.DateTime d2) { return default(bool); }
        /// <summary>
        /// Determines whether one specified <see cref="DateTime" /> is later than another specified
        /// <see cref="DateTime" />.
        /// </summary>
        /// <param name="t1">The first object to compare.</param>
        /// <param name="t2">The second object to compare.</param>
        /// <returns>
        /// true if <paramref name="t1" /> is later than <paramref name="t2" />; otherwise, false.
        /// </returns>
        public static bool operator >(System.DateTime t1, System.DateTime t2) { return default(bool); }
        /// <summary>
        /// Determines whether one specified <see cref="DateTime" /> represents a date and time
        /// that is the same as or later than another specified <see cref="DateTime" />.
        /// </summary>
        /// <param name="t1">The first object to compare.</param>
        /// <param name="t2">The second object to compare.</param>
        /// <returns>
        /// true if <paramref name="t1" /> is the same as or later than <paramref name="t2" />; otherwise,
        /// false.
        /// </returns>
        public static bool operator >=(System.DateTime t1, System.DateTime t2) { return default(bool); }
        /// <summary>
        /// Determines whether two specified instances of <see cref="DateTime" /> are not equal.
        /// </summary>
        /// <param name="d1">The first object to compare.</param>
        /// <param name="d2">The second object to compare.</param>
        /// <returns>
        /// true if <paramref name="d1" /> and <paramref name="d2" /> do not represent the same date and
        /// time; otherwise, false.
        /// </returns>
        public static bool operator !=(System.DateTime d1, System.DateTime d2) { return default(bool); }
        /// <summary>
        /// Determines whether one specified <see cref="DateTime" /> is earlier than another
        /// specified <see cref="DateTime" />.
        /// </summary>
        /// <param name="t1">The first object to compare.</param>
        /// <param name="t2">The second object to compare.</param>
        /// <returns>
        /// true if <paramref name="t1" /> is earlier than <paramref name="t2" />; otherwise, false.
        /// </returns>
        public static bool operator <(System.DateTime t1, System.DateTime t2) { return default(bool); }
        /// <summary>
        /// Determines whether one specified <see cref="DateTime" /> represents a date and time
        /// that is the same as or earlier than another specified <see cref="DateTime" />.
        /// </summary>
        /// <param name="t1">The first object to compare.</param>
        /// <param name="t2">The second object to compare.</param>
        /// <returns>
        /// true if <paramref name="t1" /> is the same as or earlier than <paramref name="t2" />; otherwise,
        /// false.
        /// </returns>
        public static bool operator <=(System.DateTime t1, System.DateTime t2) { return default(bool); }
        /// <summary>
        /// Subtracts a specified date and time from another specified date and time and returns a time
        /// interval.
        /// </summary>
        /// <param name="d1">The date and time value to subtract from (the minuend).</param>
        /// <param name="d2">The date and time value to subtract (the subtrahend).</param>
        /// <returns>
        /// The time interval between <paramref name="d1" /> and <paramref name="d2" />; that is, <paramref name="d1" />
        /// minus <paramref name="d2" />.
        /// </returns>
        public static System.TimeSpan operator -(System.DateTime d1, System.DateTime d2) { return default(System.TimeSpan); }
        /// <summary>
        /// Subtracts a specified time interval from a specified date and time and returns a new date and
        /// time.
        /// </summary>
        /// <param name="d">The date and time value to subtract from.</param>
        /// <param name="t">The time interval to subtract.</param>
        /// <returns>
        /// An object whose value is the value of <paramref name="d" /> minus the value of <paramref name="t" />.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The resulting <see cref="DateTime" /> is less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />.
        /// </exception>
        public static System.DateTime operator -(System.DateTime d, System.TimeSpan t) { return default(System.DateTime); }
        /// <summary>
        /// Converts the string representation of a date and time to its <see cref="DateTime" />
        /// equivalent.
        /// </summary>
        /// <param name="s">A string that contains a date and time to convert.</param>
        /// <returns>
        /// An object that is equivalent to the date and time contained in <paramref name="s" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="FormatException">
        /// <paramref name="s" /> does not contain a valid string representation of a date and time.
        /// </exception>
        public static System.DateTime Parse(string s) { return default(System.DateTime); }
        /// <summary>
        /// Converts the string representation of a date and time to its <see cref="DateTime" />
        /// equivalent by using culture-specific format information.
        /// </summary>
        /// <param name="s">A string that contains a date and time to convert.</param>
        /// <param name="provider">
        /// An object that supplies culture-specific format information about <paramref name="s" />.
        /// </param>
        /// <returns>
        /// An object that is equivalent to the date and time contained in <paramref name="s" /> as specified
        /// by <paramref name="provider" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="FormatException">
        /// <paramref name="s" /> does not contain a valid string representation of a date and time.
        /// </exception>
        public static System.DateTime Parse(string s, System.IFormatProvider provider) { return default(System.DateTime); }
        /// <summary>
        /// Converts the string representation of a date and time to its <see cref="DateTime" />
        /// equivalent by using culture-specific format information and formatting style.
        /// </summary>
        /// <param name="s">A string that contains a date and time to convert.</param>
        /// <param name="provider">
        /// An object that supplies culture-specific formatting information about <paramref name="s" />.
        /// </param>
        /// <param name="styles">
        /// A bitwise combination of the enumeration values that indicates the style elements that can
        /// be present in <paramref name="s" /> for the parse operation to succeed, and that defines how
        /// to interpret the parsed date in relation to the current time zone or the current date. A typical
        /// value to specify is <see cref="Globalization.DateTimeStyles.None" />.
        /// </param>
        /// <returns>
        /// An object that is equivalent to the date and time contained in <paramref name="s" />, as specified
        /// by <paramref name="provider" /> and <paramref name="styles" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="FormatException">
        /// <paramref name="s" /> does not contain a valid string representation of a date and time.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="styles" /> contains an invalid combination of
        /// <see cref="Globalization.DateTimeStyles" /> values. For example, both <see cref="Globalization.DateTimeStyles.AssumeLocal" />
        /// and <see cref="Globalization.DateTimeStyles.AssumeUniversal" />.
        /// </exception>
        public static System.DateTime Parse(string s, System.IFormatProvider provider, System.Globalization.DateTimeStyles styles) { return default(System.DateTime); }
        /// <summary>
        /// Converts the specified string representation of a date and time to its <see cref="DateTime" />
        /// equivalent using the specified format and culture-specific format information. The format
        /// of the string representation must match the specified format exactly.
        /// </summary>
        /// <param name="s">A string that contains a date and time to convert.</param>
        /// <param name="format">
        /// A format specifier that defines the required format of <paramref name="s" />. For more information,
        /// see the Remarks section.
        /// </param>
        /// <param name="provider">
        /// An object that supplies culture-specific format information about <paramref name="s" />.
        /// </param>
        /// <returns>
        /// An object that is equivalent to the date and time contained in <paramref name="s" />, as specified
        /// by <paramref name="format" /> and <paramref name="provider" />.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="s" /> or <paramref name="format" /> is null.
        /// </exception>
        /// <exception cref="FormatException">
        /// <paramref name="s" /> or <paramref name="format" /> is an empty string. -or- <paramref name="s" />
        /// does not contain a date and time that corresponds to the pattern specified in <paramref name="format" />.
        /// -or-The hour component and the AM/PM designator in <paramref name="s" />
        /// do not agree.
        /// </exception>
        public static System.DateTime ParseExact(string s, string format, System.IFormatProvider provider) { return default(System.DateTime); }
        /// <summary>
        /// Converts the specified string representation of a date and time to its <see cref="DateTime" />
        /// equivalent using the specified format, culture-specific format information, and style.
        /// The format of the string representation must match the specified format exactly or an exception
        /// is thrown.
        /// </summary>
        /// <param name="s">A string containing a date and time to convert.</param>
        /// <param name="format">
        /// A format specifier that defines the required format of <paramref name="s" />. For more information,
        /// see the Remarks section.
        /// </param>
        /// <param name="provider">
        /// An object that supplies culture-specific formatting information about <paramref name="s" />.
        /// </param>
        /// <param name="style">
        /// A bitwise combination of the enumeration values that provides additional information about
        /// <paramref name="s" />, about style elements that may be present in <paramref name="s" />,
        /// or about the conversion from <paramref name="s" /> to a <see cref="DateTime" /> value.
        /// A typical value to specify is <see cref="Globalization.DateTimeStyles.None" />.
        /// </param>
        /// <returns>
        /// An object that is equivalent to the date and time contained in <paramref name="s" />, as specified
        /// by <paramref name="format" />, <paramref name="provider" />, and <paramref name="style" />.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="s" /> or <paramref name="format" /> is null.
        /// </exception>
        /// <exception cref="FormatException">
        /// <paramref name="s" /> or <paramref name="format" /> is an empty string. -or- <paramref name="s" />
        /// does not contain a date and time that corresponds to the pattern specified in <paramref name="format" />.
        /// -or-The hour component and the AM/PM designator in <paramref name="s" />
        /// do not agree.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="style" /> contains an invalid combination of
        /// <see cref="Globalization.DateTimeStyles" /> values. For example, both <see cref="Globalization.DateTimeStyles.AssumeLocal" />
        /// and <see cref="Globalization.DateTimeStyles.AssumeUniversal" />.
        /// </exception>
        public static System.DateTime ParseExact(string s, string format, System.IFormatProvider provider, System.Globalization.DateTimeStyles style) { return default(System.DateTime); }
        /// <summary>
        /// Converts the specified string representation of a date and time to its <see cref="DateTime" />
        /// equivalent using the specified array of formats, culture-specific format information, and
        /// style. The format of the string representation must match at least one of the specified formats
        /// exactly or an exception is thrown.
        /// </summary>
        /// <param name="s">A string that contains a date and time to convert.</param>
        /// <param name="formats">
        /// An array of allowable formats of <paramref name="s" />. For more information, see the Remarks
        /// section.
        /// </param>
        /// <param name="provider">
        /// An object that supplies culture-specific format information about <paramref name="s" />.
        /// </param>
        /// <param name="style">
        /// A bitwise combination of enumeration values that indicates the permitted format of <paramref name="s" />.
        /// A typical value to specify is <see cref="Globalization.DateTimeStyles.None" />.
        /// </param>
        /// <returns>
        /// An object that is equivalent to the date and time contained in <paramref name="s" />, as specified
        /// by <paramref name="formats" />, <paramref name="provider" />, and <paramref name="style" />.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="s" /> or <paramref name="formats" /> is null.
        /// </exception>
        /// <exception cref="FormatException">
        /// <paramref name="s" /> is an empty string. -or- an element of <paramref name="formats" /> is
        /// an empty string. -or- <paramref name="s" /> does not contain a date and time that corresponds
        /// to any element of <paramref name="formats" />. -or-The hour component and the AM/PM designator
        /// in <paramref name="s" /> do not agree.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="style" /> contains an invalid combination of
        /// <see cref="Globalization.DateTimeStyles" /> values. For example, both <see cref="Globalization.DateTimeStyles.AssumeLocal" />
        /// and <see cref="Globalization.DateTimeStyles.AssumeUniversal" />.
        /// </exception>
        public static System.DateTime ParseExact(string s, string[] formats, System.IFormatProvider provider, System.Globalization.DateTimeStyles style) { return default(System.DateTime); }
        /// <summary>
        /// Creates a new <see cref="DateTime" /> object that has the same number of ticks as
        /// the specified <see cref="DateTime" />, but is designated as either local time, Coordinated
        /// Universal Time (UTC), or neither, as indicated by the specified <see cref="DateTimeKind" />
        /// value.
        /// </summary>
        /// <param name="value">A date and time.</param>
        /// <param name="kind">
        /// One of the enumeration values that indicates whether the new object represents local time,
        /// UTC, or neither.
        /// </param>
        /// <returns>
        /// A new object that has the same number of ticks as the object represented by the <paramref name="value" />
        /// parameter and the <see cref="DateTimeKind" /> value specified by
        /// the <paramref name="kind" /> parameter.
        /// </returns>
        public static System.DateTime SpecifyKind(System.DateTime value, System.DateTimeKind kind) { return default(System.DateTime); }
        /// <summary>
        /// Subtracts the specified date and time from this instance.
        /// </summary>
        /// <param name="value">The date and time value to subtract.</param>
        /// <returns>
        /// A time interval that is equal to the date and time represented by this instance minus the
        /// date and time represented by <paramref name="value" />.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The result is less than <see cref="MinValue" /> or greater than
        /// <see cref="MaxValue" />.
        /// </exception>
        public System.TimeSpan Subtract(System.DateTime value) { return default(System.TimeSpan); }
        /// <summary>
        /// Subtracts the specified duration from this instance.
        /// </summary>
        /// <param name="value">The time interval to subtract.</param>
        /// <returns>
        /// An object that is equal to the date and time represented by this instance minus the time interval
        /// represented by <paramref name="value" />.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The result is less than <see cref="MinValue" /> or greater than
        /// <see cref="MaxValue" />.
        /// </exception>
        public System.DateTime Subtract(System.TimeSpan value) { return default(System.DateTime); }
        int System.IComparable.CompareTo(object value) { return default(int); }
        System.TypeCode System.IConvertible.GetTypeCode() { return default(System.TypeCode); }
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) { return default(bool); }
        byte System.IConvertible.ToByte(System.IFormatProvider provider) { return default(byte); }
        char System.IConvertible.ToChar(System.IFormatProvider provider) { return default(char); }
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) { return default(System.DateTime); }
        decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) { return default(decimal); }
        double System.IConvertible.ToDouble(System.IFormatProvider provider) { return default(double); }
        short System.IConvertible.ToInt16(System.IFormatProvider provider) { return default(short); }
        int System.IConvertible.ToInt32(System.IFormatProvider provider) { return default(int); }
        long System.IConvertible.ToInt64(System.IFormatProvider provider) { return default(long); }
        sbyte System.IConvertible.ToSByte(System.IFormatProvider provider) { return default(sbyte); }
        float System.IConvertible.ToSingle(System.IFormatProvider provider) { return default(float); }
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) { return default(object); }
        ushort System.IConvertible.ToUInt16(System.IFormatProvider provider) { return default(ushort); }
        uint System.IConvertible.ToUInt32(System.IFormatProvider provider) { return default(uint); }
        ulong System.IConvertible.ToUInt64(System.IFormatProvider provider) { return default(ulong); }
        /// <summary>
        /// Serializes the current <see cref="DateTime" /> object to a 64-bit binary value that
        /// subsequently can be used to recreate the <see cref="DateTime" /> object.
        /// </summary>
        /// <returns>
        /// A 64-bit signed integer that encodes the <see cref="Kind" /> and
        /// <see cref="Ticks" /> properties.
        /// </returns>
        public long ToBinary() { return default(long); }
        /// <summary>
        /// Converts the value of the current <see cref="DateTime" /> object to a Windows file
        /// time.
        /// </summary>
        /// <returns>
        /// The value of the current <see cref="DateTime" /> object expressed as a Windows file
        /// time.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The resulting file time would represent a date and time before 12:00 midnight January 1, 1601
        /// C.E. UTC.
        /// </exception>
        public long ToFileTime() { return default(long); }
        /// <summary>
        /// Converts the value of the current <see cref="DateTime" /> object to a Windows file
        /// time.
        /// </summary>
        /// <returns>
        /// The value of the current <see cref="DateTime" /> object expressed as a Windows file
        /// time.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The resulting file time would represent a date and time before 12:00 midnight January 1, 1601
        /// C.E. UTC.
        /// </exception>
        public long ToFileTimeUtc() { return default(long); }
        /// <summary>
        /// Converts the value of the current <see cref="DateTime" /> object to local time.
        /// </summary>
        /// <returns>
        /// An object whose <see cref="Kind" /> property is <see cref="DateTimeKind.Local" />,
        /// and whose value is the local time equivalent to the value of the current
        /// <see cref="DateTime" /> object, or <see cref="MaxValue" /> if the converted value is too large
        /// to be represented by a <see cref="DateTime" /> object, or
        /// <see cref="MinValue" /> if the converted value is too small to be represented as a <see cref="DateTime" />
        /// object.
        /// </returns>
        public System.DateTime ToLocalTime() { return default(System.DateTime); }
        /// <summary>
        /// Converts the value of the current <see cref="DateTime" /> object to its equivalent
        /// string representation using the formatting conventions of the current culture.
        /// </summary>
        /// <returns>
        /// A string representation of the value of the current <see cref="DateTime" /> object.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The date and time is outside the range of dates supported by the calendar used by the current
        /// culture.
        /// </exception>
        public override string ToString() { return default(string); }
        /// <summary>
        /// Converts the value of the current <see cref="DateTime" /> object to its equivalent
        /// string representation using the specified culture-specific format information.
        /// </summary>
        /// <param name="provider">An object that supplies culture-specific formatting information.</param>
        /// <returns>
        /// A string representation of value of the current <see cref="DateTime" /> object as
        /// specified by <paramref name="provider" />.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The date and time is outside the range of dates supported by the calendar used by <paramref name="provider" />.
        /// </exception>
        public string ToString(System.IFormatProvider provider) { return default(string); }
        /// <summary>
        /// Converts the value of the current <see cref="DateTime" /> object to its equivalent
        /// string representation using the specified format and the formatting conventions of the current
        /// culture.
        /// </summary>
        /// <param name="format">A standard or custom date and time format string (see Remarks).</param>
        /// <returns>
        /// A string representation of value of the current <see cref="DateTime" /> object as
        /// specified by <paramref name="format" />.
        /// </returns>
        /// <exception cref="FormatException">
        /// The length of <paramref name="format" /> is 1, and it is not one of the format specifier characters
        /// defined for <see cref="Globalization.DateTimeFormatInfo" />.-or- <paramref name="format" />
        /// does not contain a valid custom format pattern.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The date and time is outside the range of dates supported by the calendar used by the current
        /// culture.
        /// </exception>
        public string ToString(string format) { return default(string); }
        /// <summary>
        /// Converts the value of the current <see cref="DateTime" /> object to its equivalent
        /// string representation using the specified format and culture-specific format information.
        /// </summary>
        /// <param name="format">A standard or custom date and time format string.</param>
        /// <param name="provider">An object that supplies culture-specific formatting information.</param>
        /// <returns>
        /// A string representation of value of the current <see cref="DateTime" /> object as
        /// specified by <paramref name="format" /> and <paramref name="provider" />.
        /// </returns>
        /// <exception cref="FormatException">
        /// The length of <paramref name="format" /> is 1, and it is not one of the format specifier characters
        /// defined for <see cref="Globalization.DateTimeFormatInfo" />.-or- <paramref name="format" />
        /// does not contain a valid custom format pattern.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The date and time is outside the range of dates supported by the calendar used by <paramref name="provider" />.
        /// </exception>
        public string ToString(string format, System.IFormatProvider provider) { return default(string); }
        /// <summary>
        /// Converts the value of the current <see cref="DateTime" /> object to Coordinated Universal
        /// Time (UTC).
        /// </summary>
        /// <returns>
        /// An object whose <see cref="Kind" /> property is <see cref="DateTimeKind.Utc" />,
        /// and whose value is the UTC equivalent to the value of the current <see cref="DateTime" />
        /// object, or <see cref="MaxValue" /> if the converted value is too large
        /// to be represented by a <see cref="DateTime" /> object, or <see cref="MinValue" />
        /// if the converted value is too small to be represented by a <see cref="DateTime" />
        /// object.
        /// </returns>
        public System.DateTime ToUniversalTime() { return default(System.DateTime); }
        /// <summary>
        /// Converts the specified string representation of a date and time to its <see cref="DateTime" />
        /// equivalent and returns a value that indicates whether the conversion succeeded.
        /// </summary>
        /// <param name="s">A string containing a date and time to convert.</param>
        /// <param name="result">
        /// When this method returns, contains the <see cref="DateTime" /> value equivalent to
        /// the date and time contained in <paramref name="s" />, if the conversion succeeded, or
        /// <see cref="MinValue" /> if the conversion failed. The conversion fails if the
        /// <paramref name="s" /> parameter is null, is an empty string (""), or does not contain a valid
        /// string representation of a date and time. This parameter is passed uninitialized.
        /// </param>
        /// <returns>
        /// true if the <paramref name="s" /> parameter was converted successfully; otherwise, false.
        /// </returns>
        public static bool TryParse(string s, out System.DateTime result) { result = default(System.DateTime); return default(bool); }
        /// <summary>
        /// Converts the specified string representation of a date and time to its <see cref="DateTime" />
        /// equivalent using the specified culture-specific format information and formatting style,
        /// and returns a value that indicates whether the conversion succeeded.
        /// </summary>
        /// <param name="s">A string containing a date and time to convert.</param>
        /// <param name="provider">
        /// An object that supplies culture-specific formatting information about <paramref name="s" />.
        /// </param>
        /// <param name="styles">
        /// A bitwise combination of enumeration values that defines how to interpret the parsed date
        /// in relation to the current time zone or the current date. A typical value to specify is
        /// <see cref="Globalization.DateTimeStyles.None" />.
        /// </param>
        /// <param name="result">
        /// When this method returns, contains the <see cref="DateTime" /> value equivalent to
        /// the date and time contained in <paramref name="s" />, if the conversion succeeded, or
        /// <see cref="MinValue" /> if the conversion failed. The conversion fails if the
        /// <paramref name="s" /> parameter is null, is an empty string (""), or does not contain a valid
        /// string representation of a date and time. This parameter is passed uninitialized.
        /// </param>
        /// <returns>
        /// true if the <paramref name="s" /> parameter was converted successfully; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// <paramref name="styles" /> is not a valid <see cref="Globalization.DateTimeStyles" />
        /// value.-or-<paramref name="styles" /> contains an invalid combination of
        /// <see cref="Globalization.DateTimeStyles" /> values (for example, both <see cref="Globalization.DateTimeStyles.AssumeLocal" />
        /// and <see cref="Globalization.DateTimeStyles.AssumeUniversal" />).
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <paramref name="provider" /> is a neutral culture and cannot be used in a parsing operation.
        /// </exception>
        public static bool TryParse(string s, System.IFormatProvider provider, System.Globalization.DateTimeStyles styles, out System.DateTime result) { result = default(System.DateTime); return default(bool); }
        /// <summary>
        /// Converts the specified string representation of a date and time to its <see cref="DateTime" />
        /// equivalent using the specified format, culture-specific format information, and style.
        /// The format of the string representation must match the specified format exactly. The method
        /// returns a value that indicates whether the conversion succeeded.
        /// </summary>
        /// <param name="s">A string containing a date and time to convert.</param>
        /// <param name="format">
        /// The required format of <paramref name="s" />. See the Remarks section for more information.
        /// </param>
        /// <param name="provider">
        /// An object that supplies culture-specific formatting information about <paramref name="s" />.
        /// </param>
        /// <param name="style">
        /// A bitwise combination of one or more enumeration values that indicate the permitted format
        /// of <paramref name="s" />.
        /// </param>
        /// <param name="result">
        /// When this method returns, contains the <see cref="DateTime" /> value equivalent to
        /// the date and time contained in <paramref name="s" />, if the conversion succeeded, or
        /// <see cref="MinValue" /> if the conversion failed. The conversion fails if either
        /// the <paramref name="s" /> or <paramref name="format" /> parameter is null, is an empty string,
        /// or does not contain a date and time that correspond to the pattern specified in <paramref name="format" />.
        /// This parameter is passed uninitialized.
        /// </param>
        /// <returns>
        /// true if <paramref name="s" /> was converted successfully; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// <paramref name="styles" /> is not a valid <see cref="Globalization.DateTimeStyles" />
        /// value.-or-<paramref name="styles" /> contains an invalid combination of
        /// <see cref="Globalization.DateTimeStyles" /> values (for example, both <see cref="Globalization.DateTimeStyles.AssumeLocal" />
        /// and <see cref="Globalization.DateTimeStyles.AssumeUniversal" />).
        /// </exception>
        public static bool TryParseExact(string s, string format, System.IFormatProvider provider, System.Globalization.DateTimeStyles style, out System.DateTime result) { result = default(System.DateTime); return default(bool); }
        /// <summary>
        /// Converts the specified string representation of a date and time to its <see cref="DateTime" />
        /// equivalent using the specified array of formats, culture-specific format information, and
        /// style. The format of the string representation must match at least one of the specified formats
        /// exactly. The method returns a value that indicates whether the conversion succeeded.
        /// </summary>
        /// <param name="s">A string that contains a date and time to convert.</param>
        /// <param name="formats">
        /// An array of allowable formats of <paramref name="s" />. See the Remarks section for more information.
        /// </param>
        /// <param name="provider">
        /// An object that supplies culture-specific format information about <paramref name="s" />.
        /// </param>
        /// <param name="style">
        /// A bitwise combination of enumeration values that indicates the permitted format of <paramref name="s" />.
        /// A typical value to specify is <see cref="Globalization.DateTimeStyles.None" />.
        /// </param>
        /// <param name="result">
        /// When this method returns, contains the <see cref="DateTime" /> value equivalent to
        /// the date and time contained in <paramref name="s" />, if the conversion succeeded, or
        /// <see cref="MinValue" /> if the conversion failed. The conversion fails if <paramref name="s" />
        /// or <paramref name="formats" /> is null, <paramref name="s" /> or an element of
        /// <paramref name="formats" /> is an empty string, or the format of <paramref name="s" /> is
        /// not exactly as specified by at least one of the format patterns in <paramref name="formats" />.
        /// This parameter is passed uninitialized.
        /// </param>
        /// <returns>
        /// true if the <paramref name="s" /> parameter was converted successfully; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// <paramref name="styles" /> is not a valid <see cref="Globalization.DateTimeStyles" />
        /// value.-or-<paramref name="styles" /> contains an invalid combination of
        /// <see cref="Globalization.DateTimeStyles" /> values (for example, both <see cref="Globalization.DateTimeStyles.AssumeLocal" />
        /// and <see cref="Globalization.DateTimeStyles.AssumeUniversal" />).
        /// </exception>
        public static bool TryParseExact(string s, string[] formats, System.IFormatProvider provider, System.Globalization.DateTimeStyles style, out System.DateTime result) { result = default(System.DateTime); return default(bool); }
    }
    /// <summary>
    /// Specifies whether a <see cref="DateTime" /> object represents a local time, a Coordinated
    /// Universal Time (UTC), or is not specified as either local time or UTC.
    /// </summary>
    public enum DateTimeKind
    {
        /// <summary>
        /// The time represented is local time.
        /// </summary>
        Local = 2,
        /// <summary>
        /// The time represented is not specified as either local time or Coordinated Universal Time (UTC).
        /// </summary>
        Unspecified = 0,
        /// <summary>
        /// The time represented is UTC.
        /// </summary>
        Utc = 1,
    }
    /// <summary>
    /// Represents a point in time, typically expressed as a date and time of day, relative to Coordinated
    /// Universal Time (UTC).
    /// </summary>
    public partial struct DateTimeOffset : System.IComparable, System.IComparable<System.DateTimeOffset>, System.IEquatable<System.DateTimeOffset>, System.IFormattable
    {
        /// <summary>
        /// Represents the greatest possible value of <see cref="DateTimeOffset" />. This field
        /// is read-only.
        /// </summary>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <see cref="System.DateTime.MaxValue" /> is outside the range of the current or specified
        /// culture's default calendar.
        /// </exception>
        public static readonly System.DateTimeOffset MaxValue;
        /// <summary>
        /// Represents the earliest possible <see cref="DateTimeOffset" /> value. This field
        /// is read-only.
        /// </summary>
        public static readonly System.DateTimeOffset MinValue;
        /// <summary>
        /// Initializes a new instance of the <see cref="DateTimeOffset" /> structure using the
        /// specified <see cref="System.DateTime" /> value.
        /// </summary>
        /// <param name="dateTime">A date and time.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The Coordinated Universal Time (UTC) date and time that results from applying the offset is
        /// earlier than <see cref="MinValue" />.-or-The UTC date and time that
        /// results from applying the offset is later than <see cref="MaxValue" />.
        /// </exception>
        public DateTimeOffset(System.DateTime dateTime) { throw new System.NotImplementedException(); }
        /// <summary>
        /// Initializes a new instance of the <see cref="DateTimeOffset" /> structure using the
        /// specified <see cref="System.DateTime" /> value and offset.
        /// </summary>
        /// <param name="dateTime">A date and time.</param>
        /// <param name="offset">The time's offset from Coordinated Universal Time (UTC).</param>
        /// <exception cref="ArgumentException">
        /// <paramref name="dateTime.Kind" /> equals <see cref="DateTimeKind.Utc" /> and
        /// <paramref name="offset" /> does not equal zero.-or-<paramref name="dateTime.Kind" /> equals
        /// <see cref="DateTimeKind.Local" /> and <paramref name="offset" /> does not equal the offset of the system's local time zone.-or-
        /// <paramref name="offset" /> is not specified in whole minutes.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="offset" /> is less than -14 hours or greater than 14 hours.-or-
        /// <see cref="UtcDateTime" /> is less than <see cref="MinValue" /> or greater than
        /// <see cref="MaxValue" />.
        /// </exception>
        public DateTimeOffset(System.DateTime dateTime, System.TimeSpan offset) { throw new System.NotImplementedException(); }
        /// <summary>
        /// Initializes a new instance of the <see cref="DateTimeOffset" /> structure using the
        /// specified year, month, day, hour, minute, second, millisecond, and offset.
        /// </summary>
        /// <param name="year">The year (1 through 9999).</param>
        /// <param name="month">The month (1 through 12).</param>
        /// <param name="day">The day (1 through the number of days in <paramref name="month" />).</param>
        /// <param name="hour">The hours (0 through 23).</param>
        /// <param name="minute">The minutes (0 through 59).</param>
        /// <param name="second">The seconds (0 through 59).</param>
        /// <param name="millisecond">The milliseconds (0 through 999).</param>
        /// <param name="offset">The time's offset from Coordinated Universal Time (UTC).</param>
        /// <exception cref="ArgumentException">
        /// <paramref name="offset" /> does not represent whole minutes.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="year" /> is less than one or greater than 9999.-or-<paramref name="month" />
        /// is less than one or greater than 12.-or-<paramref name="day" /> is less than one or greater
        /// than the number of days in <paramref name="month" />.-or-<paramref name="hour" /> is less
        /// than zero or greater than 23.-or-<paramref name="minute" /> is less than 0 or greater than
        /// 59.-or-<paramref name="second" /> is less than 0 or greater than 59.-or-<paramref name="millisecond" />
        /// is less than 0 or greater than 999.-or-<paramref name="offset" /> is less than -14 or greater
        /// than 14.-or-The <see cref="UtcDateTime" /> property is earlier than
        /// <see cref="MinValue" /> or later than <see cref="MaxValue" />.
        /// </exception>
        public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, System.TimeSpan offset) { throw new System.NotImplementedException(); }
        /// <summary>
        /// Initializes a new instance of the <see cref="DateTimeOffset" /> structure using the
        /// specified year, month, day, hour, minute, second, and offset.
        /// </summary>
        /// <param name="year">The year (1 through 9999).</param>
        /// <param name="month">The month (1 through 12).</param>
        /// <param name="day">The day (1 through the number of days in <paramref name="month" />).</param>
        /// <param name="hour">The hours (0 through 23).</param>
        /// <param name="minute">The minutes (0 through 59).</param>
        /// <param name="second">The seconds (0 through 59).</param>
        /// <param name="offset">The time's offset from Coordinated Universal Time (UTC).</param>
        /// <exception cref="ArgumentException">
        /// <paramref name="offset" /> does not represent whole minutes.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="year" /> is less than one or greater than 9999.-or-<paramref name="month" />
        /// is less than one or greater than 12.-or-<paramref name="day" /> is less than one or greater
        /// than the number of days in <paramref name="month" />.-or-<paramref name="hour" /> is less
        /// than zero or greater than 23.-or-<paramref name="minute" /> is less than 0 or greater than
        /// 59.-or-<paramref name="second" /> is less than 0 or greater than 59.-or-<paramref name="offset" />
        /// is less than -14 hours or greater than 14 hours.-or-The <see cref="UtcDateTime" />
        /// property is earlier than <see cref="MinValue" /> or later than
        /// <see cref="MaxValue" />.
        /// </exception>
        public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, System.TimeSpan offset) { throw new System.NotImplementedException(); }
        /// <summary>
        /// Initializes a new instance of the <see cref="DateTimeOffset" /> structure using the
        /// specified number of ticks and offset.
        /// </summary>
        /// <param name="ticks">
        /// A date and time expressed as the number of 100-nanosecond intervals that have elapsed since
        /// 12:00:00 midnight on January 1, 0001.
        /// </param>
        /// <param name="offset">The time's offset from Coordinated Universal Time (UTC).</param>
        /// <exception cref="ArgumentException">
        /// <paramref name="offset" /> is not specified in whole minutes.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The <see cref="UtcDateTime" /> property is earlier than
        /// <see cref="MinValue" /> or later than <see cref="MaxValue" />.-or-
        /// <paramref name="ticks" /> is less than DateTimeOffset.MinValue.Ticks or greater than DateTimeOffset.MaxValue.Ticks.-or-
        /// <paramref name="Offset" /> s less than -14 hours or greater than 14 hours.
        /// </exception>
        public DateTimeOffset(long ticks, System.TimeSpan offset) { throw new System.NotImplementedException(); }
        /// <summary>
        /// Gets a <see cref="System.DateTime" /> value that represents the date component of the current
        /// <see cref="DateTimeOffset" /> object.
        /// </summary>
        /// <returns>
        /// A <see cref="System.DateTime" /> value that represents the date component of the current
        /// <see cref="DateTimeOffset" /> object.
        /// </returns>
        public System.DateTime Date { get { return default(System.DateTime); } }
        /// <summary>
        /// Gets a <see cref="System.DateTime" /> value that represents the date and time of the current
        /// <see cref="DateTimeOffset" /> object.
        /// </summary>
        /// <returns>
        /// The date and time of the current <see cref="DateTimeOffset" /> object.
        /// </returns>
        public System.DateTime DateTime { get { return default(System.DateTime); } }
        /// <summary>
        /// Gets the day of the month represented by the current <see cref="DateTimeOffset" />
        /// object.
        /// </summary>
        /// <returns>
        /// The day component of the current <see cref="DateTimeOffset" /> object, expressed
        /// as a value between 1 and 31.
        /// </returns>
        public int Day { get { return default(int); } }
        /// <summary>
        /// Gets the day of the week represented by the current <see cref="DateTimeOffset" />
        /// object.
        /// </summary>
        /// <returns>
        /// One of the enumeration values that indicates the day of the week of the current
        /// <see cref="DateTimeOffset" /> object.
        /// </returns>
        public System.DayOfWeek DayOfWeek { get { return default(System.DayOfWeek); } }
        /// <summary>
        /// Gets the day of the year represented by the current <see cref="DateTimeOffset" />
        /// object.
        /// </summary>
        /// <returns>
        /// The day of the year of the current <see cref="DateTimeOffset" /> object, expressed
        /// as a value between 1 and 366.
        /// </returns>
        public int DayOfYear { get { return default(int); } }
        /// <summary>
        /// Gets the hour component of the time represented by the current <see cref="DateTimeOffset" />
        /// object.
        /// </summary>
        /// <returns>
        /// The hour component of the current <see cref="DateTimeOffset" /> object. This property
        /// uses a 24-hour clock; the value ranges from 0 to 23.
        /// </returns>
        public int Hour { get { return default(int); } }
        /// <summary>
        /// Gets a <see cref="System.DateTime" /> value that represents the local date and time of the
        /// current <see cref="DateTimeOffset" /> object.
        /// </summary>
        /// <returns>
        /// The local date and time of the current <see cref="DateTimeOffset" /> object.
        /// </returns>
        public System.DateTime LocalDateTime { get { return default(System.DateTime); } }
        /// <summary>
        /// Gets the millisecond component of the time represented by the current <see cref="DateTimeOffset" />
        /// object.
        /// </summary>
        /// <returns>
        /// The millisecond component of the current <see cref="DateTimeOffset" /> object, expressed
        /// as an integer between 0 and 999.
        /// </returns>
        public int Millisecond { get { return default(int); } }
        /// <summary>
        /// Gets the minute component of the time represented by the current <see cref="DateTimeOffset" />
        /// object.
        /// </summary>
        /// <returns>
        /// The minute component of the current <see cref="DateTimeOffset" /> object, expressed
        /// as an integer between 0 and 59.
        /// </returns>
        public int Minute { get { return default(int); } }
        /// <summary>
        /// Gets the month component of the date represented by the current <see cref="DateTimeOffset" />
        /// object.
        /// </summary>
        /// <returns>
        /// The month component of the current <see cref="DateTimeOffset" /> object, expressed
        /// as an integer between 1 and 12.
        /// </returns>
        public int Month { get { return default(int); } }
        /// <summary>
        /// Gets a <see cref="DateTimeOffset" /> object that is set to the current date and time
        /// on the current computer, with the offset set to the local time's offset from Coordinated Universal
        /// Time (UTC).
        /// </summary>
        /// <returns>
        /// A <see cref="DateTimeOffset" /> object whose date and time is the current local time
        /// and whose offset is the local time zone's offset from Coordinated Universal Time (UTC).
        /// </returns>
        public static System.DateTimeOffset Now { get { return default(System.DateTimeOffset); } }
        /// <summary>
        /// Gets the time's offset from Coordinated Universal Time (UTC).
        /// </summary>
        /// <returns>
        /// The difference between the current <see cref="DateTimeOffset" /> object's time value
        /// and Coordinated Universal Time (UTC).
        /// </returns>
        public System.TimeSpan Offset { get { return default(System.TimeSpan); } }
        /// <summary>
        /// Gets the second component of the clock time represented by the current <see cref="DateTimeOffset" />
        /// object.
        /// </summary>
        /// <returns>
        /// The second component of the <see cref="DateTimeOffset" /> object, expressed as an
        /// integer value between 0 and 59.
        /// </returns>
        public int Second { get { return default(int); } }
        /// <summary>
        /// Gets the number of ticks that represents the date and time of the current
        /// <see cref="DateTimeOffset" /> object in clock time.
        /// </summary>
        /// <returns>
        /// The number of ticks in the <see cref="DateTimeOffset" /> object's clock time.
        /// </returns>
        public long Ticks { get { return default(long); } }
        /// <summary>
        /// Gets the time of day for the current <see cref="DateTimeOffset" /> object.
        /// </summary>
        /// <returns>
        /// The time interval of the current date that has elapsed since midnight.
        /// </returns>
        public System.TimeSpan TimeOfDay { get { return default(System.TimeSpan); } }
        /// <summary>
        /// Gets a <see cref="System.DateTime" /> value that represents the Coordinated Universal Time
        /// (UTC) date and time of the current <see cref="DateTimeOffset" /> object.
        /// </summary>
        /// <returns>
        /// The Coordinated Universal Time (UTC) date and time of the current <see cref="DateTimeOffset" />
        /// object.
        /// </returns>
        public System.DateTime UtcDateTime { get { return default(System.DateTime); } }
        /// <summary>
        /// Gets a <see cref="DateTimeOffset" /> object whose date and time are set to the current
        /// Coordinated Universal Time (UTC) date and time and whose offset is <see cref="TimeSpan.Zero" />.
        /// </summary>
        /// <returns>
        /// An object whose date and time is the current Coordinated Universal Time (UTC) and whose offset
        /// is <see cref="TimeSpan.Zero" />.
        /// </returns>
        public static System.DateTimeOffset UtcNow { get { return default(System.DateTimeOffset); } }
        /// <summary>
        /// Gets the number of ticks that represents the date and time of the current
        /// <see cref="DateTimeOffset" /> object in Coordinated Universal Time (UTC).
        /// </summary>
        /// <returns>
        /// The number of ticks in the <see cref="DateTimeOffset" /> object's Coordinated Universal
        /// Time (UTC).
        /// </returns>
        public long UtcTicks { get { return default(long); } }
        /// <summary>
        /// Gets the year component of the date represented by the current <see cref="DateTimeOffset" />
        /// object.
        /// </summary>
        /// <returns>
        /// The year component of the current <see cref="DateTimeOffset" /> object, expressed
        /// as an integer value between 0 and 9999.
        /// </returns>
        public int Year { get { return default(int); } }
        /// <summary>
        /// Returns a new <see cref="DateTimeOffset" /> object that adds a specified time interval
        /// to the value of this instance.
        /// </summary>
        /// <param name="timeSpan">
        /// A <see cref="TimeSpan" /> object that represents a positive or a negative time interval.
        /// </param>
        /// <returns>
        /// An object whose value is the sum of the date and time represented by the current
        /// <see cref="DateTimeOffset" /> object and the time interval represented by <paramref name="timeSpan" />.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The resulting <see cref="DateTimeOffset" /> value is less than
        /// <see cref="MinValue" />.-or- The resulting <see cref="DateTimeOffset" /> value is greater than
        /// <see cref="MaxValue" />.
        /// </exception>
        public System.DateTimeOffset Add(System.TimeSpan timeSpan) { return default(System.DateTimeOffset); }
        /// <summary>
        /// Returns a new <see cref="DateTimeOffset" /> object that adds a specified number of
        /// whole and fractional days to the value of this instance.
        /// </summary>
        /// <param name="days">A number of whole and fractional days. The number can be negative or positive.</param>
        /// <returns>
        /// An object whose value is the sum of the date and time represented by the current
        /// <see cref="DateTimeOffset" /> object and the number of days represented by <paramref name="days" />.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The resulting <see cref="DateTimeOffset" /> value is less than
        /// <see cref="MinValue" />.-or- The resulting <see cref="DateTimeOffset" /> value is greater than
        /// <see cref="MaxValue" />.
        /// </exception>
        public System.DateTimeOffset AddDays(double days) { return default(System.DateTimeOffset); }
        /// <summary>
        /// Returns a new <see cref="DateTimeOffset" /> object that adds a specified number of
        /// whole and fractional hours to the value of this instance.
        /// </summary>
        /// <param name="hours">A number of whole and fractional hours. The number can be negative or positive.</param>
        /// <returns>
        /// An object whose value is the sum of the date and time represented by the current
        /// <see cref="DateTimeOffset" /> object and the number of hours represented by <paramref name="hours" />.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The resulting <see cref="DateTimeOffset" /> value is less than
        /// <see cref="MinValue" />.-or- The resulting <see cref="DateTimeOffset" /> value is greater than
        /// <see cref="MaxValue" />.
        /// </exception>
        public System.DateTimeOffset AddHours(double hours) { return default(System.DateTimeOffset); }
        /// <summary>
        /// Returns a new <see cref="DateTimeOffset" /> object that adds a specified number of
        /// milliseconds to the value of this instance.
        /// </summary>
        /// <param name="milliseconds">
        /// A number of whole and fractional milliseconds. The number can be negative or positive.
        /// </param>
        /// <returns>
        /// An object whose value is the sum of the date and time represented by the current
        /// <see cref="DateTimeOffset" /> object and the number of whole milliseconds represented by <paramref name="milliseconds" />.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The resulting <see cref="DateTimeOffset" /> value is less than
        /// <see cref="MinValue" />.-or- The resulting <see cref="DateTimeOffset" /> value is greater than
        /// <see cref="MaxValue" />.
        /// </exception>
        public System.DateTimeOffset AddMilliseconds(double milliseconds) { return default(System.DateTimeOffset); }
        /// <summary>
        /// Returns a new <see cref="DateTimeOffset" /> object that adds a specified number of
        /// whole and fractional minutes to the value of this instance.
        /// </summary>
        /// <param name="minutes">A number of whole and fractional minutes. The number can be negative or positive.</param>
        /// <returns>
        /// An object whose value is the sum of the date and time represented by the current
        /// <see cref="DateTimeOffset" /> object and the number of minutes represented by <paramref name="minutes" />.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The resulting <see cref="DateTimeOffset" /> value is less than
        /// <see cref="MinValue" />.-or- The resulting <see cref="DateTimeOffset" /> value is greater than
        /// <see cref="MaxValue" />.
        /// </exception>
        public System.DateTimeOffset AddMinutes(double minutes) { return default(System.DateTimeOffset); }
        /// <summary>
        /// Returns a new <see cref="DateTimeOffset" /> object that adds a specified number of
        /// months to the value of this instance.
        /// </summary>
        /// <param name="months">A number of whole months. The number can be negative or positive.</param>
        /// <returns>
        /// An object whose value is the sum of the date and time represented by the current
        /// <see cref="DateTimeOffset" /> object and the number of months represented by <paramref name="months" />.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The resulting <see cref="DateTimeOffset" /> value is less than
        /// <see cref="MinValue" />.-or- The resulting <see cref="DateTimeOffset" /> value is greater than
        /// <see cref="MaxValue" />.
        /// </exception>
        public System.DateTimeOffset AddMonths(int months) { return default(System.DateTimeOffset); }
        /// <summary>
        /// Returns a new <see cref="DateTimeOffset" /> object that adds a specified number of
        /// whole and fractional seconds to the value of this instance.
        /// </summary>
        /// <param name="seconds">A number of whole and fractional seconds. The number can be negative or positive.</param>
        /// <returns>
        /// An object whose value is the sum of the date and time represented by the current
        /// <see cref="DateTimeOffset" /> object and the number of seconds represented by <paramref name="seconds" />.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The resulting <see cref="DateTimeOffset" /> value is less than
        /// <see cref="MinValue" />.-or- The resulting <see cref="DateTimeOffset" /> value is greater than
        /// <see cref="MaxValue" />.
        /// </exception>
        public System.DateTimeOffset AddSeconds(double seconds) { return default(System.DateTimeOffset); }
        /// <summary>
        /// Returns a new <see cref="DateTimeOffset" /> object that adds a specified number of
        /// ticks to the value of this instance.
        /// </summary>
        /// <param name="ticks">A number of 100-nanosecond ticks. The number can be negative or positive.</param>
        /// <returns>
        /// An object whose value is the sum of the date and time represented by the current
        /// <see cref="DateTimeOffset" /> object and the number of ticks represented by <paramref name="ticks" />.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The resulting <see cref="DateTimeOffset" /> value is less than
        /// <see cref="MinValue" />.-or- The resulting <see cref="DateTimeOffset" /> value is greater than
        /// <see cref="MaxValue" />.
        /// </exception>
        public System.DateTimeOffset AddTicks(long ticks) { return default(System.DateTimeOffset); }
        /// <summary>
        /// Returns a new <see cref="DateTimeOffset" /> object that adds a specified number of
        /// years to the value of this instance.
        /// </summary>
        /// <param name="years">A number of years. The number can be negative or positive.</param>
        /// <returns>
        /// An object whose value is the sum of the date and time represented by the current
        /// <see cref="DateTimeOffset" /> object and the number of years represented by <paramref name="years" />.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The resulting <see cref="DateTimeOffset" /> value is less than
        /// <see cref="MinValue" />.-or- The resulting <see cref="DateTimeOffset" /> value is greater than
        /// <see cref="MaxValue" />.
        /// </exception>
        public System.DateTimeOffset AddYears(int years) { return default(System.DateTimeOffset); }
        /// <summary>
        /// Compares two <see cref="DateTimeOffset" /> objects and indicates whether the first
        /// is earlier than the second, equal to the second, or later than the second.
        /// </summary>
        /// <param name="first">The first object to compare.</param>
        /// <param name="second">The second object to compare.</param>
        /// <returns>
        /// A signed integer that indicates whether the value of the <paramref name="first" /> parameter
        /// is earlier than, later than, or the same time as the value of the <paramref name="second" />
        /// parameter, as the following table shows.Return valueMeaningLess than zero<paramref name="first" />
        /// is earlier than <paramref name="second" />.Zero<paramref name="first" /> is equal to <paramref name="second" />.
        /// Greater than zero<paramref name="first" /> is later than <paramref name="second" />.
        /// </returns>
        public static int Compare(System.DateTimeOffset first, System.DateTimeOffset second) { return default(int); }
        /// <summary>
        /// Compares the current <see cref="DateTimeOffset" /> object to a specified
        /// <see cref="DateTimeOffset" /> object and indicates whether the current object is earlier than, the same as, or later
        /// than the second <see cref="DateTimeOffset" /> object.
        /// </summary>
        /// <param name="other">An object to compare with the current <see cref="DateTimeOffset" /> object.</param>
        /// <returns>
        /// A signed integer that indicates the relationship between the current <see cref="DateTimeOffset" />
        /// object and <paramref name="other" />, as the following table shows.Return ValueDescriptionLess
        /// than zeroThe current <see cref="DateTimeOffset" /> object is earlier than <paramref name="other" />.
        /// ZeroThe current <see cref="DateTimeOffset" /> object is the same
        /// as <paramref name="other" />.Greater than zero.The current <see cref="DateTimeOffset" />
        /// object is later than <paramref name="other" />.
        /// </returns>
        public int CompareTo(System.DateTimeOffset other) { return default(int); }
        /// <summary>
        /// Determines whether the current <see cref="DateTimeOffset" /> object represents the
        /// same point in time as a specified <see cref="DateTimeOffset" /> object.
        /// </summary>
        /// <param name="other">An object to compare to the current <see cref="DateTimeOffset" /> object.</param>
        /// <returns>
        /// true if both <see cref="DateTimeOffset" /> objects have the same
        /// <see cref="UtcDateTime" /> value; otherwise, false.
        /// </returns>
        public bool Equals(System.DateTimeOffset other) { return default(bool); }
        /// <summary>
        /// Determines whether two specified <see cref="DateTimeOffset" /> objects represent
        /// the same point in time.
        /// </summary>
        /// <param name="first">The first object to compare.</param>
        /// <param name="second">The second object to compare.</param>
        /// <returns>
        /// true if the two <see cref="DateTimeOffset" /> objects have the same
        /// <see cref="UtcDateTime" /> value; otherwise, false.
        /// </returns>
        public static bool Equals(System.DateTimeOffset first, System.DateTimeOffset second) { return default(bool); }
        /// <summary>
        /// Determines whether a <see cref="DateTimeOffset" /> object represents the same point
        /// in time as a specified object.
        /// </summary>
        /// <param name="obj">The object to compare to the current <see cref="DateTimeOffset" /> object.</param>
        /// <returns>
        /// true if the <paramref name="obj" /> parameter is a <see cref="DateTimeOffset" />
        /// object and represents the same point in time as the current <see cref="DateTimeOffset" />
        /// object; otherwise, false.
        /// </returns>
        public override bool Equals(object obj) { return default(bool); }
        /// <summary>
        /// Determines whether the current <see cref="DateTimeOffset" /> object represents the
        /// same time and has the same offset as a specified <see cref="DateTimeOffset" /> object.
        /// </summary>
        /// <param name="other">The object to compare to the current <see cref="DateTimeOffset" /> object.</param>
        /// <returns>
        /// true if the current <see cref="DateTimeOffset" /> object and <paramref name="other" />
        /// have the same date and time value and the same <see cref="Offset" />
        /// value; otherwise, false.
        /// </returns>
        public bool EqualsExact(System.DateTimeOffset other) { return default(bool); }
        /// <summary>
        /// Converts the specified Windows file time to an equivalent local time.
        /// </summary>
        /// <param name="fileTime">A Windows file time, expressed in ticks.</param>
        /// <returns>
        /// An object that represents the date and time of <paramref name="fileTime" /> with the offset
        /// set to the local time offset.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="filetime" /> is less than zero.-or-<paramref name="filetime" /> is greater
        /// than DateTimeOffset.MaxValue.Ticks.
        /// </exception>
        public static System.DateTimeOffset FromFileTime(long fileTime) { return default(System.DateTimeOffset); }
        /// <summary>
        /// Converts a Unix time expressed as the number of milliseconds that have elapsed since 1970-01-01T00:00:00Z
        /// to a <see cref="DateTimeOffset" /> value.
        /// </summary>
        /// <param name="milliseconds">
        /// A Unix time, expressed as the number of milliseconds that have elapsed since 1970-01-01T00:00:00Z
        /// (January 1, 1970, at 12:00 AM UTC). For Unix times before this date, its value is negative.
        /// </param>
        /// <returns>
        /// A date and time value that represents the same moment in time as the Unix time.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="milliseconds" /> is less than  -62,135,596,800,000. -or-<paramref name="milliseconds" />
        /// is greater than 253,402,300,799,999.
        /// </exception>
        public static System.DateTimeOffset FromUnixTimeMilliseconds(long milliseconds) { return default(System.DateTimeOffset); }
        /// <summary>
        /// Converts a Unix time expressed as the number of seconds that have elapsed since 1970-01-01T00:00:00Z
        /// to a <see cref="DateTimeOffset" /> value.
        /// </summary>
        /// <param name="seconds">
        /// A Unix time, expressed as the number of seconds that have elapsed since 1970-01-01T00:00:00Z
        /// (January 1, 1970, at 12:00 AM UTC). For Unix times before this date, its value is negative.
        /// </param>
        /// <returns>
        /// A date and time value that represents the same moment in time as the Unix time.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="seconds" /> is less than  -62,135,596,800. -or-<paramref name="seconds" />
        /// is greater than 253,402,300,799.
        /// </exception>
        public static System.DateTimeOffset FromUnixTimeSeconds(long seconds) { return default(System.DateTimeOffset); }
        /// <summary>
        /// Returns the hash code for the current <see cref="DateTimeOffset" /> object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code.
        /// </returns>
        public override int GetHashCode() { return default(int); }
        /// <summary>
        /// Adds a specified time interval to a <see cref="DateTimeOffset" /> object that has
        /// a specified date and time, and yields a <see cref="DateTimeOffset" /> object that
        /// has new a date and time.
        /// </summary>
        /// <param name="dateTimeOffset">The object to add the time interval to.</param>
        /// <param name="timeSpan">The time interval to add.</param>
        /// <returns>
        /// An object whose value is the sum of the values of <paramref name="dateTimeTz" /> and
        /// <paramref name="timeSpan" />.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The resulting <see cref="DateTimeOffset" /> value is less than
        /// <see cref="MinValue" />.-or- The resulting <see cref="DateTimeOffset" /> value is greater than
        /// <see cref="MaxValue" />.
        /// </exception>
        public static System.DateTimeOffset operator +(System.DateTimeOffset dateTimeOffset, System.TimeSpan timeSpan) { return default(System.DateTimeOffset); }
        /// <summary>
        /// Determines whether two specified <see cref="DateTimeOffset" /> objects represent
        /// the same point in time.
        /// </summary>
        /// <param name="left">The first object to compare.</param>
        /// <param name="right">The second object to compare.</param>
        /// <returns>
        /// true if both <see cref="DateTimeOffset" /> objects have the same
        /// <see cref="UtcDateTime" /> value; otherwise, false.
        /// </returns>
        public static bool operator ==(System.DateTimeOffset left, System.DateTimeOffset right) { return default(bool); }
        /// <summary>
        /// Determines whether one specified <see cref="DateTimeOffset" /> object is greater
        /// than (or later than) a second specified <see cref="DateTimeOffset" /> object.
        /// </summary>
        /// <param name="left">The first object to compare.</param>
        /// <param name="right">The second object to compare.</param>
        /// <returns>
        /// true if the <see cref="UtcDateTime" /> value of <paramref name="left" />
        /// is later than the <see cref="UtcDateTime" /> value of <paramref name="right" />;
        /// otherwise, false.
        /// </returns>
        public static bool operator >(System.DateTimeOffset left, System.DateTimeOffset right) { return default(bool); }
        /// <summary>
        /// Determines whether one specified <see cref="DateTimeOffset" /> object is greater
        /// than or equal to a second specified <see cref="DateTimeOffset" /> object.
        /// </summary>
        /// <param name="left">The first object to compare.</param>
        /// <param name="right">The second object to compare.</param>
        /// <returns>
        /// true if the <see cref="UtcDateTime" /> value of <paramref name="left" />
        /// is the same as or later than the <see cref="UtcDateTime" /> value
        /// of <paramref name="right" />; otherwise, false.
        /// </returns>
        public static bool operator >=(System.DateTimeOffset left, System.DateTimeOffset right) { return default(bool); }
        /// <summary>
        /// Defines an implicit conversion of a <see cref="System.DateTime" /> object to a
        /// <see cref="DateTimeOffset" /> object.
        /// </summary>
        /// <param name="dateTime">The object to convert.</param>
        /// <returns>
        /// The converted object.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The Coordinated Universal Time (UTC) date and time that results from applying the offset is
        /// earlier than <see cref="MinValue" />.-or-The UTC date and time that
        /// results from applying the offset is later than <see cref="MaxValue" />.
        /// </exception>
        public static implicit operator System.DateTimeOffset(System.DateTime dateTime) { return default(System.DateTimeOffset); }
        /// <summary>
        /// Determines whether two specified <see cref="DateTimeOffset" /> objects refer to different
        /// points in time.
        /// </summary>
        /// <param name="left">The first object to compare.</param>
        /// <param name="right">The second object to compare.</param>
        /// <returns>
        /// true if <paramref name="left" /> and <paramref name="right" /> do not have the same
        /// <see cref="UtcDateTime" /> value; otherwise, false.
        /// </returns>
        public static bool operator !=(System.DateTimeOffset left, System.DateTimeOffset right) { return default(bool); }
        /// <summary>
        /// Determines whether one specified <see cref="DateTimeOffset" /> object is less than
        /// a second specified <see cref="DateTimeOffset" /> object.
        /// </summary>
        /// <param name="left">The first object to compare.</param>
        /// <param name="right">The second object to compare.</param>
        /// <returns>
        /// true if the <see cref="UtcDateTime" /> value of <paramref name="left" />
        /// is earlier than the <see cref="UtcDateTime" /> value of <paramref name="right" />;
        /// otherwise, false.
        /// </returns>
        public static bool operator <(System.DateTimeOffset left, System.DateTimeOffset right) { return default(bool); }
        /// <summary>
        /// Determines whether one specified <see cref="DateTimeOffset" /> object is less than
        /// a second specified <see cref="DateTimeOffset" /> object.
        /// </summary>
        /// <param name="left">The first object to compare.</param>
        /// <param name="right">The second object to compare.</param>
        /// <returns>
        /// true if the <see cref="UtcDateTime" /> value of <paramref name="left" />
        /// is earlier than the <see cref="UtcDateTime" /> value of <paramref name="right" />;
        /// otherwise, false.
        /// </returns>
        public static bool operator <=(System.DateTimeOffset left, System.DateTimeOffset right) { return default(bool); }
        /// <summary>
        /// Subtracts one <see cref="DateTimeOffset" /> object from another and yields a time
        /// interval.
        /// </summary>
        /// <param name="left">The minuend.</param>
        /// <param name="right">The subtrahend.</param>
        /// <returns>
        /// An object that represents the difference between <paramref name="left" /> and <paramref name="right" />.
        /// </returns>
        public static System.TimeSpan operator -(System.DateTimeOffset left, System.DateTimeOffset right) { return default(System.TimeSpan); }
        /// <summary>
        /// Subtracts a specified time interval from a specified date and time, and yields a new date and
        /// time.
        /// </summary>
        /// <param name="dateTimeOffset">The date and time object to subtract from.</param>
        /// <param name="timeSpan">The time interval to subtract.</param>
        /// <returns>
        /// An object that is equal to the value of <paramref name="dateTimeOffset" /> minus <paramref name="timeSpan" />.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The resulting <see cref="DateTimeOffset" /> value is less than
        /// <see cref="MinValue" /> or greater than <see cref="MaxValue" />.
        /// </exception>
        public static System.DateTimeOffset operator -(System.DateTimeOffset dateTimeOffset, System.TimeSpan timeSpan) { return default(System.DateTimeOffset); }
        /// <summary>
        /// Converts the specified string representation of a date, time, and offset to its
        /// <see cref="DateTimeOffset" /> equivalent.
        /// </summary>
        /// <param name="input">A string that contains a date and time to convert.</param>
        /// <returns>
        /// An object that is equivalent to the date and time that is contained in <paramref name="input" />.
        /// </returns>
        /// <exception cref="ArgumentException">The offset is greater than 14 hours or less than -14 hours.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="input" /> is null.</exception>
        /// <exception cref="FormatException">
        /// <paramref name="input" /> does not contain a valid string representation of a date and time.-or-
        /// <paramref name="input" /> contains the string representation of an offset value without a date or time.
        /// </exception>
        public static System.DateTimeOffset Parse(string input) { return default(System.DateTimeOffset); }
        /// <summary>
        /// Converts the specified string representation of a date and time to its <see cref="DateTimeOffset" />
        /// equivalent using the specified culture-specific format information.
        /// </summary>
        /// <param name="input">A string that contains a date and time to convert.</param>
        /// <param name="formatProvider">
        /// An object that provides culture-specific format information about <paramref name="input" />.
        /// </param>
        /// <returns>
        /// An object that is equivalent to the date and time that is contained in <paramref name="input" />,
        /// as specified by <paramref name="formatProvider" />.
        /// </returns>
        /// <exception cref="ArgumentException">The offset is greater than 14 hours or less than -14 hours.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="input" /> is null.</exception>
        /// <exception cref="FormatException">
        /// <paramref name="input" /> does not contain a valid string representation of a date and time.-or-
        /// <paramref name="input" /> contains the string representation of an offset value without a date or time.
        /// </exception>
        public static System.DateTimeOffset Parse(string input, System.IFormatProvider formatProvider) { return default(System.DateTimeOffset); }
        /// <summary>
        /// Converts the specified string representation of a date and time to its <see cref="DateTimeOffset" />
        /// equivalent using the specified culture-specific format information and formatting style.
        /// </summary>
        /// <param name="input">A string that contains a date and time to convert.</param>
        /// <param name="formatProvider">
        /// An object that provides culture-specific format information about <paramref name="input" />.
        /// </param>
        /// <param name="styles">
        /// A bitwise combination of enumeration values that indicates the permitted format of <paramref name="input" />.
        /// A typical value to specify is <see cref="Globalization.DateTimeStyles.None" />.
        /// </param>
        /// <returns>
        /// An object that is equivalent to the date and time that is contained in <paramref name="input" />
        /// as specified by <paramref name="formatProvider" /> and <paramref name="styles" />.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// The offset is greater than 14 hours or less than -14 hours.-or-<paramref name="styles" />
        /// is not a valid <see cref="Globalization.DateTimeStyles" /> value.-or-<paramref name="styles" />
        /// includes an unsupported <see cref="Globalization.DateTimeStyles" /> value.-or-<paramref name="styles" />
        /// includes <see cref="Globalization.DateTimeStyles" /> values that
        /// cannot be used together.
        /// </exception>
        /// <exception cref="ArgumentNullException"><paramref name="input" /> is null.</exception>
        /// <exception cref="FormatException">
        /// <paramref name="input" /> does not contain a valid string representation of a date and time.-or-
        /// <paramref name="input" /> contains the string representation of an offset value without a date or time.
        /// </exception>
        public static System.DateTimeOffset Parse(string input, System.IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles) { return default(System.DateTimeOffset); }
        /// <summary>
        /// Converts the specified string representation of a date and time to its <see cref="DateTimeOffset" />
        /// equivalent using the specified format and culture-specific format information. The format
        /// of the string representation must match the specified format exactly.
        /// </summary>
        /// <param name="input">A string that contains a date and time to convert.</param>
        /// <param name="format">A format specifier that defines the expected format of <paramref name="input" />.</param>
        /// <param name="formatProvider">
        /// An object that supplies culture-specific formatting information about <paramref name="input" />.
        /// </param>
        /// <returns>
        /// An object that is equivalent to the date and time that is contained in <paramref name="input" />
        /// as specified by <paramref name="format" /> and <paramref name="formatProvider" />.
        /// </returns>
        /// <exception cref="ArgumentException">The offset is greater than 14 hours or less than -14 hours.</exception>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="input" /> is null.-or-<paramref name="format" /> is null.
        /// </exception>
        /// <exception cref="FormatException">
        /// <paramref name="input" /> is an empty string ("").-or-<paramref name="input" /> does not contain
        /// a valid string representation of a date and time.-or-<paramref name="format" /> is an empty
        /// string.-or-The hour component and the AM/PM designator in <paramref name="input" /> do not
        /// agree.
        /// </exception>
        public static System.DateTimeOffset ParseExact(string input, string format, System.IFormatProvider formatProvider) { return default(System.DateTimeOffset); }
        /// <summary>
        /// Converts the specified string representation of a date and time to its <see cref="DateTimeOffset" />
        /// equivalent using the specified format, culture-specific format information, and style.
        /// The format of the string representation must match the specified format exactly.
        /// </summary>
        /// <param name="input">A string that contains a date and time to convert.</param>
        /// <param name="format">A format specifier that defines the expected format of <paramref name="input" />.</param>
        /// <param name="formatProvider">
        /// An object that supplies culture-specific formatting information about <paramref name="input" />.
        /// </param>
        /// <param name="styles">
        /// A bitwise combination of enumeration values that indicates the permitted format of <paramref name="input" />.
        /// </param>
        /// <returns>
        /// An object that is equivalent to the date and time that is contained in the <paramref name="input" />
        /// parameter, as specified by the <paramref name="format" />, <paramref name="formatProvider" />,
        /// and <paramref name="styles" /> parameters.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// The offset is greater than 14 hours or less than -14 hours.-or-The <paramref name="styles" />
        /// parameter includes an unsupported value.-or-The <paramref name="styles" /> parameter contains
        /// <see cref="Globalization.DateTimeStyles" /> values that cannot be used together.
        /// </exception>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="input" /> is null.-or-<paramref name="format" /> is null.
        /// </exception>
        /// <exception cref="FormatException">
        /// <paramref name="input" /> is an empty string ("").-or-<paramref name="input" /> does not contain
        /// a valid string representation of a date and time.-or-<paramref name="format" /> is an empty
        /// string.-or-The hour component and the AM/PM designator in <paramref name="input" /> do not
        /// agree.
        /// </exception>
        public static System.DateTimeOffset ParseExact(string input, string format, System.IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles) { return default(System.DateTimeOffset); }
        /// <summary>
        /// Converts the specified string representation of a date and time to its <see cref="DateTimeOffset" />
        /// equivalent using the specified formats, culture-specific format information, and style.
        /// The format of the string representation must match one of the specified formats exactly.
        /// </summary>
        /// <param name="input">A string that contains a date and time to convert.</param>
        /// <param name="formats">
        /// An array of format specifiers that define the expected formats of <paramref name="input" />.
        /// </param>
        /// <param name="formatProvider">
        /// An object that supplies culture-specific formatting information about <paramref name="input" />.
        /// </param>
        /// <param name="styles">
        /// A bitwise combination of enumeration values that indicates the permitted format of <paramref name="input" />.
        /// </param>
        /// <returns>
        /// An object that is equivalent to the date and time that is contained in the <paramref name="input" />
        /// parameter, as specified by the <paramref name="formats" />, <paramref name="formatProvider" />,
        /// and <paramref name="styles" /> parameters.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// The offset is greater than 14 hours or less than -14 hours.-or-<paramref name="styles" />
        /// includes an unsupported value.-or-The <paramref name="styles" /> parameter contains
        /// <see cref="Globalization.DateTimeStyles" /> values that cannot be used together.
        /// </exception>
        /// <exception cref="ArgumentNullException"><paramref name="input" /> is null.</exception>
        /// <exception cref="FormatException">
        /// <paramref name="input" /> is an empty string ("").-or-<paramref name="input" /> does not contain
        /// a valid string representation of a date and time.-or-No element of <paramref name="formats" />
        /// contains a valid format specifier.-or-The hour component and the AM/PM designator in <paramref name="input" />
        /// do not agree.
        /// </exception>
        public static System.DateTimeOffset ParseExact(string input, string[] formats, System.IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles) { return default(System.DateTimeOffset); }
        /// <summary>
        /// Subtracts a <see cref="DateTimeOffset" /> value that represents a specific date and
        /// time from the current <see cref="DateTimeOffset" /> object.
        /// </summary>
        /// <param name="value">An object that represents the value to subtract.</param>
        /// <returns>
        /// An object that specifies the interval between the two <see cref="DateTimeOffset" />
        /// objects.
        /// </returns>
        public System.TimeSpan Subtract(System.DateTimeOffset value) { return default(System.TimeSpan); }
        /// <summary>
        /// Subtracts a specified time interval from the current <see cref="DateTimeOffset" />
        /// object.
        /// </summary>
        /// <param name="value">The time interval to subtract.</param>
        /// <returns>
        /// An object that is equal to the date and time represented by the current <see cref="DateTimeOffset" />
        /// object, minus the time interval represented by <paramref name="value" />.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The resulting <see cref="DateTimeOffset" /> value is less than
        /// <see cref="MinValue" />.-or- The resulting <see cref="DateTimeOffset" /> value is greater than
        /// <see cref="MaxValue" />.
        /// </exception>
        public System.DateTimeOffset Subtract(System.TimeSpan value) { return default(System.DateTimeOffset); }
        int System.IComparable.CompareTo(object obj) { return default(int); }
        /// <summary>
        /// Converts the value of the current <see cref="DateTimeOffset" /> object to a Windows
        /// file time.
        /// </summary>
        /// <returns>
        /// The value of the current <see cref="DateTimeOffset" /> object, expressed as a Windows
        /// file time.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The resulting file time would represent a date and time before midnight on January 1, 1601
        /// C.E. Coordinated Universal Time (UTC).
        /// </exception>
        public long ToFileTime() { return default(long); }
        /// <summary>
        /// Converts the current <see cref="DateTimeOffset" /> object to a <see cref="DateTimeOffset" />
        /// object that represents the local time.
        /// </summary>
        /// <returns>
        /// An object that represents the date and time of the current <see cref="DateTimeOffset" />
        /// object converted to local time.
        /// </returns>
        public System.DateTimeOffset ToLocalTime() { return default(System.DateTimeOffset); }
        /// <summary>
        /// Converts the value of the current <see cref="DateTimeOffset" /> object to the date
        /// and time specified by an offset value.
        /// </summary>
        /// <param name="offset">The offset to convert the <see cref="DateTimeOffset" /> value to.</param>
        /// <returns>
        /// An object that is equal to the original <see cref="DateTimeOffset" /> object (that
        /// is, their <see cref="ToUniversalTime" /> methods return identical
        /// points in time) but whose <see cref="Offset" /> property is set to
        /// <paramref name="offset" />.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// The resulting <see cref="DateTimeOffset" /> object has a
        /// <see cref="DateTime" /> value earlier than <see cref="MinValue" />.-or-The resulting
        /// <see cref="DateTimeOffset" /> object has a <see cref="DateTime" />
        /// value later than <see cref="MaxValue" />.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="offset" /> is less than -14 hours.-or-<paramref name="offset" /> is greater
        /// than 14 hours.
        /// </exception>
        public System.DateTimeOffset ToOffset(System.TimeSpan offset) { return default(System.DateTimeOffset); }
        /// <summary>
        /// Converts the value of the current <see cref="DateTimeOffset" /> object to its equivalent
        /// string representation.
        /// </summary>
        /// <returns>
        /// A string representation of a <see cref="DateTimeOffset" /> object that includes the
        /// offset appended at the end of the string.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The date and time is outside the range of dates supported by the calendar used by the current
        /// culture.
        /// </exception>
        public override string ToString() { return default(string); }
        /// <summary>
        /// Converts the value of the current <see cref="DateTimeOffset" /> object to its equivalent
        /// string representation using the specified culture-specific formatting information.
        /// </summary>
        /// <param name="formatProvider">An object that supplies culture-specific formatting information.</param>
        /// <returns>
        /// A string representation of the value of the current <see cref="DateTimeOffset" />
        /// object, as specified by <paramref name="formatProvider" />.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The date and time is outside the range of dates supported by the calendar used by
        /// <paramref name="formatProvider" />.
        /// </exception>
        public string ToString(System.IFormatProvider formatProvider) { return default(string); }
        /// <summary>
        /// Converts the value of the current <see cref="DateTimeOffset" /> object to its equivalent
        /// string representation using the specified format.
        /// </summary>
        /// <param name="format">A format string.</param>
        /// <returns>
        /// A string representation of the value of the current <see cref="DateTimeOffset" />
        /// object, as specified by <paramref name="format" />.
        /// </returns>
        /// <exception cref="FormatException">
        /// The length of <paramref name="format" /> is one, and it is not one of the standard format
        /// specifier characters defined for <see cref="Globalization.DateTimeFormatInfo" />.
        /// -or-<paramref name="format" /> does not contain a valid custom format pattern.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The date and time is outside the range of dates supported by the calendar used by the current
        /// culture.
        /// </exception>
        public string ToString(string format) { return default(string); }
        /// <summary>
        /// Converts the value of the current <see cref="DateTimeOffset" /> object to its equivalent
        /// string representation using the specified format and culture-specific format information.
        /// </summary>
        /// <param name="format">A format string.</param>
        /// <param name="formatProvider">An object that supplies culture-specific formatting information.</param>
        /// <returns>
        /// A string representation of the value of the current <see cref="DateTimeOffset" />
        /// object, as specified by <paramref name="format" /> and <paramref name="provider" />.
        /// </returns>
        /// <exception cref="FormatException">
        /// The length of <paramref name="format" /> is one, and it is not one of the standard format
        /// specifier characters defined for <see cref="Globalization.DateTimeFormatInfo" />.-or-<paramref name="format" />
        /// does not contain a valid custom format pattern.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The date and time is outside the range of dates supported by the calendar used by
        /// <paramref name="formatProvider" />.
        /// </exception>
        public string ToString(string format, System.IFormatProvider formatProvider) { return default(string); }
        /// <summary>
        /// Converts the current <see cref="DateTimeOffset" /> object to a <see cref="DateTimeOffset" />
        /// value that represents the Coordinated Universal Time (UTC).
        /// </summary>
        /// <returns>
        /// An object that represents the date and time of the current <see cref="DateTimeOffset" />
        /// object converted to Coordinated Universal Time (UTC).
        /// </returns>
        public System.DateTimeOffset ToUniversalTime() { return default(System.DateTimeOffset); }
        /// <summary>
        /// Returns the number of milliseconds that have elapsed since 1970-01-01T00:00:00.000Z.
        /// </summary>
        /// <returns>
        /// The number of milliseconds that have elapsed since 1970-01-01T00:00:00.000Z.
        /// </returns>
        public long ToUnixTimeMilliseconds() { return default(long); }
        /// <summary>
        /// Returns the number of seconds that have elapsed since 1970-01-01T00:00:00Z.
        /// </summary>
        /// <returns>
        /// The number of seconds that have elapsed since 1970-01-01T00:00:00Z.
        /// </returns>
        public long ToUnixTimeSeconds() { return default(long); }
        /// <summary>
        /// Tries to converts a specified string representation of a date and time to its
        /// <see cref="DateTimeOffset" /> equivalent, and returns a value that indicates whether the conversion succeeded.
        /// </summary>
        /// <param name="input">A string that contains a date and time to convert.</param>
        /// <param name="result">
        /// When the method returns, contains the <see cref="DateTimeOffset" /> equivalent to
        /// the date and time of <paramref name="input" />, if the conversion succeeded, or
        /// <see cref="MinValue" />, if the conversion failed. The conversion fails if the <paramref name="input" /> parameter
        /// is null or does not contain a valid string representation of a date and time. This parameter
        /// is passed uninitialized.
        /// </param>
        /// <returns>
        /// true if the <paramref name="input" /> parameter is successfully converted; otherwise, false.
        /// </returns>
        public static bool TryParse(string input, out System.DateTimeOffset result) { result = default(System.DateTimeOffset); return default(bool); }
        /// <summary>
        /// Tries to convert a specified string representation of a date and time to its
        /// <see cref="DateTimeOffset" /> equivalent, and returns a value that indicates whether the conversion succeeded.
        /// </summary>
        /// <param name="input">A string that contains a date and time to convert.</param>
        /// <param name="formatProvider">
        /// An object that provides culture-specific formatting information about <paramref name="input" />.
        /// </param>
        /// <param name="styles">
        /// A bitwise combination of enumeration values that indicates the permitted format of <paramref name="input" />.
        /// </param>
        /// <param name="result">
        /// When the method returns, contains the <see cref="DateTimeOffset" /> value equivalent
        /// to the date and time of <paramref name="input" />, if the conversion succeeded, or
        /// <see cref="MinValue" />, if the conversion failed. The conversion fails if the <paramref name="input" /> parameter
        /// is null or does not contain a valid string representation of a date and time. This parameter
        /// is passed uninitialized.
        /// </param>
        /// <returns>
        /// true if the <paramref name="input" /> parameter is successfully converted; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// <paramref name="styles" /> includes an undefined <see cref="Globalization.DateTimeStyles" />
        /// value.-or-<see cref="Globalization.DateTimeStyles.NoCurrentDateDefault" />  is
        /// not supported.-or-<paramref name="styles" /> includes mutually exclusive
        /// <see cref="Globalization.DateTimeStyles" /> values.
        /// </exception>
        public static bool TryParse(string input, System.IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles, out System.DateTimeOffset result) { result = default(System.DateTimeOffset); return default(bool); }
        /// <summary>
        /// Converts the specified string representation of a date and time to its <see cref="DateTimeOffset" />
        /// equivalent using the specified format, culture-specific format information, and style.
        /// The format of the string representation must match the specified format exactly.
        /// </summary>
        /// <param name="input">A string that contains a date and time to convert.</param>
        /// <param name="format">A format specifier that defines the required format of <paramref name="input" />.</param>
        /// <param name="formatProvider">
        /// An object that supplies culture-specific formatting information about <paramref name="input" />.
        /// </param>
        /// <param name="styles">
        /// A bitwise combination of enumeration values that indicates the permitted format of input. A
        /// typical value to specify is None.
        /// </param>
        /// <param name="result">
        /// When the method returns, contains the <see cref="DateTimeOffset" /> equivalent to
        /// the date and time of <paramref name="input" />, if the conversion succeeded, or
        /// <see cref="MinValue" />, if the conversion failed. The conversion fails if the <paramref name="input" /> parameter
        /// is null, or does not contain a valid string representation of a date and time in the expected
        /// format defined by <paramref name="format" /> and <paramref name="provider" />. This parameter
        /// is passed uninitialized.
        /// </param>
        /// <returns>
        /// true if the <paramref name="input" /> parameter is successfully converted; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// <paramref name="styles" /> includes an undefined <see cref="Globalization.DateTimeStyles" />
        /// value.-or-<see cref="Globalization.DateTimeStyles.NoCurrentDateDefault" />  is
        /// not supported.-or-<paramref name="styles" /> includes mutually exclusive
        /// <see cref="Globalization.DateTimeStyles" /> values.
        /// </exception>
        public static bool TryParseExact(string input, string format, System.IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles, out System.DateTimeOffset result) { result = default(System.DateTimeOffset); return default(bool); }
        /// <summary>
        /// Converts the specified string representation of a date and time to its <see cref="DateTimeOffset" />
        /// equivalent using the specified array of formats, culture-specific format information, and
        /// style. The format of the string representation must match one of the specified formats exactly.
        /// </summary>
        /// <param name="input">A string that contains a date and time to convert.</param>
        /// <param name="formats">An array that defines the expected formats of <paramref name="input" />.</param>
        /// <param name="formatProvider">
        /// An object that supplies culture-specific formatting information about <paramref name="input" />.
        /// </param>
        /// <param name="styles">
        /// A bitwise combination of enumeration values that indicates the permitted format of input. A
        /// typical value to specify is None.
        /// </param>
        /// <param name="result">
        /// When the method returns, contains the <see cref="DateTimeOffset" /> equivalent to
        /// the date and time of <paramref name="input" />, if the conversion succeeded, or
        /// <see cref="MinValue" />, if the conversion failed. The conversion fails if the <paramref name="input" /> does not
        /// contain a valid string representation of a date and time, or does not contain the date and
        /// time in the expected format defined by <paramref name="format" />, or if <paramref name="formats" />
        /// is null. This parameter is passed uninitialized.
        /// </param>
        /// <returns>
        /// true if the <paramref name="input" /> parameter is successfully converted; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// <paramref name="styles" /> includes an undefined <see cref="Globalization.DateTimeStyles" />
        /// value.-or-<see cref="Globalization.DateTimeStyles.NoCurrentDateDefault" />  is
        /// not supported.-or-<paramref name="styles" /> includes mutually exclusive
        /// <see cref="Globalization.DateTimeStyles" /> values.
        /// </exception>
        public static bool TryParseExact(string input, string[] formats, System.IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles, out System.DateTimeOffset result) { result = default(System.DateTimeOffset); return default(bool); }
    }
    /// <summary>
    /// Specifies the day of the week.
    /// </summary>
    public enum DayOfWeek
    {
        /// <summary>
        /// Indicates Friday.
        /// </summary>
        Friday = 5,
        /// <summary>
        /// Indicates Monday.
        /// </summary>
        Monday = 1,
        /// <summary>
        /// Indicates Saturday.
        /// </summary>
        Saturday = 6,
        /// <summary>
        /// Indicates Sunday.
        /// </summary>
        Sunday = 0,
        /// <summary>
        /// Indicates Thursday.
        /// </summary>
        Thursday = 4,
        /// <summary>
        /// Indicates Tuesday.
        /// </summary>
        Tuesday = 2,
        /// <summary>
        /// Indicates Wednesday.
        /// </summary>
        Wednesday = 3,
    }
    /// <summary>
    /// Represents a decimal number.
    /// </summary>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct Decimal : System.IComparable, System.IComparable<decimal>, System.IConvertible, System.IEquatable<decimal>, System.IFormattable
    {
        /// <summary>
        /// Represents the largest possible value of <see cref="Decimal" />. This field is constant
        /// and read-only.
        /// </summary>
        [System.Runtime.CompilerServices.DecimalConstantAttribute((byte)0, (byte)0, (uint)4294967295, (uint)4294967295, (uint)4294967295)]
        public static readonly decimal MaxValue;
        /// <summary>
        /// Represents the number negative one (-1).
        /// </summary>
        [System.Runtime.CompilerServices.DecimalConstantAttribute((byte)0, (byte)128, (uint)0, (uint)0, (uint)1)]
        public static readonly decimal MinusOne;
        /// <summary>
        /// Represents the smallest possible value of <see cref="Decimal" />. This field is constant
        /// and read-only.
        /// </summary>
        [System.Runtime.CompilerServices.DecimalConstantAttribute((byte)0, (byte)128, (uint)4294967295, (uint)4294967295, (uint)4294967295)]
        public static readonly decimal MinValue;
        /// <summary>
        /// Represents the number one (1).
        /// </summary>
        [System.Runtime.CompilerServices.DecimalConstantAttribute((byte)0, (byte)0, (uint)0, (uint)0, (uint)1)]
        public static readonly decimal One;
        /// <summary>
        /// Represents the number zero (0).
        /// </summary>
        [System.Runtime.CompilerServices.DecimalConstantAttribute((byte)0, (byte)0, (uint)0, (uint)0, (uint)0)]
        public static readonly decimal Zero;
        /// <summary>
        /// Initializes a new instance of <see cref="Decimal" /> to the value of the specified
        /// double-precision floating-point number.
        /// </summary>
        /// <param name="value">The value to represent as a <see cref="Decimal" />.</param>
        /// <exception cref="OverflowException">
        /// <paramref name="value" /> is greater than <see cref="MaxValue" /> or less
        /// than <see cref="MinValue" />.-or- <paramref name="value" /> is <see cref="Double.NaN" />,
        /// <see cref="Double.PositiveInfinity" />, or <see cref="Double.NegativeInfinity" />.
        /// </exception>
        public Decimal(double value) { throw new System.NotImplementedException(); }
        /// <summary>
        /// Initializes a new instance of <see cref="Decimal" /> to the value of the specified
        /// 32-bit signed integer.
        /// </summary>
        /// <param name="value">The value to represent as a <see cref="Decimal" />.</param>
        public Decimal(int value) { throw new System.NotImplementedException(); }
        /// <summary>
        /// Initializes a new instance of <see cref="Decimal" /> from parameters specifying the
        /// instance's constituent parts.
        /// </summary>
        /// <param name="lo">The low 32 bits of a 96-bit integer.</param>
        /// <param name="mid">The middle 32 bits of a 96-bit integer.</param>
        /// <param name="hi">The high 32 bits of a 96-bit integer.</param>
        /// <param name="isNegative">true to indicate a negative number; false to indicate a positive number.</param>
        /// <param name="scale">A power of 10 ranging from 0 to 28.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="scale" /> is greater than 28.
        /// </exception>
        public Decimal(int lo, int mid, int hi, bool isNegative, byte scale) { throw new System.NotImplementedException(); }
        /// <summary>
        /// Initializes a new instance of <see cref="Decimal" /> to a decimal value represented
        /// in binary and contained in a specified array.
        /// </summary>
        /// <param name="bits">An array of 32-bit signed integers containing a representation of a decimal value.</param>
        /// <exception cref="ArgumentNullException"><paramref name="bits" /> is null.</exception>
        /// <exception cref="ArgumentException">
        /// The length of the <paramref name="bits" /> is not 4.-or- The representation of the decimal
        /// value in <paramref name="bits" /> is not valid.
        /// </exception>
        public Decimal(int[] bits) { throw new System.NotImplementedException(); }
        /// <summary>
        /// Initializes a new instance of <see cref="Decimal" /> to the value of the specified
        /// 64-bit signed integer.
        /// </summary>
        /// <param name="value">The value to represent as a <see cref="Decimal" />.</param>
        public Decimal(long value) { throw new System.NotImplementedException(); }
        /// <summary>
        /// Initializes a new instance of <see cref="Decimal" /> to the value of the specified
        /// single-precision floating-point number.
        /// </summary>
        /// <param name="value">The value to represent as a <see cref="Decimal" />.</param>
        /// <exception cref="OverflowException">
        /// <paramref name="value" /> is greater than <see cref="MaxValue" /> or less
        /// than <see cref="MinValue" />.-or- <paramref name="value" /> is <see cref="Single.NaN" />,
        /// <see cref="Single.PositiveInfinity" />, or <see cref="Single.NegativeInfinity" />.
        /// </exception>
        public Decimal(float value) { throw new System.NotImplementedException(); }
        /// <summary>
        /// Initializes a new instance of <see cref="Decimal" /> to the value of the specified
        /// 32-bit unsigned integer.
        /// </summary>
        /// <param name="value">The value to represent as a <see cref="Decimal" />.</param>
        [System.CLSCompliantAttribute(false)]
        public Decimal(uint value) { throw new System.NotImplementedException(); }
        /// <summary>
        /// Initializes a new instance of <see cref="Decimal" /> to the value of the specified
        /// 64-bit unsigned integer.
        /// </summary>
        /// <param name="value">The value to represent as a <see cref="Decimal" />.</param>
        [System.CLSCompliantAttribute(false)]
        public Decimal(ulong value) { throw new System.NotImplementedException(); }
        /// <summary>
        /// Adds two specified <see cref="Decimal" /> values.
        /// </summary>
        /// <param name="d1">The first value to add.</param>
        /// <param name="d2">The second value to add.</param>
        /// <returns>
        /// The sum of <paramref name="d1" /> and <paramref name="d2" />.
        /// </returns>
        /// <exception cref="OverflowException">
        /// The sum of <paramref name="d1" /> and <paramref name="d2" /> is less than
        /// <see cref="MinValue" /> or greater than <see cref="MaxValue" />.
        /// </exception>
        public static decimal Add(decimal d1, decimal d2) { return default(decimal); }
        /// <summary>
        /// Returns the smallest integral value that is greater than or equal to the specified decimal
        /// number.
        /// </summary>
        /// <param name="d">A decimal number.</param>
        /// <returns>
        /// The smallest integral value that is greater than or equal to the <paramref name="d" /> parameter.
        /// Note that this method returns a <see cref="Decimal" /> instead of an integral type.
        /// </returns>
        public static decimal Ceiling(decimal d) { return default(decimal); }
        /// <summary>
        /// Compares two specified <see cref="Decimal" /> values.
        /// </summary>
        /// <param name="d1">The first value to compare.</param>
        /// <param name="d2">The second value to compare.</param>
        /// <returns>
        /// A signed number indicating the relative values of <paramref name="d1" /> and <paramref name="d2" />.
        /// Return value Meaning Less than zero <paramref name="d1" /> is less than <paramref name="d2" />.
        /// Zero <paramref name="d1" /> and <paramref name="d2" /> are equal. Greater than zero <paramref name="d1" />
        /// is greater than <paramref name="d2" />.
        /// </returns>
        public static int Compare(decimal d1, decimal d2) { return default(int); }
        /// <summary>
        /// Compares this instance to a specified <see cref="Decimal" /> object and returns a
        /// comparison of their relative values.
        /// </summary>
        /// <param name="value">The object to compare with this instance.</param>
        /// <returns>
        /// A signed number indicating the relative values of this instance and <paramref name="value" />.
        /// Return value Meaning Less than zero This instance is less than <paramref name="value" />.
        /// Zero This instance is equal to <paramref name="value" />. Greater than zero This instance
        /// is greater than <paramref name="value" />.
        /// </returns>
        public int CompareTo(decimal value) { return default(int); }
        /// <summary>
        /// Divides two specified <see cref="Decimal" /> values.
        /// </summary>
        /// <param name="d1">The dividend.</param>
        /// <param name="d2">The divisor.</param>
        /// <returns>
        /// The result of dividing <paramref name="d1" /> by <paramref name="d2" />.
        /// </returns>
        /// <exception cref="DivideByZeroException"><paramref name="d2" /> is zero.</exception>
        /// <exception cref="OverflowException">
        /// The return value (that is, the quotient) is less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />.
        /// </exception>
        public static decimal Divide(decimal d1, decimal d2) { return default(decimal); }
        /// <summary>
        /// Returns a value indicating whether this instance and a specified <see cref="Decimal" />
        /// object represent the same value.
        /// </summary>
        /// <param name="value">An object to compare to this instance.</param>
        /// <returns>
        /// true if <paramref name="value" /> is equal to this instance; otherwise, false.
        /// </returns>
        public bool Equals(decimal value) { return default(bool); }
        /// <summary>
        /// Returns a value indicating whether two specified instances of <see cref="Decimal" />
        /// represent the same value.
        /// </summary>
        /// <param name="d1">The first value to compare.</param>
        /// <param name="d2">The second value to compare.</param>
        /// <returns>
        /// true if <paramref name="d1" /> and <paramref name="d2" /> are equal; otherwise, false.
        /// </returns>
        public static bool Equals(decimal d1, decimal d2) { return default(bool); }
        /// <summary>
        /// Returns a value indicating whether this instance and a specified <see cref="Object" />
        /// represent the same type and value.
        /// </summary>
        /// <param name="value">The object to compare with this instance.</param>
        /// <returns>
        /// true if <paramref name="value" /> is a <see cref="Decimal" /> and equal to this instance;
        /// otherwise, false.
        /// </returns>
        public override bool Equals(object value) { return default(bool); }
        /// <summary>
        /// Rounds a specified <see cref="Decimal" /> number to the closest integer toward negative
        /// infinity.
        /// </summary>
        /// <param name="d">The value to round.</param>
        /// <returns>
        /// If <paramref name="d" /> has a fractional part, the next whole <see cref="Decimal" />
        /// number toward negative infinity that is less than <paramref name="d" />.-or- If <paramref name="d" />
        /// doesn't have a fractional part, <paramref name="d" /> is returned unchanged. Note
        /// that the method returns an integral value of type <see cref="Decimal" />.
        /// </returns>
        public static decimal Floor(decimal d) { return default(decimal); }
        /// <summary>
        /// Converts the value of a specified instance of <see cref="Decimal" /> to its equivalent
        /// binary representation.
        /// </summary>
        /// <param name="d">The value to convert.</param>
        /// <returns>
        /// A 32-bit signed integer array with four elements that contain the binary representation of
        /// <paramref name="d" />.
        /// </returns>
        public static int[] GetBits(decimal d) { return default(int[]); }
        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code.
        /// </returns>
        public override int GetHashCode() { return default(int); }
        /// <summary>
        /// Multiplies two specified <see cref="Decimal" /> values.
        /// </summary>
        /// <param name="d1">The multiplicand.</param>
        /// <param name="d2">The multiplier.</param>
        /// <returns>
        /// The result of multiplying <paramref name="d1" /> and <paramref name="d2" />.
        /// </returns>
        /// <exception cref="OverflowException">
        /// The return value is less than <see cref="MinValue" /> or greater than
        /// <see cref="MaxValue" />.
        /// </exception>
        public static decimal Multiply(decimal d1, decimal d2) { return default(decimal); }
        /// <summary>
        /// Returns the result of multiplying the specified <see cref="Decimal" /> value by negative
        /// one.
        /// </summary>
        /// <param name="d">The value to negate.</param>
        /// <returns>
        /// A decimal number with the value of <paramref name="d" />, but the opposite sign.-or- Zero,
        /// if <paramref name="d" /> is zero.
        /// </returns>
        public static decimal Negate(decimal d) { return default(decimal); }
        /// <summary>
        /// Adds two specified <see cref="Decimal" /> values.
        /// </summary>
        /// <param name="d1">The first value to add.</param>
        /// <param name="d2">The second value to add.</param>
        /// <returns>
        /// The result of adding <paramref name="d1" /> and <paramref name="d2" />.
        /// </returns>
        /// <exception cref="OverflowException">
        /// The return value is less than <see cref="MinValue" /> or greater than
        /// <see cref="MaxValue" />.
        /// </exception>
        public static decimal operator +(decimal d1, decimal d2) { return default(decimal); }
        /// <summary>
        /// Decrements the <see cref="Decimal" /> operand by one.
        /// </summary>
        /// <param name="d">The value to decrement.</param>
        /// <returns>
        /// The value of <paramref name="d" /> decremented by 1.
        /// </returns>
        /// <exception cref="OverflowException">
        /// The return value is less than <see cref="MinValue" /> or greater than
        /// <see cref="MaxValue" />.
        /// </exception>
        public static decimal operator --(decimal d) { return default(decimal); }
        /// <summary>
        /// Divides two specified <see cref="Decimal" /> values.
        /// </summary>
        /// <param name="d1">The dividend.</param>
        /// <param name="d2">The divisor.</param>
        /// <returns>
        /// The result of dividing <paramref name="d1" /> by <paramref name="d2" />.
        /// </returns>
        /// <exception cref="DivideByZeroException"><paramref name="d2" /> is zero.</exception>
        /// <exception cref="OverflowException">
        /// The return value is less than <see cref="MinValue" /> or greater than
        /// <see cref="MaxValue" />.
        /// </exception>
        public static decimal operator /(decimal d1, decimal d2) { return default(decimal); }
        /// <summary>
        /// Returns a value that indicates whether two <see cref="Decimal" /> values are equal.
        /// </summary>
        /// <param name="d1">The first value to compare.</param>
        /// <param name="d2">The second value to compare.</param>
        /// <returns>
        /// true if <paramref name="d1" /> and <paramref name="d2" /> are equal; otherwise, false.
        /// </returns>
        public static bool operator ==(decimal d1, decimal d2) { return default(bool); }
        /// <summary>
        /// Defines an explicit conversion of a <see cref="Decimal" /> to an 8-bit unsigned integer.
        /// </summary>
        /// <param name="value">The value to convert.</param>
        /// <returns>
        /// An 8-bit unsigned integer that represents the converted <see cref="Decimal" />.
        /// </returns>
        /// <exception cref="OverflowException">
        /// <paramref name="value" /> is less than <see cref="Byte.MinValue" /> or greater than
        /// <see cref="Byte.MaxValue" />.
        /// </exception>
        public static explicit operator byte(decimal value) { return default(byte); }
        /// <summary>
        /// Defines an explicit conversion of a <see cref="Decimal" /> to a Unicode character.
        /// </summary>
        /// <param name="value">The value to convert.</param>
        /// <returns>
        /// A Unicode character that represents the converted <see cref="Decimal" />.
        /// </returns>
        /// <exception cref="OverflowException">
        /// <paramref name="value" /> is less than <see cref="Char.MinValue" /> or greater than
        /// <see cref="Char.MaxValue" />.
        /// </exception>
        public static explicit operator char(decimal value) { return default(char); }
        /// <summary>
        /// Defines an explicit conversion of a <see cref="Decimal" /> to a double-precision
        /// floating-point number.
        /// </summary>
        /// <param name="value">The value to convert.</param>
        /// <returns>
        /// A double-precision floating-point number that represents the converted <see cref="Decimal" />.
        /// </returns>
        public static explicit operator double(decimal value) { return default(double); }
        /// <summary>
        /// Defines an explicit conversion of a <see cref="Decimal" /> to a 16-bit signed integer.
        /// </summary>
        /// <param name="value">The value to convert.</param>
        /// <returns>
        /// A 16-bit signed integer that represents the converted <see cref="Decimal" />.
        /// </returns>
        /// <exception cref="OverflowException">
        /// <paramref name="value" /> is less than <see cref="Int16.MinValue" /> or greater than
        /// <see cref="Int16.MaxValue" />.
        /// </exception>
        public static explicit operator short(decimal value) { return default(short); }
        /// <summary>
        /// Defines an explicit conversion of a <see cref="Decimal" /> to a 32-bit signed integer.
        /// </summary>
        /// <param name="value">The value to convert.</param>
        /// <returns>
        /// A 32-bit signed integer that represents the converted <see cref="Decimal" />.
        /// </returns>
        /// <exception cref="OverflowException">
        /// <paramref name="value" /> is less than <see cref="Int32.MinValue" /> or greater than
        /// <see cref="Int32.MaxValue" />.
        /// </exception>
        public static explicit operator int(decimal value) { return default(int); }
        /// <summary>
        /// Defines an explicit conversion of a <see cref="Decimal" /> to a 64-bit signed integer.
        /// </summary>
        /// <param name="value">The value to convert.</param>
        /// <returns>
        /// A 64-bit signed integer that represents the converted <see cref="Decimal" />.
        /// </returns>
        /// <exception cref="OverflowException">
        /// <paramref name="value" /> is less than <see cref="Int64.MinValue" /> or greater than
        /// <see cref="Int64.MaxValue" />.
        /// </exception>
        public static explicit operator long(decimal value) { return default(long); }
        /// <summary>
        /// Defines an explicit conversion of a <see cref="Decimal" /> to an 8-bit signed integer.
        /// </summary>
        /// <param name="value">The value to convert.</param>
        /// <returns>
        /// An 8-bit signed integer that represents the converted <see cref="Decimal" />.
        /// </returns>
        /// <exception cref="OverflowException">
        /// <paramref name="value" /> is less than <see cref="SByte.MinValue" /> or greater than
        /// <see cref="SByte.MaxValue" />.
        /// </exception>
        [System.CLSCompliantAttribute(false)]
        public static explicit operator sbyte(decimal value) { return default(sbyte); }
        /// <summary>
        /// Defines an explicit conversion of a <see cref="Decimal" /> to a single-precision
        /// floating-point number.
        /// </summary>
        /// <param name="value">The value to convert.</param>
        /// <returns>
        /// A single-precision floating-point number that represents the converted <see cref="Decimal" />.
        /// </returns>
        public static explicit operator float(decimal value) { return default(float); }
        /// <summary>
        /// Defines an explicit conversion of a <see cref="Decimal" /> to a 16-bit unsigned integer.
        /// </summary>
        /// <param name="value">The value to convert.</param>
        /// <returns>
        /// A 16-bit unsigned integer that represents the converted <see cref="Decimal" />.
        /// </returns>
        /// <exception cref="OverflowException">
        /// <paramref name="value" /> is greater than <see cref="UInt16.MaxValue" /> or less
        /// than <see cref="UInt16.MinValue" />.
        /// </exception>
        [System.CLSCompliantAttribute(false)]
        public static explicit operator ushort(decimal value) { return default(ushort); }
        /// <summary>
        /// Defines an explicit conversion of a <see cref="Decimal" /> to a 32-bit unsigned integer.
        /// </summary>
        /// <param name="value">The value to convert.</param>
        /// <returns>
        /// A 32-bit unsigned integer that represents the converted <see cref="Decimal" />.
        /// </returns>
        /// <exception cref="OverflowException">
        /// <paramref name="value" /> is negative or greater than <see cref="UInt32.MaxValue" />.
        /// </exception>
        [System.CLSCompliantAttribute(false)]
        public static explicit operator uint(decimal value) { return default(uint); }
        /// <summary>
        /// Defines an explicit conversion of a <see cref="Decimal" /> to a 64-bit unsigned integer.
        /// </summary>
        /// <param name="value">The value to convert.</param>
        /// <returns>
        /// A 64-bit unsigned integer that represents the converted <see cref="Decimal" />.
        /// </returns>
        /// <exception cref="OverflowException">
        /// <paramref name="value" /> is negative or greater than <see cref="UInt64.MaxValue" />.
        /// </exception>
        [System.CLSCompliantAttribute(false)]
        public static explicit operator ulong(decimal value) { return default(ulong); }
        /// <summary>
        /// Defines an explicit conversion of a double-precision floating-point number to a <see cref="Decimal" />.
        /// </summary>
        /// <param name="value">The double-precision floating-point number to convert.</param>
        /// <returns>
        /// The converted double-precision floating point number.
        /// </returns>
        /// <exception cref="OverflowException">
        /// <paramref name="value" /> is less than <see cref="MinValue" /> or greater
        /// than <see cref="MaxValue" />.-or- <paramref name="value" /> is <see cref="Double.NaN" />,
        /// <see cref="Double.PositiveInfinity" />, or <see cref="Double.NegativeInfinity" />.
        /// </exception>
        public static explicit operator decimal(double value) { return default(decimal); }
        /// <summary>
        /// Defines an explicit conversion of a single-precision floating-point number to a <see cref="Decimal" />.
        /// </summary>
        /// <param name="value">The single-precision floating-point number to convert.</param>
        /// <returns>
        /// The converted single-precision floating point number.
        /// </returns>
        /// <exception cref="OverflowException">
        /// <paramref name="value" /> is less than <see cref="MinValue" /> or greater
        /// than <see cref="MaxValue" />.-or- <paramref name="value" /> is <see cref="Single.NaN" />,
        /// <see cref="Single.PositiveInfinity" />, or <see cref="Single.NegativeInfinity" />.
        /// </exception>
        public static explicit operator decimal(float value) { return default(decimal); }
        /// <summary>
        /// Returns a value indicating whether a specified <see cref="Decimal" /> is greater
        /// than another specified <see cref="Decimal" />.
        /// </summary>
        /// <param name="d1">The first value to compare.</param>
        /// <param name="d2">The second value to compare.</param>
        /// <returns>
        /// true if <paramref name="d1" /> is greater than <paramref name="d2" />; otherwise, false.
        /// </returns>
        public static bool operator >(decimal d1, decimal d2) { return default(bool); }
        /// <summary>
        /// Returns a value indicating whether a specified <see cref="Decimal" /> is greater
        /// than or equal to another specified <see cref="Decimal" />.
        /// </summary>
        /// <param name="d1">The first value to compare.</param>
        /// <param name="d2">The second value to compare.</param>
        /// <returns>
        /// true if <paramref name="d1" /> is greater than or equal to <paramref name="d2" />; otherwise,
        /// false.
        /// </returns>
        public static bool operator >=(decimal d1, decimal d2) { return default(bool); }
        /// <summary>
        /// Defines an implicit conversion of an 8-bit unsigned integer to a <see cref="Decimal" />.
        /// </summary>
        /// <param name="value">The 8-bit unsigned integer to convert.</param>
        /// <returns>
        /// The converted 8-bit unsigned integer.
        /// </returns>
        public static implicit operator decimal(byte value) { return default(decimal); }
        /// <summary>
        /// Defines an implicit conversion of a Unicode character to a <see cref="Decimal" />.
        /// </summary>
        /// <param name="value">The Unicode character to convert.</param>
        /// <returns>
        /// The converted Unicode character.
        /// </returns>
        public static implicit operator decimal(char value) { return default(decimal); }
        /// <summary>
        /// Defines an implicit conversion of a 16-bit signed integer to a <see cref="Decimal" />.
        /// </summary>
        /// <param name="value">The16-bit signed integer to convert.</param>
        /// <returns>
        /// The converted 16-bit signed integer.
        /// </returns>
        public static implicit operator decimal(short value) { return default(decimal); }
        /// <summary>
        /// Defines an implicit conversion of a 32-bit signed integer to a <see cref="Decimal" />.
        /// </summary>
        /// <param name="value">The 32-bit signed integer to convert.</param>
        /// <returns>
        /// The converted 32-bit signed integer.
        /// </returns>
        public static implicit operator decimal(int value) { return default(decimal); }
        /// <summary>
        /// Defines an implicit conversion of a 64-bit signed integer to a <see cref="Decimal" />.
        /// </summary>
        /// <param name="value">The 64-bit signed integer to convert.</param>
        /// <returns>
        /// The converted 64-bit signed integer.
        /// </returns>
        public static implicit operator decimal(long value) { return default(decimal); }
        /// <summary>
        /// Defines an implicit conversion of an 8-bit signed integer to a <see cref="Decimal" />.
        /// </summary>
        /// <param name="value">The 8-bit signed integer to convert.</param>
        /// <returns>
        /// The converted 8-bit signed integer.
        /// </returns>
        [System.CLSCompliantAttribute(false)]
        public static implicit operator decimal(sbyte value) { return default(decimal); }
        /// <summary>
        /// Defines an implicit conversion of a 16-bit unsigned integer to a <see cref="Decimal" />.
        /// </summary>
        /// <param name="value">The 16-bit unsigned integer to convert.</param>
        /// <returns>
        /// The converted 16-bit unsigned integer.
        /// </returns>
        [System.CLSCompliantAttribute(false)]
        public static implicit operator decimal(ushort value) { return default(decimal); }
        /// <summary>
        /// Defines an implicit conversion of a 32-bit unsigned integer to a <see cref="Decimal" />.
        /// </summary>
        /// <param name="value">The 32-bit unsigned integer to convert.</param>
        /// <returns>
        /// The converted 32-bit unsigned integer.
        /// </returns>
        [System.CLSCompliantAttribute(false)]
        public static implicit operator decimal(uint value) { return default(decimal); }
        /// <summary>
        /// Defines an implicit conversion of a 64-bit unsigned integer to a <see cref="Decimal" />.
        /// </summary>
        /// <param name="value">The 64-bit unsigned integer to convert.</param>
        /// <returns>
        /// The converted 64-bit unsigned integer.
        /// </returns>
        [System.CLSCompliantAttribute(false)]
        public static implicit operator decimal(ulong value) { return default(decimal); }
        /// <summary>
        /// Increments the <see cref="Decimal" /> operand by 1.
        /// </summary>
        /// <param name="d">The value to increment.</param>
        /// <returns>
        /// The value of <paramref name="d" /> incremented by 1.
        /// </returns>
        /// <exception cref="OverflowException">
        /// The return value is less than <see cref="MinValue" /> or greater than
        /// <see cref="MaxValue" />.
        /// </exception>
        public static decimal operator ++(decimal d) { return default(decimal); }
        /// <summary>
        /// Returns a value that indicates whether two <see cref="Decimal" /> objects have different
        /// values.
        /// </summary>
        /// <param name="d1">The first value to compare.</param>
        /// <param name="d2">The second value to compare.</param>
        /// <returns>
        /// true if <paramref name="d1" /> and <paramref name="d2" /> are not equal; otherwise, false.
        /// </returns>
        public static bool operator !=(decimal d1, decimal d2) { return default(bool); }
        /// <summary>
        /// Returns a value indicating whether a specified <see cref="Decimal" /> is less than
        /// another specified <see cref="Decimal" />.
        /// </summary>
        /// <param name="d1">The first value to compare.</param>
        /// <param name="d2">The second value to compare.</param>
        /// <returns>
        /// true if <paramref name="d1" /> is less than <paramref name="d2" />; otherwise, false.
        /// </returns>
        public static bool operator <(decimal d1, decimal d2) { return default(bool); }
        /// <summary>
        /// Returns a value indicating whether a specified <see cref="Decimal" /> is less than
        /// or equal to another specified <see cref="Decimal" />.
        /// </summary>
        /// <param name="d1">The first value to compare.</param>
        /// <param name="d2">The second value to compare.</param>
        /// <returns>
        /// true if <paramref name="d1" /> is less than or equal to <paramref name="d2" />; otherwise,
        /// false.
        /// </returns>
        public static bool operator <=(decimal d1, decimal d2) { return default(bool); }
        /// <summary>
        /// Returns the remainder resulting from dividing two specified <see cref="Decimal" />
        /// values.
        /// </summary>
        /// <param name="d1">The dividend.</param>
        /// <param name="d2">The divisor.</param>
        /// <returns>
        /// The remainder resulting from dividing <paramref name="d1" /> by <paramref name="d2" />.
        /// </returns>
        /// <exception cref="DivideByZeroException"><paramref name="d2" /> is zero.</exception>
        /// <exception cref="OverflowException">
        /// The return value is less than <see cref="MinValue" /> or greater than
        /// <see cref="MaxValue" />.
        /// </exception>
        public static decimal operator %(decimal d1, decimal d2) { return default(decimal); }
        /// <summary>
        /// Multiplies two specified <see cref="Decimal" /> values.
        /// </summary>
        /// <param name="d1">The first value to multiply.</param>
        /// <param name="d2">The second value to multiply.</param>
        /// <returns>
        /// The result of multiplying <paramref name="d1" /> by <paramref name="d2" />.
        /// </returns>
        /// <exception cref="OverflowException">
        /// The return value is less than <see cref="MinValue" /> or greater than
        /// <see cref="MaxValue" />.
        /// </exception>
        public static decimal operator *(decimal d1, decimal d2) { return default(decimal); }
        /// <summary>
        /// Subtracts two specified <see cref="Decimal" /> values.
        /// </summary>
        /// <param name="d1">The minuend.</param>
        /// <param name="d2">The subtrahend.</param>
        /// <returns>
        /// The result of subtracting <paramref name="d2" /> from <paramref name="d1" />.
        /// </returns>
        /// <exception cref="OverflowException">
        /// The return value is less than <see cref="MinValue" /> or greater than
        /// <see cref="MaxValue" />.
        /// </exception>
        public static decimal operator -(decimal d1, decimal d2) { return default(decimal); }
        /// <summary>
        /// Negates the value of the specified <see cref="Decimal" /> operand.
        /// </summary>
        /// <param name="d">The value to negate.</param>
        /// <returns>
        /// The result of <paramref name="d" /> multiplied by negative one (-1).
        /// </returns>
        public static decimal operator -(decimal d) { return default(decimal); }
        /// <summary>
        /// Returns the value of the <see cref="Decimal" /> operand (the sign of the operand
        /// is unchanged).
        /// </summary>
        /// <param name="d">The operand to return.</param>
        /// <returns>
        /// The value of the operand, <paramref name="d" />.
        /// </returns>
        public static decimal operator +(decimal d) { return default(decimal); }
        /// <summary>
        /// Converts the string representation of a number to its <see cref="Decimal" /> equivalent.
        /// </summary>
        /// <param name="s">The string representation of the number to convert.</param>
        /// <returns>
        /// The equivalent to the number contained in <paramref name="s" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="FormatException"><paramref name="s" /> is not in the correct format.</exception>
        /// <exception cref="OverflowException">
        /// <paramref name="s" /> represents a number less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />.
        /// </exception>
        public static decimal Parse(string s) { return default(decimal); }
        /// <summary>
        /// Converts the string representation of a number in a specified style to its <see cref="Decimal" />
        /// equivalent.
        /// </summary>
        /// <param name="s">The string representation of the number to convert.</param>
        /// <param name="style">
        /// A bitwise combination of <see cref="Globalization.NumberStyles" /> values that indicates
        /// the style elements that can be present in <paramref name="s" />. A typical value to specify
        /// is <see cref="Globalization.NumberStyles.Number" />.
        /// </param>
        /// <returns>
        /// The <see cref="Decimal" /> number equivalent to the number contained in <paramref name="s" />
        /// as specified by <paramref name="style" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="style" /> is not a <see cref="Globalization.NumberStyles" /> value.
        /// -or-<paramref name="style" /> is the <see cref="Globalization.NumberStyles.AllowHexSpecifier" />
        /// value.
        /// </exception>
        /// <exception cref="FormatException"><paramref name="s" /> is not in the correct format.</exception>
        /// <exception cref="OverflowException">
        /// <paramref name="s" /> represents a number less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />
        /// </exception>
        public static decimal Parse(string s, System.Globalization.NumberStyles style) { return default(decimal); }
        /// <summary>
        /// Converts the string representation of a number to its <see cref="Decimal" /> equivalent
        /// using the specified style and culture-specific format.
        /// </summary>
        /// <param name="s">The string representation of the number to convert.</param>
        /// <param name="style">
        /// A bitwise combination of <see cref="Globalization.NumberStyles" /> values that indicates
        /// the style elements that can be present in <paramref name="s" />. A typical value to specify
        /// is <see cref="Globalization.NumberStyles.Number" />.
        /// </param>
        /// <param name="provider">
        /// An <see cref="IFormatProvider" /> object that supplies culture-specific information
        /// about the format of <paramref name="s" />.
        /// </param>
        /// <returns>
        /// The <see cref="Decimal" /> number equivalent to the number contained in <paramref name="s" />
        /// as specified by <paramref name="style" /> and <paramref name="provider" />.
        /// </returns>
        /// <exception cref="FormatException"><paramref name="s" /> is not in the correct format.</exception>
        /// <exception cref="OverflowException">
        /// <paramref name="s" /> represents a number less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />.
        /// </exception>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="style" /> is not a <see cref="Globalization.NumberStyles" /> value.
        /// -or-<paramref name="style" /> is the <see cref="Globalization.NumberStyles.AllowHexSpecifier" />
        /// value.
        /// </exception>
        public static decimal Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider) { return default(decimal); }
        /// <summary>
        /// Converts the string representation of a number to its <see cref="Decimal" /> equivalent
        /// using the specified culture-specific format information.
        /// </summary>
        /// <param name="s">The string representation of the number to convert.</param>
        /// <param name="provider">
        /// An <see cref="IFormatProvider" /> that supplies culture-specific parsing information
        /// about <paramref name="s" />.
        /// </param>
        /// <returns>
        /// The <see cref="Decimal" /> number equivalent to the number contained in <paramref name="s" />
        /// as specified by <paramref name="provider" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="FormatException"><paramref name="s" /> is not of the correct format</exception>
        /// <exception cref="OverflowException">
        /// <paramref name="s" /> represents a number less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />
        /// </exception>
        public static decimal Parse(string s, System.IFormatProvider provider) { return default(decimal); }
        /// <summary>
        /// Computes the remainder after dividing two <see cref="Decimal" /> values.
        /// </summary>
        /// <param name="d1">The dividend.</param>
        /// <param name="d2">The divisor.</param>
        /// <returns>
        /// The remainder after dividing <paramref name="d1" /> by <paramref name="d2" />.
        /// </returns>
        /// <exception cref="DivideByZeroException"><paramref name="d2" /> is zero.</exception>
        /// <exception cref="OverflowException">
        /// The return value is less than <see cref="MinValue" /> or greater than
        /// <see cref="MaxValue" />.
        /// </exception>
        public static decimal Remainder(decimal d1, decimal d2) { return default(decimal); }
        /// <summary>
        /// Subtracts one specified <see cref="Decimal" /> value from another.
        /// </summary>
        /// <param name="d1">The minuend.</param>
        /// <param name="d2">The subtrahend.</param>
        /// <returns>
        /// The result of subtracting <paramref name="d2" /> from <paramref name="d1" />.
        /// </returns>
        /// <exception cref="OverflowException">
        /// The return value is less than <see cref="MinValue" /> or greater than
        /// <see cref="MaxValue" />.
        /// </exception>
        public static decimal Subtract(decimal d1, decimal d2) { return default(decimal); }
        int System.IComparable.CompareTo(object value) { return default(int); }
        System.TypeCode System.IConvertible.GetTypeCode() { return default(System.TypeCode); }
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) { return default(bool); }
        byte System.IConvertible.ToByte(System.IFormatProvider provider) { return default(byte); }
        char System.IConvertible.ToChar(System.IFormatProvider provider) { return default(char); }
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) { return default(System.DateTime); }
        decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) { return default(decimal); }
        double System.IConvertible.ToDouble(System.IFormatProvider provider) { return default(double); }
        short System.IConvertible.ToInt16(System.IFormatProvider provider) { return default(short); }
        int System.IConvertible.ToInt32(System.IFormatProvider provider) { return default(int); }
        long System.IConvertible.ToInt64(System.IFormatProvider provider) { return default(long); }
        sbyte System.IConvertible.ToSByte(System.IFormatProvider provider) { return default(sbyte); }
        float System.IConvertible.ToSingle(System.IFormatProvider provider) { return default(float); }
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) { return default(object); }
        ushort System.IConvertible.ToUInt16(System.IFormatProvider provider) { return default(ushort); }
        uint System.IConvertible.ToUInt32(System.IFormatProvider provider) { return default(uint); }
        ulong System.IConvertible.ToUInt64(System.IFormatProvider provider) { return default(ulong); }
        /// <summary>
        /// Converts the value of the specified <see cref="Decimal" /> to the equivalent 8-bit
        /// unsigned integer.
        /// </summary>
        /// <param name="value">The decimal number to convert.</param>
        /// <returns>
        /// An 8-bit unsigned integer equivalent to <paramref name="value" />.
        /// </returns>
        /// <exception cref="OverflowException">
        /// <paramref name="value" /> is less than <see cref="Byte.MinValue" /> or greater than
        /// <see cref="Byte.MaxValue" />.
        /// </exception>
        public static byte ToByte(decimal value) { return default(byte); }
        /// <summary>
        /// Converts the value of the specified <see cref="Decimal" /> to the equivalent double-precision
        /// floating-point number.
        /// </summary>
        /// <param name="d">The decimal number to convert.</param>
        /// <returns>
        /// A double-precision floating-point number equivalent to <paramref name="d" />.
        /// </returns>
        public static double ToDouble(decimal d) { return default(double); }
        /// <summary>
        /// Converts the value of the specified <see cref="Decimal" /> to the equivalent 16-bit
        /// signed integer.
        /// </summary>
        /// <param name="value">The decimal number to convert.</param>
        /// <returns>
        /// A 16-bit signed integer equivalent to <paramref name="value" />.
        /// </returns>
        /// <exception cref="OverflowException">
        /// <paramref name="value" /> is less than <see cref="Int16.MinValue" /> or greater than
        /// <see cref="Int16.MaxValue" />.
        /// </exception>
        public static short ToInt16(decimal value) { return default(short); }
        /// <summary>
        /// Converts the value of the specified <see cref="Decimal" /> to the equivalent 32-bit
        /// signed integer.
        /// </summary>
        /// <param name="d">The decimal number to convert.</param>
        /// <returns>
        /// A 32-bit signed integer equivalent to the value of <paramref name="d" />.
        /// </returns>
        /// <exception cref="OverflowException">
        /// <paramref name="d" /> is less than <see cref="Int32.MinValue" /> or greater than
        /// <see cref="Int32.MaxValue" />.
        /// </exception>
        public static int ToInt32(decimal d) { return default(int); }
        /// <summary>
        /// Converts the value of the specified <see cref="Decimal" /> to the equivalent 64-bit
        /// signed integer.
        /// </summary>
        /// <param name="d">The decimal number to convert.</param>
        /// <returns>
        /// A 64-bit signed integer equivalent to the value of <paramref name="d" />.
        /// </returns>
        /// <exception cref="OverflowException">
        /// <paramref name="d" /> is less than <see cref="Int64.MinValue" /> or greater than
        /// <see cref="Int64.MaxValue" />.
        /// </exception>
        public static long ToInt64(decimal d) { return default(long); }
        /// <summary>
        /// Converts the value of the specified <see cref="Decimal" /> to the equivalent 8-bit
        /// signed integer.
        /// </summary>
        /// <param name="value">The decimal number to convert.</param>
        /// <returns>
        /// An 8-bit signed integer equivalent to <paramref name="value" />.
        /// </returns>
        /// <exception cref="OverflowException">
        /// <paramref name="value" /> is less than <see cref="SByte.MinValue" /> or greater than
        /// <see cref="SByte.MaxValue" />.
        /// </exception>
        [System.CLSCompliantAttribute(false)]
        public static sbyte ToSByte(decimal value) { return default(sbyte); }
        /// <summary>
        /// Converts the value of the specified <see cref="Decimal" /> to the equivalent single-precision
        /// floating-point number.
        /// </summary>
        /// <param name="d">The decimal number to convert.</param>
        /// <returns>
        /// A single-precision floating-point number equivalent to the value of <paramref name="d" />.
        /// </returns>
        public static float ToSingle(decimal d) { return default(float); }
        /// <summary>
        /// Converts the numeric value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// A string that represents the value of this instance.
        /// </returns>
        public override string ToString() { return default(string); }
        /// <summary>
        /// Converts the numeric value of this instance to its equivalent string representation using the
        /// specified culture-specific format information.
        /// </summary>
        /// <param name="provider">An object that supplies culture-specific formatting information.</param>
        /// <returns>
        /// The string representation of the value of this instance as specified by <paramref name="provider" />.
        /// </returns>
        public string ToString(System.IFormatProvider provider) { return default(string); }
        /// <summary>
        /// Converts the numeric value of this instance to its equivalent string representation, using
        /// the specified format.
        /// </summary>
        /// <param name="format">A standard or custom numeric format string (see Remarks).</param>
        /// <returns>
        /// The string representation of the value of this instance as specified by <paramref name="format" />.
        /// </returns>
        /// <exception cref="FormatException"><paramref name="format" /> is invalid.</exception>
        public string ToString(string format) { return default(string); }
        /// <summary>
        /// Converts the numeric value of this instance to its equivalent string representation using the
        /// specified format and culture-specific format information.
        /// </summary>
        /// <param name="format">A numeric format string (see Remarks).</param>
        /// <param name="provider">An object that supplies culture-specific formatting information.</param>
        /// <returns>
        /// The string representation of the value of this instance as specified by <paramref name="format" />
        /// and <paramref name="provider" />.
        /// </returns>
        /// <exception cref="FormatException"><paramref name="format" /> is invalid.</exception>
        public string ToString(string format, System.IFormatProvider provider) { return default(string); }
        /// <summary>
        /// Converts the value of the specified <see cref="Decimal" /> to the equivalent 16-bit
        /// unsigned integer.
        /// </summary>
        /// <param name="value">The decimal number to convert.</param>
        /// <returns>
        /// A 16-bit unsigned integer equivalent to the value of <paramref name="value" />.
        /// </returns>
        /// <exception cref="OverflowException">
        /// <paramref name="value" /> is greater than <see cref="UInt16.MaxValue" /> or less
        /// than <see cref="UInt16.MinValue" />.
        /// </exception>
        [System.CLSCompliantAttribute(false)]
        public static ushort ToUInt16(decimal value) { return default(ushort); }
        /// <summary>
        /// Converts the value of the specified <see cref="Decimal" /> to the equivalent 32-bit
        /// unsigned integer.
        /// </summary>
        /// <param name="d">The decimal number to convert.</param>
        /// <returns>
        /// A 32-bit unsigned integer equivalent to the value of <paramref name="d" />.
        /// </returns>
        /// <exception cref="OverflowException">
        /// <paramref name="d" /> is negative or greater than <see cref="UInt32.MaxValue" />.
        /// </exception>
        [System.CLSCompliantAttribute(false)]
        public static uint ToUInt32(decimal d) { return default(uint); }
        /// <summary>
        /// Converts the value of the specified <see cref="Decimal" /> to the equivalent 64-bit
        /// unsigned integer.
        /// </summary>
        /// <param name="d">The decimal number to convert.</param>
        /// <returns>
        /// A 64-bit unsigned integer equivalent to the value of <paramref name="d" />.
        /// </returns>
        /// <exception cref="OverflowException">
        /// <paramref name="d" /> is negative or greater than <see cref="UInt64.MaxValue" />.
        /// </exception>
        [System.CLSCompliantAttribute(false)]
        public static ulong ToUInt64(decimal d) { return default(ulong); }
        /// <summary>
        /// Returns the integral digits of the specified <see cref="Decimal" />; any fractional
        /// digits are discarded.
        /// </summary>
        /// <param name="d">The decimal number to truncate.</param>
        /// <returns>
        /// The result of <paramref name="d" /> rounded toward zero, to the nearest whole number.
        /// </returns>
        public static decimal Truncate(decimal d) { return default(decimal); }
        /// <summary>
        /// Converts the string representation of a number to its <see cref="Decimal" /> equivalent.
        /// A return value indicates whether the conversion succeeded or failed.
        /// </summary>
        /// <param name="s">The string representation of the number to convert.</param>
        /// <param name="result">
        /// When this method returns, contains the <see cref="Decimal" /> number that is equivalent
        /// to the numeric value contained in <paramref name="s" />, if the conversion succeeded, or is
        /// zero if the conversion failed. The conversion fails if the <paramref name="s" /> parameter
        /// is null or <see cref="String.Empty" />, is not a number in a valid format, or represents
        /// a number less than <see cref="MinValue" /> or greater than <see cref="MaxValue" />.
        /// This parameter is passed uninitialized; any value originally supplied in <paramref name="result" />
        /// will be overwritten.
        /// </param>
        /// <returns>
        /// true if <paramref name="s" /> was converted successfully; otherwise, false.
        /// </returns>
        public static bool TryParse(string s, out decimal result) { result = default(decimal); return default(bool); }
        /// <summary>
        /// Converts the string representation of a number to its <see cref="Decimal" /> equivalent
        /// using the specified style and culture-specific format. A return value indicates whether the
        /// conversion succeeded or failed.
        /// </summary>
        /// <param name="s">The string representation of the number to convert.</param>
        /// <param name="style">
        /// A bitwise combination of enumeration values that indicates the permitted format of <paramref name="s" />.
        /// A typical value to specify is <see cref="Globalization.NumberStyles.Number" />.
        /// </param>
        /// <param name="provider">
        /// An object that supplies culture-specific parsing information about <paramref name="s" />.
        /// </param>
        /// <param name="result">
        /// When this method returns, contains the <see cref="Decimal" /> number that is equivalent
        /// to the numeric value contained in <paramref name="s" />, if the conversion succeeded, or is
        /// zero if the conversion failed. The conversion fails if the <paramref name="s" /> parameter
        /// is null or <see cref="String.Empty" />, is not in a format compliant with <paramref name="style" />,
        /// or represents a number less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />. This parameter is passed uninitialized;
        /// any value originally supplied in <paramref name="result" /> will be overwritten.
        /// </param>
        /// <returns>
        /// true if <paramref name="s" /> was converted successfully; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// <paramref name="style" /> is not a <see cref="Globalization.NumberStyles" /> value.
        /// -or-<paramref name="style" /> is the <see cref="Globalization.NumberStyles.AllowHexSpecifier" />
        /// value.
        /// </exception>
        public static bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out decimal result) { result = default(decimal); return default(bool); }
    }
    /// <summary>
    /// Represents a delegate, which is a data structure that refers to a static method or to a class
    /// instance and an instance method of that class.
    /// </summary>
    public abstract partial class Delegate
    {
        internal Delegate() { }
        /// <summary>
        /// Gets the class instance on which the current delegate invokes the instance method.
        /// </summary>
        /// <returns>
        /// The object on which the current delegate invokes the instance method, if the delegate represents
        /// an instance method; null if the delegate represents a static method.
        /// </returns>
        public object Target { get { return default(object); } }
        /// <summary>
        /// Concatenates the invocation lists of two delegates.
        /// </summary>
        /// <param name="a">The delegate whose invocation list comes first.</param>
        /// <param name="b">The delegate whose invocation list comes last.</param>
        /// <returns>
        /// A new delegate with an invocation list that concatenates the invocation lists of <paramref name="a" />
        /// and <paramref name="b" /> in that order. Returns <paramref name="a" /> if <paramref name="b" />
        /// is null, returns <paramref name="b" /> if <paramref name="a" /> is a null reference,
        /// and returns a null reference if both <paramref name="a" /> and <paramref name="b" /> are null
        /// references.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// Both <paramref name="a" /> and <paramref name="b" /> are not null, and <paramref name="a" />
        /// and <paramref name="b" /> are not instances of the same delegate type.
        /// </exception>
        public static System.Delegate Combine(System.Delegate a, System.Delegate b) { return default(System.Delegate); }
        /// <summary>
        /// Concatenates the invocation lists of an array of delegates.
        /// </summary>
        /// <param name="delegates">The array of delegates to combine.</param>
        /// <returns>
        /// A new delegate with an invocation list that concatenates the invocation lists of the delegates
        /// in the <paramref name="delegates" /> array. Returns null if <paramref name="delegates" />
        /// is null, if <paramref name="delegates" /> contains zero elements, or if every entry in <paramref name="delegates" />
        /// is null.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// Not all the non-null entries in <paramref name="delegates" /> are instances of the same delegate
        /// type.
        /// </exception>
        public static System.Delegate Combine(params System.Delegate[] delegates) { return default(System.Delegate); }
        /// <summary>
        /// Dynamically invokes (late-bound) the method represented by the current delegate.
        /// </summary>
        /// <param name="args">
        /// An array of objects that are the arguments to pass to the method represented by the current
        /// delegate.-or- null, if the method represented by the current delegate does not require arguments.
        /// </param>
        /// <returns>
        /// The object returned by the method represented by the delegate.
        /// </returns>
        /// <exception cref="MemberAccessException">
        /// The caller does not have access to the method represented by the delegate (for example, if
        /// the method is private).-or- The number, order, or type of parameters listed in <paramref name="args" />
        /// is invalid.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// The method represented by the delegate is invoked on an object or a class that does not support
        /// it.
        /// </exception>
        /// <exception cref="Reflection.TargetInvocationException">
        /// The method represented by the delegate is an instance method and the target object is null.-or-
        /// One of the encapsulated methods throws an exception.
        /// </exception>
        public object DynamicInvoke(params object[] args) { return default(object); }
        /// <summary>
        /// Determines whether the specified object and the current delegate are of the same type and share
        /// the same targets, methods, and invocation list.
        /// </summary>
        /// <param name="obj">The object to compare with the current delegate.</param>
        /// <returns>
        /// true if <paramref name="obj" /> and the current delegate have the same targets, methods, and
        /// invocation list; otherwise, false.
        /// </returns>
        /// <exception cref="MemberAccessException">
        /// The caller does not have access to the method represented by the delegate (for example, if
        /// the method is private).
        /// </exception>
        public override bool Equals(object obj) { return default(bool); }
        /// <summary>
        /// Returns a hash code for the delegate.
        /// </summary>
        /// <returns>
        /// A hash code for the delegate.
        /// </returns>
        public override int GetHashCode() { return default(int); }
        /// <summary>
        /// Returns the invocation list of the delegate.
        /// </summary>
        /// <returns>
        /// An array of delegates representing the invocation list of the current delegate.
        /// </returns>
        public virtual System.Delegate[] GetInvocationList() { return default(System.Delegate[]); }
        /// <summary>
        /// Determines whether the specified delegates are equal.
        /// </summary>
        /// <param name="d1">The first delegate to compare.</param>
        /// <param name="d2">The second delegate to compare.</param>
        /// <returns>
        /// true if <paramref name="d1" /> is equal to <paramref name="d2" />; otherwise, false.
        /// </returns>
        public static bool operator ==(System.Delegate d1, System.Delegate d2) { return default(bool); }
        /// <summary>
        /// Determines whether the specified delegates are not equal.
        /// </summary>
        /// <param name="d1">The first delegate to compare.</param>
        /// <param name="d2">The second delegate to compare.</param>
        /// <returns>
        /// true if <paramref name="d1" /> is not equal to <paramref name="d2" />; otherwise, false.
        /// </returns>
        public static bool operator !=(System.Delegate d1, System.Delegate d2) { return default(bool); }
        /// <summary>
        /// Removes the last occurrence of the invocation list of a delegate from the invocation list of
        /// another delegate.
        /// </summary>
        /// <param name="source">The delegate from which to remove the invocation list of <paramref name="value" />.</param>
        /// <param name="value">
        /// The delegate that supplies the invocation list to remove from the invocation list of <paramref name="source" />.
        /// </param>
        /// <returns>
        /// A new delegate with an invocation list formed by taking the invocation list of <paramref name="source" />
        /// and removing the last occurrence of the invocation list of <paramref name="value" />, if
        /// the invocation list of <paramref name="value" /> is found within the invocation list of <paramref name="source" />.
        /// Returns <paramref name="source" /> if <paramref name="value" /> is null
        /// or if the invocation list of <paramref name="value" /> is not found within the invocation
        /// list of <paramref name="source" />. Returns a null reference if the invocation list of <paramref name="value" />
        /// is equal to the invocation list of <paramref name="source" /> or if <paramref name="source" />
        /// is a null reference.
        /// </returns>
        /// <exception cref="MemberAccessException">
        /// The caller does not have access to the method represented by the delegate (for example, if
        /// the method is private).
        /// </exception>
        /// <exception cref="ArgumentException">The delegate types do not match.</exception>
        public static System.Delegate Remove(System.Delegate source, System.Delegate value) { return default(System.Delegate); }
        /// <summary>
        /// Removes all occurrences of the invocation list of a delegate from the invocation list of another
        /// delegate.
        /// </summary>
        /// <param name="source">The delegate from which to remove the invocation list of <paramref name="value" />.</param>
        /// <param name="value">
        /// The delegate that supplies the invocation list to remove from the invocation list of <paramref name="source" />.
        /// </param>
        /// <returns>
        /// A new delegate with an invocation list formed by taking the invocation list of <paramref name="source" />
        /// and removing all occurrences of the invocation list of <paramref name="value" />, if the
        /// invocation list of <paramref name="value" /> is found within the invocation list of <paramref name="source" />.
        /// Returns <paramref name="source" /> if <paramref name="value" /> is null
        /// or if the invocation list of <paramref name="value" /> is not found within the invocation
        /// list of <paramref name="source" />. Returns a null reference if the invocation list of <paramref name="value" />
        /// is equal to the invocation list of <paramref name="source" />, if <paramref name="source" />
        /// contains only a series of invocation lists that are equal to the invocation
        /// list of <paramref name="value" />, or if <paramref name="source" /> is a null reference.
        /// </returns>
        /// <exception cref="MemberAccessException">
        /// The caller does not have access to the method represented by the delegate (for example, if
        /// the method is private).
        /// </exception>
        /// <exception cref="ArgumentException">The delegate types do not match.</exception>
        public static System.Delegate RemoveAll(System.Delegate source, System.Delegate value) { return default(System.Delegate); }
    }
    /// <summary>
    /// The exception that is thrown when there is an attempt to divide an integral or <see cref="Decimal" />
    /// value by zero.
    /// </summary>
    public partial class DivideByZeroException : System.ArithmeticException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DivideByZeroException" /> class.
        /// </summary>
        public DivideByZeroException() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="DivideByZeroException" /> class with
        /// a specified error message.
        /// </summary>
        /// <param name="message">A <see cref="String" /> that describes the error.</param>
        public DivideByZeroException(string message) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="DivideByZeroException" /> class with
        /// a specified error message and a reference to the inner exception that is the cause of this
        /// exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="innerException">
        /// The exception that is the cause of the current exception. If the <paramref name="innerException" />
        /// parameter is not null, the current exception is raised in a catch block that handles the
        /// inner exception.
        /// </param>
        public DivideByZeroException(string message, System.Exception innerException) { }
    }
    /// <summary>
    /// Represents a double-precision floating-point number.
    /// </summary>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct Double : System.IComparable, System.IComparable<double>, System.IConvertible, System.IEquatable<double>, System.IFormattable
    {
        /// <summary>
        /// Compares this instance to a specified double-precision floating-point number and returns an
        /// integer that indicates whether the value of this instance is less than, equal to, or greater than the
        /// value of the specified double-precision floating-point number.
        /// </summary>
        /// <param name="value">A double-precision floating-point number to compare.</param>
        /// <returns>
        /// A signed number indicating the relative values of this instance and <paramref name="value" />.
        /// Return Value Description Less than zero This instance is less than <paramref name="value" />.
        /// -or- This instance is not a number (<see cref="NaN" />) and <paramref name="value" />
        /// is a number. Zero This instance is equal to <paramref name="value" />.-or- Both this instance
        /// and <paramref name="value" /> are not a number (<see cref="NaN" />),
        /// <see cref="PositiveInfinity" />, or <see cref="NegativeInfinity" />.
        /// Greater than zero This instance is greater than <paramref name="value" />.-or- This instance
        /// is a number and <paramref name="value" /> is not a number (<see cref="NaN" />
        /// ).
        /// </returns>
        public int CompareTo(double value) { return default(int); }
        /// <summary>
        /// Returns a value indicating whether this instance and a specified <see cref="Double" />
        /// object represent the same value.
        /// </summary>
        /// <param name="obj">A <see cref="Double" /> object to compare to this instance.</param>
        /// <returns>
        /// true if <paramref name="obj" /> is equal to this instance; otherwise, false.
        /// </returns>
        public bool Equals(double obj) { return default(bool); }
        /// <summary>
        /// Returns a value indicating whether this instance is equal to a specified object.
        /// </summary>
        /// <param name="obj">An object to compare with this instance.</param>
        /// <returns>
        /// true if <paramref name="obj" /> is an instance of <see cref="Double" /> and equals
        /// the value of this instance; otherwise, false.
        /// </returns>
        public override bool Equals(object obj) { return default(bool); }
        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code.
        /// </returns>
        public override int GetHashCode() { return default(int); }
        /// <summary>
        /// Returns a value indicating whether the specified number evaluates to negative or positive infinity
        /// </summary>
        /// <param name="d">A double-precision floating-point number.</param>
        /// <returns>
        /// true if <paramref name="d" /> evaluates to <see cref="PositiveInfinity" />
        /// or <see cref="NegativeInfinity" />; otherwise, false.
        /// </returns>
        public static bool IsInfinity(double d) { return default(bool); }
        /// <summary>
        /// Returns a value that indicates whether the specified value is not a number (<see cref="NaN" />
        /// ).
        /// </summary>
        /// <param name="d">A double-precision floating-point number.</param>
        /// <returns>
        /// true if <paramref name="d" /> evaluates to <see cref="NaN" />; otherwise,
        /// false.
        /// </returns>
        public static bool IsNaN(double d) { return default(bool); }
        /// <summary>
        /// Returns a value indicating whether the specified number evaluates to negative infinity.
        /// </summary>
        /// <param name="d">A double-precision floating-point number.</param>
        /// <returns>
        /// true if <paramref name="d" /> evaluates to <see cref="NegativeInfinity" />;
        /// otherwise, false.
        /// </returns>
        public static bool IsNegativeInfinity(double d) { return default(bool); }
        /// <summary>
        /// Returns a value indicating whether the specified number evaluates to positive infinity.
        /// </summary>
        /// <param name="d">A double-precision floating-point number.</param>
        /// <returns>
        /// true if <paramref name="d" /> evaluates to <see cref="PositiveInfinity" />;
        /// otherwise, false.
        /// </returns>
        public static bool IsPositiveInfinity(double d) { return default(bool); }
        /// <summary>
        /// Returns a value that indicates whether two specified <see cref="Double" /> values
        /// are equal.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns>
        /// true if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, false.
        /// </returns>
        public static bool operator ==(double left, double right) { return default(bool); }
        /// <summary>
        /// Returns a value that indicates whether a specified <see cref="Double" /> value is
        /// greater than another specified <see cref="Double" /> value.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns>
        /// true if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, false.
        /// </returns>
        public static bool operator >(double left, double right) { return default(bool); }
        /// <summary>
        /// Returns a value that indicates whether a specified <see cref="Double" /> value is
        /// greater than or equal to another specified <see cref="Double" /> value.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns>
        /// true if <paramref name="left" /> is greater than or equal to <paramref name="right" />; otherwise,
        /// false.
        /// </returns>
        public static bool operator >=(double left, double right) { return default(bool); }
        /// <summary>
        /// Returns a value that indicates whether two specified <see cref="Double" /> values
        /// are not equal.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns>
        /// true if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, false.
        /// </returns>
        public static bool operator !=(double left, double right) { return default(bool); }
        /// <summary>
        /// Returns a value that indicates whether a specified <see cref="Double" /> value is
        /// less than another specified <see cref="Double" /> value.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns>
        /// true if <paramref name="left" /> is less than <paramref name="right" />; otherwise, false.
        /// </returns>
        public static bool operator <(double left, double right) { return default(bool); }
        /// <summary>
        /// Returns a value that indicates whether a specified <see cref="Double" /> value is
        /// less than or equal to another specified <see cref="Double" /> value.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns>
        /// true if <paramref name="left" /> is less than or equal to <paramref name="right" />; otherwise,
        /// false.
        /// </returns>
        public static bool operator <=(double left, double right) { return default(bool); }
        /// <summary>
        /// Converts the string representation of a number to its double-precision floating-point number
        /// equivalent.
        /// </summary>
        /// <param name="s">A string that contains a number to convert.</param>
        /// <returns>
        /// A double-precision floating-point number that is equivalent to the numeric value or symbol
        /// specified in <paramref name="s" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="FormatException">
        /// <paramref name="s" /> does not represent a number in a valid format.
        /// </exception>
        /// <exception cref="OverflowException">
        /// <paramref name="s" /> represents a number that is less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />.
        /// </exception>
        public static double Parse(string s) { return default(double); }
        /// <summary>
        /// Converts the string representation of a number in a specified style to its double-precision
        /// floating-point number equivalent.
        /// </summary>
        /// <param name="s">A string that contains a number to convert.</param>
        /// <param name="style">
        /// A bitwise combination of enumeration values that indicate the style elements that can be present
        /// in <paramref name="s" />. A typical value to specify is a combination of
        /// <see cref="Globalization.NumberStyles.Float" /> combined with <see cref="Globalization.NumberStyles.AllowThousands" />.
        /// </param>
        /// <returns>
        /// A double-precision floating-point number that is equivalent to the numeric value or symbol
        /// specified in <paramref name="s" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="FormatException">
        /// <paramref name="s" /> does not represent a number in a valid format.
        /// </exception>
        /// <exception cref="OverflowException">
        /// <paramref name="s" /> represents a number that is less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="style" /> is not a <see cref="Globalization.NumberStyles" /> value.
        /// -or-<paramref name="style" /> includes the <see cref="Globalization.NumberStyles.AllowHexSpecifier" />
        /// value.
        /// </exception>
        public static double Parse(string s, System.Globalization.NumberStyles style) { return default(double); }
        /// <summary>
        /// Converts the string representation of a number in a specified style and culture-specific format
        /// to its double-precision floating-point number equivalent.
        /// </summary>
        /// <param name="s">A string that contains a number to convert.</param>
        /// <param name="style">
        /// A bitwise combination of enumeration values that indicate the style elements that can be present
        /// in <paramref name="s" />. A typical value to specify is <see cref="Globalization.NumberStyles.Float" />
        /// combined with <see cref="Globalization.NumberStyles.AllowThousands" />.
        /// </param>
        /// <param name="provider">
        /// An object that supplies culture-specific formatting information about <paramref name="s" />.
        /// </param>
        /// <returns>
        /// A double-precision floating-point number that is equivalent to the numeric value or symbol
        /// specified in <paramref name="s" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="FormatException">
        /// <paramref name="s" /> does not represent a numeric value.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="style" /> is not a <see cref="Globalization.NumberStyles" /> value.
        /// -or-<paramref name="style" /> is the <see cref="Globalization.NumberStyles.AllowHexSpecifier" />
        /// value.
        /// </exception>
        /// <exception cref="OverflowException">
        /// <paramref name="s" /> represents a number that is less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />.
        /// </exception>
        public static double Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider) { return default(double); }
        /// <summary>
        /// Converts the string representation of a number in a specified culture-specific format to its
        /// double-precision floating-point number equivalent.
        /// </summary>
        /// <param name="s">A string that contains a number to convert.</param>
        /// <param name="provider">
        /// An object that supplies culture-specific formatting information about <paramref name="s" />.
        /// </param>
        /// <returns>
        /// A double-precision floating-point number that is equivalent to the numeric value or symbol
        /// specified in <paramref name="s" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="FormatException">
        /// <paramref name="s" /> does not represent a number in a valid format.
        /// </exception>
        /// <exception cref="OverflowException">
        /// <paramref name="s" /> represents a number that is less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />.
        /// </exception>
        public static double Parse(string s, System.IFormatProvider provider) { return default(double); }
        int System.IComparable.CompareTo(object value) { return default(int); }
        System.TypeCode System.IConvertible.GetTypeCode() { return default(System.TypeCode); }
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) { return default(bool); }
        byte System.IConvertible.ToByte(System.IFormatProvider provider) { return default(byte); }
        char System.IConvertible.ToChar(System.IFormatProvider provider) { return default(char); }
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) { return default(System.DateTime); }
        decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) { return default(decimal); }
        double System.IConvertible.ToDouble(System.IFormatProvider provider) { return default(double); }
        short System.IConvertible.ToInt16(System.IFormatProvider provider) { return default(short); }
        int System.IConvertible.ToInt32(System.IFormatProvider provider) { return default(int); }
        long System.IConvertible.ToInt64(System.IFormatProvider provider) { return default(long); }
        sbyte System.IConvertible.ToSByte(System.IFormatProvider provider) { return default(sbyte); }
        float System.IConvertible.ToSingle(System.IFormatProvider provider) { return default(float); }
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) { return default(object); }
        ushort System.IConvertible.ToUInt16(System.IFormatProvider provider) { return default(ushort); }
        uint System.IConvertible.ToUInt32(System.IFormatProvider provider) { return default(uint); }
        ulong System.IConvertible.ToUInt64(System.IFormatProvider provider) { return default(ulong); }
        /// <summary>
        /// Converts the numeric value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// The string representation of the value of this instance.
        /// </returns>
        public override string ToString() { return default(string); }
        /// <summary>
        /// Converts the numeric value of this instance to its equivalent string representation using the
        /// specified culture-specific format information.
        /// </summary>
        /// <param name="provider">An object that supplies culture-specific formatting information.</param>
        /// <returns>
        /// The string representation of the value of this instance as specified by <paramref name="provider" />.
        /// </returns>
        public string ToString(System.IFormatProvider provider) { return default(string); }
        /// <summary>
        /// Converts the numeric value of this instance to its equivalent string representation, using
        /// the specified format.
        /// </summary>
        /// <param name="format">A numeric format string.</param>
        /// <returns>
        /// The string representation of the value of this instance as specified by <paramref name="format" />.
        /// </returns>
        /// <exception cref="FormatException"><paramref name="format" /> is invalid.</exception>
        public string ToString(string format) { return default(string); }
        /// <summary>
        /// Converts the numeric value of this instance to its equivalent string representation using the
        /// specified format and culture-specific format information.
        /// </summary>
        /// <param name="format">A numeric format string.</param>
        /// <param name="provider">An object that supplies culture-specific formatting information.</param>
        /// <returns>
        /// The string representation of the value of this instance as specified by <paramref name="format" />
        /// and <paramref name="provider" />.
        /// </returns>
        public string ToString(string format, System.IFormatProvider provider) { return default(string); }
        /// <summary>
        /// Converts the string representation of a number to its double-precision floating-point number
        /// equivalent. A return value indicates whether the conversion succeeded or failed.
        /// </summary>
        /// <param name="s">A string containing a number to convert.</param>
        /// <param name="result">
        /// When this method returns, contains the double-precision floating-point number equivalent of
        /// the <paramref name="s" /> parameter, if the conversion succeeded, or zero if the conversion
        /// failed. The conversion fails if the <paramref name="s" /> parameter is null  or <see cref="String.Empty" />,
        /// is not a number in a valid format, or represents a number less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />. This parameter is passed uninitialized;
        /// any value originally supplied in <paramref name="result" /> will be overwritten.
        /// </param>
        /// <returns>
        /// true if <paramref name="s" /> was converted successfully; otherwise, false.
        /// </returns>
        public static bool TryParse(string s, out double result) { result = default(double); return default(bool); }
        /// <summary>
        /// Converts the string representation of a number in a specified style and culture-specific format
        /// to its double-precision floating-point number equivalent. A return value indicates whether the
        /// conversion succeeded or failed.
        /// </summary>
        /// <param name="s">A string containing a number to convert.</param>
        /// <param name="style">
        /// A bitwise combination of <see cref="Globalization.NumberStyles" /> values that indicates
        /// the permitted format of <paramref name="s" />. A typical value to specify is
        /// <see cref="Globalization.NumberStyles.Float" /> combined with <see cref="Globalization.NumberStyles.AllowThousands" />.
        /// </param>
        /// <param name="provider">
        /// An <see cref="IFormatProvider" /> that supplies culture-specific formatting information
        /// about <paramref name="s" />.
        /// </param>
        /// <param name="result">
        /// When this method returns, contains a double-precision floating-point number equivalent of
        /// the numeric value or symbol contained in <paramref name="s" />, if the conversion succeeded,
        /// or zero if the conversion failed. The conversion fails if the <paramref name="s" /> parameter
        /// is null or <see cref="String.Empty" />, is not in a format compliant with <paramref name="style" />,
        /// represents a number less than <see cref="SByte.MinValue" /> or greater
        /// than <see cref="SByte.MaxValue" />, or if <paramref name="style" /> is not a valid
        /// combination of <see cref="Globalization.NumberStyles" /> enumerated constants. This
        /// parameter is passed uninitialized; any value originally supplied in <paramref name="result" />
        /// will be overwritten.
        /// </param>
        /// <returns>
        /// true if <paramref name="s" /> was converted successfully; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// <paramref name="style" /> is not a <see cref="Globalization.NumberStyles" /> value.
        /// -or-<paramref name="style" /> includes the <see cref="Globalization.NumberStyles.AllowHexSpecifier" />
        /// value.
        /// </exception>
        public static bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out double result) { result = default(double); return default(bool); }
    }
    /// <summary>
    /// Provides the base class for enumerations.
    /// </summary>
    public abstract partial class Enum : System.ValueType, System.IComparable, System.IConvertible, System.IFormattable
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Enum" /> class.
        /// </summary>
        protected Enum() { }
        /// <summary>
        /// Compares this instance to a specified object and returns an indication of their relative values.
        /// </summary>
        /// <param name="target">An object to compare, or null.</param>
        /// <returns>
        /// A signed number that indicates the relative values of this instance and <paramref name="target" />.
        /// Value Meaning Less than zero The value of this instance is less than the value of <paramref name="target" />.
        /// Zero The value of this instance is equal to the value of <paramref name="target" />.
        /// Greater than zero The value of this instance is greater than the value of <paramref name="target" />.
        /// -or- <paramref name="target" /> is null.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// <paramref name="target" /> and this instance are not the same type.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// This instance is not type <see cref="SByte" />, <see cref="Int16" />,
        /// <see cref="Int32" />, <see cref="Int64" />, <see cref="Byte" />, <see cref="UInt16" />,
        /// <see cref="UInt32" />, or <see cref="UInt64" />.
        /// </exception>
        public int CompareTo(object target) { return default(int); }
        /// <summary>
        /// Returns a value indicating whether this instance is equal to a specified object.
        /// </summary>
        /// <param name="obj">An object to compare with this instance, or null.</param>
        /// <returns>
        /// true if <paramref name="obj" /> is an enumeration value of the same type and with the same
        /// underlying value as this instance; otherwise, false.
        /// </returns>
        public override bool Equals(object obj) { return default(bool); }
        /// <summary>
        /// Converts the specified value of a specified enumerated type to its equivalent string representation
        /// according to the specified format.
        /// </summary>
        /// <param name="enumType">The enumeration type of the value to convert.</param>
        /// <param name="value">The value to convert.</param>
        /// <param name="format">The output format to use.</param>
        /// <returns>
        /// A string representation of <paramref name="value" />.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// The <paramref name="enumType" />, <paramref name="value" />, or <paramref name="format" />
        /// parameter is null.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// The <paramref name="enumType" /> parameter is not an <see cref="Enum" /> type.-or-
        /// The <paramref name="value" /> is from an enumeration that differs in type from <paramref name="enumType" />.
        /// -or- The type of <paramref name="value" /> is not an underlying type of <paramref name="enumType" />.
        /// </exception>
        /// <exception cref="FormatException">
        /// The <paramref name="format" /> parameter contains an invalid value.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// <paramref name="format" /> equals "X", but the enumeration type is unknown.
        /// </exception>
        public static string Format(System.Type enumType, object value, string format) { return default(string); }
        /// <summary>
        /// Returns the hash code for the value of this instance.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code.
        /// </returns>
        public override int GetHashCode() { return default(int); }
        /// <summary>
        /// Retrieves the name of the constant in the specified enumeration that has the specified value.
        /// </summary>
        /// <param name="enumType">An enumeration type.</param>
        /// <param name="value">The value of a particular enumerated constant in terms of its underlying type.</param>
        /// <returns>
        /// A string containing the name of the enumerated constant in <paramref name="enumType" /> whose
        /// value is <paramref name="value" />; or null if no such constant is found.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="enumType" /> or <paramref name="value" /> is null.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="enumType" /> is not an <see cref="Enum" />.-or- <paramref name="value" />
        /// is neither of type <paramref name="enumType" /> nor does it have the same underlying type
        /// as <paramref name="enumType" />.
        /// </exception>
        public static string GetName(System.Type enumType, object value) { return default(string); }
        /// <summary>
        /// Retrieves an array of the names of the constants in a specified enumeration.
        /// </summary>
        /// <param name="enumType">An enumeration type.</param>
        /// <returns>
        /// A string array of the names of the constants in <paramref name="enumType" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="enumType" /> is null.</exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="enumType" /> parameter is not an <see cref="Enum" />.
        /// </exception>
        public static string[] GetNames(System.Type enumType) { return default(string[]); }
        /// <summary>
        /// Returns the underlying type of the specified enumeration.
        /// </summary>
        /// <param name="enumType">The enumeration whose underlying type will be retrieved.</param>
        /// <returns>
        /// The underlying type of <paramref name="enumType" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="enumType" /> is null.</exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="enumType" /> is not an <see cref="Enum" />.
        /// </exception>
        public static System.Type GetUnderlyingType(System.Type enumType) { return default(System.Type); }
        /// <summary>
        /// Retrieves an array of the values of the constants in a specified enumeration.
        /// </summary>
        /// <param name="enumType">An enumeration type.</param>
        /// <returns>
        /// An array that contains the values of the constants in <paramref name="enumType" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="enumType" /> is null.</exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="enumType" /> is not an <see cref="Enum" />.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// The method is invoked by reflection in a reflection-only context, -or-<paramref name="enumType" />
        /// is a type from an assembly loaded in a reflection-only context.
        /// </exception>
        public static System.Array GetValues(System.Type enumType) { return default(System.Array); }
        /// <summary>
        /// Determines whether one or more bit fields are set in the current instance.
        /// </summary>
        /// <param name="flag">An enumeration value.</param>
        /// <returns>
        /// true if the bit field or bit fields that are set in <paramref name="flag" /> are also set
        /// in the current instance; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// <paramref name="flag" /> is a different type than the current instance.
        /// </exception>
        public bool HasFlag(System.Enum flag) { return default(bool); }
        /// <summary>
        /// Returns an indication whether a constant with a specified value exists in a specified enumeration.
        /// </summary>
        /// <param name="enumType">An enumeration type.</param>
        /// <param name="value">The value or name of a constant in <paramref name="enumType" />.</param>
        /// <returns>
        /// true if a constant in <paramref name="enumType" /> has a value equal to <paramref name="value" />;
        /// otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="enumType" /> or <paramref name="value" /> is null.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="enumType" /> is not an Enum.-or- The type of <paramref name="value" /> is
        /// an enumeration, but it is not an enumeration of type <paramref name="enumType" />.-or- The
        /// type of <paramref name="value" /> is not an underlying type of <paramref name="enumType" />.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// <paramref name="value" /> is not type <see cref="SByte" />, <see cref="Int16" />,
        /// <see cref="Int32" />, <see cref="Int64" />, <see cref="Byte" />,
        /// <see cref="UInt16" />, <see cref="UInt32" />, or <see cref="UInt64" />,
        /// or <see cref="String" />.
        /// </exception>
        public static bool IsDefined(System.Type enumType, object value) { return default(bool); }
        /// <summary>
        /// Converts the string representation of the name or numeric value of one or more enumerated constants
        /// to an equivalent enumerated object.
        /// </summary>
        /// <param name="enumType">An enumeration type.</param>
        /// <param name="value">A string containing the name or value to convert.</param>
        /// <returns>
        /// An object of type <paramref name="enumType" /> whose value is represented by <paramref name="value" />.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="enumType" /> or <paramref name="value" /> is null.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="enumType" /> is not an <see cref="Enum" />.-or- <paramref name="value" />
        /// is either an empty string or only contains white space.-or- <paramref name="value" /> is
        /// a name, but not one of the named constants defined for the enumeration.
        /// </exception>
        /// <exception cref="OverflowException">
        /// <paramref name="value" /> is outside the range of the underlying type of <paramref name="enumType" />.
        /// </exception>
        public static object Parse(System.Type enumType, string value) { return default(object); }
        /// <summary>
        /// Converts the string representation of the name or numeric value of one or more enumerated constants
        /// to an equivalent enumerated object. A parameter specifies whether the operation is case-insensitive.
        /// </summary>
        /// <param name="enumType">An enumeration type.</param>
        /// <param name="value">A string containing the name or value to convert.</param>
        /// <param name="ignoreCase">true to ignore case; false to regard case.</param>
        /// <returns>
        /// An object of type <paramref name="enumType" /> whose value is represented by <paramref name="value" />.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="enumType" /> or <paramref name="value" /> is null.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="enumType" /> is not an <see cref="Enum" />.-or- <paramref name="value" />
        /// is either an empty string ("") or only contains white space.-or- <paramref name="value" />
        /// is a name, but not one of the named constants defined for the enumeration.
        /// </exception>
        /// <exception cref="OverflowException">
        /// <paramref name="value" /> is outside the range of the underlying type of <paramref name="enumType" />.
        /// </exception>
        public static object Parse(System.Type enumType, string value, bool ignoreCase) { return default(object); }
        System.TypeCode System.IConvertible.GetTypeCode() { return default(System.TypeCode); }
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) { return default(bool); }
        byte System.IConvertible.ToByte(System.IFormatProvider provider) { return default(byte); }
        char System.IConvertible.ToChar(System.IFormatProvider provider) { return default(char); }
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) { return default(System.DateTime); }
        decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) { return default(decimal); }
        double System.IConvertible.ToDouble(System.IFormatProvider provider) { return default(double); }
        short System.IConvertible.ToInt16(System.IFormatProvider provider) { return default(short); }
        int System.IConvertible.ToInt32(System.IFormatProvider provider) { return default(int); }
        long System.IConvertible.ToInt64(System.IFormatProvider provider) { return default(long); }
        sbyte System.IConvertible.ToSByte(System.IFormatProvider provider) { return default(sbyte); }
        float System.IConvertible.ToSingle(System.IFormatProvider provider) { return default(float); }
        [System.ObsoleteAttribute("The provider argument is not used. Please use ToString().")]
        string System.IConvertible.ToString(System.IFormatProvider provider) { return default(string); }
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) { return default(object); }
        ushort System.IConvertible.ToUInt16(System.IFormatProvider provider) { return default(ushort); }
        uint System.IConvertible.ToUInt32(System.IFormatProvider provider) { return default(uint); }
        ulong System.IConvertible.ToUInt64(System.IFormatProvider provider) { return default(ulong); }
        [System.ObsoleteAttribute("The provider argument is not used. Please use ToString(String).")]
        string System.IFormattable.ToString(string format, System.IFormatProvider provider) { return default(string); }
        /// <summary>
        /// Converts the specified object with an integer value to an enumeration member.
        /// </summary>
        /// <param name="enumType">The enumeration type to return.</param>
        /// <param name="value">The value convert to an enumeration member.</param>
        /// <returns>
        /// An enumeration object whose value is <paramref name="value" />.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="enumType" /> or <paramref name="value" /> is null.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="enumType" /> is not an <see cref="Enum" />.-or- <paramref name="value" />
        /// is not type <see cref="SByte" />, <see cref="Int16" />, <see cref="Int32" />,
        /// <see cref="Int64" />, <see cref="Byte" />, <see cref="UInt16" />,
        /// <see cref="UInt32" />, or <see cref="UInt64" />.
        /// </exception>
        public static object ToObject(System.Type enumType, object value) { return default(object); }
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// The string representation of the value of this instance.
        /// </returns>
        public override string ToString() { return default(string); }
        /// <summary>
        /// Converts the value of this instance to its equivalent string representation using the specified
        /// format.
        /// </summary>
        /// <param name="format">A format string.</param>
        /// <returns>
        /// The string representation of the value of this instance as specified by <paramref name="format" />.
        /// </returns>
        /// <exception cref="FormatException">
        /// <paramref name="format" /> contains an invalid specification.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// <paramref name="format" /> equals "X", but the enumeration type is unknown.
        /// </exception>
        public string ToString(string format) { return default(string); }
        /// <summary>
        /// Converts the string representation of the name or numeric value of one or more enumerated constants
        /// to an equivalent enumerated object. The return value indicates whether the conversion succeeded.
        /// </summary>
        /// <param name="value">The string representation of the enumeration name or underlying value to convert.</param>
        /// <param name="result">
        /// When this method returns, <paramref name="result" /> contains an object of type <paramref name="TEnum" />
        /// whose value is represented by <paramref name="value" /> if the parse operation
        /// succeeds. If the parse operation fails, <paramref name="result" /> contains the default value
        /// of the underlying type of <paramref name="TEnum" />. Note that this value need not be a member
        /// of the <paramref name="TEnum" /> enumeration. This parameter is passed uninitialized.
        /// </param>
        /// <typeparam name="TEnum">The enumeration type to which to convert <paramref name="value" />.</typeparam>
        /// <returns>
        /// true if the <paramref name="value" /> parameter was converted successfully; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// <paramref name="TEnum" /> is not an enumeration type.
        /// </exception>
        public static bool TryParse<TEnum>(string value, out TEnum result) where TEnum : struct { result = default(TEnum); return default(bool); }
        /// <summary>
        /// Converts the string representation of the name or numeric value of one or more enumerated constants
        /// to an equivalent enumerated object. A parameter specifies whether the operation is case-sensitive.
        /// The return value indicates whether the conversion succeeded.
        /// </summary>
        /// <param name="value">The string representation of the enumeration name or underlying value to convert.</param>
        /// <param name="ignoreCase">true to ignore case; false to consider case.</param>
        /// <param name="result">
        /// When this method returns, <paramref name="result" /> contains an object of type <paramref name="TEnum" />
        /// whose value is represented by <paramref name="value" /> if the parse operation
        /// succeeds. If the parse operation fails, <paramref name="result" /> contains the default value
        /// of the underlying type of <paramref name="TEnum" />. Note that this value need not be a member
        /// of the <paramref name="TEnum" /> enumeration. This parameter is passed uninitialized.
        /// </param>
        /// <typeparam name="TEnum">The enumeration type to which to convert <paramref name="value" />.</typeparam>
        /// <returns>
        /// true if the <paramref name="value" /> parameter was converted successfully; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// <paramref name="TEnum" /> is not an enumeration type.
        /// </exception>
        public static bool TryParse<TEnum>(string value, bool ignoreCase, out TEnum result) where TEnum : struct { result = default(TEnum); return default(bool); }
    }
    /// <summary>
    /// Represents the base class for classes that contain event data, and provides a value to use
    /// for events that do not include event data.
    /// </summary>
    public partial class EventArgs
    {
        /// <summary>
        /// Provides a value to use with events that do not have event data.
        /// </summary>
        public static readonly System.EventArgs Empty;
        /// <summary>
        /// Initializes a new instance of the <see cref="EventArgs" /> class.
        /// </summary>
        public EventArgs() { }
    }
    /// <summary>
    /// Represents the method that will handle an event that has no event data.
    /// </summary>
    /// <param name="sender">The source of the event.</param>
    /// <param name="e">An object that contains no event data.</param>
    public delegate void EventHandler(object sender, System.EventArgs e);
    /// <summary>
    /// Represents the method that will handle an event when the event provides data.
    /// </summary>
    /// <param name="sender">The source of the event.</param>
    /// <param name="e">An object that contains the event data.</param>
    /// <typeparam name="TEventArgs">The type of the event data generated by the event.</typeparam>
    public delegate void EventHandler<TEventArgs>(object sender, TEventArgs e);
    /// <summary>
    /// Represents errors that occur during application execution.To browse the .NET Framework source
    /// code for this type, see the Reference Source.
    /// </summary>
    public partial class Exception
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Exception" /> class.
        /// </summary>
        public Exception() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="Exception" /> class with a specified
        /// error message.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        public Exception(string message) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="Exception" /> class with a specified
        /// error message and a reference to the inner exception that is the cause of this exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="innerException">
        /// The exception that is the cause of the current exception, or a null reference (Nothing in Visual
        /// Basic) if no inner exception is specified.
        /// </param>
        public Exception(string message, System.Exception innerException) { }
        /// <summary>
        /// Gets a collection of key/value pairs that provide additional user-defined information about
        /// the exception.
        /// </summary>
        /// <returns>
        /// An object that implements the <see cref="Collections.IDictionary" /> interface and
        /// contains a collection of user-defined key/value pairs. The default is an empty collection.
        /// </returns>
        public virtual System.Collections.IDictionary Data { get { return default(System.Collections.IDictionary); } }
        /// <summary>
        /// Gets or sets a link to the help file associated with this exception.
        /// </summary>
        /// <returns>
        /// The Uniform Resource Name (URN) or Uniform Resource Locator (URL).
        /// </returns>
        public virtual string HelpLink { get { return default(string); } set { } }
        /// <summary>
        /// Gets or sets HRESULT, a coded numerical value that is assigned to a specific exception.
        /// </summary>
        /// <returns>
        /// The HRESULT value.
        /// </returns>
        public int HResult { get { return default(int); } protected set { } }
        /// <summary>
        /// Gets the <see cref="Exception" /> instance that caused the current exception.
        /// </summary>
        /// <returns>
        /// An object that describes the error that caused the current exception. The
        /// <see cref="InnerException" /> property returns the same value as was passed into the
        /// <see cref="Exception.#ctor(System.String,System.Exception)" /> constructor, or null if the inner exception value was not supplied to the constructor.
        /// This property is read-only.
        /// </returns>
        public System.Exception InnerException { get { return default(System.Exception); } }
        /// <summary>
        /// Gets a message that describes the current exception.
        /// </summary>
        /// <returns>
        /// The error message that explains the reason for the exception, or an empty string ("").
        /// </returns>
        public virtual string Message { get { return default(string); } }
        /// <summary>
        /// Gets or sets the name of the application or the object that causes the error.
        /// </summary>
        /// <returns>
        /// The name of the application or the object that causes the error.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// The object must be a runtime <see cref="N:System.Reflection" /> object
        /// </exception>
        public virtual string Source { get { return default(string); } set { } }
        /// <summary>
        /// Gets a string representation of the immediate frames on the call stack.
        /// </summary>
        /// <returns>
        /// A string that describes the immediate frames of the call stack.
        /// </returns>
        public virtual string StackTrace { get { return default(string); } }
        /// <summary>
        /// When overridden in a derived class, returns the <see cref="Exception" /> that is
        /// the root cause of one or more subsequent exceptions.
        /// </summary>
        /// <returns>
        /// The first exception thrown in a chain of exceptions. If the <see cref="InnerException" />
        /// property of the current exception is a null reference (Nothing in Visual Basic), this property
        /// returns the current exception.
        /// </returns>
        public virtual System.Exception GetBaseException() { return default(System.Exception); }
        /// <summary>
        /// Creates and returns a string representation of the current exception.
        /// </summary>
        /// <returns>
        /// A string representation of the current exception.
        /// </returns>
        public override string ToString() { return default(string); }
    }
    /// <summary>
    /// The exception that is thrown when there is an invalid attempt to access a private or protected
    /// field inside a class.
    /// </summary>
    public partial class FieldAccessException : System.MemberAccessException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="FieldAccessException" /> class.
        /// </summary>
        public FieldAccessException() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="FieldAccessException" /> class with
        /// a specified error message.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        public FieldAccessException(string message) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="FieldAccessException" /> class with
        /// a specified error message and a reference to the inner exception that is the cause of this
        /// exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="inner">
        /// The exception that is the cause of the current exception. If the <paramref name="inner" />
        /// parameter is not null, the current exception is raised in a catch block that handles the inner
        /// exception.
        /// </param>
        public FieldAccessException(string message, System.Exception inner) { }
    }
    /// <summary>
    /// Indicates that an enumeration can be treated as a bit field; that is, a set of flags.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(16), Inherited = false)]
    public partial class FlagsAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="FlagsAttribute" /> class.
        /// </summary>
        public FlagsAttribute() { }
    }
    /// <summary>
    /// The exception that is thrown when the format of an argument is invalid, or when a composite
    /// format string is not well formed.
    /// </summary>
    public partial class FormatException : System.Exception
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="FormatException" /> class.
        /// </summary>
        public FormatException() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="FormatException" /> class with a specified
        /// error message.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        public FormatException(string message) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="FormatException" /> class with a specified
        /// error message and a reference to the inner exception that is the cause of this exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="innerException">
        /// The exception that is the cause of the current exception. If the <paramref name="innerException" />
        /// parameter is not a null reference (Nothing in Visual Basic), the current exception is raised
        /// in a catch block that handles the inner exception.
        /// </param>
        public FormatException(string message, System.Exception innerException) { }
    }
    /// <summary>
    /// Represents a composite format string, along with the arguments to be formatted.
    /// </summary>
    public abstract partial class FormattableString : System.IFormattable
    {
        /// <summary>
        /// Instantiates a new instance of the <see cref="FormattableString" /> class.
        /// </summary>
        protected FormattableString() { }
        /// <summary>
        /// Gets the number of arguments to be formatted.
        /// </summary>
        /// <returns>
        /// The number of arguments to be formatted.
        /// </returns>
        public abstract int ArgumentCount { get; }
        /// <summary>
        /// Returns the composite format string.
        /// </summary>
        /// <returns>
        /// The composite format string.
        /// </returns>
        public abstract string Format { get; }
        /// <summary>
        /// Returns the argument at the specified index position.
        /// </summary>
        /// <param name="index">
        /// The index of the argument. Its value can range from zero to one less than the value of
        /// <see cref="ArgumentCount" />.
        /// </param>
        /// <returns>
        /// The argument.
        /// </returns>
        public abstract object GetArgument(int index);
        /// <summary>
        /// Returns an object array that contains one or more objects to format.
        /// </summary>
        /// <returns>
        /// An object array that contains one or more objects to format.
        /// </returns>
        public abstract object[] GetArguments();
        /// <summary>
        /// Returns a result string in which arguments are formatted by using the conventions of the invariant
        /// culture.
        /// </summary>
        /// <param name="formattable">The object to convert to a result string.</param>
        /// <returns>
        /// The string that results from formatting the current instance by using the conventions of the
        /// invariant culture.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="formattable" /> is null.</exception>
        public static string Invariant(System.FormattableString formattable) { return default(string); }
        string System.IFormattable.ToString(string ignored, System.IFormatProvider formatProvider) { return default(string); }
        /// <summary>
        /// Returns the string that results from formatting the composite format string along with its
        /// arguments by using the formatting conventions of the current culture.
        /// </summary>
        /// <returns>
        /// A result string formatted by using the conventions of the current culture.
        /// </returns>
        public override string ToString() { return default(string); }
        /// <summary>
        /// Returns the string that results from formatting the composite format string along with its
        /// arguments by using the formatting conventions of a specified culture.
        /// </summary>
        /// <param name="formatProvider">An object that provides culture-specific formatting information.</param>
        /// <returns>
        /// A result string formatted by using the conventions of <paramref name="formatProvider" />.
        /// </returns>
        public abstract string ToString(System.IFormatProvider formatProvider);
    }
    /// <summary>
    /// Encapsulates a method that has no parameters and returns a value of the type specified by
    /// the <paramref name="TResult" /> parameter.
    /// </summary>
    /// <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
    /// <returns>
    /// The return value of the method that this delegate encapsulates.
    /// </returns>
    public delegate TResult Func<out TResult>();
    /// <summary>
    /// Encapsulates a method that has nine parameters and returns a value of the type specified by
    /// the <paramref name="TResult" /> parameter.
    /// </summary>
    /// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
    /// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
    /// <returns>
    /// The return value of the method that this delegate encapsulates.
    /// </returns>
    public delegate TResult Func<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
    /// <summary>
    /// Encapsulates a method that has 10 parameters and returns a value of the type specified by
    /// the <paramref name="TResult" /> parameter.
    /// </summary>
    /// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
    /// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
    /// <returns>
    /// The return value of the method that this delegate encapsulates.
    /// </returns>
    public delegate TResult Func<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10);
    /// <summary>
    /// Encapsulates a method that has 11 parameters and returns a value of the type specified by
    /// the <paramref name="TResult" /> parameter.
    /// </summary>
    /// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
    /// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
    /// <returns>
    /// The return value of the method that this delegate encapsulates.
    /// </returns>
    public delegate TResult Func<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11);
    /// <summary>
    /// Encapsulates a method that has 12 parameters and returns a value of the type specified by
    /// the <paramref name="TResult" /> parameter.
    /// </summary>
    /// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg12">The twelfth parameter of the method that this delegate encapsulates.</param>
    /// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T12">The type of the twelfth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
    /// <returns>
    /// The return value of the method that this delegate encapsulates.
    /// </returns>
    public delegate TResult Func<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, in T12, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12);
    /// <summary>
    /// Encapsulates a method that has 13 parameters and returns a value of the type specified by
    /// the <paramref name="TResult" /> parameter.
    /// </summary>
    /// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg12">The twelfth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg13">The thirteenth parameter of the method that this delegate encapsulates.</param>
    /// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T12">The type of the twelfth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T13">The type of the thirteenth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
    /// <returns>
    /// The return value of the method that this delegate encapsulates.
    /// </returns>
    public delegate TResult Func<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, in T12, in T13, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13);
    /// <summary>
    /// Encapsulates a method that has 14 parameters and returns a value of the type specified by
    /// the <paramref name="TResult" /> parameter.
    /// </summary>
    /// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg12">The twelfth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg13">The thirteenth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg14">The fourteenth parameter of the method that this delegate encapsulates.</param>
    /// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T12">The type of the twelfth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T13">The type of the thirteenth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T14">The type of the fourteenth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
    /// <returns>
    /// The return value of the method that this delegate encapsulates.
    /// </returns>
    public delegate TResult Func<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, in T12, in T13, in T14, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14);
    /// <summary>
    /// Encapsulates a method that has 15 parameters and returns a value of the type specified by
    /// the <paramref name="TResult" /> parameter.
    /// </summary>
    /// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg12">The twelfth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg13">The thirteenth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg14">The fourteenth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg15">The fifteenth parameter of the method that this delegate encapsulates.</param>
    /// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T12">The type of the twelfth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T13">The type of the thirteenth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T14">The type of the fourteenth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T15">The type of the fifteenth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
    /// <returns>
    /// The return value of the method that this delegate encapsulates.
    /// </returns>
    public delegate TResult Func<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, in T12, in T13, in T14, in T15, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15);
    /// <summary>
    /// Encapsulates a method that has 16 parameters and returns a value of the type specified by
    /// the <paramref name="TResult" /> parameter.
    /// </summary>
    /// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg12">The twelfth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg13">The thirteenth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg14">The fourteenth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg15">The fifteenth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg16">The sixteenth parameter of the method that this delegate encapsulates.</param>
    /// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T12">The type of the twelfth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T13">The type of the thirteenth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T14">The type of the fourteenth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T15">The type of the fifteenth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T16">The type of the sixteenth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
    /// <returns>
    /// The return value of the method that this delegate encapsulates.
    /// </returns>
    public delegate TResult Func<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, in T12, in T13, in T14, in T15, in T16, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16);
    /// <summary>
    /// Encapsulates a method that has one parameter and returns a value of the type specified by
    /// the <paramref name="TResult" /> parameter.To browse the .NET Framework source code for this
    /// type, see the Reference Source.
    /// </summary>
    /// <param name="arg">The parameter of the method that this delegate encapsulates.</param>
    /// <typeparam name="T">The type of the parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
    /// <returns>
    /// The return value of the method that this delegate encapsulates.
    /// </returns>
    public delegate TResult Func<in T, out TResult>(T arg);
    /// <summary>
    /// Encapsulates a method that has two parameters and returns a value of the type specified by
    /// the <paramref name="TResult" /> parameter.
    /// </summary>
    /// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
    /// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
    /// <returns>
    /// The return value of the method that this delegate encapsulates.
    /// </returns>
    public delegate TResult Func<in T1, in T2, out TResult>(T1 arg1, T2 arg2);
    /// <summary>
    /// Encapsulates a method that has three parameters and returns a value of the type specified
    /// by the <paramref name="TResult" /> parameter.
    /// </summary>
    /// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
    /// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
    /// <returns>
    /// The return value of the method that this delegate encapsulates.
    /// </returns>
    public delegate TResult Func<in T1, in T2, in T3, out TResult>(T1 arg1, T2 arg2, T3 arg3);
    /// <summary>
    /// Encapsulates a method that has four parameters and returns a value of the type specified by
    /// the <paramref name="TResult" /> parameter.
    /// </summary>
    /// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
    /// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
    /// <returns>
    /// The return value of the method that this delegate encapsulates.
    /// </returns>
    public delegate TResult Func<in T1, in T2, in T3, in T4, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    /// <summary>
    /// Encapsulates a method that has five parameters and returns a value of the type specified by
    /// the <paramref name="TResult" /> parameter.
    /// </summary>
    /// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
    /// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
    /// <returns>
    /// The return value of the method that this delegate encapsulates.
    /// </returns>
    public delegate TResult Func<in T1, in T2, in T3, in T4, in T5, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    /// <summary>
    /// Encapsulates a method that has six parameters and returns a value of the type specified by
    /// the <paramref name="TResult" /> parameter.
    /// </summary>
    /// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
    /// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
    /// <returns>
    /// The return value of the method that this delegate encapsulates.
    /// </returns>
    public delegate TResult Func<in T1, in T2, in T3, in T4, in T5, in T6, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    /// <summary>
    /// Encapsulates a method that has seven parameters and returns a value of the type specified
    /// by the <paramref name="TResult" /> parameter.
    /// </summary>
    /// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
    /// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
    /// <returns>
    /// The return value of the method that this delegate encapsulates.
    /// </returns>
    public delegate TResult Func<in T1, in T2, in T3, in T4, in T5, in T6, in T7, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    /// <summary>
    /// Encapsulates a method that has eight parameters and returns a value of the type specified
    /// by the <paramref name="TResult" /> parameter.
    /// </summary>
    /// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
    /// <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
    /// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
    /// <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
    /// <returns>
    /// The return value of the method that this delegate encapsulates.
    /// </returns>
    public delegate TResult Func<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    /// <summary>
    /// Controls the system garbage collector, a service that automatically reclaims unused memory.
    /// </summary>
    public static partial class GC
    {
        /// <summary>
        /// Gets the maximum number of generations that the system currently supports.
        /// </summary>
        /// <returns>
        /// A value that ranges from zero to the maximum number of supported generations.
        /// </returns>
        public static int MaxGeneration { get { return default(int); } }
        /// <summary>
        /// Informs the runtime of a large allocation of unmanaged memory that should be taken into account
        /// when scheduling garbage collection.
        /// </summary>
        /// <param name="bytesAllocated">The incremental amount of unmanaged memory that has been allocated.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="bytesAllocated" /> is less than or equal to 0.-or-On a 32-bit computer,
        /// <paramref name="bytesAllocated" /> is larger than <see cref="Int32.MaxValue" />.
        /// </exception>
        [System.Security.SecurityCriticalAttribute]
        public static void AddMemoryPressure(long bytesAllocated) { }
        /// <summary>
        /// Forces an immediate garbage collection of all generations.
        /// </summary>
        public static void Collect() { }
        /// <summary>
        /// Forces an immediate garbage collection from generation 0 through a specified generation.
        /// </summary>
        /// <param name="generation">The number of the oldest generation to be garbage collected.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="generation" /> is not valid.
        /// </exception>
        public static void Collect(int generation) { }
        /// <summary>
        /// Forces a garbage collection from generation 0 through a specified generation, at a time specified
        /// by a <see cref="GCCollectionMode" /> value.
        /// </summary>
        /// <param name="generation">The number of the oldest generation to be garbage collected.</param>
        /// <param name="mode">
        /// An enumeration value that specifies whether the garbage collection is forced (
        /// <see cref="GCCollectionMode.Default" /> or <see cref="GCCollectionMode.Forced" />) or optimized (
        /// <see cref="GCCollectionMode.Optimized" />).
        /// </param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="generation" /> is not valid.-or-<paramref name="mode" /> is not one of the
        /// <see cref="GCCollectionMode" /> values.
        /// </exception>
        public static void Collect(int generation, System.GCCollectionMode mode) { }
        /// <summary>
        /// Forces a garbage collection from generation 0 through a specified generation, at a time specified
        /// by a <see cref="GCCollectionMode" /> value, with a value specifying whether the collection
        /// should be blocking.
        /// </summary>
        /// <param name="generation">The number of the oldest generation to be garbage collected.</param>
        /// <param name="mode">
        /// An enumeration value that specifies whether the garbage collection is forced (
        /// <see cref="GCCollectionMode.Default" /> or <see cref="GCCollectionMode.Forced" />) or optimized (
        /// <see cref="GCCollectionMode.Optimized" />).
        /// </param>
        /// <param name="blocking">
        /// true to perform a blocking garbage collection; false to perform a background garbage collection
        /// where possible.
        /// </param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="generation" /> is not valid.-or-<paramref name="mode" /> is not one of the
        /// <see cref="GCCollectionMode" /> values.
        /// </exception>
        public static void Collect(int generation, System.GCCollectionMode mode, bool blocking) { }
        /// <summary>
        /// Returns the number of times garbage collection has occurred for the specified generation of
        /// objects.
        /// </summary>
        /// <param name="generation">
        /// The generation of objects for which the garbage collection count is to be determined.
        /// </param>
        /// <returns>
        /// The number of times garbage collection has occurred for the specified generation since the
        /// process was started.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="generation" /> is less than 0.
        /// </exception>
        public static int CollectionCount(int generation) { return default(int); }
        /// <summary>
        /// Returns the current generation number of the specified object.
        /// </summary>
        /// <param name="obj">The object that generation information is retrieved for.</param>
        /// <returns>
        /// The current generation number of <paramref name="obj" />.
        /// </returns>
        public static int GetGeneration(object obj) { return default(int); }
        /// <summary>
        /// Retrieves the number of bytes currently thought to be allocated. A parameter indicates whether
        /// this method can wait a short interval before returning, to allow the system to collect garbage and
        /// finalize objects.
        /// </summary>
        /// <param name="forceFullCollection">
        /// true to indicate that this method can wait for garbage collection to occur before returning;
        /// otherwise, false.
        /// </param>
        /// <returns>
        /// A number that is the best available approximation of the number of bytes currently allocated
        /// in managed memory.
        /// </returns>
        public static long GetTotalMemory(bool forceFullCollection) { return default(long); }
        /// <summary>
        /// References the specified object, which makes it ineligible for garbage collection from the
        /// start of the current routine to the point where this method is called.
        /// </summary>
        /// <param name="obj">The object to reference.</param>
        public static void KeepAlive(object obj) { }
        /// <summary>
        /// Informs the runtime that unmanaged memory has been released and no longer needs to be taken
        /// into account when scheduling garbage collection.
        /// </summary>
        /// <param name="bytesAllocated">The amount of unmanaged memory that has been released.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="bytesAllocated" /> is less than or equal to 0. -or- On a 32-bit computer,
        /// <paramref name="bytesAllocated" /> is larger than <see cref="Int32.MaxValue" />.
        /// </exception>
        [System.Security.SecurityCriticalAttribute]
        public static void RemoveMemoryPressure(long bytesAllocated) { }
        /// <summary>
        /// Requests that the system call the finalizer for the specified object for which
        /// <see cref="GC.SuppressFinalize(Object)" /> has previously been called.
        /// </summary>
        /// <param name="obj">The object that a finalizer must be called for.</param>
        /// <exception cref="ArgumentNullException"><paramref name="obj" /> is null.</exception>
        public static void ReRegisterForFinalize(object obj) { }
        /// <summary>
        /// Requests that the common language runtime not call the finalizer for the specified object.
        /// </summary>
        /// <param name="obj">The object whose finalizer must not be executed.</param>
        /// <exception cref="ArgumentNullException"><paramref name="obj" /> is null.</exception>
        public static void SuppressFinalize(object obj) { }
        /// <summary>
        /// Suspends the current thread until the thread that is processing the queue of finalizers has
        /// emptied that queue.
        /// </summary>
        public static void WaitForPendingFinalizers() { }
    }
    /// <summary>
    /// Specifies the behavior for a forced garbage collection.
    /// </summary>
    public enum GCCollectionMode
    {
        /// <summary>
        /// The default setting for this enumeration, which is currently <see cref="Forced" />.
        /// </summary>
        Default = 0,
        /// <summary>
        /// Forces the garbage collection to occur immediately.
        /// </summary>
        Forced = 1,
        /// <summary>
        /// Allows the garbage collector to determine whether the current time is optimal to reclaim objects.
        /// </summary>
        Optimized = 2,
    }
    /// <summary>
    /// Represents a globally unique identifier (GUID).To browse the .NET Framework source code for
    /// this type, see the Reference Source.
    /// </summary>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct Guid : System.IComparable, System.IComparable<System.Guid>, System.IEquatable<System.Guid>, System.IFormattable
    {
        /// <summary>
        /// A read-only instance of the <see cref="Guid" /> structure whose value is all zeros.
        /// </summary>
        public static readonly System.Guid Empty;
        /// <summary>
        /// Initializes a new instance of the <see cref="Guid" /> structure by using the specified
        /// array of bytes.
        /// </summary>
        /// <param name="b">A 16-element byte array containing values with which to initialize the GUID.</param>
        /// <exception cref="ArgumentNullException"><paramref name="b" /> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="b" /> is not 16 bytes long.</exception>
        public Guid(byte[] b) { throw new System.NotImplementedException(); }
        /// <summary>
        /// Initializes a new instance of the <see cref="Guid" /> structure by using the specified
        /// integers and bytes.
        /// </summary>
        /// <param name="a">The first 4 bytes of the GUID.</param>
        /// <param name="b">The next 2 bytes of the GUID.</param>
        /// <param name="c">The next 2 bytes of the GUID.</param>
        /// <param name="d">The next byte of the GUID.</param>
        /// <param name="e">The next byte of the GUID.</param>
        /// <param name="f">The next byte of the GUID.</param>
        /// <param name="g">The next byte of the GUID.</param>
        /// <param name="h">The next byte of the GUID.</param>
        /// <param name="i">The next byte of the GUID.</param>
        /// <param name="j">The next byte of the GUID.</param>
        /// <param name="k">The next byte of the GUID.</param>
        public Guid(int a, short b, short c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k) { throw new System.NotImplementedException(); }
        /// <summary>
        /// Initializes a new instance of the <see cref="Guid" /> structure by using the specified
        /// integers and byte array.
        /// </summary>
        /// <param name="a">The first 4 bytes of the GUID.</param>
        /// <param name="b">The next 2 bytes of the GUID.</param>
        /// <param name="c">The next 2 bytes of the GUID.</param>
        /// <param name="d">The remaining 8 bytes of the GUID.</param>
        /// <exception cref="ArgumentNullException"><paramref name="d" /> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="d" /> is not 8 bytes long.</exception>
        public Guid(int a, short b, short c, byte[] d) { throw new System.NotImplementedException(); }
        /// <summary>
        /// Initializes a new instance of the <see cref="Guid" /> structure by using the value
        /// represented by the specified string.
        /// </summary>
        /// <param name="g">
        /// A string that contains a GUID in one of the following formats ("d" represents a hexadecimal
        /// digit whose case is ignored): 32 contiguous digits: dddddddddddddddddddddddddddddddd -or- Groups of
        /// 8, 4, 4, 4, and 12 digits with hyphens between the groups. The entire GUID can optionally be enclosed
        /// in matching braces or parentheses: dddddddd-dddd-dddd-dddd-dddddddddddd -or- {dddddddd-dddd-dddd-dddd-dddddddddddd}
        /// -or- (dddddddd-dddd-dddd-dddd-dddddddddddd) -or- Groups of 8, 4, and 4 digits, and
        /// a subset of eight groups of 2 digits, with each group prefixed by "0x" or "0X", and separated by commas.
        /// The entire GUID, as well as the subset, is enclosed in matching braces: {0xdddddddd, 0xdddd,
        /// 0xdddd,{0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd}} All braces, commas, and "0x" prefixes are required.
        /// All embedded spaces are ignored. All leading zeros in a group are ignored.The digits shown in a group
        /// are the maximum number of meaningful digits that can appear in that group. You can specify from
        /// 1 to the number of digits shown for a group. The specified digits are assumed to be the low-order digits
        /// of the group.
        /// </param>
        /// <exception cref="ArgumentNullException"><paramref name="g" /> is null.</exception>
        /// <exception cref="FormatException">The format of <paramref name="g" /> is invalid.</exception>
        /// <exception cref="OverflowException">The format of <paramref name="g" /> is invalid.</exception>
        public Guid(string g) { throw new System.NotImplementedException(); }
        /// <summary>
        /// Initializes a new instance of the <see cref="Guid" /> structure by using the specified
        /// unsigned integers and bytes.
        /// </summary>
        /// <param name="a">The first 4 bytes of the GUID.</param>
        /// <param name="b">The next 2 bytes of the GUID.</param>
        /// <param name="c">The next 2 bytes of the GUID.</param>
        /// <param name="d">The next byte of the GUID.</param>
        /// <param name="e">The next byte of the GUID.</param>
        /// <param name="f">The next byte of the GUID.</param>
        /// <param name="g">The next byte of the GUID.</param>
        /// <param name="h">The next byte of the GUID.</param>
        /// <param name="i">The next byte of the GUID.</param>
        /// <param name="j">The next byte of the GUID.</param>
        /// <param name="k">The next byte of the GUID.</param>
        [System.CLSCompliantAttribute(false)]
        public Guid(uint a, ushort b, ushort c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k) { throw new System.NotImplementedException(); }
        /// <summary>
        /// Compares this instance to a specified <see cref="Guid" /> object and returns an indication
        /// of their relative values.
        /// </summary>
        /// <param name="value">An object to compare to this instance.</param>
        /// <returns>
        /// A signed number indicating the relative values of this instance and <paramref name="value" />.
        /// Return value Description A negative integer This instance is less than <paramref name="value" />.
        /// Zero This instance is equal to <paramref name="value" />. A positive integer This instance
        /// is greater than <paramref name="value" />.
        /// </returns>
        public int CompareTo(System.Guid value) { return default(int); }
        /// <summary>
        /// Returns a value indicating whether this instance and a specified <see cref="Guid" />
        /// object represent the same value.
        /// </summary>
        /// <param name="g">An object to compare to this instance.</param>
        /// <returns>
        /// true if <paramref name="g" /> is equal to this instance; otherwise, false.
        /// </returns>
        public bool Equals(System.Guid g) { return default(bool); }
        /// <summary>
        /// Returns a value that indicates whether this instance is equal to a specified object.
        /// </summary>
        /// <param name="o">The object to compare with this instance.</param>
        /// <returns>
        /// true if <paramref name="o" /> is a <see cref="Guid" /> that has the same value as
        /// this instance; otherwise, false.
        /// </returns>
        public override bool Equals(object o) { return default(bool); }
        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>
        /// The hash code for this instance.
        /// </returns>
        public override int GetHashCode() { return default(int); }
        /// <summary>
        /// Initializes a new instance of the <see cref="Guid" /> structure.
        /// </summary>
        /// <returns>
        /// A new GUID object.
        /// </returns>
        public static System.Guid NewGuid() { return default(System.Guid); }
        /// <summary>
        /// Indicates whether the values of two specified <see cref="Guid" /> objects are equal.
        /// </summary>
        /// <param name="a">The first object to compare.</param>
        /// <param name="b">The second object to compare.</param>
        /// <returns>
        /// true if <paramref name="a" /> and <paramref name="b" /> are equal; otherwise, false.
        /// </returns>
        public static bool operator ==(System.Guid a, System.Guid b) { return default(bool); }
        /// <summary>
        /// Indicates whether the values of two specified <see cref="Guid" /> objects are not
        /// equal.
        /// </summary>
        /// <param name="a">The first object to compare.</param>
        /// <param name="b">The second object to compare.</param>
        /// <returns>
        /// true if <paramref name="a" /> and <paramref name="b" /> are not equal; otherwise, false.
        /// </returns>
        public static bool operator !=(System.Guid a, System.Guid b) { return default(bool); }
        /// <summary>
        /// Converts the string representation of a GUID to the equivalent <see cref="Guid" />
        /// structure.
        /// </summary>
        /// <param name="input">The string to convert.</param>
        /// <returns>
        /// A structure that contains the value that was parsed.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="input" /> is null.</exception>
        /// <exception cref="FormatException">
        /// <paramref name="input" /> is not in a recognized format.
        /// </exception>
        public static System.Guid Parse(string input) { return default(System.Guid); }
        /// <summary>
        /// Converts the string representation of a GUID to the equivalent <see cref="Guid" />
        /// structure, provided that the string is in the specified format.
        /// </summary>
        /// <param name="input">The GUID to convert.</param>
        /// <param name="format">
        /// One of the following specifiers that indicates the exact format to use when interpreting
        /// <paramref name="input" />: "N", "D", "B", "P", or "X".
        /// </param>
        /// <returns>
        /// A structure that contains the value that was parsed.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="input" /> or <paramref name="format" /> is null.
        /// </exception>
        /// <exception cref="FormatException">
        /// <paramref name="input" /> is not in the format specified by <paramref name="format" />.
        /// </exception>
        public static System.Guid ParseExact(string input, string format) { return default(System.Guid); }
        int System.IComparable.CompareTo(object value) { return default(int); }
        string System.IFormattable.ToString(string format, System.IFormatProvider provider) { return default(string); }
        /// <summary>
        /// Returns a 16-element byte array that contains the value of this instance.
        /// </summary>
        /// <returns>
        /// A 16-element byte array.
        /// </returns>
        public byte[] ToByteArray() { return default(byte[]); }
        /// <summary>
        /// Returns a string representation of the value of this instance in registry format.
        /// </summary>
        /// <returns>
        /// The value of this <see cref="Guid" />, formatted by using the "D" format specifier
        /// as follows: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx where the value of the GUID is represented
        /// as a series of lowercase hexadecimal digits in groups of 8, 4, 4, 4, and 12 digits and separated
        /// by hyphens. An example of a return value is "382c74c3-721d-4f34-80e5-57657b6cbc27". To convert
        /// the hexadecimal digits from a through f to uppercase, call the <see cref="String.ToUpper" />
        /// method on the returned string.
        /// </returns>
        public override string ToString() { return default(string); }
        /// <summary>
        /// Returns a string representation of the value of this <see cref="Guid" /> instance,
        /// according to the provided format specifier.
        /// </summary>
        /// <param name="format">
        /// A single format specifier that indicates how to format the value of this <see cref="Guid" />.
        /// The <paramref name="format" /> parameter can be "N", "D", "B", "P", or "X". If <paramref name="format" />
        /// is null or an empty string (""), "D" is used.
        /// </param>
        /// <returns>
        /// The value of this <see cref="Guid" />, represented as a series of lowercase hexadecimal
        /// digits in the specified format.
        /// </returns>
        /// <exception cref="FormatException">
        /// The value of <paramref name="format" /> is not null, an empty string (""), "N", "D", "B",
        /// "P", or "X".
        /// </exception>
        public string ToString(string format) { return default(string); }
        /// <summary>
        /// Converts the string representation of a GUID to the equivalent <see cref="Guid" />
        /// structure.
        /// </summary>
        /// <param name="input">The GUID to convert.</param>
        /// <param name="result">
        /// The structure that will contain the parsed value. If the method returns true, <paramref name="result" />
        /// contains a valid <see cref="Guid" />. If the method returns false, <paramref name="result" />
        /// equals <see cref="Empty" />.
        /// </param>
        /// <returns>
        /// true if the parse operation was successful; otherwise, false.
        /// </returns>
        public static bool TryParse(string input, out System.Guid result) { result = default(System.Guid); return default(bool); }
        /// <summary>
        /// Converts the string representation of a GUID to the equivalent <see cref="Guid" />
        /// structure, provided that the string is in the specified format.
        /// </summary>
        /// <param name="input">The GUID to convert.</param>
        /// <param name="format">
        /// One of the following specifiers that indicates the exact format to use when interpreting
        /// <paramref name="input" />: "N", "D", "B", "P", or "X".
        /// </param>
        /// <param name="result">
        /// The structure that will contain the parsed value. If the method returns true, <paramref name="result" />
        /// contains a valid <see cref="Guid" />. If the method returns false, <paramref name="result" />
        /// equals <see cref="Empty" />.
        /// </param>
        /// <returns>
        /// true if the parse operation was successful; otherwise, false.
        /// </returns>
        public static bool TryParseExact(string input, string format, out System.Guid result) { result = default(System.Guid); return default(bool); }
    }
    /// <summary>
    /// Represents the status of an asynchronous operation.
    /// </summary>
    public partial interface IAsyncResult
    {
        /// <summary>
        /// Gets a user-defined object that qualifies or contains information about an asynchronous operation.
        /// </summary>
        /// <returns>
        /// A user-defined object that qualifies or contains information about an asynchronous operation.
        /// </returns>
        object AsyncState { get; }
        /// <summary>
        /// Gets a <see cref="System.Threading.WaitHandle" /> that is used to wait for an asynchronous
        /// operation to complete.
        /// </summary>
        /// <returns>
        /// A <see cref="System.Threading.WaitHandle" /> that is used to wait for an asynchronous operation
        /// to complete.
        /// </returns>
        System.Threading.WaitHandle AsyncWaitHandle { get; }
        /// <summary>
        /// Gets a value that indicates whether the asynchronous operation completed synchronously.
        /// </summary>
        /// <returns>
        /// true if the asynchronous operation completed synchronously; otherwise, false.
        /// </returns>
        bool CompletedSynchronously { get; }
        /// <summary>
        /// Gets a value that indicates whether the asynchronous operation has completed.
        /// </summary>
        /// <returns>
        /// true if the operation is complete; otherwise, false.
        /// </returns>
        bool IsCompleted { get; }
    }
    /// <summary>
    /// Defines a generalized type-specific comparison method that a value type or class implements
    /// to order or sort its instances.
    /// </summary>
    public partial interface IComparable
    {
        /// <summary>
        /// Compares the current instance with another object of the same type and returns an integer that
        /// indicates whether the current instance precedes, follows, or occurs in the same position in the
        /// sort order as the other object.
        /// </summary>
        /// <param name="obj">An object to compare with this instance.</param>
        /// <returns>
        /// A value that indicates the relative order of the objects being compared. The return value
        /// has these meanings: Value Meaning Less than zero This instance precedes <paramref name="obj" />
        /// in the sort order. Zero This instance occurs in the same position in the sort order as
        /// <paramref name="obj" />. Greater than zero This instance follows <paramref name="obj" /> in
        /// the sort order.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// <paramref name="obj" /> is not the same type as this instance.
        /// </exception>
        int CompareTo(object obj);
    }
    /// <summary>
    /// Defines a generalized comparison method that a value type or class implements to create a type-specific
    /// comparison method for ordering or sorting its instances.
    /// </summary>
    /// <typeparam name="T">The type of object to compare.</typeparam>
    public partial interface IComparable<in T>
    {
        /// <summary>
        /// Compares the current instance with another object of the same type and returns an integer that
        /// indicates whether the current instance precedes, follows, or occurs in the same position in the
        /// sort order as the other object.
        /// </summary>
        /// <param name="other">An object to compare with this instance.</param>
        /// <returns>
        /// A value that indicates the relative order of the objects being compared. The return value
        /// has these meanings: Value Meaning Less than zero This instance precedes <paramref name="other" />
        /// in the sort order.  Zero This instance occurs in the same position in the sort order as
        /// <paramref name="other" />. Greater than zero This instance follows <paramref name="other" />
        /// in the sort order.
        /// </returns>
        int CompareTo(T other);
    }
    /// <summary>
    /// Defines methods that convert the value of the implementing reference or value type to a common
    /// language runtime type that has an equivalent value.
    /// </summary>
    [System.CLSCompliantAttribute(false)]
    public partial interface IConvertible
    {
        /// <summary>
        /// Returns the <see cref="System.TypeCode" /> for this instance.
        /// </summary>
        /// <returns>
        /// The enumerated constant that is the <see cref="System.TypeCode" /> of the class or value
        /// type that implements this interface.
        /// </returns>
        System.TypeCode GetTypeCode();
        /// <summary>
        /// Converts the value of this instance to an equivalent Boolean value using the specified culture-specific
        /// formatting information.
        /// </summary>
        /// <param name="provider">
        /// An <see cref="IFormatProvider" /> interface implementation that supplies culture-specific
        /// formatting information.
        /// </param>
        /// <returns>
        /// A Boolean value equivalent to the value of this instance.
        /// </returns>
        bool ToBoolean(System.IFormatProvider provider);
        /// <summary>
        /// Converts the value of this instance to an equivalent 8-bit unsigned integer using the specified
        /// culture-specific formatting information.
        /// </summary>
        /// <param name="provider">
        /// An <see cref="IFormatProvider" /> interface implementation that supplies culture-specific
        /// formatting information.
        /// </param>
        /// <returns>
        /// An 8-bit unsigned integer equivalent to the value of this instance.
        /// </returns>
        byte ToByte(System.IFormatProvider provider);
        /// <summary>
        /// Converts the value of this instance to an equivalent Unicode character using the specified
        /// culture-specific formatting information.
        /// </summary>
        /// <param name="provider">
        /// An <see cref="IFormatProvider" /> interface implementation that supplies culture-specific
        /// formatting information.
        /// </param>
        /// <returns>
        /// A Unicode character equivalent to the value of this instance.
        /// </returns>
        char ToChar(System.IFormatProvider provider);
        /// <summary>
        /// Converts the value of this instance to an equivalent <see cref="System.DateTime" /> using
        /// the specified culture-specific formatting information.
        /// </summary>
        /// <param name="provider">
        /// An <see cref="System.IFormatProvider" /> interface implementation that supplies culture-specific
        /// formatting information.
        /// </param>
        /// <returns>
        /// A <see cref="System.DateTime" /> instance equivalent to the value of this instance.
        /// </returns>
        System.DateTime ToDateTime(System.IFormatProvider provider);
        /// <summary>
        /// Converts the value of this instance to an equivalent <see cref="Decimal" /> number
        /// using the specified culture-specific formatting information.
        /// </summary>
        /// <param name="provider">
        /// An <see cref="IFormatProvider" /> interface implementation that supplies culture-specific
        /// formatting information.
        /// </param>
        /// <returns>
        /// A <see cref="Decimal" /> number equivalent to the value of this instance.
        /// </returns>
        decimal ToDecimal(System.IFormatProvider provider);
        /// <summary>
        /// Converts the value of this instance to an equivalent double-precision floating-point number
        /// using the specified culture-specific formatting information.
        /// </summary>
        /// <param name="provider">
        /// An <see cref="IFormatProvider" /> interface implementation that supplies culture-specific
        /// formatting information.
        /// </param>
        /// <returns>
        /// A double-precision floating-point number equivalent to the value of this instance.
        /// </returns>
        double ToDouble(System.IFormatProvider provider);
        /// <summary>
        /// Converts the value of this instance to an equivalent 16-bit signed integer using the specified
        /// culture-specific formatting information.
        /// </summary>
        /// <param name="provider">
        /// An <see cref="IFormatProvider" /> interface implementation that supplies culture-specific
        /// formatting information.
        /// </param>
        /// <returns>
        /// An 16-bit signed integer equivalent to the value of this instance.
        /// </returns>
        short ToInt16(System.IFormatProvider provider);
        /// <summary>
        /// Converts the value of this instance to an equivalent 32-bit signed integer using the specified
        /// culture-specific formatting information.
        /// </summary>
        /// <param name="provider">
        /// An <see cref="IFormatProvider" /> interface implementation that supplies culture-specific
        /// formatting information.
        /// </param>
        /// <returns>
        /// An 32-bit signed integer equivalent to the value of this instance.
        /// </returns>
        int ToInt32(System.IFormatProvider provider);
        /// <summary>
        /// Converts the value of this instance to an equivalent 64-bit signed integer using the specified
        /// culture-specific formatting information.
        /// </summary>
        /// <param name="provider">
        /// An <see cref="IFormatProvider" /> interface implementation that supplies culture-specific
        /// formatting information.
        /// </param>
        /// <returns>
        /// An 64-bit signed integer equivalent to the value of this instance.
        /// </returns>
        long ToInt64(System.IFormatProvider provider);
        /// <summary>
        /// Converts the value of this instance to an equivalent 8-bit signed integer using the specified
        /// culture-specific formatting information.
        /// </summary>
        /// <param name="provider">
        /// An <see cref="IFormatProvider" /> interface implementation that supplies culture-specific
        /// formatting information.
        /// </param>
        /// <returns>
        /// An 8-bit signed integer equivalent to the value of this instance.
        /// </returns>
        sbyte ToSByte(System.IFormatProvider provider);
        /// <summary>
        /// Converts the value of this instance to an equivalent single-precision floating-point number
        /// using the specified culture-specific formatting information.
        /// </summary>
        /// <param name="provider">
        /// An <see cref="IFormatProvider" /> interface implementation that supplies culture-specific
        /// formatting information.
        /// </param>
        /// <returns>
        /// A single-precision floating-point number equivalent to the value of this instance.
        /// </returns>
        float ToSingle(System.IFormatProvider provider);
        /// <summary>
        /// Converts the value of this instance to an equivalent <see cref="String" /> using
        /// the specified culture-specific formatting information.
        /// </summary>
        /// <param name="provider">
        /// An <see cref="IFormatProvider" /> interface implementation that supplies culture-specific
        /// formatting information.
        /// </param>
        /// <returns>
        /// A <see cref="String" /> instance equivalent to the value of this instance.
        /// </returns>
        string ToString(System.IFormatProvider provider);
        /// <summary>
        /// Converts the value of this instance to an <see cref="Object" /> of the specified
        /// <see cref="Type" /> that has an equivalent value, using the specified culture-specific
        /// formatting information.
        /// </summary>
        /// <param name="conversionType">
        /// The <see cref="Type" /> to which the value of this instance is converted.
        /// </param>
        /// <param name="provider">
        /// An <see cref="IFormatProvider" /> interface implementation that supplies culture-specific
        /// formatting information.
        /// </param>
        /// <returns>
        /// An <see cref="Object" /> instance of type <paramref name="conversionType" /> whose
        /// value is equivalent to the value of this instance.
        /// </returns>
        object ToType(System.Type conversionType, System.IFormatProvider provider);
        /// <summary>
        /// Converts the value of this instance to an equivalent 16-bit unsigned integer using the specified
        /// culture-specific formatting information.
        /// </summary>
        /// <param name="provider">
        /// An <see cref="IFormatProvider" /> interface implementation that supplies culture-specific
        /// formatting information.
        /// </param>
        /// <returns>
        /// An 16-bit unsigned integer equivalent to the value of this instance.
        /// </returns>
        ushort ToUInt16(System.IFormatProvider provider);
        /// <summary>
        /// Converts the value of this instance to an equivalent 32-bit unsigned integer using the specified
        /// culture-specific formatting information.
        /// </summary>
        /// <param name="provider">
        /// An <see cref="IFormatProvider" /> interface implementation that supplies culture-specific
        /// formatting information.
        /// </param>
        /// <returns>
        /// An 32-bit unsigned integer equivalent to the value of this instance.
        /// </returns>
        uint ToUInt32(System.IFormatProvider provider);
        /// <summary>
        /// Converts the value of this instance to an equivalent 64-bit unsigned integer using the specified
        /// culture-specific formatting information.
        /// </summary>
        /// <param name="provider">
        /// An <see cref="IFormatProvider" /> interface implementation that supplies culture-specific
        /// formatting information.
        /// </param>
        /// <returns>
        /// An 64-bit unsigned integer equivalent to the value of this instance.
        /// </returns>
        ulong ToUInt64(System.IFormatProvider provider);
    }
    /// <summary>
    /// Defines a method that supports custom formatting of the value of an object.
    /// </summary>
    public partial interface ICustomFormatter
    {
        /// <summary>
        /// Converts the value of a specified object to an equivalent string representation using specified
        /// format and culture-specific formatting information.
        /// </summary>
        /// <param name="format">A format string containing formatting specifications.</param>
        /// <param name="arg">An object to format.</param>
        /// <param name="formatProvider">An object that supplies format information about the current instance.</param>
        /// <returns>
        /// The string representation of the value of <paramref name="arg" />, formatted as specified
        /// by <paramref name="format" /> and <paramref name="formatProvider" />.
        /// </returns>
        string Format(string format, object arg, System.IFormatProvider formatProvider);
    }
    /// <summary>
    /// Provides a mechanism for releasing unmanaged resources.To browse the .NET Framework source
    /// code for this type, see the Reference Source.
    /// </summary>
    public partial interface IDisposable
    {
        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged
        /// resources.
        /// </summary>
        void Dispose();
    }
    /// <summary>
    /// Defines a generalized method that a value type or class implements to create a type-specific
    /// method for determining equality of instances.
    /// </summary>
    /// <typeparam name="T">The type of objects to compare.</typeparam>
    public partial interface IEquatable<T>
    {
        /// <summary>
        /// Indicates whether the current object is equal to another object of the same type.
        /// </summary>
        /// <param name="other">An object to compare with this object.</param>
        /// <returns>
        /// true if the current object is equal to the <paramref name="other" /> parameter; otherwise,
        /// false.
        /// </returns>
        bool Equals(T other);
    }
    /// <summary>
    /// Provides a mechanism for retrieving an object to control formatting.
    /// </summary>
    public partial interface IFormatProvider
    {
        /// <summary>
        /// Returns an object that provides formatting services for the specified type.
        /// </summary>
        /// <param name="formatType">An object that specifies the type of format object to return.</param>
        /// <returns>
        /// An instance of the object specified by <paramref name="formatType" />, if the
        /// <see cref="IFormatProvider" /> implementation can supply that type of object; otherwise, null.
        /// </returns>
        object GetFormat(System.Type formatType);
    }
    /// <summary>
    /// Provides functionality to format the value of an object into a string representation.
    /// </summary>
    public partial interface IFormattable
    {
        /// <summary>
        /// Formats the value of the current instance using the specified format.
        /// </summary>
        /// <param name="format">
        /// The format to use.-or- A null reference (Nothing in Visual Basic) to use the default format
        /// defined for the type of the <see cref="IFormattable" /> implementation.
        /// </param>
        /// <param name="formatProvider">
        /// The provider to use to format the value.-or- A null reference (Nothing in Visual Basic) to
        /// obtain the numeric format information from the current locale setting of the operating system.
        /// </param>
        /// <returns>
        /// The value of the current instance in the specified format.
        /// </returns>
        string ToString(string format, System.IFormatProvider formatProvider);
    }
    /// <summary>
    /// The exception that is thrown when an attempt is made to access an element of an array or collection
    /// with an index that is outside its bounds.
    /// </summary>
    public sealed partial class IndexOutOfRangeException : System.Exception
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="IndexOutOfRangeException" /> class.
        /// </summary>
        public IndexOutOfRangeException() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="IndexOutOfRangeException" /> class with
        /// a specified error message.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        public IndexOutOfRangeException(string message) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="IndexOutOfRangeException" /> class with
        /// a specified error message and a reference to the inner exception that is the cause of this
        /// exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="innerException">
        /// The exception that is the cause of the current exception. If the <paramref name="innerException" />
        /// parameter is not a null reference (Nothing in Visual Basic), the current exception is raised
        /// in a catch block that handles the inner exception.
        /// </param>
        public IndexOutOfRangeException(string message, System.Exception innerException) { }
    }
    /// <summary>
    /// The exception that is thrown when there is insufficient execution stack available to allow
    /// most methods to execute.
    /// </summary>
    public sealed partial class InsufficientExecutionStackException : System.Exception
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="InsufficientExecutionStackException" />
        /// class.
        /// </summary>
        public InsufficientExecutionStackException() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="InsufficientExecutionStackException" />
        /// class with a specified error message.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        public InsufficientExecutionStackException(string message) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="InsufficientExecutionStackException" />
        /// class with a specified error message and a reference to the inner exception that is the
        /// cause of this exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="innerException">
        /// The exception that is the cause of the current exception. If the <paramref name="inner" />
        /// parameter is not null, the current exception is raised in a catch block that handles the inner
        /// exception.
        /// </param>
        public InsufficientExecutionStackException(string message, System.Exception innerException) { }
    }
    /// <summary>
    /// Represents a 16-bit signed integer.
    /// </summary>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct Int16 : System.IComparable, System.IComparable<short>, System.IConvertible, System.IEquatable<short>, System.IFormattable
    {
        /// <summary>
        /// Represents the largest possible value of an <see cref="Int16" />. This field is constant.
        /// </summary>
        public const short MaxValue = (short)32767;
        /// <summary>
        /// Represents the smallest possible value of <see cref="Int16" />. This field is constant.
        /// </summary>
        public const short MinValue = (short)-32768;
        /// <summary>
        /// Compares this instance to a specified 16-bit signed integer and returns an integer that indicates
        /// whether the value of this instance is less than, equal to, or greater than the value of the specified
        /// 16-bit signed integer.
        /// </summary>
        /// <param name="value">An integer to compare.</param>
        /// <returns>
        /// A signed number indicating the relative values of this instance and <paramref name="value" />.
        /// Return Value Description Less than zero This instance is less than <paramref name="value" />.
        /// Zero This instance is equal to <paramref name="value" />. Greater than zero This instance
        /// is greater than <paramref name="value" />.
        /// </returns>
        public int CompareTo(short value) { return default(int); }
        /// <summary>
        /// Returns a value indicating whether this instance is equal to a specified <see cref="Int16" />
        /// value.
        /// </summary>
        /// <param name="obj">An <see cref="Int16" /> value to compare to this instance.</param>
        /// <returns>
        /// true if <paramref name="obj" /> has the same value as this instance; otherwise, false.
        /// </returns>
        public bool Equals(short obj) { return default(bool); }
        /// <summary>
        /// Returns a value indicating whether this instance is equal to a specified object.
        /// </summary>
        /// <param name="obj">An object to compare to this instance.</param>
        /// <returns>
        /// true if <paramref name="obj" /> is an instance of <see cref="Int16" /> and equals
        /// the value of this instance; otherwise, false.
        /// </returns>
        public override bool Equals(object obj) { return default(bool); }
        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code.
        /// </returns>
        public override int GetHashCode() { return default(int); }
        /// <summary>
        /// Converts the string representation of a number to its 16-bit signed integer equivalent.
        /// </summary>
        /// <param name="s">A string containing a number to convert.</param>
        /// <returns>
        /// A 16-bit signed integer equivalent to the number contained in <paramref name="s" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="FormatException"><paramref name="s" /> is not in the correct format.</exception>
        /// <exception cref="OverflowException">
        /// <paramref name="s" /> represents a number less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />.
        /// </exception>
        public static short Parse(string s) { return default(short); }
        /// <summary>
        /// Converts the string representation of a number in a specified style to its 16-bit signed integer
        /// equivalent.
        /// </summary>
        /// <param name="s">A string containing a number to convert.</param>
        /// <param name="style">
        /// A bitwise combination of the enumeration values that indicates the style elements that can
        /// be present in <paramref name="s" />. A typical value to specify is
        /// <see cref="Globalization.NumberStyles.Integer" />.
        /// </param>
        /// <returns>
        /// A 16-bit signed integer equivalent to the number specified in <paramref name="s" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="style" /> is not a <see cref="Globalization.NumberStyles" /> value.
        /// -or-<paramref name="style" /> is not a combination of
        /// <see cref="Globalization.NumberStyles.AllowHexSpecifier" /> and <see cref="Globalization.NumberStyles.HexNumber" /> values.
        /// </exception>
        /// <exception cref="FormatException">
        /// <paramref name="s" /> is not in a format compliant with <paramref name="style" />.
        /// </exception>
        /// <exception cref="OverflowException">
        /// <paramref name="s" /> represents a number less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />. -or-<paramref name="s" /> includes
        /// non-zero fractional digits.
        /// </exception>
        public static short Parse(string s, System.Globalization.NumberStyles style) { return default(short); }
        /// <summary>
        /// Converts the string representation of a number in a specified style and culture-specific format
        /// to its 16-bit signed integer equivalent.
        /// </summary>
        /// <param name="s">A string containing a number to convert.</param>
        /// <param name="style">
        /// A bitwise combination of enumeration values that indicates the style elements that can be
        /// present in <paramref name="s" />. A typical value to specify is
        /// <see cref="Globalization.NumberStyles.Integer" />.
        /// </param>
        /// <param name="provider">
        /// An <see cref="IFormatProvider" /> that supplies culture-specific formatting information
        /// about <paramref name="s" />.
        /// </param>
        /// <returns>
        /// A 16-bit signed integer equivalent to the number specified in <paramref name="s" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="style" /> is not a <see cref="Globalization.NumberStyles" /> value.
        /// -or-<paramref name="style" /> is not a combination of
        /// <see cref="Globalization.NumberStyles.AllowHexSpecifier" /> and <see cref="Globalization.NumberStyles.HexNumber" /> values.
        /// </exception>
        /// <exception cref="FormatException">
        /// <paramref name="s" /> is not in a format compliant with <paramref name="style" />.
        /// </exception>
        /// <exception cref="OverflowException">
        /// <paramref name="s" /> represents a number less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />. -or-<paramref name="s" /> includes
        /// non-zero fractional digits.
        /// </exception>
        public static short Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider) { return default(short); }
        /// <summary>
        /// Converts the string representation of a number in a specified culture-specific format to its
        /// 16-bit signed integer equivalent.
        /// </summary>
        /// <param name="s">A string containing a number to convert.</param>
        /// <param name="provider">
        /// An <see cref="IFormatProvider" /> that supplies culture-specific formatting information
        /// about <paramref name="s" />.
        /// </param>
        /// <returns>
        /// A 16-bit signed integer equivalent to the number specified in <paramref name="s" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="FormatException"><paramref name="s" /> is not in the correct format.</exception>
        /// <exception cref="OverflowException">
        /// <paramref name="s" /> represents a number less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />.
        /// </exception>
        public static short Parse(string s, System.IFormatProvider provider) { return default(short); }
        int System.IComparable.CompareTo(object value) { return default(int); }
        System.TypeCode System.IConvertible.GetTypeCode() { return default(System.TypeCode); }
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) { return default(bool); }
        byte System.IConvertible.ToByte(System.IFormatProvider provider) { return default(byte); }
        char System.IConvertible.ToChar(System.IFormatProvider provider) { return default(char); }
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) { return default(System.DateTime); }
        decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) { return default(decimal); }
        double System.IConvertible.ToDouble(System.IFormatProvider provider) { return default(double); }
        short System.IConvertible.ToInt16(System.IFormatProvider provider) { return default(short); }
        int System.IConvertible.ToInt32(System.IFormatProvider provider) { return default(int); }
        long System.IConvertible.ToInt64(System.IFormatProvider provider) { return default(long); }
        sbyte System.IConvertible.ToSByte(System.IFormatProvider provider) { return default(sbyte); }
        float System.IConvertible.ToSingle(System.IFormatProvider provider) { return default(float); }
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) { return default(object); }
        ushort System.IConvertible.ToUInt16(System.IFormatProvider provider) { return default(ushort); }
        uint System.IConvertible.ToUInt32(System.IFormatProvider provider) { return default(uint); }
        ulong System.IConvertible.ToUInt64(System.IFormatProvider provider) { return default(ulong); }
        /// <summary>
        /// Converts the numeric value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// The string representation of the value of this instance, consisting of a minus sign if the
        /// value is negative, and a sequence of digits ranging from 0 to 9 with no leading zeroes.
        /// </returns>
        public override string ToString() { return default(string); }
        /// <summary>
        /// Converts the numeric value of this instance to its equivalent string representation using the
        /// specified culture-specific format information.
        /// </summary>
        /// <param name="provider">
        /// An <see cref="IFormatProvider" /> that supplies culture-specific formatting information.
        /// </param>
        /// <returns>
        /// The string representation of the value of this instance as specified by <paramref name="provider" />.
        /// </returns>
        public string ToString(System.IFormatProvider provider) { return default(string); }
        /// <summary>
        /// Converts the numeric value of this instance to its equivalent string representation, using
        /// the specified format.
        /// </summary>
        /// <param name="format">A numeric format string.</param>
        /// <returns>
        /// The string representation of the value of this instance as specified by <paramref name="format" />.
        /// </returns>
        public string ToString(string format) { return default(string); }
        /// <summary>
        /// Converts the numeric value of this instance to its equivalent string representation using the
        /// specified format and culture-specific formatting information.
        /// </summary>
        /// <param name="format">A numeric format string.</param>
        /// <param name="provider">An object that supplies culture-specific formatting information.</param>
        /// <returns>
        /// The string representation of the value of this instance as specified by <paramref name="format" />
        /// and <paramref name="provider" />.
        /// </returns>
        public string ToString(string format, System.IFormatProvider provider) { return default(string); }
        /// <summary>
        /// Converts the string representation of a number in a specified style and culture-specific format
        /// to its 16-bit signed integer equivalent. A return value indicates whether the conversion succeeded
        /// or failed.
        /// </summary>
        /// <param name="s">
        /// A string containing a number to convert. The string is interpreted using the style specified
        /// by <paramref name="style" />.
        /// </param>
        /// <param name="style">
        /// A bitwise combination of enumeration values that indicates the style elements that can be
        /// present in <paramref name="s" />. A typical value to specify is
        /// <see cref="Globalization.NumberStyles.Integer" />.
        /// </param>
        /// <param name="provider">
        /// An object that supplies culture-specific formatting information about <paramref name="s" />.
        /// </param>
        /// <param name="result">
        /// When this method returns, contains the 16-bit signed integer value equivalent to the number
        /// contained in <paramref name="s" />, if the conversion succeeded, or zero if the conversion
        /// failed. The conversion fails if the <paramref name="s" /> parameter is null  or <see cref="String.Empty" />,
        /// is not in a format compliant with <paramref name="style" />, or represents a number less
        /// than <see cref="MinValue" /> or greater than <see cref="MaxValue" />.
        /// This parameter is passed uninitialized; any value originally supplied in <paramref name="result" />
        /// will be overwritten.
        /// </param>
        /// <returns>
        /// true if <paramref name="s" /> was converted successfully; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// <paramref name="style" /> is not a <see cref="Globalization.NumberStyles" /> value.
        /// -or-<paramref name="style" /> is not a combination of
        /// <see cref="Globalization.NumberStyles.AllowHexSpecifier" /> and <see cref="Globalization.NumberStyles.HexNumber" /> values.
        /// </exception>
        public static bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out short result) { result = default(short); return default(bool); }
        /// <summary>
        /// Converts the string representation of a number to its 16-bit signed integer equivalent. A return
        /// value indicates whether the conversion succeeded or failed.
        /// </summary>
        /// <param name="s">A string containing a number to convert.</param>
        /// <param name="result">
        /// When this method returns, contains the 16-bit signed integer value equivalent to the number
        /// contained in <paramref name="s" />, if the conversion succeeded, or zero if the conversion
        /// failed. The conversion fails if the <paramref name="s" /> parameter is null  or <see cref="String.Empty" />,
        /// is not of the correct format, or represents a number less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />. This parameter is passed uninitialized;
        /// any value originally supplied in <paramref name="result" /> will be overwritten.
        /// </param>
        /// <returns>
        /// true if <paramref name="s" /> was converted successfully; otherwise, false.
        /// </returns>
        public static bool TryParse(string s, out short result) { result = default(short); return default(bool); }
    }
    /// <summary>
    /// Represents a 32-bit signed integer.To browse the .NET Framework source code for this type,
    /// see the Reference Source.
    /// </summary>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct Int32 : System.IComparable, System.IComparable<int>, System.IConvertible, System.IEquatable<int>, System.IFormattable
    {
        /// <summary>
        /// Represents the largest possible value of an <see cref="Int32" />. This field is constant.
        /// </summary>
        public const int MaxValue = 2147483647;
        /// <summary>
        /// Represents the smallest possible value of <see cref="Int32" />. This field is constant.
        /// </summary>
        public const int MinValue = -2147483648;
        /// <summary>
        /// Compares this instance to a specified 32-bit signed integer and returns an indication of their
        /// relative values.
        /// </summary>
        /// <param name="value">An integer to compare.</param>
        /// <returns>
        /// A signed number indicating the relative values of this instance and <paramref name="value" />.
        /// Return Value Description Less than zero This instance is less than <paramref name="value" />.
        /// Zero This instance is equal to <paramref name="value" />. Greater than zero This instance
        /// is greater than <paramref name="value" />.
        /// </returns>
        public int CompareTo(int value) { return default(int); }
        /// <summary>
        /// Returns a value indicating whether this instance is equal to a specified <see cref="Int32" />
        /// value.
        /// </summary>
        /// <param name="obj">An <see cref="Int32" /> value to compare to this instance.</param>
        /// <returns>
        /// true if <paramref name="obj" /> has the same value as this instance; otherwise, false.
        /// </returns>
        public bool Equals(int obj) { return default(bool); }
        /// <summary>
        /// Returns a value indicating whether this instance is equal to a specified object.
        /// </summary>
        /// <param name="obj">An object to compare with this instance.</param>
        /// <returns>
        /// true if <paramref name="obj" /> is an instance of <see cref="Int32" /> and equals
        /// the value of this instance; otherwise, false.
        /// </returns>
        public override bool Equals(object obj) { return default(bool); }
        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code.
        /// </returns>
        public override int GetHashCode() { return default(int); }
        /// <summary>
        /// Converts the string representation of a number to its 32-bit signed integer equivalent.
        /// </summary>
        /// <param name="s">A string containing a number to convert.</param>
        /// <returns>
        /// A 32-bit signed integer equivalent to the number contained in <paramref name="s" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="FormatException"><paramref name="s" /> is not in the correct format.</exception>
        /// <exception cref="OverflowException">
        /// <paramref name="s" /> represents a number less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />.
        /// </exception>
        public static int Parse(string s) { return default(int); }
        /// <summary>
        /// Converts the string representation of a number in a specified style to its 32-bit signed integer
        /// equivalent.
        /// </summary>
        /// <param name="s">A string containing a number to convert.</param>
        /// <param name="style">
        /// A bitwise combination of the enumeration values that indicates the style elements that can
        /// be present in <paramref name="s" />. A typical value to specify is
        /// <see cref="Globalization.NumberStyles.Integer" />.
        /// </param>
        /// <returns>
        /// A 32-bit signed integer equivalent to the number specified in <paramref name="s" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="style" /> is not a <see cref="Globalization.NumberStyles" /> value.
        /// -or-<paramref name="style" /> is not a combination of
        /// <see cref="Globalization.NumberStyles.AllowHexSpecifier" /> and <see cref="Globalization.NumberStyles.HexNumber" /> values.
        /// </exception>
        /// <exception cref="FormatException">
        /// <paramref name="s" /> is not in a format compliant with <paramref name="style" />.
        /// </exception>
        /// <exception cref="OverflowException">
        /// <paramref name="s" /> represents a number less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />. -or-<paramref name="s" /> includes
        /// non-zero, fractional digits.
        /// </exception>
        public static int Parse(string s, System.Globalization.NumberStyles style) { return default(int); }
        /// <summary>
        /// Converts the string representation of a number in a specified style and culture-specific format
        /// to its 32-bit signed integer equivalent.
        /// </summary>
        /// <param name="s">A string containing a number to convert.</param>
        /// <param name="style">
        /// A bitwise combination of enumeration values that indicates the style elements that can be
        /// present in <paramref name="s" />. A typical value to specify is
        /// <see cref="Globalization.NumberStyles.Integer" />.
        /// </param>
        /// <param name="provider">
        /// An object that supplies culture-specific information about the format of <paramref name="s" />.
        /// </param>
        /// <returns>
        /// A 32-bit signed integer equivalent to the number specified in <paramref name="s" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="style" /> is not a <see cref="Globalization.NumberStyles" /> value.
        /// -or-<paramref name="style" /> is not a combination of
        /// <see cref="Globalization.NumberStyles.AllowHexSpecifier" /> and <see cref="Globalization.NumberStyles.HexNumber" /> values.
        /// </exception>
        /// <exception cref="FormatException">
        /// <paramref name="s" /> is not in a format compliant with <paramref name="style" />.
        /// </exception>
        /// <exception cref="OverflowException">
        /// <paramref name="s" /> represents a number less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />. -or-<paramref name="s" /> includes
        /// non-zero, fractional digits.
        /// </exception>
        public static int Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider) { return default(int); }
        /// <summary>
        /// Converts the string representation of a number in a specified culture-specific format to its
        /// 32-bit signed integer equivalent.
        /// </summary>
        /// <param name="s">A string containing a number to convert.</param>
        /// <param name="provider">
        /// An object that supplies culture-specific formatting information about <paramref name="s" />.
        /// </param>
        /// <returns>
        /// A 32-bit signed integer equivalent to the number specified in <paramref name="s" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="FormatException"><paramref name="s" /> is not of the correct format.</exception>
        /// <exception cref="OverflowException">
        /// <paramref name="s" /> represents a number less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />.
        /// </exception>
        public static int Parse(string s, System.IFormatProvider provider) { return default(int); }
        int System.IComparable.CompareTo(object value) { return default(int); }
        System.TypeCode System.IConvertible.GetTypeCode() { return default(System.TypeCode); }
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) { return default(bool); }
        byte System.IConvertible.ToByte(System.IFormatProvider provider) { return default(byte); }
        char System.IConvertible.ToChar(System.IFormatProvider provider) { return default(char); }
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) { return default(System.DateTime); }
        decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) { return default(decimal); }
        double System.IConvertible.ToDouble(System.IFormatProvider provider) { return default(double); }
        short System.IConvertible.ToInt16(System.IFormatProvider provider) { return default(short); }
        int System.IConvertible.ToInt32(System.IFormatProvider provider) { return default(int); }
        long System.IConvertible.ToInt64(System.IFormatProvider provider) { return default(long); }
        sbyte System.IConvertible.ToSByte(System.IFormatProvider provider) { return default(sbyte); }
        float System.IConvertible.ToSingle(System.IFormatProvider provider) { return default(float); }
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) { return default(object); }
        ushort System.IConvertible.ToUInt16(System.IFormatProvider provider) { return default(ushort); }
        uint System.IConvertible.ToUInt32(System.IFormatProvider provider) { return default(uint); }
        ulong System.IConvertible.ToUInt64(System.IFormatProvider provider) { return default(ulong); }
        /// <summary>
        /// Converts the numeric value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// The string representation of the value of this instance, consisting of a negative sign if the
        /// value is negative, and a sequence of digits ranging from 0 to 9 with no leading zeroes.
        /// </returns>
        public override string ToString() { return default(string); }
        /// <summary>
        /// Converts the numeric value of this instance to its equivalent string representation using the
        /// specified culture-specific format information.
        /// </summary>
        /// <param name="provider">An object that supplies culture-specific formatting information.</param>
        /// <returns>
        /// The string representation of the value of this instance as specified by <paramref name="provider" />.
        /// </returns>
        public string ToString(System.IFormatProvider provider) { return default(string); }
        /// <summary>
        /// Converts the numeric value of this instance to its equivalent string representation, using
        /// the specified format.
        /// </summary>
        /// <param name="format">A standard or custom numeric format string.</param>
        /// <returns>
        /// The string representation of the value of this instance as specified by <paramref name="format" />.
        /// </returns>
        /// <exception cref="FormatException">
        /// <paramref name="format" /> is invalid or not supported.
        /// </exception>
        public string ToString(string format) { return default(string); }
        /// <summary>
        /// Converts the numeric value of this instance to its equivalent string representation using the
        /// specified format and culture-specific format information.
        /// </summary>
        /// <param name="format">A standard or custom numeric format string.</param>
        /// <param name="provider">An object that supplies culture-specific formatting information.</param>
        /// <returns>
        /// The string representation of the value of this instance as specified by <paramref name="format" />
        /// and <paramref name="provider" />.
        /// </returns>
        /// <exception cref="FormatException">
        /// <paramref name="format" /> is invalid or not supported.
        /// </exception>
        public string ToString(string format, System.IFormatProvider provider) { return default(string); }
        /// <summary>
        /// Converts the string representation of a number in a specified style and culture-specific format
        /// to its 32-bit signed integer equivalent. A return value indicates whether the conversion succeeded.
        /// </summary>
        /// <param name="s">
        /// A string containing a number to convert. The string is interpreted using the style specified
        /// by <paramref name="style" />.
        /// </param>
        /// <param name="style">
        /// A bitwise combination of enumeration values that indicates the style elements that can be
        /// present in <paramref name="s" />. A typical value to specify is
        /// <see cref="Globalization.NumberStyles.Integer" />.
        /// </param>
        /// <param name="provider">
        /// An object that supplies culture-specific formatting information about <paramref name="s" />.
        /// </param>
        /// <param name="result">
        /// When this method returns, contains the 32-bit signed integer value equivalent of the number
        /// contained in <paramref name="s" />, if the conversion succeeded, or zero if the conversion
        /// failed. The conversion fails if the <paramref name="s" /> parameter is null  or <see cref="String.Empty" />,
        /// is not in a format compliant with <paramref name="style" />, or represents a number less
        /// than <see cref="MinValue" /> or greater than <see cref="MaxValue" />.
        /// This parameter is passed uninitialized; any value originally supplied in <paramref name="result" />
        /// will be overwritten.
        /// </param>
        /// <returns>
        /// true if <paramref name="s" /> was converted successfully; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// <paramref name="style" /> is not a <see cref="Globalization.NumberStyles" /> value.
        /// -or-<paramref name="style" /> is not a combination of
        /// <see cref="Globalization.NumberStyles.AllowHexSpecifier" /> and <see cref="Globalization.NumberStyles.HexNumber" /> values.
        /// </exception>
        public static bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out int result) { result = default(int); return default(bool); }
        /// <summary>
        /// Converts the string representation of a number to its 32-bit signed integer equivalent. A return
        /// value indicates whether the conversion succeeded.
        /// </summary>
        /// <param name="s">A string containing a number to convert.</param>
        /// <param name="result">
        /// When this method returns, contains the 32-bit signed integer value equivalent of the number
        /// contained in <paramref name="s" />, if the conversion succeeded, or zero if the conversion
        /// failed. The conversion fails if the <paramref name="s" /> parameter is null  or <see cref="String.Empty" />,
        /// is not of the correct format, or represents a number less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />. This parameter is passed uninitialized;
        /// any value originally supplied in <paramref name="result" /> will be overwritten.
        /// </param>
        /// <returns>
        /// true if <paramref name="s" /> was converted successfully; otherwise, false.
        /// </returns>
        public static bool TryParse(string s, out int result) { result = default(int); return default(bool); }
    }
    /// <summary>
    /// Represents a 64-bit signed integer.
    /// </summary>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct Int64 : System.IComparable, System.IComparable<long>, System.IConvertible, System.IEquatable<long>, System.IFormattable
    {
        /// <summary>
        /// Represents the largest possible value of an Int64. This field is constant.
        /// </summary>
        public const long MaxValue = (long)9223372036854775807;
        /// <summary>
        /// Represents the smallest possible value of an Int64. This field is constant.
        /// </summary>
        public const long MinValue = (long)-9223372036854775808;
        /// <summary>
        /// Compares this instance to a specified 64-bit signed integer and returns an indication of their
        /// relative values.
        /// </summary>
        /// <param name="value">An integer to compare.</param>
        /// <returns>
        /// A signed number indicating the relative values of this instance and <paramref name="value" />.
        /// Return Value Description Less than zero This instance is less than <paramref name="value" />.
        /// Zero This instance is equal to <paramref name="value" />. Greater than zero This instance
        /// is greater than <paramref name="value" />.
        /// </returns>
        public int CompareTo(long value) { return default(int); }
        /// <summary>
        /// Returns a value indicating whether this instance is equal to a specified <see cref="Int64" />
        /// value.
        /// </summary>
        /// <param name="obj">An <see cref="Int64" /> value to compare to this instance.</param>
        /// <returns>
        /// true if <paramref name="obj" /> has the same value as this instance; otherwise, false.
        /// </returns>
        public bool Equals(long obj) { return default(bool); }
        /// <summary>
        /// Returns a value indicating whether this instance is equal to a specified object.
        /// </summary>
        /// <param name="obj">An object to compare with this instance.</param>
        /// <returns>
        /// true if <paramref name="obj" /> is an instance of an <see cref="Int64" /> and equals
        /// the value of this instance; otherwise, false.
        /// </returns>
        public override bool Equals(object obj) { return default(bool); }
        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code.
        /// </returns>
        public override int GetHashCode() { return default(int); }
        /// <summary>
        /// Converts the string representation of a number to its 64-bit signed integer equivalent.
        /// </summary>
        /// <param name="s">A string containing a number to convert.</param>
        /// <returns>
        /// A 64-bit signed integer equivalent to the number contained in <paramref name="s" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="FormatException"><paramref name="s" /> is not in the correct format.</exception>
        /// <exception cref="OverflowException">
        /// <paramref name="s" /> represents a number less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />.
        /// </exception>
        public static long Parse(string s) { return default(long); }
        /// <summary>
        /// Converts the string representation of a number in a specified style to its 64-bit signed integer
        /// equivalent.
        /// </summary>
        /// <param name="s">A string containing a number to convert.</param>
        /// <param name="style">
        /// A bitwise combination of <see cref="Globalization.NumberStyles" /> values that indicates
        /// the permitted format of <paramref name="s" />. A typical value to specify is
        /// <see cref="Globalization.NumberStyles.Integer" />.
        /// </param>
        /// <returns>
        /// A 64-bit signed integer equivalent to the number specified in <paramref name="s" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="style" /> is not a <see cref="Globalization.NumberStyles" /> value.
        /// -or-<paramref name="style" /> is not a combination of
        /// <see cref="Globalization.NumberStyles.AllowHexSpecifier" /> and <see cref="Globalization.NumberStyles.HexNumber" /> values.
        /// </exception>
        /// <exception cref="FormatException">
        /// <paramref name="s" /> is not in a format compliant with <paramref name="style" />.
        /// </exception>
        /// <exception cref="OverflowException">
        /// <paramref name="s" /> represents a number less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />.-or-<paramref name="style" /> supports
        /// fractional digits but <paramref name="s" /> includes non-zero fractional digits.
        /// </exception>
        public static long Parse(string s, System.Globalization.NumberStyles style) { return default(long); }
        /// <summary>
        /// Converts the string representation of a number in a specified style and culture-specific format
        /// to its 64-bit signed integer equivalent.
        /// </summary>
        /// <param name="s">A string containing a number to convert.</param>
        /// <param name="style">
        /// A bitwise combination of enumeration values that indicates the style elements that can be
        /// present in <paramref name="s" />. A typical value to specify is
        /// <see cref="Globalization.NumberStyles.Integer" />.
        /// </param>
        /// <param name="provider">
        /// An <see cref="IFormatProvider" /> that supplies culture-specific formatting information
        /// about <paramref name="s" />.
        /// </param>
        /// <returns>
        /// A 64-bit signed integer equivalent to the number specified in <paramref name="s" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="style" /> is not a <see cref="Globalization.NumberStyles" /> value.
        /// -or-<paramref name="style" /> is not a combination of
        /// <see cref="Globalization.NumberStyles.AllowHexSpecifier" /> and <see cref="Globalization.NumberStyles.HexNumber" /> values.
        /// </exception>
        /// <exception cref="FormatException">
        /// <paramref name="s" /> is not in a format compliant with <paramref name="style" />.
        /// </exception>
        /// <exception cref="OverflowException">
        /// <paramref name="s" /> represents a number less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />. -or-<paramref name="style" /> supports
        /// fractional digits, but <paramref name="s" /> includes non-zero fractional digits.
        /// </exception>
        public static long Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider) { return default(long); }
        /// <summary>
        /// Converts the string representation of a number in a specified culture-specific format to its
        /// 64-bit signed integer equivalent.
        /// </summary>
        /// <param name="s">A string containing a number to convert.</param>
        /// <param name="provider">
        /// An object that supplies culture-specific formatting information about <paramref name="s" />.
        /// </param>
        /// <returns>
        /// A 64-bit signed integer equivalent to the number specified in <paramref name="s" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="FormatException"><paramref name="s" /> is not in the correct format.</exception>
        /// <exception cref="OverflowException">
        /// <paramref name="s" /> represents a number less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />.
        /// </exception>
        public static long Parse(string s, System.IFormatProvider provider) { return default(long); }
        int System.IComparable.CompareTo(object value) { return default(int); }
        System.TypeCode System.IConvertible.GetTypeCode() { return default(System.TypeCode); }
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) { return default(bool); }
        byte System.IConvertible.ToByte(System.IFormatProvider provider) { return default(byte); }
        char System.IConvertible.ToChar(System.IFormatProvider provider) { return default(char); }
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) { return default(System.DateTime); }
        decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) { return default(decimal); }
        double System.IConvertible.ToDouble(System.IFormatProvider provider) { return default(double); }
        short System.IConvertible.ToInt16(System.IFormatProvider provider) { return default(short); }
        int System.IConvertible.ToInt32(System.IFormatProvider provider) { return default(int); }
        long System.IConvertible.ToInt64(System.IFormatProvider provider) { return default(long); }
        sbyte System.IConvertible.ToSByte(System.IFormatProvider provider) { return default(sbyte); }
        float System.IConvertible.ToSingle(System.IFormatProvider provider) { return default(float); }
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) { return default(object); }
        ushort System.IConvertible.ToUInt16(System.IFormatProvider provider) { return default(ushort); }
        uint System.IConvertible.ToUInt32(System.IFormatProvider provider) { return default(uint); }
        ulong System.IConvertible.ToUInt64(System.IFormatProvider provider) { return default(ulong); }
        /// <summary>
        /// Converts the numeric value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// The string representation of the value of this instance, consisting of a minus sign if the
        /// value is negative, and a sequence of digits ranging from 0 to 9 with no leading zeroes.
        /// </returns>
        public override string ToString() { return default(string); }
        /// <summary>
        /// Converts the numeric value of this instance to its equivalent string representation using the
        /// specified culture-specific format information.
        /// </summary>
        /// <param name="provider">
        /// An <see cref="IFormatProvider" /> that supplies culture-specific formatting information.
        /// </param>
        /// <returns>
        /// The string representation of the value of this instance as specified by <paramref name="provider" />.
        /// </returns>
        public string ToString(System.IFormatProvider provider) { return default(string); }
        /// <summary>
        /// Converts the numeric value of this instance to its equivalent string representation, using
        /// the specified format.
        /// </summary>
        /// <param name="format">A numeric format string.</param>
        /// <returns>
        /// The string representation of the value of this instance as specified by <paramref name="format" />.
        /// </returns>
        /// <exception cref="FormatException">
        /// <paramref name="format" /> is invalid or not supported.
        /// </exception>
        public string ToString(string format) { return default(string); }
        /// <summary>
        /// Converts the numeric value of this instance to its equivalent string representation using the
        /// specified format and culture-specific format information.
        /// </summary>
        /// <param name="format">A numeric format string.</param>
        /// <param name="provider">An object that supplies culture-specific formatting information about this instance.</param>
        /// <returns>
        /// The string representation of the value of this instance as specified by <paramref name="format" />
        /// and <paramref name="provider" />.
        /// </returns>
        /// <exception cref="FormatException">
        /// <paramref name="format" /> is invalid or not supported.
        /// </exception>
        public string ToString(string format, System.IFormatProvider provider) { return default(string); }
        /// <summary>
        /// Converts the string representation of a number in a specified style and culture-specific format
        /// to its 64-bit signed integer equivalent. A return value indicates whether the conversion succeeded
        /// or failed.
        /// </summary>
        /// <param name="s">
        /// A string containing a number to convert. The string is interpreted using the style specified
        /// by <paramref name="style" />.
        /// </param>
        /// <param name="style">
        /// A bitwise combination of enumeration values that indicates the style elements that can be
        /// present in <paramref name="s" />. A typical value to specify is
        /// <see cref="Globalization.NumberStyles.Integer" />.
        /// </param>
        /// <param name="provider">
        /// An object that supplies culture-specific formatting information about <paramref name="s" />.
        /// </param>
        /// <param name="result">
        /// When this method returns, contains the 64-bit signed integer value equivalent of the number
        /// contained in <paramref name="s" />, if the conversion succeeded, or zero if the conversion
        /// failed. The conversion fails if the <paramref name="s" /> parameter is null  or <see cref="String.Empty" />,
        /// is not in a format compliant with <paramref name="style" />, or represents a number less
        /// than <see cref="MinValue" /> or greater than <see cref="MaxValue" />.
        /// This parameter is passed uninitialized; any value originally supplied in <paramref name="result" />
        /// will be overwritten.
        /// </param>
        /// <returns>
        /// true if <paramref name="s" /> was converted successfully; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// <paramref name="style" /> is not a <see cref="Globalization.NumberStyles" /> value.
        /// -or-<paramref name="style" /> is not a combination of
        /// <see cref="Globalization.NumberStyles.AllowHexSpecifier" /> and <see cref="Globalization.NumberStyles.HexNumber" /> values.
        /// </exception>
        public static bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out long result) { result = default(long); return default(bool); }
        /// <summary>
        /// Converts the string representation of a number to its 64-bit signed integer equivalent. A return
        /// value indicates whether the conversion succeeded or failed.
        /// </summary>
        /// <param name="s">A string containing a number to convert.</param>
        /// <param name="result">
        /// When this method returns, contains the 64-bit signed integer value equivalent of the number
        /// contained in <paramref name="s" />, if the conversion succeeded, or zero if the conversion
        /// failed. The conversion fails if the <paramref name="s" /> parameter is null  or <see cref="String.Empty" />,
        /// is not of the correct format, or represents a number less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />. This parameter is passed uninitialized;
        /// any value originally supplied in <paramref name="result" /> will be overwritten.
        /// </param>
        /// <returns>
        /// true if <paramref name="s" /> was converted successfully; otherwise, false.
        /// </returns>
        public static bool TryParse(string s, out long result) { result = default(long); return default(bool); }
    }
    /// <summary>
    /// A platform-specific type that is used to represent a pointer or a handle.
    /// </summary>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct IntPtr
    {
        /// <summary>
        /// A read-only field that represents a pointer or handle that has been initialized to zero.
        /// </summary>
        public static readonly System.IntPtr Zero;
        /// <summary>
        /// Initializes a new instance of <see cref="IntPtr" /> using the specified 32-bit pointer
        /// or handle.
        /// </summary>
        /// <param name="value">A pointer or handle contained in a 32-bit signed integer.</param>
        public IntPtr(int value) { throw new System.NotImplementedException(); }
        /// <summary>
        /// Initializes a new instance of <see cref="IntPtr" /> using the specified 64-bit pointer.
        /// </summary>
        /// <param name="value">A pointer or handle contained in a 64-bit signed integer.</param>
        /// <exception cref="OverflowException">
        /// On a 32-bit platform, <paramref name="value" /> is too large or too small to represent as
        /// an <see cref="IntPtr" />.
        /// </exception>
        public IntPtr(long value) { throw new System.NotImplementedException(); }
        /// <summary>
        /// Initializes a new instance of <see cref="IntPtr" /> using the specified pointer to
        /// an unspecified type.
        /// </summary>
        /// <param name="value">A pointer to an unspecified type.</param>
        [System.CLSCompliantAttribute(false)]
        [System.Security.SecurityCriticalAttribute]
        public unsafe IntPtr(void* value) { throw new System.NotImplementedException(); }
        /// <summary>
        /// Gets the size of this instance.
        /// </summary>
        /// <returns>
        /// The size of a pointer or handle in this process, measured in bytes. The value of this property
        /// is 4 in a 32-bit process, and 8 in a 64-bit process. You can define the process type by setting
        /// the /platform switch when you compile your code with the C# and Visual Basic compilers.
        /// </returns>
        public static int Size { get { return default(int); } }
        /// <summary>
        /// Adds an offset to the value of a pointer.
        /// </summary>
        /// <param name="pointer">The pointer to add the offset to.</param>
        /// <param name="offset">The offset to add.</param>
        /// <returns>
        /// A new pointer that reflects the addition of <paramref name="offset" /> to <paramref name="pointer" />.
        /// </returns>
        public static System.IntPtr Add(System.IntPtr pointer, int offset) { return default(System.IntPtr); }
        /// <summary>
        /// Returns a value indicating whether this instance is equal to a specified object.
        /// </summary>
        /// <param name="obj">An object to compare with this instance or null.</param>
        /// <returns>
        /// true if <paramref name="obj" /> is an instance of <see cref="IntPtr" /> and equals
        /// the value of this instance; otherwise, false.
        /// </returns>
        public override bool Equals(object obj) { return default(bool); }
        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code.
        /// </returns>
        public override int GetHashCode() { return default(int); }
        /// <summary>
        /// Adds an offset to the value of a pointer.
        /// </summary>
        /// <param name="pointer">The pointer to add the offset to.</param>
        /// <param name="offset">The offset to add.</param>
        /// <returns>
        /// A new pointer that reflects the addition of <paramref name="offset" /> to <paramref name="pointer" />.
        /// </returns>
        public static System.IntPtr operator +(System.IntPtr pointer, int offset) { return default(System.IntPtr); }
        /// <summary>
        /// Determines whether two specified instances of <see cref="IntPtr" /> are equal.
        /// </summary>
        /// <param name="value1">The first pointer or handle to compare.</param>
        /// <param name="value2">The second pointer or handle to compare.</param>
        /// <returns>
        /// true if <paramref name="value1" /> equals <paramref name="value2" />; otherwise, false.
        /// </returns>
        public static bool operator ==(System.IntPtr value1, System.IntPtr value2) { return default(bool); }
        /// <summary>
        /// Converts the value of a 32-bit signed integer to an <see cref="IntPtr" />.
        /// </summary>
        /// <param name="value">A 32-bit signed integer.</param>
        /// <returns>
        /// A new instance of <see cref="IntPtr" /> initialized to <paramref name="value" />.
        /// </returns>
        public static explicit operator System.IntPtr(int value) { return default(System.IntPtr); }
        /// <summary>
        /// Converts the value of a 64-bit signed integer to an <see cref="IntPtr" />.
        /// </summary>
        /// <param name="value">A 64-bit signed integer.</param>
        /// <returns>
        /// A new instance of <see cref="IntPtr" /> initialized to <paramref name="value" />.
        /// </returns>
        /// <exception cref="OverflowException">
        /// On a 32-bit platform, <paramref name="value" /> is too large to represent as an <see cref="IntPtr" />.
        /// </exception>
        public static explicit operator System.IntPtr(long value) { return default(System.IntPtr); }
        /// <summary>
        /// Converts the value of the specified <see cref="IntPtr" /> to a 32-bit signed integer.
        /// </summary>
        /// <param name="value">The pointer or handle to convert.</param>
        /// <returns>
        /// The contents of <paramref name="value" />.
        /// </returns>
        /// <exception cref="OverflowException">
        /// On a 64-bit platform, the value of <paramref name="value" /> is too large to represent as
        /// a 32-bit signed integer.
        /// </exception>
        public static explicit operator int(System.IntPtr value) { return default(int); }
        /// <summary>
        /// Converts the value of the specified <see cref="IntPtr" /> to a 64-bit signed integer.
        /// </summary>
        /// <param name="value">The pointer or handle to convert.</param>
        /// <returns>
        /// The contents of <paramref name="value" />.
        /// </returns>
        public static explicit operator long(System.IntPtr value) { return default(long); }
        /// <summary>
        /// Converts the value of the specified <see cref="IntPtr" /> to a pointer to an unspecified
        /// type.
        /// </summary>
        /// <param name="value">The pointer or handle to convert.</param>
        /// <returns>
        /// The contents of <paramref name="value" />.
        /// </returns>
        [System.CLSCompliantAttribute(false)]
        public unsafe static explicit operator void* (System.IntPtr value) { return default(void*); }
        /// <summary>
        /// Converts the specified pointer to an unspecified type to an <see cref="IntPtr" />.
        /// </summary>
        /// <param name="value">A pointer to an unspecified type.</param>
        /// <returns>
        /// A new instance of <see cref="IntPtr" /> initialized to <paramref name="value" />.
        /// </returns>
        [System.CLSCompliantAttribute(false)]
        [System.Security.SecurityCriticalAttribute]
        public unsafe static explicit operator System.IntPtr(void* value) { return default(System.IntPtr); }
        /// <summary>
        /// Determines whether two specified instances of <see cref="IntPtr" /> are not equal.
        /// </summary>
        /// <param name="value1">The first pointer or handle to compare.</param>
        /// <param name="value2">The second pointer or handle to compare.</param>
        /// <returns>
        /// true if <paramref name="value1" /> does not equal <paramref name="value2" />; otherwise, false.
        /// </returns>
        public static bool operator !=(System.IntPtr value1, System.IntPtr value2) { return default(bool); }
        /// <summary>
        /// Subtracts an offset from the value of a pointer.
        /// </summary>
        /// <param name="pointer">The pointer to subtract the offset from.</param>
        /// <param name="offset">The offset to subtract.</param>
        /// <returns>
        /// A new pointer that reflects the subtraction of <paramref name="offset" /> from <paramref name="pointer" />.
        /// </returns>
        public static System.IntPtr operator -(System.IntPtr pointer, int offset) { return default(System.IntPtr); }
        /// <summary>
        /// Subtracts an offset from the value of a pointer.
        /// </summary>
        /// <param name="pointer">The pointer to subtract the offset from.</param>
        /// <param name="offset">The offset to subtract.</param>
        /// <returns>
        /// A new pointer that reflects the subtraction of <paramref name="offset" /> from <paramref name="pointer" />.
        /// </returns>
        public static System.IntPtr Subtract(System.IntPtr pointer, int offset) { return default(System.IntPtr); }
        /// <summary>
        /// Converts the value of this instance to a 32-bit signed integer.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer equal to the value of this instance.
        /// </returns>
        /// <exception cref="OverflowException">
        /// On a 64-bit platform, the value of this instance is too large or too small to represent as
        /// a 32-bit signed integer.
        /// </exception>
        public int ToInt32() { return default(int); }
        /// <summary>
        /// Converts the value of this instance to a 64-bit signed integer.
        /// </summary>
        /// <returns>
        /// A 64-bit signed integer equal to the value of this instance.
        /// </returns>
        public long ToInt64() { return default(long); }
        /// <summary>
        /// Converts the value of this instance to a pointer to an unspecified type.
        /// </summary>
        /// <returns>
        /// A pointer to <see cref="Void" />; that is, a pointer to memory containing data of
        /// an unspecified type.
        /// </returns>
        [System.CLSCompliantAttribute(false)]
        public unsafe void* ToPointer() { return default(void*); }
        /// <summary>
        /// Converts the numeric value of the current <see cref="IntPtr" /> object to its equivalent
        /// string representation.
        /// </summary>
        /// <returns>
        /// The string representation of the value of this instance.
        /// </returns>
        public override string ToString() { return default(string); }
        /// <summary>
        /// Converts the numeric value of the current <see cref="IntPtr" /> object to its equivalent
        /// string representation.
        /// </summary>
        /// <param name="format">
        /// A format specification that governs how the current <see cref="IntPtr" /> object
        /// is converted.
        /// </param>
        /// <returns>
        /// The string representation of the value of the current <see cref="IntPtr" /> object.
        /// </returns>
        public string ToString(string format) { return default(string); }
    }
    /// <summary>
    /// The exception that is thrown for invalid casting or explicit conversion.
    /// </summary>
    public partial class InvalidCastException : System.Exception
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="InvalidCastException" /> class.
        /// </summary>
        public InvalidCastException() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="InvalidCastException" /> class with
        /// a specified error message.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        public InvalidCastException(string message) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="InvalidCastException" /> class with
        /// a specified error message and a reference to the inner exception that is the cause of this
        /// exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="innerException">
        /// The exception that is the cause of the current exception. If the <paramref name="innerException" />
        /// parameter is not null, the current exception is raised in a catch block that handles the
        /// inner exception.
        /// </param>
        public InvalidCastException(string message, System.Exception innerException) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="InvalidCastException" /> class with
        /// a specified message and error code.
        /// </summary>
        /// <param name="message">The message that indicates the reason the exception occurred.</param>
        /// <param name="errorCode">The error code (HRESULT) value associated with the exception.</param>
        public InvalidCastException(string message, int errorCode) { }
    }
    /// <summary>
    /// The exception that is thrown when a method call is invalid for the object's current state.
    /// </summary>
    public partial class InvalidOperationException : System.Exception
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="InvalidOperationException" /> class.
        /// </summary>
        public InvalidOperationException() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="InvalidOperationException" /> class
        /// with a specified error message.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        public InvalidOperationException(string message) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="InvalidOperationException" /> class
        /// with a specified error message and a reference to the inner exception that is the cause of
        /// this exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="innerException">
        /// The exception that is the cause of the current exception. If the <paramref name="innerException" />
        /// parameter is not a null reference (Nothing in Visual Basic), the current exception is raised
        /// in a catch block that handles the inner exception.
        /// </param>
        public InvalidOperationException(string message, System.Exception innerException) { }
    }
    /// <summary>
    /// The exception that is thrown when a program contains invalid Microsoft intermediate language
    /// (MSIL) or metadata. Generally this indicates a bug in the compiler that generated the program.
    /// </summary>
    public sealed partial class InvalidProgramException : System.Exception
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="InvalidProgramException" /> class with
        /// default properties.
        /// </summary>
        public InvalidProgramException() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="InvalidProgramException" /> class with
        /// a specified error message.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        public InvalidProgramException(string message) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="InvalidProgramException" /> class with
        /// a specified error message and a reference to the inner exception that is the cause of this
        /// exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="inner">
        /// The exception that is the cause of the current exception. If the <paramref name="inner" />
        /// parameter is not a null reference (Nothing in Visual Basic), the current exception is raised
        /// in a catch block that handles the inner exception.
        /// </param>
        public InvalidProgramException(string message, System.Exception inner) { }
    }
    /// <summary>
    /// The exception that is thrown when time zone information is invalid.
    /// </summary>
    public partial class InvalidTimeZoneException : System.Exception
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="InvalidTimeZoneException" /> class with
        /// a system-supplied message.
        /// </summary>
        public InvalidTimeZoneException() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="InvalidTimeZoneException" /> class with
        /// the specified message string.
        /// </summary>
        /// <param name="message">A string that describes the exception.</param>
        public InvalidTimeZoneException(string message) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="InvalidTimeZoneException" /> class with
        /// a specified error message and a reference to the inner exception that is the cause of this
        /// exception.
        /// </summary>
        /// <param name="message">A string that describes the exception.</param>
        /// <param name="innerException">The exception that is the cause of the current exception.</param>
        public InvalidTimeZoneException(string message, System.Exception innerException) { }
    }
    /// <summary>
    /// Defines a provider for push-based notification.
    /// </summary>
    /// <typeparam name="T">The object that provides notification information.</typeparam>
    public partial interface IObservable<out T>
    {
        /// <summary>
        /// Notifies the provider that an observer is to receive notifications.
        /// </summary>
        /// <param name="observer">The object that is to receive notifications.</param>
        /// <returns>
        /// A reference to an interface that allows observers to stop receiving notifications before the
        /// provider has finished sending them.
        /// </returns>
        System.IDisposable Subscribe(System.IObserver<T> observer);
    }
    /// <summary>
    /// Provides a mechanism for receiving push-based notifications.
    /// </summary>
    /// <typeparam name="T">The object that provides notification information.</typeparam>
    public partial interface IObserver<in T>
    {
        /// <summary>
        /// Notifies the observer that the provider has finished sending push-based notifications.
        /// </summary>
        void OnCompleted();
        /// <summary>
        /// Notifies the observer that the provider has experienced an error condition.
        /// </summary>
        /// <param name="error">An object that provides additional information about the error.</param>
        void OnError(System.Exception error);
        /// <summary>
        /// Provides the observer with new data.
        /// </summary>
        /// <param name="value">The current notification information.</param>
        void OnNext(T value);
    }
    /// <summary>
    /// Defines a provider for progress updates.
    /// </summary>
    /// <typeparam name="T">The type of progress update value.</typeparam>
    public partial interface IProgress<in T>
    {
        /// <summary>
        /// Reports a progress update.
        /// </summary>
        /// <param name="value">The value of the updated progress.</param>
        void Report(T value);
    }
    /// <summary>
    /// Provides support for lazy initialization.
    /// </summary>
    /// <typeparam name="T">The type of object that is being lazily initialized.</typeparam>
    public partial class Lazy<T>
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="System.Lazy`1" /> class. When lazy initialization
        /// occurs, the default constructor of the target type is used.
        /// </summary>
        public Lazy() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="System.Lazy`1" /> class. When lazy initialization
        /// occurs, the default constructor of the target type and the specified initialization mode are
        /// used.
        /// </summary>
        /// <param name="isThreadSafe">
        /// true to make this instance usable concurrently by multiple threads; false to make the instance
        /// usable by only one thread at a time.
        /// </param>
        public Lazy(bool isThreadSafe) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="System.Lazy`1" /> class. When lazy initialization
        /// occurs, the specified initialization function is used.
        /// </summary>
        /// <param name="valueFactory">
        /// The delegate that is invoked to produce the lazily initialized value when it is needed.
        /// </param>
        /// <exception cref="ArgumentNullException"><paramref name="valueFactory" /> is null.</exception>
        public Lazy(System.Func<T> valueFactory) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="System.Lazy`1" /> class. When lazy initialization
        /// occurs, the specified initialization function and initialization mode are used.
        /// </summary>
        /// <param name="valueFactory">
        /// The delegate that is invoked to produce the lazily initialized value when it is needed.
        /// </param>
        /// <param name="isThreadSafe">
        /// true to make this instance usable concurrently by multiple threads; false to make this instance
        /// usable by only one thread at a time.
        /// </param>
        /// <exception cref="ArgumentNullException"><paramref name="valueFactory" /> is null.</exception>
        public Lazy(System.Func<T> valueFactory, bool isThreadSafe) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="System.Lazy`1" /> class that uses the specified
        /// initialization function and thread-safety mode.
        /// </summary>
        /// <param name="valueFactory">
        /// The delegate that is invoked to produce the lazily initialized value when it is needed.
        /// </param>
        /// <param name="mode">One of the enumeration values that specifies the thread safety mode.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="mode" /> contains an invalid value.
        /// </exception>
        /// <exception cref="ArgumentNullException"><paramref name="valueFactory" /> is null.</exception>
        public Lazy(System.Func<T> valueFactory, System.Threading.LazyThreadSafetyMode mode) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="System.Lazy`1" /> class that uses the default
        /// constructor of <paramref name="T" /> and the specified thread-safety mode.
        /// </summary>
        /// <param name="mode">One of the enumeration values that specifies the thread safety mode.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="mode" /> contains an invalid value.
        /// </exception>
        public Lazy(System.Threading.LazyThreadSafetyMode mode) { }
        /// <summary>
        /// Gets a value that indicates whether a value has been created for this <see cref="System.Lazy`1" />
        /// instance.
        /// </summary>
        /// <returns>
        /// true if a value has been created for this <see cref="System.Lazy`1" /> instance; otherwise,
        /// false.
        /// </returns>
        public bool IsValueCreated { get { return default(bool); } }
        /// <summary>
        /// Gets the lazily initialized value of the current <see cref="System.Lazy`1" /> instance.
        /// </summary>
        /// <returns>
        /// The lazily initialized value of the current <see cref="System.Lazy`1" /> instance.
        /// </returns>
        /// <exception cref="MemberAccessException">
        /// The <see cref="System.Lazy`1" /> instance is initialized to use the default constructor
        /// of the type that is being lazily initialized, and permissions to access the constructor are
        /// missing.
        /// </exception>
        /// <exception cref="MissingMemberException">
        /// The <see cref="System.Lazy`1" /> instance is initialized to use the default constructor
        /// of the type that is being lazily initialized, and that type does not have a public, parameterless
        /// constructor.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// The initialization function tries to access <see cref="System.Lazy`1.Value" /> on this instance.
        /// </exception>
        public T Value { get { return default(T); } }
        /// <summary>
        /// Creates and returns a string representation of the <see cref="System.Lazy`1.Value" /> property
        /// for this instance.
        /// </summary>
        /// <returns>
        /// The result of calling the <see cref="Object.ToString" /> method on the
        /// <see cref="System.Lazy`1.Value" /> property for this instance, if the value has been created (that is, if the
        /// <see cref="System.Lazy`1.IsValueCreated" /> property returns true). Otherwise, a string indicating that the value has not been created.
        /// </returns>
        /// <exception cref="NullReferenceException">
        /// The <see cref="System.Lazy`1.Value" /> property is null.
        /// </exception>
        public override string ToString() { return default(string); }
    }
    /// <summary>
    /// Provides a lazy indirect reference to an object and its associated metadata for use by the
    /// Managed Extensibility Framework.
    /// </summary>
    /// <typeparam name="T">The type of the object referenced.</typeparam>
    /// <typeparam name="TMetadata">The type of the metadata.</typeparam>
    public partial class Lazy<T, TMetadata> : System.Lazy<T>
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="System.Lazy`2" /> class with the specified
        /// metadata.
        /// </summary>
        /// <param name="metadata">The metadata associated with the referenced object.</param>
        public Lazy(TMetadata metadata) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="System.Lazy`2" /> class with the specified
        /// metadata and thread safety value.
        /// </summary>
        /// <param name="metadata">The metadata associated with the referenced object.</param>
        /// <param name="isThreadSafe">
        /// Indicates whether the <see cref="System.Lazy`2" /> object that is created will be thread-safe.
        /// </param>
        public Lazy(TMetadata metadata, bool isThreadSafe) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="System.Lazy`2" /> class with the specified
        /// metadata and thread synchronization mode.
        /// </summary>
        /// <param name="metadata">The metadata associated with the referenced object.</param>
        /// <param name="mode">The thread synchronization mode.</param>
        public Lazy(TMetadata metadata, System.Threading.LazyThreadSafetyMode mode) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="System.Lazy`2" /> class with the specified
        /// metadata that uses the specified function to get the referenced object.
        /// </summary>
        /// <param name="valueFactory">A function that returns the referenced object.</param>
        /// <param name="metadata">The metadata associated with the referenced object.</param>
        public Lazy(System.Func<T> valueFactory, TMetadata metadata) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="System.Lazy`2" /> class with the specified
        /// metadata and thread safety value that uses the specified function to get the referenced object.
        /// </summary>
        /// <param name="valueFactory">A function that returns the referenced object.</param>
        /// <param name="metadata">The metadata associated with the referenced object.</param>
        /// <param name="isThreadSafe">
        /// Indicates whether the <see cref="System.Lazy`2" /> object that is created will be thread-safe.
        /// </param>
        public Lazy(System.Func<T> valueFactory, TMetadata metadata, bool isThreadSafe) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="System.Lazy`2" /> class with the specified
        /// metadata and thread synchronization mode that uses the specified function to get the referenced
        /// object.
        /// </summary>
        /// <param name="valueFactory">A function that returns the referenced object</param>
        /// <param name="metadata">The metadata associated with the referenced object.</param>
        /// <param name="mode">The thread synchronization mode</param>
        public Lazy(System.Func<T> valueFactory, TMetadata metadata, System.Threading.LazyThreadSafetyMode mode) { }
        /// <summary>
        /// Gets the metadata associated with the referenced object.
        /// </summary>
        /// <returns>
        /// The metadata associated with the referenced object.
        /// </returns>
        public TMetadata Metadata { get { return default(TMetadata); } }
    }
    /// <summary>
    /// The exception that is thrown when an attempt to access a class member fails.
    /// </summary>
    public partial class MemberAccessException : System.Exception
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="MemberAccessException" /> class.
        /// </summary>
        public MemberAccessException() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="MemberAccessException" /> class with
        /// a specified error message.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        public MemberAccessException(string message) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="MemberAccessException" /> class with
        /// a specified error message and a reference to the inner exception that is the cause of this
        /// exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="inner">
        /// The exception that is the cause of the current exception. If the <paramref name="inner" />
        /// parameter is not a null reference (Nothing in Visual Basic), the current exception is raised
        /// in a catch block that handles the inner exception.
        /// </param>
        public MemberAccessException(string message, System.Exception inner) { }
    }
    /// <summary>
    /// The exception that is thrown when there is an invalid attempt to access a method, such as accessing
    /// a private method from partially trusted code.
    /// </summary>
    public partial class MethodAccessException : System.MemberAccessException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="MethodAccessException" /> class, setting
        /// the <see cref="Exception.Message" /> property of the new instance to a system-supplied
        /// message that describes the error, such as "Attempt to access the method failed." This message
        /// takes into account the current system culture.
        /// </summary>
        public MethodAccessException() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="MethodAccessException" /> class with
        /// a specified error message.
        /// </summary>
        /// <param name="message">A <see cref="String" /> that describes the error.</param>
        public MethodAccessException(string message) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="MethodAccessException" /> class with
        /// a specified error message and a reference to the inner exception that is the cause of this
        /// exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="inner">
        /// The exception that is the cause of the current exception. If the <paramref name="inner" />
        /// parameter is not a null reference (Nothing in Visual Basic), the current exception is raised
        /// in a catch block that handles the inner exception.
        /// </param>
        public MethodAccessException(string message, System.Exception inner) { }
    }
    /// <summary>
    /// The exception that is thrown when there is an attempt to dynamically access a field that does
    /// not exist. If a field in a class library has been removed or renamed, recompile any assemblies that
    /// reference that library.
    /// </summary>
    public partial class MissingFieldException : System.MissingMemberException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="MissingFieldException" /> class.
        /// </summary>
        public MissingFieldException() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="MissingFieldException" /> class with
        /// a specified error message.
        /// </summary>
        /// <param name="message">A <see cref="String" /> that describes the error.</param>
        public MissingFieldException(string message) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="MissingFieldException" /> class with
        /// a specified error message and a reference to the inner exception that is the cause of this
        /// exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="inner">
        /// The exception that is the cause of the current exception. If the <paramref name="inner" />
        /// parameter is not a null reference (Nothing in Visual Basic), the current exception is raised
        /// in a catch block that handles the inner exception.
        /// </param>
        public MissingFieldException(string message, System.Exception inner) { }
        /// <summary>
        /// Gets the text string showing the signature of the missing field, the class name, and the field
        /// name. This property is read-only.
        /// </summary>
        /// <returns>
        /// The error message string.
        /// </returns>
        public override string Message { get { return default(string); } }
    }
    /// <summary>
    /// The exception that is thrown when there is an attempt to dynamically access a class member
    /// that does not exist or that is not declared as public. If a member in a class library has been removed
    /// or renamed, recompile any assemblies that reference that library.
    /// </summary>
    public partial class MissingMemberException : System.MemberAccessException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="MissingMemberException" /> class.
        /// </summary>
        public MissingMemberException() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="MissingMemberException" /> class with
        /// a specified error message.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        public MissingMemberException(string message) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="MissingMemberException" /> class with
        /// a specified error message and a reference to the inner exception that is the root cause of
        /// this exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="inner">
        /// An instance of <see cref="Exception" /> that is the cause of the current Exception.
        /// If <paramref name="inner" /> is not a null reference (Nothing in Visual Basic), then the current
        /// Exception is raised in a catch block handling <paramref name="inner" />.
        /// </param>
        public MissingMemberException(string message, System.Exception inner) { }
        /// <summary>
        /// Gets the text string showing the class name, the member name, and the signature of the missing
        /// member.
        /// </summary>
        /// <returns>
        /// The error message string.
        /// </returns>
        public override string Message { get { return default(string); } }
    }
    /// <summary>
    /// The exception that is thrown when there is an attempt to dynamically access a method that does
    /// not exist.
    /// </summary>
    public partial class MissingMethodException : System.MissingMemberException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="MissingMethodException" /> class.
        /// </summary>
        public MissingMethodException() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="MissingMethodException" /> class with
        /// a specified error message.
        /// </summary>
        /// <param name="message">A <see cref="String" /> that describes the error.</param>
        public MissingMethodException(string message) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="MissingMethodException" /> class with
        /// a specified error message and a reference to the inner exception that is the cause of this
        /// exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="inner">
        /// The exception that is the cause of the current exception. If the <paramref name="inner" />
        /// parameter is not a null reference (Nothing in Visual Basic), the current exception is raised
        /// in a catch block that handles the inner exception.
        /// </param>
        public MissingMethodException(string message, System.Exception inner) { }
        /// <summary>
        /// Gets the text string showing the class name, the method name, and the signature of the missing
        /// method. This property is read-only.
        /// </summary>
        /// <returns>
        /// The error message string.
        /// </returns>
        public override string Message { get { return default(string); } }
    }
    /// <summary>
    /// Indicates that the COM threading model for an application is multithreaded apartment (MTA).
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(64))]
    public sealed partial class MTAThreadAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="MTAThreadAttribute" /> class.
        /// </summary>
        public MTAThreadAttribute() { }
    }
    /// <summary>
    /// Represents a multicast delegate; that is, a delegate that can have more than one element in
    /// its invocation list.
    /// </summary>
    public abstract partial class MulticastDelegate : System.Delegate
    {
        internal MulticastDelegate() { }
        /// <summary>
        /// Determines whether this multicast delegate and the specified object are equal.
        /// </summary>
        /// <param name="obj">The object to compare with this instance.</param>
        /// <returns>
        /// true if <paramref name="obj" /> and this instance have the same invocation lists; otherwise,
        /// false.
        /// </returns>
        /// <exception cref="MemberAccessException">
        /// Cannot create an instance of an abstract class, or this member was invoked with a late-binding
        /// mechanism.
        /// </exception>
        public sealed override bool Equals(object obj) { return default(bool); }
        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code.
        /// </returns>
        /// <exception cref="MemberAccessException">
        /// Cannot create an instance of an abstract class, or this member was invoked with a late-binding
        /// mechanism.
        /// </exception>
        public sealed override int GetHashCode() { return default(int); }
        /// <summary>
        /// Returns the invocation list of this multicast delegate, in invocation order.
        /// </summary>
        /// <returns>
        /// An array of delegates whose invocation lists collectively match the invocation list of this
        /// instance.
        /// </returns>
        /// <exception cref="MemberAccessException">
        /// Cannot create an instance of an abstract class, or this member was invoked with a late-binding
        /// mechanism.
        /// </exception>
        public sealed override System.Delegate[] GetInvocationList() { return default(System.Delegate[]); }
        /// <summary>
        /// Determines whether two <see cref="MulticastDelegate" /> objects are equal.
        /// </summary>
        /// <param name="d1">The left operand.</param>
        /// <param name="d2">The right operand.</param>
        /// <returns>
        /// true if <paramref name="d1" /> and <paramref name="d2" /> have the same invocation lists;
        /// otherwise, false.
        /// </returns>
        /// <exception cref="MemberAccessException">
        /// Cannot create an instance of an abstract class, or this member was invoked with a late-binding
        /// mechanism.
        /// </exception>
        public static bool operator ==(System.MulticastDelegate d1, System.MulticastDelegate d2) { return default(bool); }
        /// <summary>
        /// Determines whether two <see cref="MulticastDelegate" /> objects are not equal.
        /// </summary>
        /// <param name="d1">The left operand.</param>
        /// <param name="d2">The right operand.</param>
        /// <returns>
        /// true if <paramref name="d1" /> and <paramref name="d2" /> do not have the same invocation
        /// lists; otherwise, false.
        /// </returns>
        /// <exception cref="MemberAccessException">
        /// Cannot create an instance of an abstract class, or this member was invoked with a late-binding
        /// mechanism.
        /// </exception>
        public static bool operator !=(System.MulticastDelegate d1, System.MulticastDelegate d2) { return default(bool); }
    }
    /// <summary>
    /// The exception that is thrown when a requested method or operation is not implemented.
    /// </summary>
    public partial class NotImplementedException : System.Exception
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="NotImplementedException" /> class with
        /// default properties.
        /// </summary>
        public NotImplementedException() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="NotImplementedException" /> class with
        /// a specified error message.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        public NotImplementedException(string message) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="NotImplementedException" /> class with
        /// a specified error message and a reference to the inner exception that is the cause of this
        /// exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="inner">
        /// The exception that is the cause of the current exception. If the <paramref name="inner" />
        /// parameter is not null, the current exception is raised in a catch block that handles the inner
        /// exception.
        /// </param>
        public NotImplementedException(string message, System.Exception inner) { }
    }
    /// <summary>
    /// The exception that is thrown when an invoked method is not supported, or when there is an attempt
    /// to read, seek, or write to a stream that does not support the invoked functionality.
    /// </summary>
    public partial class NotSupportedException : System.Exception
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="NotSupportedException" /> class, setting
        /// the <see cref="Exception.Message" /> property of the new instance to a system-supplied
        /// message that describes the error. This message takes into account the current system culture.
        /// </summary>
        public NotSupportedException() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="NotSupportedException" /> class with
        /// a specified error message.
        /// </summary>
        /// <param name="message">
        /// A <see cref="String" /> that describes the error. The content of <paramref name="message" />
        /// is intended to be understood by humans. The caller of this constructor is required to ensure
        /// that this string has been localized for the current system culture.
        /// </param>
        public NotSupportedException(string message) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="NotSupportedException" /> class with
        /// a specified error message and a reference to the inner exception that is the cause of this
        /// exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="innerException">
        /// The exception that is the cause of the current exception. If the <paramref name="innerException" />
        /// parameter is not a null reference, the current exception is raised in a catch block that
        /// handles the inner exception.
        /// </param>
        public NotSupportedException(string message, System.Exception innerException) { }
    }
    /// <summary>
    /// Supports a value type that can be assigned null. This class cannot be inherited.
    /// </summary>
    public static partial class Nullable
    {
        /// <summary>
        /// Compares the relative values of two <see cref="Nullable`1" /> objects.
        /// </summary>
        /// <param name="n1">A <see cref="Nullable`1" /> object.</param>
        /// <param name="n2">A <see cref="Nullable`1" /> object.</param>
        /// <typeparam name="T">
        /// The underlying value type of the <paramref name="n1" /> and <paramref name="n2" /> parameters.
        /// </typeparam>
        /// <returns>
        /// An integer that indicates the relative values of the <paramref name="n1" /> and <paramref name="n2" />
        /// parameters.Return ValueDescriptionLess than zeroThe <see cref="Nullable`1.HasValue" />
        /// property for <paramref name="n1" /> is false, and the <see cref="Nullable`1.HasValue" />
        /// property for <paramref name="n2" /> is true.-or-The <see cref="Nullable`1.HasValue" />
        /// properties for <paramref name="n1" /> and <paramref name="n2" /> are true, and the value
        /// of the <see cref="Nullable`1.Value" /> property for <paramref name="n1" /> is less
        /// than the value of the <see cref="Nullable`1.Value" /> property for <paramref name="n2" />.
        /// ZeroThe <see cref="Nullable`1.HasValue" /> properties for <paramref name="n1" />
        /// and <paramref name="n2" /> are false.-or-The <see cref="Nullable`1.HasValue" />
        /// properties for <paramref name="n1" /> and <paramref name="n2" /> are true, and the value of
        /// the <see cref="Nullable`1.Value" /> property for <paramref name="n1" /> is equal
        /// to the value of the <see cref="Nullable`1.Value" /> property for <paramref name="n2" />.
        /// Greater than zeroThe <see cref="Nullable`1.HasValue" /> property for <paramref name="n1" />
        /// is true, and the <see cref="Nullable`1.HasValue" /> property for <paramref name="n2" />
        /// is false.-or-The <see cref="Nullable`1.HasValue" /> properties for <paramref name="n1" />
        /// and <paramref name="n2" /> are true, and the value of the <see cref="Nullable`1.Value" />
        /// property for <paramref name="n1" /> is greater than the value of the <see cref="Nullable`1.Value" />
        /// property for <paramref name="n2" />.
        /// </returns>
        public static int Compare<T>(System.Nullable<T> n1, System.Nullable<T> n2) where T : struct { return default(int); }
        /// <summary>
        /// Indicates whether two specified <see cref="Nullable`1" /> objects are equal.
        /// </summary>
        /// <param name="n1">A <see cref="Nullable`1" /> object.</param>
        /// <param name="n2">A <see cref="Nullable`1" /> object.</param>
        /// <typeparam name="T">
        /// The underlying value type of the <paramref name="n1" /> and <paramref name="n2" /> parameters.
        /// </typeparam>
        /// <returns>
        /// true if the <paramref name="n1" /> parameter is equal to the <paramref name="n2" /> parameter;
        /// otherwise, false. The return value depends on the <see cref="Nullable`1.HasValue" />
        /// and <see cref="Nullable`1.Value" /> properties of the two parameters that are
        /// compared.Return ValueDescriptiontrueThe <see cref="Nullable`1.HasValue" /> properties
        /// for <paramref name="n1" /> and <paramref name="n2" /> are false. -or-The <see cref="Nullable`1.HasValue" />
        /// properties for <paramref name="n1" /> and <paramref name="n2" /> are true, and the <see cref="Nullable`1.Value" />
        /// properties of the parameters are equal.falseThe <see cref="Nullable`1.HasValue" />
        /// property is true for one parameter and false for the other parameter.-or-The
        /// <see cref="Nullable`1.HasValue" /> properties for <paramref name="n1" /> and <paramref name="n2" /> are true, and the
        /// <see cref="Nullable`1.Value" /> properties of the parameters are unequal.
        /// </returns>
        public static bool Equals<T>(System.Nullable<T> n1, System.Nullable<T> n2) where T : struct { return default(bool); }
        /// <summary>
        /// Returns the underlying type argument of the specified nullable type.
        /// </summary>
        /// <param name="nullableType">
        /// A <see cref="Type" /> object that describes a closed generic nullable type.
        /// </param>
        /// <returns>
        /// The type argument of the <paramref name="nullableType" /> parameter, if the <paramref name="nullableType" />
        /// parameter is a closed generic nullable type; otherwise, null.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="nullableType" /> is null.</exception>
        public static System.Type GetUnderlyingType(System.Type nullableType) { return default(System.Type); }
    }
    /// <summary>
    /// Represents a value type that can be assigned null.
    /// </summary>
    /// <typeparam name="T">The underlying value type of the <see cref="Nullable`1" /> generic type.</typeparam>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct Nullable<T> where T : struct
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Nullable`1" /> structure to the specified
        /// value.
        /// </summary>
        /// <param name="value">A value type.</param>
        public Nullable(T value) { throw new System.NotImplementedException(); }
        /// <summary>
        /// Gets a value indicating whether the current <see cref="Nullable`1" /> object has
        /// a valid value of its underlying type.
        /// </summary>
        /// <returns>
        /// true if the current <see cref="Nullable`1" /> object has a value; false if the current
        /// <see cref="Nullable`1" /> object has no value.
        /// </returns>
        public bool HasValue { get { return default(bool); } }
        /// <summary>
        /// Gets the value of the current <see cref="Nullable`1" /> object if it has been assigned
        /// a valid underlying value.
        /// </summary>
        /// <returns>
        /// The value of the current <see cref="Nullable`1" /> object if the
        /// <see cref="Nullable`1.HasValue" /> property is true. An exception is thrown if the <see cref="Nullable`1.HasValue" />
        /// property is false.
        /// </returns>
        /// <exception cref="InvalidOperationException">
        /// The <see cref="Nullable`1.HasValue" /> property is false.
        /// </exception>
        public T Value { get { return default(T); } }
        /// <summary>
        /// Indicates whether the current <see cref="Nullable`1" /> object is equal to a specified
        /// object.
        /// </summary>
        /// <param name="other">An object.</param>
        /// <returns>
        /// true if the <paramref name="other" /> parameter is equal to the current <see cref="Nullable`1" />
        /// object; otherwise, false. This table describes how equality is defined for the compared
        /// values: Return ValueDescriptiontrueThe <see cref="Nullable`1.HasValue" /> property
        /// is false, and the <paramref name="other" /> parameter is null. That is, two null values are
        /// equal by definition.-or-The <see cref="Nullable`1.HasValue" /> property is true,
        /// and the value returned by the <see cref="Nullable`1.Value" /> property is equal to
        /// the <paramref name="other" /> parameter.falseThe <see cref="Nullable`1.HasValue" />
        /// property for the current <see cref="Nullable`1" /> structure is true, and the
        /// <paramref name="other" /> parameter is null.-or-The <see cref="Nullable`1.HasValue" />
        /// property for the current <see cref="Nullable`1" /> structure is false, and the
        /// <paramref name="other" /> parameter is not null.-or-The <see cref="Nullable`1.HasValue" />
        /// property for the current <see cref="Nullable`1" /> structure is true, and the
        /// value returned by the <see cref="Nullable`1.Value" /> property is not equal to the
        /// <paramref name="other" /> parameter.
        /// </returns>
        public override bool Equals(object other) { return default(bool); }
        /// <summary>
        /// Retrieves the hash code of the object returned by the <see cref="Nullable`1.Value" />
        /// property.
        /// </summary>
        /// <returns>
        /// The hash code of the object returned by the <see cref="Nullable`1.Value" /> property
        /// if the <see cref="Nullable`1.HasValue" /> property is true, or zero if the
        /// <see cref="Nullable`1.HasValue" /> property is false.
        /// </returns>
        public override int GetHashCode() { return default(int); }
        /// <summary>
        /// Retrieves the value of the current <see cref="Nullable`1" /> object, or the object's
        /// default value.
        /// </summary>
        /// <returns>
        /// The value of the <see cref="Nullable`1.Value" /> property if the
        /// <see cref="Nullable`1.HasValue" /> property is true; otherwise, the default value of the current
        /// <see cref="Nullable`1" /> object. The type of the default value is the type argument of the current
        /// <see cref="Nullable`1" /> object, and the value of the default value consists solely of binary zeroes.
        /// </returns>
        public T GetValueOrDefault() { return default(T); }
        /// <summary>
        /// Retrieves the value of the current <see cref="Nullable`1" /> object, or the specified
        /// default value.
        /// </summary>
        /// <param name="defaultValue">
        /// A value to return if the <see cref="Nullable`1.HasValue" /> property is false.
        /// </param>
        /// <returns>
        /// The value of the <see cref="Nullable`1.Value" /> property if the
        /// <see cref="Nullable`1.HasValue" /> property is true; otherwise, the <paramref name="defaultValue" /> parameter.
        /// </returns>
        public T GetValueOrDefault(T defaultValue) { return default(T); }
        /// <summary>
        /// Defines an explicit conversion of a <see cref="Nullable`1" /> instance to its underlying
        /// value.
        /// </summary>
        /// <param name="value">A nullable value.</param>
        /// <returns>
        /// The value of the <see cref="Nullable`1.Value" /> property for the <paramref name="value" />
        /// parameter.
        /// </returns>
        public static explicit operator T(System.Nullable<T> value) { return default(T); }
        /// <summary>
        /// Creates a new <see cref="Nullable`1" /> object initialized to a specified value.
        /// </summary>
        /// <param name="value">A value type.</param>
        /// <returns>
        /// A <see cref="Nullable`1" /> object whose <see cref="Nullable`1.Value" />
        /// property is initialized with the <paramref name="value" /> parameter.
        /// </returns>
        public static implicit operator System.Nullable<T>(T value) { return default(System.Nullable<T>); }
        /// <summary>
        /// Returns the text representation of the value of the current <see cref="Nullable`1" />
        /// object.
        /// </summary>
        /// <returns>
        /// The text representation of the value of the current <see cref="Nullable`1" /> object
        /// if the <see cref="Nullable`1.HasValue" /> property is true, or an empty string ("")
        /// if the <see cref="Nullable`1.HasValue" /> property is false.
        /// </returns>
        public override string ToString() { return default(string); }
    }
    /// <summary>
    /// The exception that is thrown when there is an attempt to dereference a null object reference.
    /// </summary>
    public partial class NullReferenceException : System.Exception
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="NullReferenceException" /> class, setting
        /// the <see cref="Exception.Message" /> property of the new instance to a system-supplied
        /// message that describes the error, such as "The value 'null' was found where an instance of
        /// an object was required." This message takes into account the current system culture.
        /// </summary>
        public NullReferenceException() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="NullReferenceException" /> class with
        /// a specified error message.
        /// </summary>
        /// <param name="message">
        /// A <see cref="String" /> that describes the error. The content of <paramref name="message" />
        /// is intended to be understood by humans. The caller of this constructor is required to ensure
        /// that this string has been localized for the current system culture.
        /// </param>
        public NullReferenceException(string message) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="NullReferenceException" /> class with
        /// a specified error message and a reference to the inner exception that is the cause of this
        /// exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="innerException">
        /// The exception that is the cause of the current exception. If the <paramref name="innerException" />
        /// parameter is not null, the current exception is raised in a catch block that handles the
        /// inner exception.
        /// </param>
        public NullReferenceException(string message, System.Exception innerException) { }
    }
    /// <summary>
    /// Supports all classes in the .NET Framework class hierarchy and provides low-level services
    /// to derived classes. This is the ultimate base class of all classes in the .NET Framework; it is the
    /// root of the type hierarchy.To browse the .NET Framework source code for this type, see the Reference
    /// Source.
    /// </summary>
    public partial class Object
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Object" /> class.
        /// </summary>
        public Object() { }
        /// <summary>
        /// Determines whether the specified object is equal to the current object.
        /// </summary>
        /// <param name="obj">The object to compare with the current object.</param>
        /// <returns>
        /// true if the specified object  is equal to the current object; otherwise, false.
        /// </returns>
        public virtual bool Equals(object obj) { return default(bool); }
        /// <summary>
        /// Determines whether the specified object instances are considered equal.
        /// </summary>
        /// <param name="objA">The first object to compare.</param>
        /// <param name="objB">The second object to compare.</param>
        /// <returns>
        /// true if the objects are considered equal; otherwise, false. If both <paramref name="objA" />
        /// and <paramref name="objB" /> are null, the method returns true.
        /// </returns>
        public static bool Equals(object objA, object objB) { return default(bool); }
        /// <summary>
        /// Allows an object to try to free resources and perform other cleanup operations before it is
        /// reclaimed by garbage collection.
        /// </summary>
        ~Object() { }
        /// <summary>
        /// Serves as the default hash function.
        /// </summary>
        /// <returns>
        /// A hash code for the current object.
        /// </returns>
        public virtual int GetHashCode() { return default(int); }
        /// <summary>
        /// Gets the <see cref="Type" /> of the current instance.
        /// </summary>
        /// <returns>
        /// The exact runtime type of the current instance.
        /// </returns>
        public System.Type GetType() { return default(System.Type); }
        /// <summary>
        /// Creates a shallow copy of the current <see cref="Object" />.
        /// </summary>
        /// <returns>
        /// A shallow copy of the current <see cref="Object" />.
        /// </returns>
        protected object MemberwiseClone() { return default(object); }
        /// <summary>
        /// Determines whether the specified <see cref="Object" /> instances are the same instance.
        /// </summary>
        /// <param name="objA">The first object to compare.</param>
        /// <param name="objB">The second object  to compare.</param>
        /// <returns>
        /// true if <paramref name="objA" /> is the same instance as <paramref name="objB" /> or if both
        /// are null; otherwise, false.
        /// </returns>
        public static bool ReferenceEquals(object objA, object objB) { return default(bool); }
        /// <summary>
        /// Returns a string that represents the current object.
        /// </summary>
        /// <returns>
        /// A string that represents the current object.
        /// </returns>
        public virtual string ToString() { return default(string); }
    }
    /// <summary>
    /// The exception that is thrown when an operation is performed on a disposed object.
    /// </summary>
    public partial class ObjectDisposedException : System.InvalidOperationException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ObjectDisposedException" /> class with
        /// a string containing the name of the disposed object.
        /// </summary>
        /// <param name="objectName">A string containing the name of the disposed object.</param>
        public ObjectDisposedException(string objectName) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ObjectDisposedException" /> class with
        /// a specified error message and a reference to the inner exception that is the cause of this
        /// exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="innerException">
        /// The exception that is the cause of the current exception. If <paramref name="innerException" />
        /// is not null, the current exception is raised in a catch block that handles the inner exception.
        /// </param>
        public ObjectDisposedException(string message, System.Exception innerException) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ObjectDisposedException" /> class with
        /// the specified object name and message.
        /// </summary>
        /// <param name="objectName">The name of the disposed object.</param>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        public ObjectDisposedException(string objectName, string message) { }
        /// <summary>
        /// Gets the message that describes the error.
        /// </summary>
        /// <returns>
        /// A string that describes the error.
        /// </returns>
        public override string Message { get { return default(string); } }
        /// <summary>
        /// Gets the name of the disposed object.
        /// </summary>
        /// <returns>
        /// A string containing the name of the disposed object.
        /// </returns>
        public string ObjectName { get { return default(string); } }
    }
    /// <summary>
    /// Marks the program elements that are no longer in use. This class cannot be inherited.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(6140), Inherited = false)]
    public sealed partial class ObsoleteAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ObsoleteAttribute" /> class with default
        /// properties.
        /// </summary>
        public ObsoleteAttribute() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ObsoleteAttribute" /> class with a specified
        /// workaround message.
        /// </summary>
        /// <param name="message">The text string that describes alternative workarounds.</param>
        public ObsoleteAttribute(string message) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ObsoleteAttribute" /> class with a workaround
        /// message and a Boolean value indicating whether the obsolete element usage is considered an
        /// error.
        /// </summary>
        /// <param name="message">The text string that describes alternative workarounds.</param>
        /// <param name="error">
        /// true if the obsolete element usage generates a compiler error; false if it generates a compiler
        /// warning.
        /// </param>
        public ObsoleteAttribute(string message, bool error) { }
        /// <summary>
        /// Gets a Boolean value indicating whether the compiler will treat usage of the obsolete program
        /// element as an error.
        /// </summary>
        /// <returns>
        /// true if the obsolete element usage is considered an error; otherwise, false. The default is
        /// false.
        /// </returns>
        public bool IsError { get { return default(bool); } }
        /// <summary>
        /// Gets the workaround message, including a description of the alternative program elements.
        /// </summary>
        /// <returns>
        /// The workaround text string.
        /// </returns>
        public string Message { get { return default(string); } }
    }
    /// <summary>
    /// The exception that is thrown when there is not enough memory to continue the execution of a
    /// program.
    /// </summary>
    public partial class OutOfMemoryException : System.Exception
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="OutOfMemoryException" /> class.
        /// </summary>
        public OutOfMemoryException() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="OutOfMemoryException" /> class with
        /// a specified error message.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        public OutOfMemoryException(string message) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="OutOfMemoryException" /> class with
        /// a specified error message and a reference to the inner exception that is the cause of this
        /// exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="innerException">
        /// The exception that is the cause of the current exception. If the <paramref name="innerException" />
        /// parameter is not a null reference (Nothing in Visual Basic), the current exception is raised
        /// in a catch block that handles the inner exception.
        /// </param>
        public OutOfMemoryException(string message, System.Exception innerException) { }
    }
    /// <summary>
    /// The exception that is thrown when an arithmetic, casting, or conversion operation in a checked
    /// context results in an overflow.
    /// </summary>
    public partial class OverflowException : System.ArithmeticException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="OverflowException" /> class.
        /// </summary>
        public OverflowException() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="OverflowException" /> class with a specified
        /// error message.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        public OverflowException(string message) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="OverflowException" /> class with a specified
        /// error message and a reference to the inner exception that is the cause of this exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="innerException">
        /// The exception that is the cause of the current exception. If the <paramref name="innerException" />
        /// parameter is not a null reference (Nothing in Visual Basic), the current exception is raised
        /// in a catch block that handles the inner exception.
        /// </param>
        public OverflowException(string message, System.Exception innerException) { }
    }
    /// <summary>
    /// Indicates that a method will allow a variable number of arguments in its invocation. This class
    /// cannot be inherited.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(2048), Inherited = true, AllowMultiple = false)]
    public sealed partial class ParamArrayAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ParamArrayAttribute" /> class with default
        /// properties.
        /// </summary>
        public ParamArrayAttribute() { }
    }
    /// <summary>
    /// The exception that is thrown when a feature does not run on a particular platform.
    /// </summary>
    public partial class PlatformNotSupportedException : System.NotSupportedException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="PlatformNotSupportedException" /> class
        /// with default properties.
        /// </summary>
        public PlatformNotSupportedException() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="PlatformNotSupportedException" /> class
        /// with a specified error message.
        /// </summary>
        /// <param name="message">The text message that explains the reason for the exception.</param>
        public PlatformNotSupportedException(string message) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="PlatformNotSupportedException" /> class
        /// with a specified error message and a reference to the inner exception that is the cause of
        /// this exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="inner">
        /// The exception that is the cause of the current exception. If the <paramref name="inner" />
        /// parameter is not null, the current exception is raised in a catch block that handles the inner
        /// exception.
        /// </param>
        public PlatformNotSupportedException(string message, System.Exception inner) { }
    }
    /// <summary>
    /// Represents the method that defines a set of criteria and determines whether the specified object
    /// meets those criteria.
    /// </summary>
    /// <param name="obj">
    /// The object to compare against the criteria defined within the method represented by this delegate.
    /// </param>
    /// <typeparam name="T">The type of the object to compare.</typeparam>
    /// <returns>
    /// true if <paramref name="obj" /> meets the criteria defined within the method represented by
    /// this delegate; otherwise, false.
    /// </returns>
    public delegate bool Predicate<in T>(T obj);
    /// <summary>
    /// The exception that is thrown when an array with the wrong number of dimensions is passed to
    /// a method.
    /// </summary>
    public partial class RankException : System.Exception
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RankException" /> class.
        /// </summary>
        public RankException() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="RankException" /> class with a specified
        /// error message.
        /// </summary>
        /// <param name="message">A <see cref="String" /> that describes the error.</param>
        public RankException(string message) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="RankException" /> class with a specified
        /// error message and a reference to the inner exception that is the cause of this exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="innerException">
        /// The exception that is the cause of the current exception. If the <paramref name="innerException" />
        /// parameter is not a null reference (Nothing in Visual Basic), the current exception is raised
        /// in a catch block that handles the inner exception.
        /// </param>
        public RankException(string message, System.Exception innerException) { }
    }
    /// <summary>
    /// Represents a field using an internal metadata token.
    /// </summary>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct RuntimeFieldHandle
    {
        /// <summary>
        /// Indicates whether the current instance is equal to the specified object.
        /// </summary>
        /// <param name="obj">The object to compare to the current instance.</param>
        /// <returns>
        /// true if <paramref name="obj" /> is a <see cref="RuntimeFieldHandle" /> and equal
        /// to the value of the current instance; otherwise, false.
        /// </returns>
        public override bool Equals(object obj) { return default(bool); }
        /// <summary>
        /// Indicates whether the current instance is equal to the specified <see cref="RuntimeFieldHandle" />.
        /// </summary>
        /// <param name="handle">The <see cref="RuntimeFieldHandle" /> to compare to the current instance.</param>
        /// <returns>
        /// true if the value of <paramref name="handle" /> is equal to the value of the current instance;
        /// otherwise, false.
        /// </returns>
        public bool Equals(System.RuntimeFieldHandle handle) { return default(bool); }
        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer that is the hash code for this instance.
        /// </returns>
        public override int GetHashCode() { return default(int); }
        /// <summary>
        /// Indicates whether two <see cref="RuntimeFieldHandle" /> structures are equal.
        /// </summary>
        /// <param name="left">The <see cref="RuntimeFieldHandle" /> to compare to <paramref name="right" />.</param>
        /// <param name="right">The <see cref="RuntimeFieldHandle" /> to compare to <paramref name="left" />.</param>
        /// <returns>
        /// true if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, false.
        /// </returns>
        public static bool operator ==(System.RuntimeFieldHandle left, System.RuntimeFieldHandle right) { return default(bool); }
        /// <summary>
        /// Indicates whether two <see cref="RuntimeFieldHandle" /> structures are not equal.
        /// </summary>
        /// <param name="left">The <see cref="RuntimeFieldHandle" /> to compare to <paramref name="right" />.</param>
        /// <param name="right">The <see cref="RuntimeFieldHandle" /> to compare to <paramref name="left" />.</param>
        /// <returns>
        /// true if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, false.
        /// </returns>
        public static bool operator !=(System.RuntimeFieldHandle left, System.RuntimeFieldHandle right) { return default(bool); }
    }
    /// <summary>
    /// <see cref="RuntimeMethodHandle" /> is a handle to the internal metadata representation
    /// of a method.
    /// </summary>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct RuntimeMethodHandle
    {
        /// <summary>
        /// Indicates whether this instance is equal to a specified object.
        /// </summary>
        /// <param name="obj">A <see cref="Object" /> to compare to this instance.</param>
        /// <returns>
        /// true if <paramref name="obj" /> is a <see cref="RuntimeMethodHandle" /> and equal
        /// to the value of this instance; otherwise, false.
        /// </returns>
        public override bool Equals(object obj) { return default(bool); }
        /// <summary>
        /// Indicates whether this instance is equal to a specified <see cref="RuntimeMethodHandle" />.
        /// </summary>
        /// <param name="handle">A <see cref="RuntimeMethodHandle" /> to compare to this instance.</param>
        /// <returns>
        /// true if <paramref name="handle" /> is equal to the value of this instance; otherwise, false.
        /// </returns>
        public bool Equals(System.RuntimeMethodHandle handle) { return default(bool); }
        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code.
        /// </returns>
        public override int GetHashCode() { return default(int); }
        /// <summary>
        /// Indicates whether two instances of <see cref="RuntimeMethodHandle" /> are equal.
        /// </summary>
        /// <param name="left">A <see cref="RuntimeMethodHandle" /> to compare to <paramref name="right" />.</param>
        /// <param name="right">A <see cref="RuntimeMethodHandle" /> to compare to <paramref name="left" />.</param>
        /// <returns>
        /// true if the value of <paramref name="left" /> is equal to the value of <paramref name="right" />;
        /// otherwise, false.
        /// </returns>
        public static bool operator ==(System.RuntimeMethodHandle left, System.RuntimeMethodHandle right) { return default(bool); }
        /// <summary>
        /// Indicates whether two instances of <see cref="RuntimeMethodHandle" /> are not equal.
        /// </summary>
        /// <param name="left">A <see cref="RuntimeMethodHandle" /> to compare to <paramref name="right" />.</param>
        /// <param name="right">A <see cref="RuntimeMethodHandle" /> to compare to <paramref name="left" />.</param>
        /// <returns>
        /// true if the value of <paramref name="left" /> is unequal to the value of <paramref name="right" />;
        /// otherwise, false.
        /// </returns>
        public static bool operator !=(System.RuntimeMethodHandle left, System.RuntimeMethodHandle right) { return default(bool); }
    }
    /// <summary>
    /// Represents a type using an internal metadata token.
    /// </summary>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct RuntimeTypeHandle
    {
        /// <summary>
        /// Indicates whether the specified object is equal to the current <see cref="RuntimeTypeHandle" />
        /// structure.
        /// </summary>
        /// <param name="obj">An object to compare to the current instance.</param>
        /// <returns>
        /// true if <paramref name="obj" /> is a <see cref="RuntimeTypeHandle" /> structure and
        /// is equal to the value of this instance; otherwise, false.
        /// </returns>
        public override bool Equals(object obj) { return default(bool); }
        /// <summary>
        /// Indicates whether the specified <see cref="RuntimeTypeHandle" /> structure is equal
        /// to the current <see cref="RuntimeTypeHandle" /> structure.
        /// </summary>
        /// <param name="handle">
        /// The <see cref="RuntimeTypeHandle" /> structure to compare to the current instance.
        /// </param>
        /// <returns>
        /// true if the value of <paramref name="handle" /> is equal to the value of this instance; otherwise,
        /// false.
        /// </returns>
        public bool Equals(System.RuntimeTypeHandle handle) { return default(bool); }
        /// <summary>
        /// Returns the hash code for the current instance.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code.
        /// </returns>
        public override int GetHashCode() { return default(int); }
        /// <summary>
        /// Indicates whether an object and a <see cref="RuntimeTypeHandle" /> structure are
        /// equal.
        /// </summary>
        /// <param name="left">An object to compare to <paramref name="right" />.</param>
        /// <param name="right">
        /// A <see cref="RuntimeTypeHandle" /> structure to compare to <paramref name="left" />.
        /// </param>
        /// <returns>
        /// true if <paramref name="left" /> is a <see cref="RuntimeTypeHandle" /> structure
        /// and is equal to <paramref name="right" />; otherwise, false.
        /// </returns>
        public static bool operator ==(object left, System.RuntimeTypeHandle right) { return default(bool); }
        /// <summary>
        /// Indicates whether a <see cref="RuntimeTypeHandle" /> structure is equal to an object.
        /// </summary>
        /// <param name="left">
        /// A <see cref="RuntimeTypeHandle" /> structure to compare to <paramref name="right" />.
        /// </param>
        /// <param name="right">An object to compare to <paramref name="left" />.</param>
        /// <returns>
        /// true if <paramref name="right" /> is a <see cref="RuntimeTypeHandle" /> and is equal
        /// to <paramref name="left" />; otherwise, false.
        /// </returns>
        public static bool operator ==(System.RuntimeTypeHandle left, object right) { return default(bool); }
        /// <summary>
        /// Indicates whether an object and a <see cref="RuntimeTypeHandle" /> structure are
        /// not equal.
        /// </summary>
        /// <param name="left">An object to compare to <paramref name="right" />.</param>
        /// <param name="right">
        /// A <see cref="RuntimeTypeHandle" /> structure to compare to <paramref name="left" />.
        /// </param>
        /// <returns>
        /// true if <paramref name="left" /> is a <see cref="RuntimeTypeHandle" /> and is not
        /// equal to <paramref name="right" />; otherwise, false.
        /// </returns>
        public static bool operator !=(object left, System.RuntimeTypeHandle right) { return default(bool); }
        /// <summary>
        /// Indicates whether a <see cref="RuntimeTypeHandle" /> structure is not equal to an
        /// object.
        /// </summary>
        /// <param name="left">
        /// A <see cref="RuntimeTypeHandle" /> structure to compare to <paramref name="right" />.
        /// </param>
        /// <param name="right">An object to compare to <paramref name="left" />.</param>
        /// <returns>
        /// true if <paramref name="right" /> is a <see cref="RuntimeTypeHandle" /> structure
        /// and is not equal to <paramref name="left" />; otherwise, false.
        /// </returns>
        public static bool operator !=(System.RuntimeTypeHandle left, object right) { return default(bool); }
    }
    /// <summary>
    /// Represents an 8-bit signed integer.
    /// </summary>
    [System.CLSCompliantAttribute(false)]
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct SByte : System.IComparable, System.IComparable<sbyte>, System.IConvertible, System.IEquatable<sbyte>, System.IFormattable
    {
        /// <summary>
        /// Represents the largest possible value of <see cref="SByte" />. This field is constant.
        /// </summary>
        public const sbyte MaxValue = (sbyte)127;
        /// <summary>
        /// Represents the smallest possible value of <see cref="SByte" />. This field is constant.
        /// </summary>
        public const sbyte MinValue = (sbyte)-128;
        /// <summary>
        /// Compares this instance to a specified 8-bit signed integer and returns an indication of their
        /// relative values.
        /// </summary>
        /// <param name="value">An 8-bit signed integer to compare.</param>
        /// <returns>
        /// A signed integer that indicates the relative order of this instance and <paramref name="value" />.
        /// Return Value Description Less than zero This instance is less than <paramref name="value" />.
        /// Zero This instance is equal to <paramref name="value" />. Greater than zero This instance
        /// is greater than <paramref name="value" />.
        /// </returns>
        public int CompareTo(sbyte value) { return default(int); }
        /// <summary>
        /// Returns a value indicating whether this instance is equal to a specified object.
        /// </summary>
        /// <param name="obj">An object to compare with this instance.</param>
        /// <returns>
        /// true if <paramref name="obj" /> is an instance of <see cref="SByte" /> and equals
        /// the value of this instance; otherwise, false.
        /// </returns>
        public override bool Equals(object obj) { return default(bool); }
        /// <summary>
        /// Returns a value indicating whether this instance is equal to a specified <see cref="SByte" />
        /// value.
        /// </summary>
        /// <param name="obj">An <see cref="SByte" /> value to compare to this instance.</param>
        /// <returns>
        /// true if <paramref name="obj" /> has the same value as this instance; otherwise, false.
        /// </returns>
        public bool Equals(sbyte obj) { return default(bool); }
        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code.
        /// </returns>
        public override int GetHashCode() { return default(int); }
        /// <summary>
        /// Converts the string representation of a number to its 8-bit signed integer equivalent.
        /// </summary>
        /// <param name="s">
        /// A string that represents a number to convert. The string is interpreted using the
        /// <see cref="Globalization.NumberStyles.Integer" /> style.
        /// </param>
        /// <returns>
        /// An 8-bit signed integer that is equivalent to the number contained in the <paramref name="s" />
        /// parameter.
        /// </returns>
        /// <exception cref="ArgumentException"><paramref name="s" /> is null.</exception>
        /// <exception cref="FormatException">
        /// <paramref name="s" /> does not consist of an optional sign followed by a sequence of digits
        /// (zero through nine).
        /// </exception>
        /// <exception cref="OverflowException">
        /// <paramref name="s" /> represents a number less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />.
        /// </exception>
        [System.CLSCompliantAttribute(false)]
        public static sbyte Parse(string s) { return default(sbyte); }
        /// <summary>
        /// Converts the string representation of a number in a specified style to its 8-bit signed integer
        /// equivalent.
        /// </summary>
        /// <param name="s">
        /// A string that contains a number to convert. The string is interpreted using the style specified
        /// by <paramref name="style" />.
        /// </param>
        /// <param name="style">
        /// A bitwise combination of the enumeration values that indicates the style elements that can
        /// be present in <paramref name="s" />. A typical value to specify is
        /// <see cref="Globalization.NumberStyles.Integer" />.
        /// </param>
        /// <returns>
        /// An 8-bit signed integer that is equivalent to the number specified in <paramref name="s" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="FormatException">
        /// <paramref name="s" /> is not in a format that is compliant with <paramref name="style" />.
        /// </exception>
        /// <exception cref="OverflowException">
        /// <paramref name="s" /> represents a number less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />. -or-<paramref name="s" /> includes
        /// non-zero, fractional digits.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="style" /> is not a <see cref="Globalization.NumberStyles" /> value.
        /// -or-<paramref name="style" /> is not a combination of
        /// <see cref="Globalization.NumberStyles.AllowHexSpecifier" /> and <see cref="Globalization.NumberStyles.HexNumber" /> values.
        /// </exception>
        [System.CLSCompliantAttribute(false)]
        public static sbyte Parse(string s, System.Globalization.NumberStyles style) { return default(sbyte); }
        /// <summary>
        /// Converts the string representation of a number that is in a specified style and culture-specific
        /// format to its 8-bit signed equivalent.
        /// </summary>
        /// <param name="s">
        /// A string that contains the number to convert. The string is interpreted by using the style
        /// specified by <paramref name="style" />.
        /// </param>
        /// <param name="style">
        /// A bitwise combination of the enumeration values that indicates the style elements that can
        /// be present in <paramref name="s" />. A typical value to specify is
        /// <see cref="Globalization.NumberStyles.Integer" />.
        /// </param>
        /// <param name="provider">
        /// An object that supplies culture-specific formatting information about <paramref name="s" />.
        /// If <paramref name="provider" /> is null, the thread current culture is used.
        /// </param>
        /// <returns>
        /// An 8-bit signed byte value that is equivalent to the number specified in the <paramref name="s" />
        /// parameter.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// <paramref name="style" /> is not a <see cref="Globalization.NumberStyles" /> value.-or-
        /// <paramref name="style" /> is not a combination of
        /// <see cref="Globalization.NumberStyles.AllowHexSpecifier" /> and <see cref="Globalization.NumberStyles.HexNumber" />.
        /// </exception>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="FormatException">
        /// <paramref name="s" /> is not in a format that is compliant with <paramref name="style" />.
        /// </exception>
        /// <exception cref="OverflowException">
        /// <paramref name="s" /> represents a number that is less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />.-or-<paramref name="s" /> includes
        /// non-zero, fractional digits.
        /// </exception>
        [System.CLSCompliantAttribute(false)]
        public static sbyte Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider) { return default(sbyte); }
        /// <summary>
        /// Converts the string representation of a number in a specified culture-specific format to its
        /// 8-bit signed integer equivalent.
        /// </summary>
        /// <param name="s">
        /// A string that represents a number to convert. The string is interpreted using the
        /// <see cref="Globalization.NumberStyles.Integer" /> style.
        /// </param>
        /// <param name="provider">
        /// An object that supplies culture-specific formatting information about <paramref name="s" />.
        /// If <paramref name="provider" /> is null, the thread current culture is used.
        /// </param>
        /// <returns>
        /// An 8-bit signed integer that is equivalent to the number specified in <paramref name="s" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="FormatException"><paramref name="s" /> is not in the correct format.</exception>
        /// <exception cref="OverflowException">
        /// <paramref name="s" /> represents a number less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />.
        /// </exception>
        [System.CLSCompliantAttribute(false)]
        public static sbyte Parse(string s, System.IFormatProvider provider) { return default(sbyte); }
        int System.IComparable.CompareTo(object obj) { return default(int); }
        System.TypeCode System.IConvertible.GetTypeCode() { return default(System.TypeCode); }
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) { return default(bool); }
        byte System.IConvertible.ToByte(System.IFormatProvider provider) { return default(byte); }
        char System.IConvertible.ToChar(System.IFormatProvider provider) { return default(char); }
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) { return default(System.DateTime); }
        decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) { return default(decimal); }
        double System.IConvertible.ToDouble(System.IFormatProvider provider) { return default(double); }
        short System.IConvertible.ToInt16(System.IFormatProvider provider) { return default(short); }
        int System.IConvertible.ToInt32(System.IFormatProvider provider) { return default(int); }
        long System.IConvertible.ToInt64(System.IFormatProvider provider) { return default(long); }
        sbyte System.IConvertible.ToSByte(System.IFormatProvider provider) { return default(sbyte); }
        float System.IConvertible.ToSingle(System.IFormatProvider provider) { return default(float); }
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) { return default(object); }
        ushort System.IConvertible.ToUInt16(System.IFormatProvider provider) { return default(ushort); }
        uint System.IConvertible.ToUInt32(System.IFormatProvider provider) { return default(uint); }
        ulong System.IConvertible.ToUInt64(System.IFormatProvider provider) { return default(ulong); }
        /// <summary>
        /// Converts the numeric value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// The string representation of the value of this instance, consisting of a negative sign if the
        /// value is negative, and a sequence of digits ranging from 0 to 9 with no leading zeroes.
        /// </returns>
        public override string ToString() { return default(string); }
        /// <summary>
        /// Converts the numeric value of this instance to its equivalent string representation using the
        /// specified culture-specific format information.
        /// </summary>
        /// <param name="provider">An object that supplies culture-specific formatting information.</param>
        /// <returns>
        /// The string representation of the value of this instance, as specified by <paramref name="provider" />.
        /// </returns>
        public string ToString(System.IFormatProvider provider) { return default(string); }
        /// <summary>
        /// Converts the numeric value of this instance to its equivalent string representation, using
        /// the specified format.
        /// </summary>
        /// <param name="format">A standard or custom numeric format string.</param>
        /// <returns>
        /// The string representation of the value of this instance as specified by <paramref name="format" />.
        /// </returns>
        /// <exception cref="FormatException"><paramref name="format" /> is invalid.</exception>
        public string ToString(string format) { return default(string); }
        /// <summary>
        /// Converts the numeric value of this instance to its equivalent string representation using the
        /// specified format and culture-specific format information.
        /// </summary>
        /// <param name="format">A standard or custom numeric format string.</param>
        /// <param name="provider">An object that supplies culture-specific formatting information.</param>
        /// <returns>
        /// The string representation of the value of this instance as specified by <paramref name="format" />
        /// and <paramref name="provider" />.
        /// </returns>
        /// <exception cref="FormatException"><paramref name="format" /> is invalid.</exception>
        public string ToString(string format, System.IFormatProvider provider) { return default(string); }
        /// <summary>
        /// Tries to convert the string representation of a number in a specified style and culture-specific
        /// format to its <see cref="SByte" /> equivalent, and returns a value that indicates
        /// whether the conversion succeeded.
        /// </summary>
        /// <param name="s">A string representing a number to convert.</param>
        /// <param name="style">
        /// A bitwise combination of enumeration values that indicates the permitted format of <paramref name="s" />.
        /// A typical value to specify is <see cref="Globalization.NumberStyles.Integer" />.
        /// </param>
        /// <param name="provider">
        /// An object that supplies culture-specific formatting information about <paramref name="s" />.
        /// </param>
        /// <param name="result">
        /// When this method returns, contains the 8-bit signed integer value equivalent to the number
        /// contained in <paramref name="s" />, if the conversion succeeded, or zero if the conversion
        /// failed. The conversion fails if the <paramref name="s" /> parameter is null  or <see cref="String.Empty" />,
        /// is not in a format compliant with <paramref name="style" />, or represents a number less
        /// than <see cref="MinValue" /> or greater than <see cref="MaxValue" />.
        /// This parameter is passed uninitialized; any value originally supplied in <paramref name="result" />
        /// will be overwritten.
        /// </param>
        /// <returns>
        /// true if <paramref name="s" /> was converted successfully; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// <paramref name="style" /> is not a <see cref="Globalization.NumberStyles" /> value.
        /// -or-<paramref name="style" /> is not a combination of
        /// <see cref="Globalization.NumberStyles.AllowHexSpecifier" /> and <see cref="Globalization.NumberStyles.HexNumber" /> values.
        /// </exception>
        [System.CLSCompliantAttribute(false)]
        public static bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out sbyte result) { result = default(sbyte); return default(bool); }
        /// <summary>
        /// Tries to convert the string representation of a number to its <see cref="SByte" />
        /// equivalent, and returns a value that indicates whether the conversion succeeded.
        /// </summary>
        /// <param name="s">A string that contains a number to convert.</param>
        /// <param name="result">
        /// When this method returns, contains the 8-bit signed integer value that is equivalent to the
        /// number contained in <paramref name="s" /> if the conversion succeeded, or zero if the conversion
        /// failed. The conversion fails if the <paramref name="s" /> parameter is null  or <see cref="String.Empty" />,
        /// is not in the correct format, or represents a number that is less than
        /// <see cref="MinValue" /> or greater than <see cref="MaxValue" />. This parameter is passed uninitialized;
        /// any value originally supplied in <paramref name="result" /> will be overwritten.
        /// </param>
        /// <returns>
        /// true if <paramref name="s" /> was converted successfully; otherwise, false.
        /// </returns>
        [System.CLSCompliantAttribute(false)]
        public static bool TryParse(string s, out sbyte result) { result = default(sbyte); return default(bool); }
    }
    /// <summary>
    /// Represents a single-precision floating-point number.
    /// </summary>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct Single : System.IComparable, System.IComparable<float>, System.IConvertible, System.IEquatable<float>, System.IFormattable
    {
        /// <summary>
        /// Compares this instance to a specified single-precision floating-point number and returns an
        /// integer that indicates whether the value of this instance is less than, equal to, or greater than the
        /// value of the specified single-precision floating-point number.
        /// </summary>
        /// <param name="value">A single-precision floating-point number to compare.</param>
        /// <returns>
        /// A signed number indicating the relative values of this instance and <paramref name="value" />.
        /// Return Value Description Less than zero This instance is less than <paramref name="value" />.
        /// -or- This instance is not a number (<see cref="NaN" />) and <paramref name="value" />
        /// is a number. Zero This instance is equal to <paramref name="value" />.-or- Both this instance
        /// and <paramref name="value" /> are not a number (<see cref="NaN" />),
        /// <see cref="PositiveInfinity" />, or <see cref="NegativeInfinity" />.
        /// Greater than zero This instance is greater than <paramref name="value" />.-or- This instance
        /// is a number and <paramref name="value" /> is not a number (<see cref="NaN" />
        /// ).
        /// </returns>
        public int CompareTo(float value) { return default(int); }
        /// <summary>
        /// Returns a value indicating whether this instance is equal to a specified object.
        /// </summary>
        /// <param name="obj">An object to compare with this instance.</param>
        /// <returns>
        /// true if <paramref name="obj" /> is an instance of <see cref="Single" /> and equals
        /// the value of this instance; otherwise, false.
        /// </returns>
        public override bool Equals(object obj) { return default(bool); }
        /// <summary>
        /// Returns a value indicating whether this instance and a specified <see cref="Single" />
        /// object represent the same value.
        /// </summary>
        /// <param name="obj">An object to compare with this instance.</param>
        /// <returns>
        /// true if <paramref name="obj" /> is equal to this instance; otherwise, false.
        /// </returns>
        public bool Equals(float obj) { return default(bool); }
        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code.
        /// </returns>
        public override int GetHashCode() { return default(int); }
        /// <summary>
        /// Returns a value indicating whether the specified number evaluates to negative or positive infinity.
        /// </summary>
        /// <param name="f">A single-precision floating-point number.</param>
        /// <returns>
        /// true if <paramref name="f" /> evaluates to <see cref="PositiveInfinity" />
        /// or <see cref="NegativeInfinity" />; otherwise, false.
        /// </returns>
        public static bool IsInfinity(float f) { return default(bool); }
        /// <summary>
        /// Returns a value that indicates whether the specified value is not a number (<see cref="NaN" />
        /// ).
        /// </summary>
        /// <param name="f">A single-precision floating-point number.</param>
        /// <returns>
        /// true if <paramref name="f" /> evaluates to not a number (<see cref="NaN" />);
        /// otherwise, false.
        /// </returns>
        public static bool IsNaN(float f) { return default(bool); }
        /// <summary>
        /// Returns a value indicating whether the specified number evaluates to negative infinity.
        /// </summary>
        /// <param name="f">A single-precision floating-point number.</param>
        /// <returns>
        /// true if <paramref name="f" /> evaluates to <see cref="NegativeInfinity" />;
        /// otherwise, false.
        /// </returns>
        public static bool IsNegativeInfinity(float f) { return default(bool); }
        /// <summary>
        /// Returns a value indicating whether the specified number evaluates to positive infinity.
        /// </summary>
        /// <param name="f">A single-precision floating-point number.</param>
        /// <returns>
        /// true if <paramref name="f" /> evaluates to <see cref="PositiveInfinity" />;
        /// otherwise, false.
        /// </returns>
        public static bool IsPositiveInfinity(float f) { return default(bool); }
        /// <summary>
        /// Returns a value that indicates whether two specified <see cref="Single" /> values
        /// are equal.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns>
        /// true if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, false.
        /// </returns>
        public static bool operator ==(float left, float right) { return default(bool); }
        /// <summary>
        /// Returns a value that indicates whether a specified <see cref="Single" /> value is
        /// greater than another specified <see cref="Single" /> value.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns>
        /// true if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, false.
        /// </returns>
        public static bool operator >(float left, float right) { return default(bool); }
        /// <summary>
        /// Returns a value that indicates whether a specified <see cref="Single" /> value is
        /// greater than or equal to another specified <see cref="Single" /> value.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns>
        /// true if <paramref name="left" /> is greater than or equal to <paramref name="right" />; otherwise,
        /// false.
        /// </returns>
        public static bool operator >=(float left, float right) { return default(bool); }
        /// <summary>
        /// Returns a value that indicates whether two specified <see cref="Single" /> values
        /// are not equal.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns>
        /// true if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, false.
        /// </returns>
        public static bool operator !=(float left, float right) { return default(bool); }
        /// <summary>
        /// Returns a value that indicates whether a specified <see cref="Single" /> value is
        /// less than another specified <see cref="Single" /> value.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns>
        /// true if <paramref name="left" /> is less than <paramref name="right" />; otherwise, false.
        /// </returns>
        public static bool operator <(float left, float right) { return default(bool); }
        /// <summary>
        /// Returns a value that indicates whether a specified <see cref="Single" /> value is
        /// less than or equal to another specified <see cref="Single" /> value.
        /// </summary>
        /// <param name="left">The first value to compare.</param>
        /// <param name="right">The second value to compare.</param>
        /// <returns>
        /// true if <paramref name="left" /> is less than or equal to <paramref name="right" />; otherwise,
        /// false.
        /// </returns>
        public static bool operator <=(float left, float right) { return default(bool); }
        /// <summary>
        /// Converts the string representation of a number to its single-precision floating-point number
        /// equivalent.
        /// </summary>
        /// <param name="s">A string that contains a number to convert.</param>
        /// <returns>
        /// A single-precision floating-point number equivalent to the numeric value or symbol specified
        /// in <paramref name="s" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="FormatException">
        /// <paramref name="s" /> does not represent a number in a valid format.
        /// </exception>
        /// <exception cref="OverflowException">
        /// <paramref name="s" /> represents a number less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />.
        /// </exception>
        public static float Parse(string s) { return default(float); }
        /// <summary>
        /// Converts the string representation of a number in a specified style to its single-precision
        /// floating-point number equivalent.
        /// </summary>
        /// <param name="s">A string that contains a number to convert.</param>
        /// <param name="style">
        /// A bitwise combination of enumeration values that indicates the style elements that can be
        /// present in <paramref name="s" />. A typical value to specify is <see cref="Globalization.NumberStyles.Float" />
        /// combined with <see cref="Globalization.NumberStyles.AllowThousands" />.
        /// </param>
        /// <returns>
        /// A single-precision floating-point number that is equivalent to the numeric value or symbol
        /// specified in <paramref name="s" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="FormatException">
        /// <paramref name="s" /> is not a number in a valid format.
        /// </exception>
        /// <exception cref="OverflowException">
        /// <paramref name="s" /> represents a number that is less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="style" /> is not a <see cref="Globalization.NumberStyles" /> value.
        /// -or-<paramref name="style" /> includes the <see cref="Globalization.NumberStyles.AllowHexSpecifier" />
        /// value.
        /// </exception>
        public static float Parse(string s, System.Globalization.NumberStyles style) { return default(float); }
        /// <summary>
        /// Converts the string representation of a number in a specified style and culture-specific format
        /// to its single-precision floating-point number equivalent.
        /// </summary>
        /// <param name="s">A string that contains a number to convert.</param>
        /// <param name="style">
        /// A bitwise combination of enumeration values that indicates the style elements that can be
        /// present in <paramref name="s" />. A typical value to specify is <see cref="Globalization.NumberStyles.Float" />
        /// combined with <see cref="Globalization.NumberStyles.AllowThousands" />.
        /// </param>
        /// <param name="provider">
        /// An object that supplies culture-specific formatting information about <paramref name="s" />.
        /// </param>
        /// <returns>
        /// A single-precision floating-point number equivalent to the numeric value or symbol specified
        /// in <paramref name="s" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="FormatException">
        /// <paramref name="s" /> does not represent a numeric value.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="style" /> is not a <see cref="Globalization.NumberStyles" /> value.
        /// -or-<paramref name="style" /> is the <see cref="Globalization.NumberStyles.AllowHexSpecifier" />
        /// value.
        /// </exception>
        /// <exception cref="OverflowException">
        /// <paramref name="s" /> represents a number that is less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />.
        /// </exception>
        public static float Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider) { return default(float); }
        /// <summary>
        /// Converts the string representation of a number in a specified culture-specific format to its
        /// single-precision floating-point number equivalent.
        /// </summary>
        /// <param name="s">A string that contains a number to convert.</param>
        /// <param name="provider">
        /// An object that supplies culture-specific formatting information about <paramref name="s" />.
        /// </param>
        /// <returns>
        /// A single-precision floating-point number equivalent to the numeric value or symbol specified
        /// in <paramref name="s" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="FormatException">
        /// <paramref name="s" /> does not represent a number in a valid format.
        /// </exception>
        /// <exception cref="OverflowException">
        /// <paramref name="s" /> represents a number less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />.
        /// </exception>
        public static float Parse(string s, System.IFormatProvider provider) { return default(float); }
        int System.IComparable.CompareTo(object value) { return default(int); }
        System.TypeCode System.IConvertible.GetTypeCode() { return default(System.TypeCode); }
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) { return default(bool); }
        byte System.IConvertible.ToByte(System.IFormatProvider provider) { return default(byte); }
        char System.IConvertible.ToChar(System.IFormatProvider provider) { return default(char); }
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) { return default(System.DateTime); }
        decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) { return default(decimal); }
        double System.IConvertible.ToDouble(System.IFormatProvider provider) { return default(double); }
        short System.IConvertible.ToInt16(System.IFormatProvider provider) { return default(short); }
        int System.IConvertible.ToInt32(System.IFormatProvider provider) { return default(int); }
        long System.IConvertible.ToInt64(System.IFormatProvider provider) { return default(long); }
        sbyte System.IConvertible.ToSByte(System.IFormatProvider provider) { return default(sbyte); }
        float System.IConvertible.ToSingle(System.IFormatProvider provider) { return default(float); }
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) { return default(object); }
        ushort System.IConvertible.ToUInt16(System.IFormatProvider provider) { return default(ushort); }
        uint System.IConvertible.ToUInt32(System.IFormatProvider provider) { return default(uint); }
        ulong System.IConvertible.ToUInt64(System.IFormatProvider provider) { return default(ulong); }
        /// <summary>
        /// Converts the numeric value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// The string representation of the value of this instance.
        /// </returns>
        public override string ToString() { return default(string); }
        /// <summary>
        /// Converts the numeric value of this instance to its equivalent string representation using the
        /// specified culture-specific format information.
        /// </summary>
        /// <param name="provider">An object that supplies culture-specific formatting information.</param>
        /// <returns>
        /// The string representation of the value of this instance as specified by <paramref name="provider" />.
        /// </returns>
        public string ToString(System.IFormatProvider provider) { return default(string); }
        /// <summary>
        /// Converts the numeric value of this instance to its equivalent string representation, using
        /// the specified format.
        /// </summary>
        /// <param name="format">A numeric format string.</param>
        /// <returns>
        /// The string representation of the value of this instance as specified by <paramref name="format" />.
        /// </returns>
        /// <exception cref="FormatException"><paramref name="format" /> is invalid.</exception>
        public string ToString(string format) { return default(string); }
        /// <summary>
        /// Converts the numeric value of this instance to its equivalent string representation using the
        /// specified format and culture-specific format information.
        /// </summary>
        /// <param name="format">A numeric format string.</param>
        /// <param name="provider">An object that supplies culture-specific formatting information.</param>
        /// <returns>
        /// The string representation of the value of this instance as specified by <paramref name="format" />
        /// and <paramref name="provider" />.
        /// </returns>
        public string ToString(string format, System.IFormatProvider provider) { return default(string); }
        /// <summary>
        /// Converts the string representation of a number in a specified style and culture-specific format
        /// to its single-precision floating-point number equivalent. A return value indicates whether the
        /// conversion succeeded or failed.
        /// </summary>
        /// <param name="s">A string representing a number to convert.</param>
        /// <param name="style">
        /// A bitwise combination of enumeration values that indicates the permitted format of <paramref name="s" />.
        /// A typical value to specify is <see cref="Globalization.NumberStyles.Float" />
        /// combined with <see cref="Globalization.NumberStyles.AllowThousands" />.
        /// </param>
        /// <param name="provider">
        /// An object that supplies culture-specific formatting information about <paramref name="s" />.
        /// </param>
        /// <param name="result">
        /// When this method returns, contains the single-precision floating-point number equivalent to
        /// the numeric value or symbol contained in <paramref name="s" />, if the conversion succeeded,
        /// or zero if the conversion failed. The conversion fails if the <paramref name="s" /> parameter
        /// is null or <see cref="String.Empty" />, is not in a format compliant with <paramref name="style" />,
        /// represents a number less than <see cref="MinValue" /> or
        /// greater than <see cref="MaxValue" />, or if <paramref name="style" /> is not
        /// a valid combination of <see cref="Globalization.NumberStyles" /> enumerated constants.
        /// This parameter is passed uninitialized; any value originally supplied in <paramref name="result" />
        /// will be overwritten.
        /// </param>
        /// <returns>
        /// true if <paramref name="s" /> was converted successfully; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// <paramref name="style" /> is not a <see cref="Globalization.NumberStyles" /> value.
        /// -or-<paramref name="style" /> is the <see cref="Globalization.NumberStyles.AllowHexSpecifier" />
        /// value.
        /// </exception>
        public static bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out float result) { result = default(float); return default(bool); }
        /// <summary>
        /// Converts the string representation of a number to its single-precision floating-point number
        /// equivalent. A return value indicates whether the conversion succeeded or failed.
        /// </summary>
        /// <param name="s">A string representing a number to convert.</param>
        /// <param name="result">
        /// When this method returns, contains single-precision floating-point number equivalent to the
        /// numeric value or symbol contained in <paramref name="s" />, if the conversion succeeded, or
        /// zero if the conversion failed. The conversion fails if the <paramref name="s" /> parameter
        /// is null or <see cref="String.Empty" />, is not a number in a valid format, or represents
        /// a number less than <see cref="MinValue" /> or greater than <see cref="MaxValue" />.
        /// This parameter is passed uninitialized; any value originally supplied in <paramref name="result" />
        /// will be overwritten.
        /// </param>
        /// <returns>
        /// true if <paramref name="s" /> was converted successfully; otherwise, false.
        /// </returns>
        public static bool TryParse(string s, out float result) { result = default(float); return default(bool); }
    }
    /// <summary>
    /// Indicates that the COM threading model for an application is single-threaded apartment (STA).
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(64))]
    public sealed partial class STAThreadAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="STAThreadAttribute" /> class.
        /// </summary>
        public STAThreadAttribute() { }
    }
    /// <summary>
    /// Represents text as a sequence of UTF-16 code units.To browse the .NET Framework source code
    /// for this type, see the Reference Source.
    /// </summary>
    public sealed partial class String : System.Collections.Generic.IEnumerable<char>, System.Collections.IEnumerable, System.IComparable, System.IComparable<string>, System.IConvertible, System.IEquatable<string>
    {
        /// <summary>
        /// Represents the empty string. This field is read-only.
        /// </summary>
        public static readonly string Empty;
        /// <summary>
        /// Initializes a new instance of the <see cref="String" /> class to the value indicated
        /// by a specified pointer to an array of Unicode characters.
        /// </summary>
        /// <param name="value">A pointer to a null-terminated array of Unicode characters.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The current process does not have read access to all the addressed characters.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="value" /> specifies an array that contains an invalid Unicode character, or
        /// <paramref name="value" /> specifies an address less than 64000.
        /// </exception>
        [System.CLSCompliantAttribute(false)]
        [System.Security.SecurityCriticalAttribute]
        public unsafe String(char* value) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="String" /> class to the value indicated
        /// by a specified pointer to an array of Unicode characters, a starting character position within
        /// that array, and a length.
        /// </summary>
        /// <param name="value">A pointer to an array of Unicode characters.</param>
        /// <param name="startIndex">The starting position within <paramref name="value" />.</param>
        /// <param name="length">The number of characters within <paramref name="value" /> to use.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="startIndex" /> or <paramref name="length" /> is less than zero, <paramref name="value" />
        /// + <paramref name="startIndex" /> cause a pointer overflow, or the current
        /// process does not have read access to all the addressed characters.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="value" /> specifies an array that contains an invalid Unicode character, or
        /// <paramref name="value" /> + <paramref name="startIndex" /> specifies an address less than
        /// 64000.
        /// </exception>
        [System.CLSCompliantAttribute(false)]
        [System.Security.SecurityCriticalAttribute]
        public unsafe String(char* value, int startIndex, int length) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="String" /> class to the value indicated
        /// by a specified Unicode character repeated a specified number of times.
        /// </summary>
        /// <param name="c">A Unicode character.</param>
        /// <param name="count">The number of times <paramref name="c" /> occurs.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="count" /> is less than zero.
        /// </exception>
        public String(char c, int count) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="String" /> class to the value indicated
        /// by an array of Unicode characters.
        /// </summary>
        /// <param name="value">An array of Unicode characters.</param>
        public String(char[] value) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="String" /> class to the value indicated
        /// by an array of Unicode characters, a starting character position within that array, and a
        /// length.
        /// </summary>
        /// <param name="value">An array of Unicode characters.</param>
        /// <param name="startIndex">The starting position within <paramref name="value" />.</param>
        /// <param name="length">The number of characters within <paramref name="value" /> to use.</param>
        /// <exception cref="ArgumentNullException"><paramref name="value" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="startIndex" /> or <paramref name="length" /> is less than zero.-or- The sum
        /// of <paramref name="startIndex" /> and <paramref name="length" /> is greater than the number
        /// of elements in <paramref name="value" />.
        /// </exception>
        public String(char[] value, int startIndex, int length) { }
        /// <summary>
        /// Gets the <see cref="Char" /> object at a specified position in the current
        /// <see cref="String" /> object.
        /// </summary>
        /// <param name="index">A position in the current string.</param>
        /// <returns>
        /// The object at position <paramref name="index" />.
        /// </returns>
        /// <exception cref="IndexOutOfRangeException">
        /// <paramref name="index" /> is greater than or equal to the length of this object or less than
        /// zero.
        /// </exception>
        [System.Runtime.CompilerServices.IndexerName("Chars")]
        public char this[int index] { get { return default(char); } }
        /// <summary>
        /// Gets the number of characters in the current <see cref="String" /> object.
        /// </summary>
        /// <returns>
        /// The number of characters in the current string.
        /// </returns>
        public int Length { get { return default(int); } }
        /// <summary>
        /// Compares substrings of two specified <see cref="String" /> objects and returns an
        /// integer that indicates their relative position in the sort order.
        /// </summary>
        /// <param name="strA">The first string to use in the comparison.</param>
        /// <param name="indexA">The position of the substring within <paramref name="strA" />.</param>
        /// <param name="strB">The second string to use in the comparison.</param>
        /// <param name="indexB">The position of the substring within <paramref name="strB" />.</param>
        /// <param name="length">The maximum number of characters in the substrings to compare.</param>
        /// <returns>
        /// A 32-bit signed integer indicating the lexical relationship between the two comparands.Value
        /// Condition Less than zero The substring in <paramref name="strA" /> precedes the substring
        /// in <paramref name="strB" /> in the sort order. Zero The substrings occur in the same position
        /// in the sort order, or <paramref name="length" /> is zero. Greater than zero The substring
        /// in <paramref name="strA" /> follows the substring in <paramref name="strB" /> in the sort
        /// order.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="indexA" /> is greater than <paramref name="strA" />.<see cref="Length" />.
        /// -or- <paramref name="indexB" /> is greater than <paramref name="strB" />.
        /// <see cref="Length" />.-or- <paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" />
        /// is negative. -or-Either <paramref name="indexA" /> or <paramref name="indexB" /> is null,
        /// and <paramref name="length" /> is greater than zero.
        /// </exception>
        public static int Compare(string strA, int indexA, string strB, int indexB, int length) { return default(int); }
        /// <summary>
        /// Compares substrings of two specified <see cref="String" /> objects using the specified
        /// rules, and returns an integer that indicates their relative position in the sort order.
        /// </summary>
        /// <param name="strA">The first string to use in the comparison.</param>
        /// <param name="indexA">The position of the substring within <paramref name="strA" />.</param>
        /// <param name="strB">The second string to use in the comparison.</param>
        /// <param name="indexB">The position of the substring within <paramref name="strB" />.</param>
        /// <param name="length">The maximum number of characters in the substrings to compare.</param>
        /// <param name="comparisonType">
        /// One of the enumeration values that specifies the rules to use in the comparison.
        /// </param>
        /// <returns>
        /// A 32-bit signed integer that indicates the lexical relationship between the two comparands.Value
        /// Condition Less than zero The substring in <paramref name="strA" /> precedes the substring
        /// in <paramref name="strB" /> in the sort order.Zero The substrings occur in the same position
        /// in the sort order, or the <paramref name="length" /> parameter is zero. Greater than zero
        /// The substring in <paramref name="strA" /> follllows the substring in <paramref name="strB" />
        /// in the sort order.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="indexA" /> is greater than <paramref name="strA" />.<see cref="Length" />.
        /// -or- <paramref name="indexB" /> is greater than <paramref name="strB" />.
        /// <see cref="Length" />.-or- <paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" />
        /// is negative. -or-Either <paramref name="indexA" /> or <paramref name="indexB" /> is null,
        /// and <paramref name="length" /> is greater than zero.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="comparisonType" /> is not a <see cref="StringComparison" /> value.
        /// </exception>
        public static int Compare(string strA, int indexA, string strB, int indexB, int length, System.StringComparison comparisonType) { return default(int); }
        /// <summary>
        /// Compares two specified <see cref="String" /> objects and returns an integer that
        /// indicates their relative position in the sort order.
        /// </summary>
        /// <param name="strA">The first string to compare.</param>
        /// <param name="strB">The second string to compare.</param>
        /// <returns>
        /// A 32-bit signed integer that indicates the lexical relationship between the two comparands.Value
        /// Condition Less than zero <paramref name="strA" /> precedes <paramref name="strB" /> in the
        /// sort order. Zero <paramref name="strA" /> occurs in the same position as <paramref name="strB" />
        /// in the sort order. Greater than zero <paramref name="strA" /> follows <paramref name="strB" />
        /// in the sort order.
        /// </returns>
        public static int Compare(string strA, string strB) { return default(int); }
        /// <summary>
        /// Compares two specified <see cref="String" /> objects, ignoring or honoring their
        /// case, and returns an integer that indicates their relative position in the sort order.
        /// </summary>
        /// <param name="strA">The first string to compare.</param>
        /// <param name="strB">The second string to compare.</param>
        /// <param name="ignoreCase">true to ignore case during the comparison; otherwise, false.</param>
        /// <returns>
        /// A 32-bit signed integer that indicates the lexical relationship between the two comparands.Value
        /// Condition Less than zero <paramref name="strA" /> precedes <paramref name="strB" /> in the
        /// sort order. Zero <paramref name="strA" /> occurs in the same position as <paramref name="strB" />
        /// in the sort order. Greater than zero <paramref name="strA" />follows <paramref name="strB" />
        /// in the sort order.
        /// </returns>
        public static int Compare(string strA, string strB, bool ignoreCase) { return default(int); }
        /// <summary>
        /// Compares two specified <see cref="String" /> objects using the specified rules, and
        /// returns an integer that indicates their relative position in the sort order.
        /// </summary>
        /// <param name="strA">The first string to compare.</param>
        /// <param name="strB">The second string to compare.</param>
        /// <param name="comparisonType">
        /// One of the enumeration values that specifies the rules to use in the comparison.
        /// </param>
        /// <returns>
        /// A 32-bit signed integer that indicates the lexical relationship between the two comparands.Value
        /// Condition Less than zero <paramref name="strA" /> precedes <paramref name="strB" /> in the
        /// sort order. Zero <paramref name="strA" />is in the same position as <paramref name="strB" />
        /// in the sort order. Greater than zero <paramref name="strA" /> follows <paramref name="strB" />
        /// in the sort order.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// <paramref name="comparisonType" /> is not a <see cref="StringComparison" /> value.
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <see cref="StringComparison" /> is not supported.
        /// </exception>
        public static int Compare(string strA, string strB, System.StringComparison comparisonType) { return default(int); }
        /// <summary>
        /// Compares substrings of two specified <see cref="String" /> objects by evaluating
        /// the numeric values of the corresponding <see cref="Char" /> objects in each substring.
        /// </summary>
        /// <param name="strA">The first string to use in the comparison.</param>
        /// <param name="indexA">The starting index of the substring in <paramref name="strA" />.</param>
        /// <param name="strB">The second string to use in the comparison.</param>
        /// <param name="indexB">The starting index of the substring in <paramref name="strB" />.</param>
        /// <param name="length">The maximum number of characters in the substrings to compare.</param>
        /// <returns>
        /// A 32-bit signed integer that indicates the lexical relationship between the two comparands.ValueConditionLess
        /// than zero The substring in <paramref name="strA" /> is less than the substring in
        /// <paramref name="strB" />. Zero The substrings are equal, or <paramref name="length" /> is zero. Greater
        /// than zero The substring in <paramref name="strA" /> is greater than the substring in <paramref name="strB" />.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="strA" /> is not null and <paramref name="indexA" /> is greater than <paramref name="strA" />.
        /// <see cref="Length" />.-or- <paramref name="strB" /> is not
        /// null and<paramref name="indexB" /> is greater than <paramref name="strB" />.<see cref="Length" />.
        /// -or- <paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" />
        /// is negative.
        /// </exception>
        public static int CompareOrdinal(string strA, int indexA, string strB, int indexB, int length) { return default(int); }
        /// <summary>
        /// Compares two specified <see cref="String" /> objects by evaluating the numeric values
        /// of the corresponding <see cref="Char" /> objects in each string.
        /// </summary>
        /// <param name="strA">The first string to compare.</param>
        /// <param name="strB">The second string to compare.</param>
        /// <returns>
        /// An integer that indicates the lexical relationship between the two comparands.ValueCondition
        /// Less than zero <paramref name="strA" /> is less than <paramref name="strB" />. Zero <paramref name="strA" />
        /// and <paramref name="strB" /> are equal. Greater than zero <paramref name="strA" />
        /// is greater than <paramref name="strB" />.
        /// </returns>
        public static int CompareOrdinal(string strA, string strB) { return default(int); }
        /// <summary>
        /// Compares this instance with a specified <see cref="String" /> object and indicates
        /// whether this instance precedes, follows, or appears in the same position in the sort order
        /// as the specified string.
        /// </summary>
        /// <param name="strB">The string to compare with this instance.</param>
        /// <returns>
        /// A 32-bit signed integer that indicates whether this instance precedes, follows, or appears
        /// in the same position in the sort order as the <paramref name="strB" /> parameter.Value Condition
        /// Less than zero This instance precedes <paramref name="strB" />. Zero This instance has the
        /// same position in the sort order as <paramref name="strB" />. Greater than zero This instance
        /// follows <paramref name="strB" />.-or- <paramref name="strB" /> is null.
        /// </returns>
        public int CompareTo(string strB) { return default(int); }
        /// <summary>
        /// Concatenates the members of a constructed <see cref="Collections.Generic.IEnumerable`1" />
        /// collection of type <see cref="String" />.
        /// </summary>
        /// <param name="values">
        /// A collection object that implements <see cref="Collections.Generic.IEnumerable`1" />
        /// and whose generic type argument is <see cref="String" />.
        /// </param>
        /// <returns>
        /// The concatenated strings in <paramref name="values" />, or <see cref="Empty" />
        /// if <paramref name="values" /> is an empty IEnumerable(Of String).
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="values" /> is null.</exception>
        public static string Concat(System.Collections.Generic.IEnumerable<string> values) { return default(string); }
        /// <summary>
        /// Creates the string  representation of a specified object.
        /// </summary>
        /// <param name="arg0">The object to represent, or null.</param>
        /// <returns>
        /// The string representation of the value of <paramref name="arg0" />, or <see cref="Empty" />
        /// if <paramref name="arg0" /> is null.
        /// </returns>
        public static string Concat(object arg0) { return default(string); }
        /// <summary>
        /// Concatenates the string representations of two specified objects.
        /// </summary>
        /// <param name="arg0">The first object to concatenate.</param>
        /// <param name="arg1">The second object to concatenate.</param>
        /// <returns>
        /// The concatenated string representations of the values of <paramref name="arg0" /> and <paramref name="arg1" />.
        /// </returns>
        public static string Concat(object arg0, object arg1) { return default(string); }
        /// <summary>
        /// Concatenates the string representations of three specified objects.
        /// </summary>
        /// <param name="arg0">The first object to concatenate.</param>
        /// <param name="arg1">The second object to concatenate.</param>
        /// <param name="arg2">The third object to concatenate.</param>
        /// <returns>
        /// The concatenated string representations of the values of <paramref name="arg0" />, <paramref name="arg1" />,
        /// and <paramref name="arg2" />.
        /// </returns>
        public static string Concat(object arg0, object arg1, object arg2) { return default(string); }
        /// <summary>
        /// Concatenates the string representations of the elements in a specified <see cref="Object" />
        /// array.
        /// </summary>
        /// <param name="args">An object array that contains the elements to concatenate.</param>
        /// <returns>
        /// The concatenated string representations of the values of the elements in <paramref name="args" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="args" /> is null.</exception>
        /// <exception cref="OutOfMemoryException">Out of memory.</exception>
        public static string Concat(params object[] args) { return default(string); }
        /// <summary>
        /// Concatenates two specified instances of <see cref="String" />.
        /// </summary>
        /// <param name="str0">The first string to concatenate.</param>
        /// <param name="str1">The second string to concatenate.</param>
        /// <returns>
        /// The concatenation of <paramref name="str0" /> and <paramref name="str1" />.
        /// </returns>
        public static string Concat(string str0, string str1) { return default(string); }
        /// <summary>
        /// Concatenates three specified instances of <see cref="String" />.
        /// </summary>
        /// <param name="str0">The first string to concatenate.</param>
        /// <param name="str1">The second string to concatenate.</param>
        /// <param name="str2">The third string to concatenate.</param>
        /// <returns>
        /// The concatenation of <paramref name="str0" />, <paramref name="str1" />, and <paramref name="str2" />.
        /// </returns>
        public static string Concat(string str0, string str1, string str2) { return default(string); }
        /// <summary>
        /// Concatenates four specified instances of <see cref="String" />.
        /// </summary>
        /// <param name="str0">The first string to concatenate.</param>
        /// <param name="str1">The second string to concatenate.</param>
        /// <param name="str2">The third string to concatenate.</param>
        /// <param name="str3">The fourth string to concatenate.</param>
        /// <returns>
        /// The concatenation of <paramref name="str0" />, <paramref name="str1" />, <paramref name="str2" />,
        /// and <paramref name="str3" />.
        /// </returns>
        public static string Concat(string str0, string str1, string str2, string str3) { return default(string); }
        /// <summary>
        /// Concatenates the elements of a specified <see cref="String" /> array.
        /// </summary>
        /// <param name="values">An array of string instances.</param>
        /// <returns>
        /// The concatenated elements of <paramref name="values" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="values" /> is null.</exception>
        /// <exception cref="OutOfMemoryException">Out of memory.</exception>
        public static string Concat(params string[] values) { return default(string); }
        /// <summary>
        /// Concatenates the members of an <see cref="Collections.Generic.IEnumerable`1" /> implementation.
        /// </summary>
        /// <param name="values">
        /// A collection object that implements the <see cref="Collections.Generic.IEnumerable`1" />
        /// interface.
        /// </param>
        /// <typeparam name="T">The type of the members of <paramref name="values" />.</typeparam>
        /// <returns>
        /// The concatenated members in <paramref name="values" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="values" /> is null.</exception>
        public static string Concat<T>(System.Collections.Generic.IEnumerable<T> values) { return default(string); }
        /// <summary>
        /// Returns a value indicating whether a specified substring occurs within this string.
        /// </summary>
        /// <param name="value">The string to seek.</param>
        /// <returns>
        /// true if the <paramref name="value" /> parameter occurs within this string, or if <paramref name="value" />
        /// is the empty string (""); otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="value" /> is null.</exception>
        public bool Contains(string value) { return default(bool); }
        /// <summary>
        /// Copies a specified number of characters from a specified position in this instance to a specified
        /// position in an array of Unicode characters.
        /// </summary>
        /// <param name="sourceIndex">The index of the first character in this instance to copy.</param>
        /// <param name="destination">An array of Unicode characters to which characters in this instance are copied.</param>
        /// <param name="destinationIndex">
        /// The index in <paramref name="destination" /> at which the copy operation begins.
        /// </param>
        /// <param name="count">The number of characters in this instance to copy to <paramref name="destination" />.</param>
        /// <exception cref="ArgumentNullException"><paramref name="destination" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="sourceIndex" />, <paramref name="destinationIndex" />, or <paramref name="count" />
        /// is negative -or- <paramref name="sourceIndex" /> does not identify a position in the current
        /// instance. -or-<paramref name="destinationIndex" /> does not identify a valid index in the
        /// <paramref name="destination" /> array. -or-<paramref name="count" /> is greater than the length
        /// of the substring from <paramref name="startIndex" /> to the end of this instance -or- <paramref name="count" />
        /// is greater than the length of the subarray from <paramref name="destinationIndex" />
        /// to the end of the <paramref name="destination" /> array.
        /// </exception>
        public void CopyTo(int sourceIndex, char[] destination, int destinationIndex, int count) { }
        /// <summary>
        /// Determines whether the end of this string instance matches the specified string.
        /// </summary>
        /// <param name="value">The string to compare to the substring at the end of this instance.</param>
        /// <returns>
        /// true if <paramref name="value" /> matches the end of this instance; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="value" /> is null.</exception>
        public bool EndsWith(string value) { return default(bool); }
        /// <summary>
        /// Determines whether the end of this string instance matches the specified string when compared
        /// using the specified comparison option.
        /// </summary>
        /// <param name="value">The string to compare to the substring at the end of this instance.</param>
        /// <param name="comparisonType">
        /// One of the enumeration values that determines how this string and <paramref name="value" />
        /// are compared.
        /// </param>
        /// <returns>
        /// true if the <paramref name="value" /> parameter matches the end of this string; otherwise,
        /// false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="value" /> is null.</exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="comparisonType" /> is not a <see cref="StringComparison" /> value.
        /// </exception>
        public bool EndsWith(string value, System.StringComparison comparisonType) { return default(bool); }
        /// <summary>
        /// Determines whether this instance and a specified object, which must also be a <see cref="String" />
        /// object, have the same value.
        /// </summary>
        /// <param name="obj">The string to compare to this instance.</param>
        /// <returns>
        /// true if <paramref name="obj" /> is a <see cref="String" /> and its value is the same
        /// as this instance; otherwise, false.  If <paramref name="obj" /> is null, the method returns
        /// false.
        /// </returns>
        public override bool Equals(object obj) { return default(bool); }
        /// <summary>
        /// Determines whether this instance and another specified <see cref="String" /> object
        /// have the same value.
        /// </summary>
        /// <param name="value">The string to compare to this instance.</param>
        /// <returns>
        /// true if the value of the <paramref name="value" /> parameter is the same as the value of this
        /// instance; otherwise, false. If <paramref name="value" /> is null, the method returns false.
        /// </returns>
        public bool Equals(string value) { return default(bool); }
        /// <summary>
        /// Determines whether two specified <see cref="String" /> objects have the same value.
        /// </summary>
        /// <param name="a">The first string to compare, or null.</param>
        /// <param name="b">The second string to compare, or null.</param>
        /// <returns>
        /// true if the value of <paramref name="a" /> is the same as the value of <paramref name="b" />;
        /// otherwise, false. If both <paramref name="a" /> and <paramref name="b" /> are null, the
        /// method returns true.
        /// </returns>
        public static bool Equals(string a, string b) { return default(bool); }
        /// <summary>
        /// Determines whether two specified <see cref="String" /> objects have the same value.
        /// A parameter specifies the culture, case, and sort rules used in the comparison.
        /// </summary>
        /// <param name="a">The first string to compare, or null.</param>
        /// <param name="b">The second string to compare, or null.</param>
        /// <param name="comparisonType">One of the enumeration values that specifies the rules for the comparison.</param>
        /// <returns>
        /// true if the value of the <paramref name="a" /> parameter is equal to the value of the <paramref name="b" />
        /// parameter; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// <paramref name="comparisonType" /> is not a <see cref="StringComparison" /> value.
        /// </exception>
        public static bool Equals(string a, string b, System.StringComparison comparisonType) { return default(bool); }
        /// <summary>
        /// Determines whether this string and a specified <see cref="String" /> object have
        /// the same value. A parameter specifies the culture, case, and sort rules used in the comparison.
        /// </summary>
        /// <param name="value">The string to compare to this instance.</param>
        /// <param name="comparisonType">One of the enumeration values that specifies how the strings will be compared.</param>
        /// <returns>
        /// true if the value of the <paramref name="value" /> parameter is the same as this string; otherwise,
        /// false.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// <paramref name="comparisonType" /> is not a <see cref="StringComparison" /> value.
        /// </exception>
        public bool Equals(string value, System.StringComparison comparisonType) { return default(bool); }
        /// <summary>
        /// Replaces the format item or items in a specified string with the string representation of the
        /// corresponding object. A parameter supplies culture-specific formatting information.
        /// </summary>
        /// <param name="provider">An object that supplies culture-specific formatting information.</param>
        /// <param name="format">A composite format string.</param>
        /// <param name="arg0">The object to format.</param>
        /// <returns>
        /// A copy of <paramref name="format" /> in which the format item or items have been replaced
        /// by the string representation of <paramref name="arg0" />.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="format" /> or <paramref name="arg0" /> is null.
        /// </exception>
        /// <exception cref="FormatException">
        /// <paramref name="format" /> is invalid.-or- The index of a format item is less than zero, or
        /// greater than or equal to one.
        /// </exception>
        public static string Format(System.IFormatProvider provider, string format, object arg0) { return default(string); }
        /// <summary>
        /// Replaces the format items in a specified string with the string representation of two specified
        /// objects. A parameter supplies culture-specific formatting information.
        /// </summary>
        /// <param name="provider">An object that supplies culture-specific formatting information.</param>
        /// <param name="format">A composite format string.</param>
        /// <param name="arg0">The first object to format.</param>
        /// <param name="arg1">The second object to format.</param>
        /// <returns>
        /// A copy of <paramref name="format" /> in which format items are replaced by the string representations
        /// of <paramref name="arg0" /> and <paramref name="arg1" />.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="format" />, <paramref name="arg0" />, or <paramref name="arg1" /> is null.
        /// </exception>
        /// <exception cref="FormatException">
        /// <paramref name="format" /> is invalid.-or- The index of a format item is less than zero, or
        /// greater than or equal to two.
        /// </exception>
        public static string Format(System.IFormatProvider provider, string format, object arg0, object arg1) { return default(string); }
        /// <summary>
        /// Replaces the format items in a specified string with the string representation of three specified
        /// objects. An parameter supplies culture-specific formatting information.
        /// </summary>
        /// <param name="provider">An object that supplies culture-specific formatting information.</param>
        /// <param name="format">A composite format string.</param>
        /// <param name="arg0">The first object to format.</param>
        /// <param name="arg1">The second object to format.</param>
        /// <param name="arg2">The third object to format.</param>
        /// <returns>
        /// A copy of <paramref name="format" /> in which the format items have been replaced by the string
        /// representations of <paramref name="arg0" />, <paramref name="arg1" />, and <paramref name="arg2" />.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="format" />, <paramref name="arg0" />, <paramref name="arg1" />, or <paramref name="arg2" />
        /// is null.
        /// </exception>
        /// <exception cref="FormatException">
        /// <paramref name="format" /> is invalid.-or- The index of a format item is less than zero, or
        /// greater than or equal to three.
        /// </exception>
        public static string Format(System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) { return default(string); }
        /// <summary>
        /// Replaces the format items in a specified string with the string representations of corresponding
        /// objects in a specified array. A parameter supplies culture-specific formatting information.
        /// </summary>
        /// <param name="provider">An object that supplies culture-specific formatting information.</param>
        /// <param name="format">A composite format string.</param>
        /// <param name="args">An object array that contains zero or more objects to format.</param>
        /// <returns>
        /// A copy of <paramref name="format" /> in which the format items have been replaced by the string
        /// representation of the corresponding objects in <paramref name="args" />.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="format" /> or <paramref name="args" /> is null.
        /// </exception>
        /// <exception cref="FormatException">
        /// <paramref name="format" /> is invalid.-or- The index of a format item is less than zero, or
        /// greater than or equal to the length of the <paramref name="args" /> array.
        /// </exception>
        public static string Format(System.IFormatProvider provider, string format, params object[] args) { return default(string); }
        /// <summary>
        /// Replaces one or more format items in a specified string with the string representation of a
        /// specified object.
        /// </summary>
        /// <param name="format">A composite format string.</param>
        /// <param name="arg0">The object to format.</param>
        /// <returns>
        /// A copy of <paramref name="format" /> in which any format items are replaced by the string
        /// representation of <paramref name="arg0" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="format" /> is null.</exception>
        /// <exception cref="FormatException">
        /// The format item in <paramref name="format" /> is invalid.-or- The index of a format item is
        /// not zero.
        /// </exception>
        public static string Format(string format, object arg0) { return default(string); }
        /// <summary>
        /// Replaces the format items in a specified string with the string representation of two specified
        /// objects.
        /// </summary>
        /// <param name="format">A composite format string.</param>
        /// <param name="arg0">The first object to format.</param>
        /// <param name="arg1">The second object to format.</param>
        /// <returns>
        /// A copy of <paramref name="format" /> in which format items are replaced by the string representations
        /// of <paramref name="arg0" /> and <paramref name="arg1" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="format" /> is null.</exception>
        /// <exception cref="FormatException">
        /// <paramref name="format" /> is invalid.-or- The index of a format item is not zero or one.
        /// </exception>
        public static string Format(string format, object arg0, object arg1) { return default(string); }
        /// <summary>
        /// Replaces the format items in a specified string with the string representation of three specified
        /// objects.
        /// </summary>
        /// <param name="format">A composite format string.</param>
        /// <param name="arg0">The first object to format.</param>
        /// <param name="arg1">The second object to format.</param>
        /// <param name="arg2">The third object to format.</param>
        /// <returns>
        /// A copy of <paramref name="format" /> in which the format items have been replaced by the string
        /// representations of <paramref name="arg0" />, <paramref name="arg1" />, and <paramref name="arg2" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="format" /> is null.</exception>
        /// <exception cref="FormatException">
        /// <paramref name="format" /> is invalid.-or- The index of a format item is less than zero, or
        /// greater than two.
        /// </exception>
        public static string Format(string format, object arg0, object arg1, object arg2) { return default(string); }
        /// <summary>
        /// Replaces the format item in a specified string with the string representation of a corresponding
        /// object in a specified array.
        /// </summary>
        /// <param name="format">A composite format string.</param>
        /// <param name="args">An object array that contains zero or more objects to format.</param>
        /// <returns>
        /// A copy of <paramref name="format" /> in which the format items have been replaced by the string
        /// representation of the corresponding objects in <paramref name="args" />.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="format" /> or <paramref name="args" /> is null.
        /// </exception>
        /// <exception cref="FormatException">
        /// <paramref name="format" /> is invalid.-or- The index of a format item is less than zero, or
        /// greater than or equal to the length of the <paramref name="args" /> array.
        /// </exception>
        public static string Format(string format, params object[] args) { return default(string); }
        /// <summary>
        /// Returns the hash code for this string.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code.
        /// </returns>
        public override int GetHashCode() { return default(int); }
        /// <summary>
        /// Reports the zero-based index of the first occurrence of the specified Unicode character in
        /// this string.
        /// </summary>
        /// <param name="value">A Unicode character to seek.</param>
        /// <returns>
        /// The zero-based index position of <paramref name="value" /> if that character is found, or
        /// -1 if it is not.
        /// </returns>
        public int IndexOf(char value) { return default(int); }
        /// <summary>
        /// Reports the zero-based index of the first occurrence of the specified Unicode character in
        /// this string. The search starts at a specified character position.
        /// </summary>
        /// <param name="value">A Unicode character to seek.</param>
        /// <param name="startIndex">The search starting position.</param>
        /// <returns>
        /// The zero-based index position of <paramref name="value" /> from the start of the string if
        /// that character is found, or -1 if it is not.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="startIndex" /> is less than 0 (zero) or greater than the length of the string.
        /// </exception>
        public int IndexOf(char value, int startIndex) { return default(int); }
        /// <summary>
        /// Reports the zero-based index of the first occurrence of the specified character in this instance.
        /// The search starts at a specified character position and examines a specified number of character
        /// positions.
        /// </summary>
        /// <param name="value">A Unicode character to seek.</param>
        /// <param name="startIndex">The search starting position.</param>
        /// <param name="count">The number of character positions to examine.</param>
        /// <returns>
        /// The zero-based index position of <paramref name="value" /> from the start of the string if
        /// that character is found, or -1 if it is not.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="count" /> or <paramref name="startIndex" /> is negative.-or- <paramref name="startIndex" />
        /// is greater than the length of this string.-or-<paramref name="count" /> is greater than
        /// the length of this string minus <paramref name="startIndex" />.
        /// </exception>
        public int IndexOf(char value, int startIndex, int count) { return default(int); }
        /// <summary>
        /// Reports the zero-based index of the first occurrence of the specified string in this instance.
        /// </summary>
        /// <param name="value">The string to seek.</param>
        /// <returns>
        /// The zero-based index position of <paramref name="value" /> if that string is found, or -1
        /// if it is not. If <paramref name="value" /> is <see cref="Empty" />, the return
        /// value is 0.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="value" /> is null.</exception>
        public int IndexOf(string value) { return default(int); }
        /// <summary>
        /// Reports the zero-based index of the first occurrence of the specified string in this instance.
        /// The search starts at a specified character position.
        /// </summary>
        /// <param name="value">The string to seek.</param>
        /// <param name="startIndex">The search starting position.</param>
        /// <returns>
        /// The zero-based index position of <paramref name="value" /> from the start of the current instance
        /// if that string is found, or -1 if it is not. If <paramref name="value" /> is <see cref="Empty" />,
        /// the return value is <paramref name="startIndex" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="value" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="startIndex" /> is less than 0 (zero) or greater than the length of this string.
        /// </exception>
        public int IndexOf(string value, int startIndex) { return default(int); }
        /// <summary>
        /// Reports the zero-based index of the first occurrence of the specified string in this instance.
        /// The search starts at a specified character position and examines a specified number of character
        /// positions.
        /// </summary>
        /// <param name="value">The string to seek.</param>
        /// <param name="startIndex">The search starting position.</param>
        /// <param name="count">The number of character positions to examine.</param>
        /// <returns>
        /// The zero-based index position of <paramref name="value" /> from the start of the current instance
        /// if that string is found, or -1 if it is not. If <paramref name="value" /> is <see cref="Empty" />,
        /// the return value is <paramref name="startIndex" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="value" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="count" /> or <paramref name="startIndex" /> is negative.-or- <paramref name="startIndex" />
        /// is greater than the length of this string.-or-<paramref name="count" /> is greater than
        /// the length of this string minus <paramref name="startIndex" />.
        /// </exception>
        public int IndexOf(string value, int startIndex, int count) { return default(int); }
        /// <summary>
        /// Reports the zero-based index of the first occurrence of the specified string in the current
        /// <see cref="String" /> object. Parameters specify the starting search position in
        /// the current string, the number of characters in the current string to search, and the type
        /// of search to use for the specified string.
        /// </summary>
        /// <param name="value">The string to seek.</param>
        /// <param name="startIndex">The search starting position.</param>
        /// <param name="count">The number of character positions to examine.</param>
        /// <param name="comparisonType">One of the enumeration values that specifies the rules for the search.</param>
        /// <returns>
        /// The zero-based index position of the <paramref name="value" /> parameter from the start of
        /// the current instance if that string is found, or -1 if it is not. If <paramref name="value" />
        /// is <see cref="Empty" />, the return value is <paramref name="startIndex" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="value" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="count" /> or <paramref name="startIndex" /> is negative.-or- <paramref name="startIndex" />
        /// is greater than the length of this instance.-or-<paramref name="count" /> is greater than
        /// the length of this string minus <paramref name="startIndex" />.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="comparisonType" /> is not a valid <see cref="StringComparison" />
        /// value.
        /// </exception>
        public int IndexOf(string value, int startIndex, int count, System.StringComparison comparisonType) { return default(int); }
        /// <summary>
        /// Reports the zero-based index of the first occurrence of the specified string in the current
        /// <see cref="String" /> object. Parameters specify the starting search position in
        /// the current string and the type of search to use for the specified string.
        /// </summary>
        /// <param name="value">The string to seek.</param>
        /// <param name="startIndex">The search starting position.</param>
        /// <param name="comparisonType">One of the enumeration values that specifies the rules for the search.</param>
        /// <returns>
        /// The zero-based index position of the <paramref name="value" /> parameter from the start of
        /// the current instance if that string is found, or -1 if it is not. If <paramref name="value" />
        /// is <see cref="Empty" />, the return value is <paramref name="startIndex" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="value" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="startIndex" /> is less than 0 (zero) or greater than the length of this string.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="comparisonType" /> is not a valid <see cref="StringComparison" />
        /// value.
        /// </exception>
        public int IndexOf(string value, int startIndex, System.StringComparison comparisonType) { return default(int); }
        /// <summary>
        /// Reports the zero-based index of the first occurrence of the specified string in the current
        /// <see cref="String" /> object. A parameter specifies the type of search to use for
        /// the specified string.
        /// </summary>
        /// <param name="value">The string to seek.</param>
        /// <param name="comparisonType">One of the enumeration values that specifies the rules for the search.</param>
        /// <returns>
        /// The index position of the <paramref name="value" /> parameter if that string is found, or
        /// -1 if it is not. If <paramref name="value" /> is <see cref="Empty" />, the
        /// return value is 0.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="value" /> is null.</exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="comparisonType" /> is not a valid <see cref="StringComparison" />
        /// value.
        /// </exception>
        public int IndexOf(string value, System.StringComparison comparisonType) { return default(int); }
        /// <summary>
        /// Reports the zero-based index of the first occurrence in this instance of any character in a
        /// specified array of Unicode characters.
        /// </summary>
        /// <param name="anyOf">A Unicode character array containing one or more characters to seek.</param>
        /// <returns>
        /// The zero-based index position of the first occurrence in this instance where any character
        /// in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was
        /// found.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="anyOf" /> is null.</exception>
        public int IndexOfAny(char[] anyOf) { return default(int); }
        /// <summary>
        /// Reports the zero-based index of the first occurrence in this instance of any character in a
        /// specified array of Unicode characters. The search starts at a specified character position.
        /// </summary>
        /// <param name="anyOf">A Unicode character array containing one or more characters to seek.</param>
        /// <param name="startIndex">The search starting position.</param>
        /// <returns>
        /// The zero-based index position of the first occurrence in this instance where any character
        /// in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was
        /// found.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="anyOf" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="startIndex" /> is negative.-or- <paramref name="startIndex" /> is greater
        /// than the number of characters in this instance.
        /// </exception>
        public int IndexOfAny(char[] anyOf, int startIndex) { return default(int); }
        /// <summary>
        /// Reports the zero-based index of the first occurrence in this instance of any character in a
        /// specified array of Unicode characters. The search starts at a specified character position and examines
        /// a specified number of character positions.
        /// </summary>
        /// <param name="anyOf">A Unicode character array containing one or more characters to seek.</param>
        /// <param name="startIndex">The search starting position.</param>
        /// <param name="count">The number of character positions to examine.</param>
        /// <returns>
        /// The zero-based index position of the first occurrence in this instance where any character
        /// in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was
        /// found.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="anyOf" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="count" /> or <paramref name="startIndex" /> is negative.-or- <paramref name="count" />
        /// + <paramref name="startIndex" /> is greater than the number of characters in this instance.
        /// </exception>
        public int IndexOfAny(char[] anyOf, int startIndex, int count) { return default(int); }
        /// <summary>
        /// Returns a new string in which a specified string is inserted at a specified index position
        /// in this instance.
        /// </summary>
        /// <param name="startIndex">The zero-based index position of the insertion.</param>
        /// <param name="value">The string to insert.</param>
        /// <returns>
        /// A new string that is equivalent to this instance, but with <paramref name="value" /> inserted
        /// at position <paramref name="startIndex" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="value" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="startIndex" /> is negative or greater than the length of this instance.
        /// </exception>
        public string Insert(int startIndex, string value) { return default(string); }
        /// <summary>
        /// Indicates whether the specified string is null or an <see cref="Empty" />
        /// string.
        /// </summary>
        /// <param name="value">The string to test.</param>
        /// <returns>
        /// true if the <paramref name="value" /> parameter is null or an empty string (""); otherwise,
        /// false.
        /// </returns>
        public static bool IsNullOrEmpty(string value) { return default(bool); }
        /// <summary>
        /// Indicates whether a specified string is null, empty, or consists only of white-space characters.
        /// </summary>
        /// <param name="value">The string to test.</param>
        /// <returns>
        /// true if the <paramref name="value" /> parameter is null or <see cref="Empty" />,
        /// or if <paramref name="value" /> consists exclusively of white-space characters.
        /// </returns>
        public static bool IsNullOrWhiteSpace(string value) { return default(bool); }
        /// <summary>
        /// Concatenates the members of a constructed <see cref="Collections.Generic.IEnumerable`1" />
        /// collection of type <see cref="String" />, using the specified separator between
        /// each member.
        /// </summary>
        /// <param name="separator">
        /// The string to use as a separator.<paramref name="separator" /> is included in the returned
        /// string only if <paramref name="values" /> has more than one element.
        /// </param>
        /// <param name="values">A collection that contains the strings to concatenate.</param>
        /// <returns>
        /// A string that consists of the members of <paramref name="values" /> delimited by the
        /// <paramref name="separator" /> string. If <paramref name="values" /> has no members, the method returns
        /// <see cref="Empty" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="values" /> is null.</exception>
        public static string Join(string separator, System.Collections.Generic.IEnumerable<string> values) { return default(string); }
        /// <summary>
        /// Concatenates the elements of an object array, using the specified separator between each element.
        /// </summary>
        /// <param name="separator">
        /// The string to use as a separator.<paramref name="separator" /> is included in the returned
        /// string only if <paramref name="values" /> has more than one element.
        /// </param>
        /// <param name="values">An array that contains the elements to concatenate.</param>
        /// <returns>
        /// A string that consists of the elements of <paramref name="values" /> delimited by the
        /// <paramref name="separator" /> string. If <paramref name="values" /> is an empty array, the method returns
        /// <see cref="Empty" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="values" /> is null.</exception>
        public static string Join(string separator, params object[] values) { return default(string); }
        /// <summary>
        /// Concatenates all the elements of a string array, using the specified separator between each
        /// element.
        /// </summary>
        /// <param name="separator">
        /// The string to use as a separator. <paramref name="separator" /> is included in the returned
        /// string only if <paramref name="value" /> has more than one element.
        /// </param>
        /// <param name="value">An array that contains the elements to concatenate.</param>
        /// <returns>
        /// A string that consists of the elements in <paramref name="value" /> delimited by the
        /// <paramref name="separator" /> string. If <paramref name="value" /> is an empty array, the method returns
        /// <see cref="Empty" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="value" /> is null.</exception>
        public static string Join(string separator, params string[] value) { return default(string); }
        /// <summary>
        /// Concatenates the specified elements of a string array, using the specified separator between
        /// each element.
        /// </summary>
        /// <param name="separator">
        /// The string to use as a separator. <paramref name="separator" /> is included in the returned
        /// string only if <paramref name="value" /> has more than one element.
        /// </param>
        /// <param name="value">An array that contains the elements to concatenate.</param>
        /// <param name="startIndex">The first element in <paramref name="value" /> to use.</param>
        /// <param name="count">The number of elements of <paramref name="value" /> to use.</param>
        /// <returns>
        /// A string that consists of the strings in <paramref name="value" /> delimited by the
        /// <paramref name="separator" /> string. -or-<see cref="Empty" /> if <paramref name="count" />
        /// is zero, <paramref name="value" /> has no elements, or <paramref name="separator" /> and
        /// all the elements of <paramref name="value" /> are <see cref="Empty" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="value" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="startIndex" /> or <paramref name="count" /> is less than 0.-or- <paramref name="startIndex" />
        /// plus <paramref name="count" /> is greater than the number of elements
        /// in <paramref name="value" />.
        /// </exception>
        /// <exception cref="OutOfMemoryException">Out of memory.</exception>
        public static string Join(string separator, string[] value, int startIndex, int count) { return default(string); }
        /// <summary>
        /// Concatenates the members of a collection, using the specified separator between each member.
        /// </summary>
        /// <param name="separator">
        /// The string to use as a separator.<paramref name="separator" /> is included in the returned
        /// string only if <paramref name="values" /> has more than one element.
        /// </param>
        /// <param name="values">A collection that contains the objects to concatenate.</param>
        /// <typeparam name="T">The type of the members of <paramref name="values" />.</typeparam>
        /// <returns>
        /// A string that consists of the members of <paramref name="values" /> delimited by the
        /// <paramref name="separator" /> string. If <paramref name="values" /> has no members, the method returns
        /// <see cref="Empty" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="values" /> is null.</exception>
        public static string Join<T>(string separator, System.Collections.Generic.IEnumerable<T> values) { return default(string); }
        /// <summary>
        /// Reports the zero-based index position of the last occurrence of a specified Unicode character
        /// within this instance.
        /// </summary>
        /// <param name="value">The Unicode character to seek.</param>
        /// <returns>
        /// The zero-based index position of <paramref name="value" /> if that character is found, or
        /// -1 if it is not.
        /// </returns>
        public int LastIndexOf(char value) { return default(int); }
        /// <summary>
        /// Reports the zero-based index position of the last occurrence of a specified Unicode character
        /// within this instance. The search starts at a specified character position and proceeds backward toward
        /// the beginning of the string.
        /// </summary>
        /// <param name="value">The Unicode character to seek.</param>
        /// <param name="startIndex">
        /// The starting position of the search. The search proceeds from <paramref name="startIndex" />
        /// toward the beginning of this instance.
        /// </param>
        /// <returns>
        /// The zero-based index position of <paramref name="value" /> if that character is found, or
        /// -1 if it is not found or if the current instance equals <see cref="Empty" />.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The current instance does not equal <see cref="Empty" />, and <paramref name="startIndex" />
        /// is less than zero or greater than or equal to the length of this instance.
        /// </exception>
        public int LastIndexOf(char value, int startIndex) { return default(int); }
        /// <summary>
        /// Reports the zero-based index position of the last occurrence of the specified Unicode character
        /// in a substring within this instance. The search starts at a specified character position and proceeds
        /// backward toward the beginning of the string for a specified number of character positions.
        /// </summary>
        /// <param name="value">The Unicode character to seek.</param>
        /// <param name="startIndex">
        /// The starting position of the search. The search proceeds from <paramref name="startIndex" />
        /// toward the beginning of this instance.
        /// </param>
        /// <param name="count">The number of character positions to examine.</param>
        /// <returns>
        /// The zero-based index position of <paramref name="value" /> if that character is found, or
        /// -1 if it is not found or if the current instance equals <see cref="Empty" />.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The current instance does not equal <see cref="Empty" />, and <paramref name="startIndex" />
        /// is less than zero or greater than or equal to the length of this instance.-or-The current
        /// instance does not equal <see cref="Empty" />, and <paramref name="startIndex" />
        /// - <paramref name="count" /> + 1 is less than zero.
        /// </exception>
        public int LastIndexOf(char value, int startIndex, int count) { return default(int); }
        /// <summary>
        /// Reports the zero-based index position of the last occurrence of a specified string within this
        /// instance.
        /// </summary>
        /// <param name="value">The string to seek.</param>
        /// <returns>
        /// The zero-based starting index position of <paramref name="value" /> if that string is found,
        /// or -1 if it is not. If <paramref name="value" /> is <see cref="Empty" />,
        /// the return value is the last index position in this instance.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="value" /> is null.</exception>
        public int LastIndexOf(string value) { return default(int); }
        /// <summary>
        /// Reports the zero-based index position of the last occurrence of a specified string within this
        /// instance. The search starts at a specified character position and proceeds backward toward the beginning
        /// of the string.
        /// </summary>
        /// <param name="value">The string to seek.</param>
        /// <param name="startIndex">
        /// The search starting position. The search proceeds from <paramref name="startIndex" /> toward
        /// the beginning of this instance.
        /// </param>
        /// <returns>
        /// The zero-based starting index position of <paramref name="value" /> if that string is found,
        /// or -1 if it is not found or if the current instance equals <see cref="Empty" />.
        /// If <paramref name="value" /> is <see cref="Empty" />, the return value
        /// is the smaller of <paramref name="startIndex" /> and the last index position in this instance.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="value" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The current instance does not equal <see cref="Empty" />, and <paramref name="startIndex" />
        /// is less than zero or greater than the length of the current instance. -or-The current instance
        /// equals <see cref="Empty" />, and <paramref name="startIndex" /> is less than
        /// -1 or greater than zero.
        /// </exception>
        public int LastIndexOf(string value, int startIndex) { return default(int); }
        /// <summary>
        /// Reports the zero-based index position of the last occurrence of a specified string within this
        /// instance. The search starts at a specified character position and proceeds backward toward the beginning
        /// of the string for a specified number of character positions.
        /// </summary>
        /// <param name="value">The string to seek.</param>
        /// <param name="startIndex">
        /// The search starting position. The search proceeds from <paramref name="startIndex" /> toward
        /// the beginning of this instance.
        /// </param>
        /// <param name="count">The number of character positions to examine.</param>
        /// <returns>
        /// The zero-based starting index position of <paramref name="value" /> if that string is found,
        /// or -1 if it is not found or if the current instance equals <see cref="Empty" />.
        /// If <paramref name="value" /> is <see cref="Empty" />, the return value
        /// is the smaller of <paramref name="startIndex" /> and the last index position in this instance.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="value" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="count" /> is negative.-or-The current instance does not equal
        /// <see cref="Empty" />, and <paramref name="startIndex" /> is negative.-or- The current instance does not equal
        /// <see cref="Empty" />, and <paramref name="startIndex" /> is greater than the
        /// length of this instance.-or-The current instance does not equal <see cref="Empty" />,
        /// and <paramref name="startIndex" /> - <paramref name="count" />+ 1 specifies a position
        /// that is not within this instance. -or-The current instance equals <see cref="Empty" />
        /// and <paramref name="start" /> is less than -1 or greater than zero. -or-The current instance
        /// equals <see cref="Empty" /> and <paramref name="count" /> is greater than
        /// 1.
        /// </exception>
        public int LastIndexOf(string value, int startIndex, int count) { return default(int); }
        /// <summary>
        /// Reports the zero-based index position of the last occurrence of a specified string within this
        /// instance. The search starts at a specified character position and proceeds backward toward the beginning
        /// of the string for the specified number of character positions. A parameter specifies the type
        /// of comparison to perform when searching for the specified string.
        /// </summary>
        /// <param name="value">The string to seek.</param>
        /// <param name="startIndex">
        /// The search starting position. The search proceeds from <paramref name="startIndex" /> toward
        /// the beginning of this instance.
        /// </param>
        /// <param name="count">The number of character positions to examine.</param>
        /// <param name="comparisonType">One of the enumeration values that specifies the rules for the search.</param>
        /// <returns>
        /// The zero-based starting index position of the <paramref name="value" /> parameter if that
        /// string is found, or -1 if it is not found or if the current instance equals <see cref="Empty" />.
        /// If <paramref name="value" /> is <see cref="Empty" />, the return value
        /// is the smaller of <paramref name="startIndex" /> and the last index position in this instance.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="value" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="count" /> is negative.-or-The current instance does not equal
        /// <see cref="Empty" />, and <paramref name="startIndex" /> is negative.-or- The current instance does not equal
        /// <see cref="Empty" />, and <paramref name="startIndex" /> is greater than the
        /// length of this instance.-or-The current instance does not equal <see cref="Empty" />,
        /// and <paramref name="startIndex" /> + 1 - <paramref name="count" /> specifies a position
        /// that is not within this instance. -or-The current instance equals <see cref="Empty" />
        /// and <paramref name="start" /> is less than -1 or greater than zero. -or-The current instance
        /// equals <see cref="Empty" /> and <paramref name="count" /> is greater than
        /// 1.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="comparisonType" /> is not a valid <see cref="StringComparison" />
        /// value.
        /// </exception>
        public int LastIndexOf(string value, int startIndex, int count, System.StringComparison comparisonType) { return default(int); }
        /// <summary>
        /// Reports the zero-based index of the last occurrence of a specified string within the current
        /// <see cref="String" /> object. The search starts at a specified character position
        /// and proceeds backward toward the beginning of the string. A parameter specifies the type of
        /// comparison to perform when searching for the specified string.
        /// </summary>
        /// <param name="value">The string to seek.</param>
        /// <param name="startIndex">
        /// The search starting position. The search proceeds from <paramref name="startIndex" /> toward
        /// the beginning of this instance.
        /// </param>
        /// <param name="comparisonType">One of the enumeration values that specifies the rules for the search.</param>
        /// <returns>
        /// The zero-based starting index position of the <paramref name="value" /> parameter if that
        /// string is found, or -1 if it is not found or if the current instance equals <see cref="Empty" />.
        /// If <paramref name="value" /> is <see cref="Empty" />, the return value
        /// is the smaller of <paramref name="startIndex" /> and the last index position in this instance.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="value" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The current instance does not equal <see cref="Empty" />, and <paramref name="startIndex" />
        /// is less than zero or greater than the length of the current instance. -or-The current instance
        /// equals <see cref="Empty" />, and <paramref name="startIndex" /> is less than
        /// -1 or greater than zero.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="comparisonType" /> is not a valid <see cref="StringComparison" />
        /// value.
        /// </exception>
        public int LastIndexOf(string value, int startIndex, System.StringComparison comparisonType) { return default(int); }
        /// <summary>
        /// Reports the zero-based index of the last occurrence of a specified string within the current
        /// <see cref="String" /> object. A parameter specifies the type of search to use for
        /// the specified string.
        /// </summary>
        /// <param name="value">The string to seek.</param>
        /// <param name="comparisonType">One of the enumeration values that specifies the rules for the search.</param>
        /// <returns>
        /// The zero-based starting index position of the <paramref name="value" /> parameter if that
        /// string is found, or -1 if it is not. If <paramref name="value" /> is <see cref="Empty" />,
        /// the return value is the last index position in this instance.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="value" /> is null.</exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="comparisonType" /> is not a valid <see cref="StringComparison" />
        /// value.
        /// </exception>
        public int LastIndexOf(string value, System.StringComparison comparisonType) { return default(int); }
        /// <summary>
        /// Reports the zero-based index position of the last occurrence in this instance of one or more
        /// characters specified in a Unicode array.
        /// </summary>
        /// <param name="anyOf">A Unicode character array containing one or more characters to seek.</param>
        /// <returns>
        /// The index position of the last occurrence in this instance where any character in <paramref name="anyOf" />
        /// was found; -1 if no character in <paramref name="anyOf" /> was found.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="anyOf" /> is null.</exception>
        public int LastIndexOfAny(char[] anyOf) { return default(int); }
        /// <summary>
        /// Reports the zero-based index position of the last occurrence in this instance of one or more
        /// characters specified in a Unicode array. The search starts at a specified character position and proceeds
        /// backward toward the beginning of the string.
        /// </summary>
        /// <param name="anyOf">A Unicode character array containing one or more characters to seek.</param>
        /// <param name="startIndex">
        /// The search starting position. The search proceeds from <paramref name="startIndex" /> toward
        /// the beginning of this instance.
        /// </param>
        /// <returns>
        /// The index position of the last occurrence in this instance where any character in <paramref name="anyOf" />
        /// was found; -1 if no character in <paramref name="anyOf" /> was found or if
        /// the current instance equals <see cref="Empty" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="anyOf" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The current instance does not equal <see cref="Empty" />, and <paramref name="startIndex" />
        /// specifies a position that is not within this instance.
        /// </exception>
        public int LastIndexOfAny(char[] anyOf, int startIndex) { return default(int); }
        /// <summary>
        /// Reports the zero-based index position of the last occurrence in this instance of one or more
        /// characters specified in a Unicode array. The search starts at a specified character position and proceeds
        /// backward toward the beginning of the string for a specified number of character positions.
        /// </summary>
        /// <param name="anyOf">A Unicode character array containing one or more characters to seek.</param>
        /// <param name="startIndex">
        /// The search starting position. The search proceeds from <paramref name="startIndex" /> toward
        /// the beginning of this instance.
        /// </param>
        /// <param name="count">The number of character positions to examine.</param>
        /// <returns>
        /// The index position of the last occurrence in this instance where any character in <paramref name="anyOf" />
        /// was found; -1 if no character in <paramref name="anyOf" /> was found or if
        /// the current instance equals <see cref="Empty" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="anyOf" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The current instance does not equal <see cref="Empty" />, and <paramref name="count" />
        /// or <paramref name="startIndex" /> is negative.-or- The current instance does not equal
        /// <see cref="Empty" />, and <paramref name="startIndex" /> minus <paramref name="count" />
        /// + 1 is less than zero.
        /// </exception>
        public int LastIndexOfAny(char[] anyOf, int startIndex, int count) { return default(int); }
        /// <summary>
        /// Determines whether two specified strings have the same value.
        /// </summary>
        /// <param name="a">The first string to compare, or null.</param>
        /// <param name="b">The second string to compare, or null.</param>
        /// <returns>
        /// true if the value of <paramref name="a" /> is the same as the value of <paramref name="b" />;
        /// otherwise, false.
        /// </returns>
        public static bool operator ==(string a, string b) { return default(bool); }
        /// <summary>
        /// Determines whether two specified strings have different values.
        /// </summary>
        /// <param name="a">The first string to compare, or null.</param>
        /// <param name="b">The second string to compare, or null.</param>
        /// <returns>
        /// true if the value of <paramref name="a" /> is different from the value of <paramref name="b" />;
        /// otherwise, false.
        /// </returns>
        public static bool operator !=(string a, string b) { return default(bool); }
        /// <summary>
        /// Returns a new string that right-aligns the characters in this instance by padding them with
        /// spaces on the left, for a specified total length.
        /// </summary>
        /// <param name="totalWidth">
        /// The number of characters in the resulting string, equal to the number of original characters
        /// plus any additional padding characters.
        /// </param>
        /// <returns>
        /// A new string that is equivalent to this instance, but right-aligned and padded on the left
        /// with as many spaces as needed to create a length of <paramref name="totalWidth" />. However,
        /// if <paramref name="totalWidth" /> is less than the length of this instance, the method returns
        /// a reference to the existing instance. If <paramref name="totalWidth" /> is equal to the length
        /// of this instance, the method returns a new string that is identical to this instance.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="totalWidth" /> is less than zero.
        /// </exception>
        public string PadLeft(int totalWidth) { return default(string); }
        /// <summary>
        /// Returns a new string that right-aligns the characters in this instance by padding them on the
        /// left with a specified Unicode character, for a specified total length.
        /// </summary>
        /// <param name="totalWidth">
        /// The number of characters in the resulting string, equal to the number of original characters
        /// plus any additional padding characters.
        /// </param>
        /// <param name="paddingChar">A Unicode padding character.</param>
        /// <returns>
        /// A new string that is equivalent to this instance, but right-aligned and padded on the left
        /// with as many <paramref name="paddingChar" /> characters as needed to create a length of <paramref name="totalWidth" />.
        /// However, if <paramref name="totalWidth" /> is less than the length of
        /// this instance, the method returns a reference to the existing instance. If <paramref name="totalWidth" />
        /// is equal to the length of this instance, the method returns a new string that is identical
        /// to this instance.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="totalWidth" /> is less than zero.
        /// </exception>
        public string PadLeft(int totalWidth, char paddingChar) { return default(string); }
        /// <summary>
        /// Returns a new string that left-aligns the characters in this string by padding them with spaces
        /// on the right, for a specified total length.
        /// </summary>
        /// <param name="totalWidth">
        /// The number of characters in the resulting string, equal to the number of original characters
        /// plus any additional padding characters.
        /// </param>
        /// <returns>
        /// A new string that is equivalent to this instance, but left-aligned and padded on the right
        /// with as many spaces as needed to create a length of <paramref name="totalWidth" />. However,
        /// if <paramref name="totalWidth" /> is less than the length of this instance, the method returns
        /// a reference to the existing instance. If <paramref name="totalWidth" /> is equal to the length
        /// of this instance, the method returns a new string that is identical to this instance.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="totalWidth" /> is less than zero.
        /// </exception>
        public string PadRight(int totalWidth) { return default(string); }
        /// <summary>
        /// Returns a new string that left-aligns the characters in this string by padding them on the
        /// right with a specified Unicode character, for a specified total length.
        /// </summary>
        /// <param name="totalWidth">
        /// The number of characters in the resulting string, equal to the number of original characters
        /// plus any additional padding characters.
        /// </param>
        /// <param name="paddingChar">A Unicode padding character.</param>
        /// <returns>
        /// A new string that is equivalent to this instance, but left-aligned and padded on the right
        /// with as many <paramref name="paddingChar" /> characters as needed to create a length of <paramref name="totalWidth" />.
        /// However, if <paramref name="totalWidth" /> is less than the length of
        /// this instance, the method returns a reference to the existing instance. If <paramref name="totalWidth" />
        /// is equal to the length of this instance, the method returns a new string that is identical
        /// to this instance.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="totalWidth" /> is less than zero.
        /// </exception>
        public string PadRight(int totalWidth, char paddingChar) { return default(string); }
        /// <summary>
        /// Returns a new string in which all the characters in the current instance, beginning at a specified
        /// position and continuing through the last position, have been deleted.
        /// </summary>
        /// <param name="startIndex">The zero-based position to begin deleting characters.</param>
        /// <returns>
        /// A new string that is equivalent to this string except for the removed characters.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="startIndex" /> is less than zero.-or- <paramref name="startIndex" /> specifies
        /// a position that is not within this string.
        /// </exception>
        public string Remove(int startIndex) { return default(string); }
        /// <summary>
        /// Returns a new string in which a specified number of characters in the current instance beginning
        /// at a specified position have been deleted.
        /// </summary>
        /// <param name="startIndex">The zero-based position to begin deleting characters.</param>
        /// <param name="count">The number of characters to delete.</param>
        /// <returns>
        /// A new string that is equivalent to this instance except for the removed characters.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// Either <paramref name="startIndex" /> or <paramref name="count" /> is less than zero.-or-
        /// <paramref name="startIndex" /> plus <paramref name="count" /> specify a position outside this
        /// instance.
        /// </exception>
        public string Remove(int startIndex, int count) { return default(string); }
        /// <summary>
        /// Returns a new string in which all occurrences of a specified Unicode character in this instance
        /// are replaced with another specified Unicode character.
        /// </summary>
        /// <param name="oldChar">The Unicode character to be replaced.</param>
        /// <param name="newChar">The Unicode character to replace all occurrences of <paramref name="oldChar" />.</param>
        /// <returns>
        /// A string that is equivalent to this instance except that all instances of <paramref name="oldChar" />
        /// are replaced with <paramref name="newChar" />. If <paramref name="oldChar" /> is not found
        /// in the current instance, the method returns the current instance unchanged.
        /// </returns>
        public string Replace(char oldChar, char newChar) { return default(string); }
        /// <summary>
        /// Returns a new string in which all occurrences of a specified string in the current instance
        /// are replaced with another specified string.
        /// </summary>
        /// <param name="oldValue">The string to be replaced.</param>
        /// <param name="newValue">The string to replace all occurrences of <paramref name="oldValue" />.</param>
        /// <returns>
        /// A string that is equivalent to the current string except that all instances of <paramref name="oldValue" />
        /// are replaced with <paramref name="newValue" />. If <paramref name="oldValue" /> is not
        /// found in the current instance, the method returns the current instance unchanged.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="oldValue" /> is null.</exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="oldValue" /> is the empty string ("").
        /// </exception>
        public string Replace(string oldValue, string newValue) { return default(string); }
        /// <summary>
        /// Splits a string into substrings that are based on the characters in an array.
        /// </summary>
        /// <param name="separator">
        /// A character array that delimits the substrings in this string, an empty array that contains
        /// no delimiters, or null.
        /// </param>
        /// <returns>
        /// An array whose elements contain the substrings from this instance that are delimited by one
        /// or more characters in <paramref name="separator" />. For more information, see the Remarks
        /// section.
        /// </returns>
        public string[] Split(params char[] separator) { return default(string[]); }
        /// <summary>
        /// Splits a string into a maximum number of substrings based on the characters in an array. You
        /// also specify the maximum number of substrings to return.
        /// </summary>
        /// <param name="separator">
        /// A character array that delimits the substrings in this string, an empty array that contains
        /// no delimiters, or null.
        /// </param>
        /// <param name="count">The maximum number of substrings to return.</param>
        /// <returns>
        /// An array whose elements contain the substrings in this instance that are delimited by one
        /// or more characters in <paramref name="separator" />. For more information, see the Remarks
        /// section.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="count" /> is negative.</exception>
        public string[] Split(char[] separator, int count) { return default(string[]); }
        /// <summary>
        /// Splits a string into a maximum number of substrings based on the characters in an array.
        /// </summary>
        /// <param name="separator">
        /// A character array that delimits the substrings in this string, an empty array that contains
        /// no delimiters, or null.
        /// </param>
        /// <param name="count">The maximum number of substrings to return.</param>
        /// <param name="options">
        /// <see cref="StringSplitOptions.RemoveEmptyEntries" /> to omit empty array elements
        /// from the array returned; or <see cref="StringSplitOptions.None" /> to include empty
        /// array elements in the array returned.
        /// </param>
        /// <returns>
        /// An array whose elements contain the substrings in this string that are delimited by one or
        /// more characters in <paramref name="separator" />. For more information, see the Remarks section.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="count" /> is negative.</exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="options" /> is not one of the <see cref="StringSplitOptions" /> values.
        /// </exception>
        public string[] Split(char[] separator, int count, System.StringSplitOptions options) { return default(string[]); }
        /// <summary>
        /// Splits a string into substrings based on the characters in an array. You can specify whether
        /// the substrings include empty array elements.
        /// </summary>
        /// <param name="separator">
        /// A character array that delimits the substrings in this string, an empty array that contains
        /// no delimiters, or null.
        /// </param>
        /// <param name="options">
        /// <see cref="StringSplitOptions.RemoveEmptyEntries" /> to omit empty array elements
        /// from the array returned; or <see cref="StringSplitOptions.None" /> to include empty
        /// array elements in the array returned.
        /// </param>
        /// <returns>
        /// An array whose elements contain the substrings in this string that are delimited by one or
        /// more characters in <paramref name="separator" />. For more information, see the Remarks section.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// <paramref name="options" /> is not one of the <see cref="StringSplitOptions" /> values.
        /// </exception>
        public string[] Split(char[] separator, System.StringSplitOptions options) { return default(string[]); }
        /// <summary>
        /// Splits a string into a maximum number of substrings based on the strings in an array. You can
        /// specify whether the substrings include empty array elements.
        /// </summary>
        /// <param name="separator">
        /// A string array that delimits the substrings in this string, an empty array that contains no
        /// delimiters, or null.
        /// </param>
        /// <param name="count">The maximum number of substrings to return.</param>
        /// <param name="options">
        /// <see cref="StringSplitOptions.RemoveEmptyEntries" /> to omit empty array elements
        /// from the array returned; or <see cref="StringSplitOptions.None" /> to include empty
        /// array elements in the array returned.
        /// </param>
        /// <returns>
        /// An array whose elements contain the substrings in this string that are delimited by one or
        /// more strings in <paramref name="separator" />. For more information, see the Remarks section.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="count" /> is negative.</exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="options" /> is not one of the <see cref="StringSplitOptions" /> values.
        /// </exception>
        public string[] Split(string[] separator, int count, System.StringSplitOptions options) { return default(string[]); }
        /// <summary>
        /// Splits a string into substrings based on the strings in an array. You can specify whether the
        /// substrings include empty array elements.
        /// </summary>
        /// <param name="separator">
        /// A string array that delimits the substrings in this string, an empty array that contains no
        /// delimiters, or null.
        /// </param>
        /// <param name="options">
        /// <see cref="StringSplitOptions.RemoveEmptyEntries" /> to omit empty array elements
        /// from the array returned; or <see cref="StringSplitOptions.None" /> to include empty
        /// array elements in the array returned.
        /// </param>
        /// <returns>
        /// An array whose elements contain the substrings in this string that are delimited by one or
        /// more strings in <paramref name="separator" />. For more information, see the Remarks section.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// <paramref name="options" /> is not one of the <see cref="StringSplitOptions" /> values.
        /// </exception>
        public string[] Split(string[] separator, System.StringSplitOptions options) { return default(string[]); }
        /// <summary>
        /// Determines whether the beginning of this string instance matches the specified string.
        /// </summary>
        /// <param name="value">The string to compare.</param>
        /// <returns>
        /// true if <paramref name="value" /> matches the beginning of this string; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="value" /> is null.</exception>
        public bool StartsWith(string value) { return default(bool); }
        /// <summary>
        /// Determines whether the beginning of this string instance matches the specified string when
        /// compared using the specified comparison option.
        /// </summary>
        /// <param name="value">The string to compare.</param>
        /// <param name="comparisonType">
        /// One of the enumeration values that determines how this string and <paramref name="value" />
        /// are compared.
        /// </param>
        /// <returns>
        /// true if this instance begins with <paramref name="value" />; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="value" /> is null.</exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="comparisonType" /> is not a <see cref="StringComparison" /> value.
        /// </exception>
        public bool StartsWith(string value, System.StringComparison comparisonType) { return default(bool); }
        /// <summary>
        /// Retrieves a substring from this instance. The substring starts at a specified character position
        /// and continues to the end of the string.
        /// </summary>
        /// <param name="startIndex">The zero-based starting character position of a substring in this instance.</param>
        /// <returns>
        /// A string that is equivalent to the substring that begins at <paramref name="startIndex" />
        /// in this instance, or <see cref="Empty" /> if <paramref name="startIndex" />
        /// is equal to the length of this instance.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="startIndex" /> is less than zero or greater than the length of this instance.
        /// </exception>
        public string Substring(int startIndex) { return default(string); }
        /// <summary>
        /// Retrieves a substring from this instance. The substring starts at a specified character position
        /// and has a specified length.
        /// </summary>
        /// <param name="startIndex">The zero-based starting character position of a substring in this instance.</param>
        /// <param name="length">The number of characters in the substring.</param>
        /// <returns>
        /// A string that is equivalent to the substring of length <paramref name="length" /> that begins
        /// at <paramref name="startIndex" /> in this instance, or <see cref="Empty" />
        /// if <paramref name="startIndex" /> is equal to the length of this instance and <paramref name="length" />
        /// is zero.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="startIndex" /> plus <paramref name="length" /> indicates a position not within
        /// this instance.-or- <paramref name="startIndex" /> or <paramref name="length" /> is less than
        /// zero.
        /// </exception>
        public string Substring(int startIndex, int length) { return default(string); }
        System.Collections.Generic.IEnumerator<char> System.Collections.Generic.IEnumerable<System.Char>.GetEnumerator() { return default(System.Collections.Generic.IEnumerator<char>); }
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { return default(System.Collections.IEnumerator); }
        int System.IComparable.CompareTo(object value) { return default(int); }
        System.TypeCode System.IConvertible.GetTypeCode() { return default(System.TypeCode); }
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) { return default(bool); }
        byte System.IConvertible.ToByte(System.IFormatProvider provider) { return default(byte); }
        char System.IConvertible.ToChar(System.IFormatProvider provider) { return default(char); }
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) { return default(System.DateTime); }
        decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) { return default(decimal); }
        double System.IConvertible.ToDouble(System.IFormatProvider provider) { return default(double); }
        short System.IConvertible.ToInt16(System.IFormatProvider provider) { return default(short); }
        int System.IConvertible.ToInt32(System.IFormatProvider provider) { return default(int); }
        long System.IConvertible.ToInt64(System.IFormatProvider provider) { return default(long); }
        sbyte System.IConvertible.ToSByte(System.IFormatProvider provider) { return default(sbyte); }
        float System.IConvertible.ToSingle(System.IFormatProvider provider) { return default(float); }
        string System.IConvertible.ToString(System.IFormatProvider provider) { return default(string); }
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) { return default(object); }
        ushort System.IConvertible.ToUInt16(System.IFormatProvider provider) { return default(ushort); }
        uint System.IConvertible.ToUInt32(System.IFormatProvider provider) { return default(uint); }
        ulong System.IConvertible.ToUInt64(System.IFormatProvider provider) { return default(ulong); }
        /// <summary>
        /// Copies the characters in this instance to a Unicode character array.
        /// </summary>
        /// <returns>
        /// A Unicode character array whose elements are the individual characters of this instance. If
        /// this instance is an empty string, the returned array is empty and has a zero length.
        /// </returns>
        public char[] ToCharArray() { return default(char[]); }
        /// <summary>
        /// Copies the characters in a specified substring in this instance to a Unicode character array.
        /// </summary>
        /// <param name="startIndex">The starting position of a substring in this instance.</param>
        /// <param name="length">The length of the substring in this instance.</param>
        /// <returns>
        /// A Unicode character array whose elements are the <paramref name="length" /> number of characters
        /// in this instance starting from character position <paramref name="startIndex" />.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="startIndex" /> or <paramref name="length" /> is less than zero.-or-
        /// <paramref name="startIndex" /> plus <paramref name="length" /> is greater than the length of this instance.
        /// </exception>
        public char[] ToCharArray(int startIndex, int length) { return default(char[]); }
        /// <summary>
        /// Returns a copy of this string converted to lowercase.
        /// </summary>
        /// <returns>
        /// A string in lowercase.
        /// </returns>
        public string ToLower() { return default(string); }
        /// <summary>
        /// Returns a copy of this <see cref="String" /> object converted to lowercase using
        /// the casing rules of the invariant culture.
        /// </summary>
        /// <returns>
        /// The lowercase equivalent of the current string.
        /// </returns>
        public string ToLowerInvariant() { return default(string); }
        /// <summary>
        /// Returns this instance of <see cref="String" />; no actual conversion is performed.
        /// </summary>
        /// <returns>
        /// The current string.
        /// </returns>
        public override string ToString() { return default(string); }
        /// <summary>
        /// Returns a copy of this string converted to uppercase.
        /// </summary>
        /// <returns>
        /// The uppercase equivalent of the current string.
        /// </returns>
        public string ToUpper() { return default(string); }
        /// <summary>
        /// Returns a copy of this <see cref="String" /> object converted to uppercase using
        /// the casing rules of the invariant culture.
        /// </summary>
        /// <returns>
        /// The uppercase equivalent of the current string.
        /// </returns>
        public string ToUpperInvariant() { return default(string); }
        /// <summary>
        /// Removes all leading and trailing white-space characters from the current <see cref="String" />
        /// object.
        /// </summary>
        /// <returns>
        /// The string that remains after all white-space characters are removed from the start and end
        /// of the current string. If no characters can be trimmed from the current instance, the method returns
        /// the current instance unchanged.
        /// </returns>
        public string Trim() { return default(string); }
        /// <summary>
        /// Removes all leading and trailing occurrences of a set of characters specified in an array
        /// from the current <see cref="String" /> object.
        /// </summary>
        /// <param name="trimChars">An array of Unicode characters to remove, or null.</param>
        /// <returns>
        /// The string that remains after all occurrences of the characters in the <paramref name="trimChars" />
        /// parameter are removed from the start and end of the current string. If <paramref name="trimChars" />
        /// is null or an empty array, white-space characters are removed instead. If no characters
        /// can be trimmed from the current instance, the method returns the current instance unchanged.
        /// </returns>
        public string Trim(params char[] trimChars) { return default(string); }
        /// <summary>
        /// Removes all trailing occurrences of a set of characters specified in an array from the current
        /// <see cref="String" /> object.
        /// </summary>
        /// <param name="trimChars">An array of Unicode characters to remove, or null.</param>
        /// <returns>
        /// The string that remains after all occurrences of the characters in the <paramref name="trimChars" />
        /// parameter are removed from the end of the current string. If <paramref name="trimChars" />
        /// is null or an empty array, Unicode white-space characters are removed instead. If no characters
        /// can be trimmed from the current instance, the method returns the current instance unchanged.
        /// </returns>
        public string TrimEnd(params char[] trimChars) { return default(string); }
        /// <summary>
        /// Removes all leading occurrences of a set of characters specified in an array from the current
        /// <see cref="String" /> object.
        /// </summary>
        /// <param name="trimChars">An array of Unicode characters to remove, or null.</param>
        /// <returns>
        /// The string that remains after all occurrences of characters in the <paramref name="trimChars" />
        /// parameter are removed from the start of the current string. If <paramref name="trimChars" />
        /// is null or an empty array, white-space characters are removed instead.
        /// </returns>
        public string TrimStart(params char[] trimChars) { return default(string); }
    }
    /// <summary>
    /// Specifies the culture, case, and sort rules to be used by certain overloads of the
    /// <see cref="String.Compare(String,String)" /> and <see cref="String.Equals(Object)" /> methods.
    /// </summary>
    public enum StringComparison
    {
        /// <summary>
        /// Compare strings using culture-sensitive sort rules and the current culture.
        /// </summary>
        CurrentCulture = 0,
        /// <summary>
        /// Compare strings using culture-sensitive sort rules, the current culture, and ignoring the case
        /// of the strings being compared.
        /// </summary>
        CurrentCultureIgnoreCase = 1,
        /// <summary>
        /// Compare strings using ordinal (binary) sort rules.
        /// </summary>
        Ordinal = 4,
        /// <summary>
        /// Compare strings using ordinal (binary) sort rules and ignoring the case of the strings being
        /// compared.
        /// </summary>
        OrdinalIgnoreCase = 5,
    }
    /// <summary>
    /// Specifies whether applicable <see cref="Overload:System.String.Split" /> method overloads
    /// include or omit empty substrings from the return value.
    /// </summary>
    [System.FlagsAttribute]
    public enum StringSplitOptions
    {
        /// <summary>
        /// The return value includes array elements that contain an empty string
        /// </summary>
        None = 0,
        /// <summary>
        /// The return value does not include array elements that contain an empty string
        /// </summary>
        RemoveEmptyEntries = 1,
    }
    /// <summary>
    /// Indicates that the value of a static field is unique for each thread.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(256), Inherited = false)]
    public partial class ThreadStaticAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ThreadStaticAttribute" /> class.
        /// </summary>
        public ThreadStaticAttribute() { }
    }
    /// <summary>
    /// The exception that is thrown when the time allotted for a process or operation has expired.
    /// </summary>
    public partial class TimeoutException : System.Exception
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TimeoutException" /> class.
        /// </summary>
        public TimeoutException() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="TimeoutException" /> class with the
        /// specified error message.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        public TimeoutException(string message) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="TimeoutException" /> class with the
        /// specified error message and inner exception.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        /// <param name="innerException">
        /// The exception that is the cause of the current exception. If the <paramref name="innerException" />
        /// parameter is not null, the current exception is raised in a catch block that handles the
        /// inner exception.
        /// </param>
        public TimeoutException(string message, System.Exception innerException) { }
    }
    /// <summary>
    /// Represents a time interval.To browse the .NET Framework source code for this type, see the
    /// Reference Source.
    /// </summary>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct TimeSpan : System.IComparable, System.IComparable<System.TimeSpan>, System.IEquatable<System.TimeSpan>, System.IFormattable
    {
        /// <summary>
        /// Represents the maximum <see cref="TimeSpan" /> value. This field is read-only.
        /// </summary>
        public static readonly System.TimeSpan MaxValue;
        /// <summary>
        /// Represents the minimum <see cref="TimeSpan" /> value. This field is read-only.
        /// </summary>
        public static readonly System.TimeSpan MinValue;
        /// <summary>
        /// Represents the number of ticks in 1 day. This field is constant.
        /// </summary>
        public const long TicksPerDay = (long)864000000000;
        /// <summary>
        /// Represents the number of ticks in 1 hour. This field is constant.
        /// </summary>
        public const long TicksPerHour = (long)36000000000;
        /// <summary>
        /// Represents the number of ticks in 1 millisecond. This field is constant.
        /// </summary>
        public const long TicksPerMillisecond = (long)10000;
        /// <summary>
        /// Represents the number of ticks in 1 minute. This field is constant.
        /// </summary>
        public const long TicksPerMinute = (long)600000000;
        /// <summary>
        /// Represents the number of ticks in 1 second.
        /// </summary>
        public const long TicksPerSecond = (long)10000000;
        /// <summary>
        /// Represents the zero <see cref="TimeSpan" /> value. This field is read-only.
        /// </summary>
        public static readonly System.TimeSpan Zero;
        /// <summary>
        /// Initializes a new instance of the <see cref="TimeSpan" /> structure to a specified
        /// number of hours, minutes, and seconds.
        /// </summary>
        /// <param name="hours">Number of hours.</param>
        /// <param name="minutes">Number of minutes.</param>
        /// <param name="seconds">Number of seconds.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The parameters specify a <see cref="TimeSpan" /> value less than
        /// <see cref="MinValue" /> or greater than <see cref="MaxValue" />.
        /// </exception>
        public TimeSpan(int hours, int minutes, int seconds) { throw new System.NotImplementedException(); }
        /// <summary>
        /// Initializes a new instance of the <see cref="TimeSpan" /> structure to a specified
        /// number of days, hours, minutes, and seconds.
        /// </summary>
        /// <param name="days">Number of days.</param>
        /// <param name="hours">Number of hours.</param>
        /// <param name="minutes">Number of minutes.</param>
        /// <param name="seconds">Number of seconds.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The parameters specify a <see cref="TimeSpan" /> value less than
        /// <see cref="MinValue" /> or greater than <see cref="MaxValue" />.
        /// </exception>
        public TimeSpan(int days, int hours, int minutes, int seconds) { throw new System.NotImplementedException(); }
        /// <summary>
        /// Initializes a new instance of the <see cref="TimeSpan" /> structure to a specified
        /// number of days, hours, minutes, seconds, and milliseconds.
        /// </summary>
        /// <param name="days">Number of days.</param>
        /// <param name="hours">Number of hours.</param>
        /// <param name="minutes">Number of minutes.</param>
        /// <param name="seconds">Number of seconds.</param>
        /// <param name="milliseconds">Number of milliseconds.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The parameters specify a <see cref="TimeSpan" /> value less than
        /// <see cref="MinValue" /> or greater than <see cref="MaxValue" />.
        /// </exception>
        public TimeSpan(int days, int hours, int minutes, int seconds, int milliseconds) { throw new System.NotImplementedException(); }
        /// <summary>
        /// Initializes a new instance of the <see cref="TimeSpan" /> structure to the specified
        /// number of ticks.
        /// </summary>
        /// <param name="ticks">A time period expressed in 100-nanosecond units.</param>
        public TimeSpan(long ticks) { throw new System.NotImplementedException(); }
        /// <summary>
        /// Gets the days component of the time interval represented by the current <see cref="TimeSpan" />
        /// structure.
        /// </summary>
        /// <returns>
        /// The day component of this instance. The return value can be positive or negative.
        /// </returns>
        public int Days { get { return default(int); } }
        /// <summary>
        /// Gets the hours component of the time interval represented by the current <see cref="TimeSpan" />
        /// structure.
        /// </summary>
        /// <returns>
        /// The hour component of the current <see cref="TimeSpan" /> structure. The return value
        /// ranges from -23 through 23.
        /// </returns>
        public int Hours { get { return default(int); } }
        /// <summary>
        /// Gets the milliseconds component of the time interval represented by the current
        /// <see cref="TimeSpan" /> structure.
        /// </summary>
        /// <returns>
        /// The millisecond component of the current <see cref="TimeSpan" /> structure. The return
        /// value ranges from -999 through 999.
        /// </returns>
        public int Milliseconds { get { return default(int); } }
        /// <summary>
        /// Gets the minutes component of the time interval represented by the current <see cref="TimeSpan" />
        /// structure.
        /// </summary>
        /// <returns>
        /// The minute component of the current <see cref="TimeSpan" /> structure. The return
        /// value ranges from -59 through 59.
        /// </returns>
        public int Minutes { get { return default(int); } }
        /// <summary>
        /// Gets the seconds component of the time interval represented by the current <see cref="TimeSpan" />
        /// structure.
        /// </summary>
        /// <returns>
        /// The second component of the current <see cref="TimeSpan" /> structure. The return
        /// value ranges from -59 through 59.
        /// </returns>
        public int Seconds { get { return default(int); } }
        /// <summary>
        /// Gets the number of ticks that represent the value of the current <see cref="TimeSpan" />
        /// structure.
        /// </summary>
        /// <returns>
        /// The number of ticks contained in this instance.
        /// </returns>
        public long Ticks { get { return default(long); } }
        /// <summary>
        /// Gets the value of the current <see cref="TimeSpan" /> structure expressed in whole
        /// and fractional days.
        /// </summary>
        /// <returns>
        /// The total number of days represented by this instance.
        /// </returns>
        public double TotalDays { get { return default(double); } }
        /// <summary>
        /// Gets the value of the current <see cref="TimeSpan" /> structure expressed in whole
        /// and fractional hours.
        /// </summary>
        /// <returns>
        /// The total number of hours represented by this instance.
        /// </returns>
        public double TotalHours { get { return default(double); } }
        /// <summary>
        /// Gets the value of the current <see cref="TimeSpan" /> structure expressed in whole
        /// and fractional milliseconds.
        /// </summary>
        /// <returns>
        /// The total number of milliseconds represented by this instance.
        /// </returns>
        public double TotalMilliseconds { get { return default(double); } }
        /// <summary>
        /// Gets the value of the current <see cref="TimeSpan" /> structure expressed in whole
        /// and fractional minutes.
        /// </summary>
        /// <returns>
        /// The total number of minutes represented by this instance.
        /// </returns>
        public double TotalMinutes { get { return default(double); } }
        /// <summary>
        /// Gets the value of the current <see cref="TimeSpan" /> structure expressed in whole
        /// and fractional seconds.
        /// </summary>
        /// <returns>
        /// The total number of seconds represented by this instance.
        /// </returns>
        public double TotalSeconds { get { return default(double); } }
        /// <summary>
        /// Returns a new <see cref="TimeSpan" /> object whose value is the sum of the specified
        /// <see cref="TimeSpan" /> object and this instance.
        /// </summary>
        /// <param name="ts">The time interval to add.</param>
        /// <returns>
        /// A new object that represents the value of this instance plus the value of <paramref name="ts" />.
        /// </returns>
        /// <exception cref="OverflowException">
        /// The resulting <see cref="TimeSpan" /> is less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />.
        /// </exception>
        public System.TimeSpan Add(System.TimeSpan ts) { return default(System.TimeSpan); }
        /// <summary>
        /// Compares two <see cref="TimeSpan" /> values and returns an integer that indicates
        /// whether the first value is shorter than, equal to, or longer than the second value.
        /// </summary>
        /// <param name="t1">The first time interval to compare.</param>
        /// <param name="t2">The second time interval to compare.</param>
        /// <returns>
        /// One of the following values.Value Description -1 <paramref name="t1" /> is shorter than <paramref name="t2" />.
        /// 0 <paramref name="t1" /> is equal to <paramref name="t2" />. 1 <paramref name="t1" />
        /// is longer than <paramref name="t2" />.
        /// </returns>
        public static int Compare(System.TimeSpan t1, System.TimeSpan t2) { return default(int); }
        /// <summary>
        /// Compares this instance to a specified <see cref="TimeSpan" /> object and returns
        /// an integer that indicates whether this instance is shorter than, equal to, or longer than
        /// the <see cref="TimeSpan" /> object.
        /// </summary>
        /// <param name="value">An object to compare to this instance.</param>
        /// <returns>
        /// A signed number indicating the relative values of this instance and <paramref name="value" />.
        /// Value Description A negative integer This instance is shorter than <paramref name="value" />.
        /// Zero This instance is equal to <paramref name="value" />. A positive integer This instance
        /// is longer than <paramref name="value" />.
        /// </returns>
        public int CompareTo(System.TimeSpan value) { return default(int); }
        /// <summary>
        /// Returns a new <see cref="TimeSpan" /> object whose value is the absolute value of
        /// the current <see cref="TimeSpan" /> object.
        /// </summary>
        /// <returns>
        /// A new object whose value is the absolute value of the current <see cref="TimeSpan" />
        /// object.
        /// </returns>
        /// <exception cref="OverflowException">
        /// The value of this instance is <see cref="MinValue" />.
        /// </exception>
        public System.TimeSpan Duration() { return default(System.TimeSpan); }
        /// <summary>
        /// Returns a value indicating whether this instance is equal to a specified object.
        /// </summary>
        /// <param name="value">An object to compare with this instance.</param>
        /// <returns>
        /// true if <paramref name="value" /> is a <see cref="TimeSpan" /> object that represents
        /// the same time interval as the current <see cref="TimeSpan" /> structure; otherwise,
        /// false.
        /// </returns>
        public override bool Equals(object value) { return default(bool); }
        /// <summary>
        /// Returns a value indicating whether this instance is equal to a specified <see cref="TimeSpan" />
        /// object.
        /// </summary>
        /// <param name="obj">An object to compare with this instance.</param>
        /// <returns>
        /// true if <paramref name="obj" /> represents the same time interval as this instance; otherwise,
        /// false.
        /// </returns>
        public bool Equals(System.TimeSpan obj) { return default(bool); }
        /// <summary>
        /// Returns a value that indicates whether two specified instances of <see cref="TimeSpan" />
        /// are equal.
        /// </summary>
        /// <param name="t1">The first time interval to compare.</param>
        /// <param name="t2">The second time interval to compare.</param>
        /// <returns>
        /// true if the values of <paramref name="t1" /> and <paramref name="t2" /> are equal; otherwise,
        /// false.
        /// </returns>
        public static bool Equals(System.TimeSpan t1, System.TimeSpan t2) { return default(bool); }
        /// <summary>
        /// Returns a <see cref="TimeSpan" /> that represents a specified number of days, where
        /// the specification is accurate to the nearest millisecond.
        /// </summary>
        /// <param name="value">A number of days, accurate to the nearest millisecond.</param>
        /// <returns>
        /// An object that represents <paramref name="value" />.
        /// </returns>
        /// <exception cref="OverflowException">
        /// <paramref name="value" /> is less than <see cref="MinValue" /> or greater
        /// than <see cref="MaxValue" />. -or-<paramref name="value" /> is
        /// <see cref="Double.PositiveInfinity" />.-or-<paramref name="value" /> is <see cref="Double.NegativeInfinity" />.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="value" /> is equal to <see cref="Double.NaN" />.
        /// </exception>
        public static System.TimeSpan FromDays(double value) { return default(System.TimeSpan); }
        /// <summary>
        /// Returns a <see cref="TimeSpan" /> that represents a specified number of hours, where
        /// the specification is accurate to the nearest millisecond.
        /// </summary>
        /// <param name="value">A number of hours accurate to the nearest millisecond.</param>
        /// <returns>
        /// An object that represents <paramref name="value" />.
        /// </returns>
        /// <exception cref="OverflowException">
        /// <paramref name="value" /> is less than <see cref="MinValue" /> or greater
        /// than <see cref="MaxValue" />. -or-<paramref name="value" /> is
        /// <see cref="Double.PositiveInfinity" />.-or-<paramref name="value" /> is <see cref="Double.NegativeInfinity" />.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="value" /> is equal to <see cref="Double.NaN" />.
        /// </exception>
        public static System.TimeSpan FromHours(double value) { return default(System.TimeSpan); }
        /// <summary>
        /// Returns a <see cref="TimeSpan" /> that represents a specified number of milliseconds.
        /// </summary>
        /// <param name="value">A number of milliseconds.</param>
        /// <returns>
        /// An object that represents <paramref name="value" />.
        /// </returns>
        /// <exception cref="OverflowException">
        /// <paramref name="value" /> is less than <see cref="MinValue" /> or greater
        /// than <see cref="MaxValue" />.-or-<paramref name="value" /> is
        /// <see cref="Double.PositiveInfinity" />.-or-<paramref name="value" /> is <see cref="Double.NegativeInfinity" />.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="value" /> is equal to <see cref="Double.NaN" />.
        /// </exception>
        public static System.TimeSpan FromMilliseconds(double value) { return default(System.TimeSpan); }
        /// <summary>
        /// Returns a <see cref="TimeSpan" /> that represents a specified number of minutes,
        /// where the specification is accurate to the nearest millisecond.
        /// </summary>
        /// <param name="value">A number of minutes, accurate to the nearest millisecond.</param>
        /// <returns>
        /// An object that represents <paramref name="value" />.
        /// </returns>
        /// <exception cref="OverflowException">
        /// <paramref name="value" /> is less than <see cref="MinValue" /> or greater
        /// than <see cref="MaxValue" />.-or-<paramref name="value" /> is
        /// <see cref="Double.PositiveInfinity" />.-or-<paramref name="value" /> is <see cref="Double.NegativeInfinity" />.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="value" /> is equal to <see cref="Double.NaN" />.
        /// </exception>
        public static System.TimeSpan FromMinutes(double value) { return default(System.TimeSpan); }
        /// <summary>
        /// Returns a <see cref="TimeSpan" /> that represents a specified number of seconds,
        /// where the specification is accurate to the nearest millisecond.
        /// </summary>
        /// <param name="value">A number of seconds, accurate to the nearest millisecond.</param>
        /// <returns>
        /// An object that represents <paramref name="value" />.
        /// </returns>
        /// <exception cref="OverflowException">
        /// <paramref name="value" /> is less than <see cref="MinValue" /> or greater
        /// than <see cref="MaxValue" />.-or-<paramref name="value" /> is
        /// <see cref="Double.PositiveInfinity" />.-or-<paramref name="value" /> is <see cref="Double.NegativeInfinity" />.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="value" /> is equal to <see cref="Double.NaN" />.
        /// </exception>
        public static System.TimeSpan FromSeconds(double value) { return default(System.TimeSpan); }
        /// <summary>
        /// Returns a <see cref="TimeSpan" /> that represents a specified time, where the specification
        /// is in units of ticks.
        /// </summary>
        /// <param name="value">A number of ticks that represent a time.</param>
        /// <returns>
        /// An object that represents <paramref name="value" />.
        /// </returns>
        public static System.TimeSpan FromTicks(long value) { return default(System.TimeSpan); }
        /// <summary>
        /// Returns a hash code for this instance.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code.
        /// </returns>
        public override int GetHashCode() { return default(int); }
        /// <summary>
        /// Returns a new <see cref="TimeSpan" /> object whose value is the negated value of
        /// this instance.
        /// </summary>
        /// <returns>
        /// A new object with the same numeric value as this instance, but with the opposite sign.
        /// </returns>
        /// <exception cref="OverflowException">
        /// The negated value of this instance cannot be represented by a <see cref="TimeSpan" />;
        /// that is, the value of this instance is <see cref="MinValue" />.
        /// </exception>
        public System.TimeSpan Negate() { return default(System.TimeSpan); }
        /// <summary>
        /// Adds two specified <see cref="TimeSpan" /> instances.
        /// </summary>
        /// <param name="t1">The first time interval to add.</param>
        /// <param name="t2">The second time interval to add.</param>
        /// <returns>
        /// An object whose value is the sum of the values of <paramref name="t1" /> and <paramref name="t2" />.
        /// </returns>
        /// <exception cref="OverflowException">
        /// The resulting <see cref="TimeSpan" /> is less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />.
        /// </exception>
        public static System.TimeSpan operator +(System.TimeSpan t1, System.TimeSpan t2) { return default(System.TimeSpan); }
        /// <summary>
        /// Indicates whether two <see cref="TimeSpan" /> instances are equal.
        /// </summary>
        /// <param name="t1">The first time interval to compare.</param>
        /// <param name="t2">The second time interval to compare.</param>
        /// <returns>
        /// true if the values of <paramref name="t1" /> and <paramref name="t2" /> are equal; otherwise,
        /// false.
        /// </returns>
        public static bool operator ==(System.TimeSpan t1, System.TimeSpan t2) { return default(bool); }
        /// <summary>
        /// Indicates whether a specified <see cref="TimeSpan" /> is greater than another specified
        /// <see cref="TimeSpan" />.
        /// </summary>
        /// <param name="t1">The first time interval to compare.</param>
        /// <param name="t2">The second time interval to compare.</param>
        /// <returns>
        /// true if the value of <paramref name="t1" /> is greater than the value of <paramref name="t2" />;
        /// otherwise, false.
        /// </returns>
        public static bool operator >(System.TimeSpan t1, System.TimeSpan t2) { return default(bool); }
        /// <summary>
        /// Indicates whether a specified <see cref="TimeSpan" /> is greater than or equal to
        /// another specified <see cref="TimeSpan" />.
        /// </summary>
        /// <param name="t1">The first time interval to compare.</param>
        /// <param name="t2">The second time interval to compare.</param>
        /// <returns>
        /// true if the value of <paramref name="t1" /> is greater than or equal to the value of <paramref name="t2" />;
        /// otherwise, false.
        /// </returns>
        public static bool operator >=(System.TimeSpan t1, System.TimeSpan t2) { return default(bool); }
        /// <summary>
        /// Indicates whether two <see cref="TimeSpan" /> instances are not equal.
        /// </summary>
        /// <param name="t1">The first time interval to compare.</param>
        /// <param name="t2">The second time interval to compare.</param>
        /// <returns>
        /// true if the values of <paramref name="t1" /> and <paramref name="t2" /> are not equal; otherwise,
        /// false.
        /// </returns>
        public static bool operator !=(System.TimeSpan t1, System.TimeSpan t2) { return default(bool); }
        /// <summary>
        /// Indicates whether a specified <see cref="TimeSpan" /> is less than another specified
        /// <see cref="TimeSpan" />.
        /// </summary>
        /// <param name="t1">The first time interval to compare.</param>
        /// <param name="t2">The second time interval to compare.</param>
        /// <returns>
        /// true if the value of <paramref name="t1" /> is less than the value of <paramref name="t2" />;
        /// otherwise, false.
        /// </returns>
        public static bool operator <(System.TimeSpan t1, System.TimeSpan t2) { return default(bool); }
        /// <summary>
        /// Indicates whether a specified <see cref="TimeSpan" /> is less than or equal to another
        /// specified <see cref="TimeSpan" />.
        /// </summary>
        /// <param name="t1">The first time interval to compare.</param>
        /// <param name="t2">The second time interval to compare.</param>
        /// <returns>
        /// true if the value of <paramref name="t1" /> is less than or equal to the value of <paramref name="t2" />;
        /// otherwise, false.
        /// </returns>
        public static bool operator <=(System.TimeSpan t1, System.TimeSpan t2) { return default(bool); }
        /// <summary>
        /// Subtracts a specified <see cref="TimeSpan" /> from another specified <see cref="TimeSpan" />.
        /// </summary>
        /// <param name="t1">The minuend.</param>
        /// <param name="t2">The subtrahend.</param>
        /// <returns>
        /// An object whose value is the result of the value of <paramref name="t1" /> minus the value
        /// of <paramref name="t2" />.
        /// </returns>
        /// <exception cref="OverflowException">
        /// The return value is less than <see cref="MinValue" /> or greater than
        /// <see cref="MaxValue" />.
        /// </exception>
        public static System.TimeSpan operator -(System.TimeSpan t1, System.TimeSpan t2) { return default(System.TimeSpan); }
        /// <summary>
        /// Returns a <see cref="TimeSpan" /> whose value is the negated value of the specified
        /// instance.
        /// </summary>
        /// <param name="t">The time interval to be negated.</param>
        /// <returns>
        /// An object that has the same numeric value as this instance, but the opposite sign.
        /// </returns>
        /// <exception cref="OverflowException">
        /// The negated value of this instance cannot be represented by a <see cref="TimeSpan" />;
        /// that is, the value of this instance is <see cref="MinValue" />.
        /// </exception>
        public static System.TimeSpan operator -(System.TimeSpan t) { return default(System.TimeSpan); }
        /// <summary>
        /// Returns the specified instance of <see cref="TimeSpan" />.
        /// </summary>
        /// <param name="t">The time interval to return.</param>
        /// <returns>
        /// The time interval specified by <paramref name="t" />.
        /// </returns>
        public static System.TimeSpan operator +(System.TimeSpan t) { return default(System.TimeSpan); }
        /// <summary>
        /// Converts the string representation of a time interval to its <see cref="TimeSpan" />
        /// equivalent.
        /// </summary>
        /// <param name="s">A string that specifies the time interval to convert.</param>
        /// <returns>
        /// A time interval that corresponds to <paramref name="s" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="FormatException"><paramref name="s" /> has an invalid format.</exception>
        /// <exception cref="OverflowException">
        /// <paramref name="s" /> represents a number that is less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />.-or- At least one of the days,
        /// hours, minutes, or seconds components is outside its valid range.
        /// </exception>
        public static System.TimeSpan Parse(string s) { return default(System.TimeSpan); }
        /// <summary>
        /// Converts the string representation of a time interval to its <see cref="TimeSpan" />
        /// equivalent by using the specified culture-specific format information.
        /// </summary>
        /// <param name="input">A string that specifies the time interval to convert.</param>
        /// <param name="formatProvider">An object that supplies culture-specific formatting information.</param>
        /// <returns>
        /// A time interval that corresponds to <paramref name="input" />, as specified by
        /// <paramref name="formatProvider" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="input" /> is null.</exception>
        /// <exception cref="FormatException"><paramref name="input" /> has an invalid format.</exception>
        /// <exception cref="OverflowException">
        /// <paramref name="input" /> represents a number that is less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />.-or- At least one of the days,
        /// hours, minutes, or seconds components in <paramref name="input" /> is outside its valid range.
        /// </exception>
        public static System.TimeSpan Parse(string input, System.IFormatProvider formatProvider) { return default(System.TimeSpan); }
        /// <summary>
        /// Converts the string representation of a time interval to its <see cref="TimeSpan" />
        /// equivalent by using the specified format and culture-specific format information. The format
        /// of the string representation must match the specified format exactly.
        /// </summary>
        /// <param name="input">A string that specifies the time interval to convert.</param>
        /// <param name="format">
        /// A standard or custom format string that defines the required format of <paramref name="input" />.
        /// </param>
        /// <param name="formatProvider">An object that provides culture-specific formatting information.</param>
        /// <returns>
        /// A time interval that corresponds to <paramref name="input" />, as specified by <paramref name="format" />
        /// and <paramref name="formatProvider" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="input" /> is null.</exception>
        /// <exception cref="FormatException"><paramref name="input" /> has an invalid format.</exception>
        /// <exception cref="OverflowException">
        /// <paramref name="input" /> represents a number that is less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />.-or- At least one of the days,
        /// hours, minutes, or seconds components in <paramref name="input" /> is outside its valid range.
        /// </exception>
        public static System.TimeSpan ParseExact(string input, string format, System.IFormatProvider formatProvider) { return default(System.TimeSpan); }
        /// <summary>
        /// Converts the string representation of a time interval to its <see cref="TimeSpan" />
        /// equivalent by using the specified format, culture-specific format information, and styles.
        /// The format of the string representation must match the specified format exactly.
        /// </summary>
        /// <param name="input">A string that specifies the time interval to convert.</param>
        /// <param name="format">
        /// A standard or custom format string that defines the required format of <paramref name="input" />.
        /// </param>
        /// <param name="formatProvider">An object that provides culture-specific formatting information.</param>
        /// <param name="styles">
        /// A bitwise combination of enumeration values that defines the style elements that may be present
        /// in <paramref name="input" />.
        /// </param>
        /// <returns>
        /// A time interval that corresponds to <paramref name="input" />, as specified by <paramref name="format" />,
        /// <paramref name="formatProvider" />, and <paramref name="styles" />.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// <paramref name="styles" /> is an invalid <see cref="Globalization.TimeSpanStyles" />
        /// value.
        /// </exception>
        /// <exception cref="ArgumentNullException"><paramref name="input" /> is null.</exception>
        /// <exception cref="FormatException"><paramref name="input" /> has an invalid format.</exception>
        /// <exception cref="OverflowException">
        /// <paramref name="input" /> represents a number that is less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />.-or- At least one of the days,
        /// hours, minutes, or seconds components in <paramref name="input" /> is outside its valid range.
        /// </exception>
        public static System.TimeSpan ParseExact(string input, string format, System.IFormatProvider formatProvider, System.Globalization.TimeSpanStyles styles) { return default(System.TimeSpan); }
        /// <summary>
        /// Converts the string representation of a time interval to its <see cref="TimeSpan" />
        /// equivalent by using the specified array of format strings and culture-specific format information.
        /// The format of the string representation must match one of the specified formats exactly.
        /// </summary>
        /// <param name="input">A string that specifies the time interval to convert.</param>
        /// <param name="formats">
        /// A array of standard or custom format strings that defines the required format of <paramref name="input" />.
        /// </param>
        /// <param name="formatProvider">An object that provides culture-specific formatting information.</param>
        /// <returns>
        /// A time interval that corresponds to <paramref name="input" />, as specified by <paramref name="formats" />
        /// and <paramref name="formatProvider" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="input" /> is null.</exception>
        /// <exception cref="FormatException"><paramref name="input" /> has an invalid format.</exception>
        /// <exception cref="OverflowException">
        /// <paramref name="input" /> represents a number that is less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />.-or- At least one of the days,
        /// hours, minutes, or seconds components in <paramref name="input" /> is outside its valid range.
        /// </exception>
        public static System.TimeSpan ParseExact(string input, string[] formats, System.IFormatProvider formatProvider) { return default(System.TimeSpan); }
        /// <summary>
        /// Converts the string representation of a time interval to its <see cref="TimeSpan" />
        /// equivalent by using the specified formats, culture-specific format information, and styles.
        /// The format of the string representation must match one of the specified formats exactly.
        /// </summary>
        /// <param name="input">A string that specifies the time interval to convert.</param>
        /// <param name="formats">
        /// A array of standard or custom format strings that define the required format of <paramref name="input" />.
        /// </param>
        /// <param name="formatProvider">An object that provides culture-specific formatting information.</param>
        /// <param name="styles">
        /// A bitwise combination of enumeration values that defines the style elements that may be present
        /// in input.
        /// </param>
        /// <returns>
        /// A time interval that corresponds to <paramref name="input" />, as specified by <paramref name="formats" />,
        /// <paramref name="formatProvider" />, and <paramref name="styles" />.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// <paramref name="styles" /> is an invalid <see cref="Globalization.TimeSpanStyles" />
        /// value.
        /// </exception>
        /// <exception cref="ArgumentNullException"><paramref name="input" /> is null.</exception>
        /// <exception cref="FormatException"><paramref name="input" /> has an invalid format.</exception>
        /// <exception cref="OverflowException">
        /// <paramref name="input" /> represents a number that is less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />.-or- At least one of the days,
        /// hours, minutes, or seconds components in <paramref name="input" /> is outside its valid range.
        /// </exception>
        public static System.TimeSpan ParseExact(string input, string[] formats, System.IFormatProvider formatProvider, System.Globalization.TimeSpanStyles styles) { return default(System.TimeSpan); }
        /// <summary>
        /// Returns a new <see cref="TimeSpan" /> object whose value is the difference between
        /// the specified <see cref="TimeSpan" /> object and this instance.
        /// </summary>
        /// <param name="ts">The time interval to be subtracted.</param>
        /// <returns>
        /// A new time interval whose value is the result of the value of this instance minus the value
        /// of <paramref name="ts" />.
        /// </returns>
        /// <exception cref="OverflowException">
        /// The return value is less than <see cref="MinValue" /> or greater than
        /// <see cref="MaxValue" />.
        /// </exception>
        public System.TimeSpan Subtract(System.TimeSpan ts) { return default(System.TimeSpan); }
        int System.IComparable.CompareTo(object value) { return default(int); }
        /// <summary>
        /// Converts the value of the current <see cref="TimeSpan" /> object to its equivalent
        /// string representation.
        /// </summary>
        /// <returns>
        /// The string representation of the current <see cref="TimeSpan" /> value.
        /// </returns>
        public override string ToString() { return default(string); }
        /// <summary>
        /// Converts the value of the current <see cref="TimeSpan" /> object to its equivalent
        /// string representation by using the specified format.
        /// </summary>
        /// <param name="format">A standard or custom <see cref="TimeSpan" /> format string.</param>
        /// <returns>
        /// The string representation of the current <see cref="TimeSpan" /> value in the format
        /// specified by the <paramref name="format" /> parameter.
        /// </returns>
        /// <exception cref="FormatException">
        /// The <paramref name="format" /> parameter is not recognized or is not supported.
        /// </exception>
        public string ToString(string format) { return default(string); }
        /// <summary>
        /// Converts the value of the current <see cref="TimeSpan" /> object to its equivalent
        /// string representation by using the specified format and culture-specific formatting information.
        /// </summary>
        /// <param name="format">A standard or custom <see cref="TimeSpan" /> format string.</param>
        /// <param name="formatProvider">An object that supplies culture-specific formatting information.</param>
        /// <returns>
        /// The string representation of the current <see cref="TimeSpan" /> value, as specified
        /// by <paramref name="format" /> and <paramref name="formatProvider" />.
        /// </returns>
        /// <exception cref="FormatException">
        /// The <paramref name="format" /> parameter is not recognized or is not supported.
        /// </exception>
        public string ToString(string format, System.IFormatProvider formatProvider) { return default(string); }
        /// <summary>
        /// Converts the string representation of a time interval to its <see cref="TimeSpan" />
        /// equivalent by using the specified culture-specific formatting information, and returns
        /// a value that indicates whether the conversion succeeded.
        /// </summary>
        /// <param name="input">A string that specifies the time interval to convert.</param>
        /// <param name="formatProvider">An object that supplies culture-specific formatting information.</param>
        /// <param name="result">
        /// When this method returns, contains an object that represents the time interval specified by
        /// <paramref name="input" />, or <see cref="Zero" /> if the conversion failed.
        /// This parameter is passed uninitialized.
        /// </param>
        /// <returns>
        /// true if <paramref name="input" /> was converted successfully; otherwise, false. This operation
        /// returns false if the <paramref name="input" /> parameter is null or <see cref="String.Empty" />,
        /// has an invalid format, represents a time interval that is less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />, or has at least one days, hours,
        /// minutes, or seconds component outside its valid range.
        /// </returns>
        public static bool TryParse(string input, System.IFormatProvider formatProvider, out System.TimeSpan result) { result = default(System.TimeSpan); return default(bool); }
        /// <summary>
        /// Converts the string representation of a time interval to its <see cref="TimeSpan" />
        /// equivalent and returns a value that indicates whether the conversion succeeded.
        /// </summary>
        /// <param name="s">A string that specifies the time interval to convert.</param>
        /// <param name="result">
        /// When this method returns, contains an object that represents the time interval specified by
        /// <paramref name="s" />, or <see cref="Zero" /> if the conversion failed.
        /// This parameter is passed uninitialized.
        /// </param>
        /// <returns>
        /// true if <paramref name="s" /> was converted successfully; otherwise, false. This operation
        /// returns false if the <paramref name="s" /> parameter is null or <see cref="String.Empty" />,
        /// has an invalid format, represents a time interval that is less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />, or has at least one days, hours,
        /// minutes, or seconds component outside its valid range.
        /// </returns>
        public static bool TryParse(string s, out System.TimeSpan result) { result = default(System.TimeSpan); return default(bool); }
        /// <summary>
        /// Converts the string representation of a time interval to its <see cref="TimeSpan" />
        /// equivalent by using the specified format, culture-specific format information, and styles,
        /// and returns a value that indicates whether the conversion succeeded. The format of the string
        /// representation must match the specified format exactly.
        /// </summary>
        /// <param name="input">A string that specifies the time interval to convert.</param>
        /// <param name="format">
        /// A standard or custom format string that defines the required format of <paramref name="input" />.
        /// </param>
        /// <param name="formatProvider">An object that provides culture-specific formatting information.</param>
        /// <param name="styles">One or more enumeration values that indicate the style of <paramref name="input" />.</param>
        /// <param name="result">
        /// When this method returns, contains an object that represents the time interval specified by
        /// <paramref name="input" />, or <see cref="Zero" /> if the conversion failed.
        /// This parameter is passed uninitialized.
        /// </param>
        /// <returns>
        /// true if <paramref name="input" /> was converted successfully; otherwise, false.
        /// </returns>
        public static bool TryParseExact(string input, string format, System.IFormatProvider formatProvider, System.Globalization.TimeSpanStyles styles, out System.TimeSpan result) { result = default(System.TimeSpan); return default(bool); }
        /// <summary>
        /// Converts the string representation of a time interval to its <see cref="TimeSpan" />
        /// equivalent by using the specified format and culture-specific format information, and returns
        /// a value that indicates whether the conversion succeeded. The format of the string representation
        /// must match the specified format exactly.
        /// </summary>
        /// <param name="input">A string that specifies the time interval to convert.</param>
        /// <param name="format">
        /// A standard or custom format string that defines the required format of <paramref name="input" />.
        /// </param>
        /// <param name="formatProvider">An object that supplies culture-specific formatting information.</param>
        /// <param name="result">
        /// When this method returns, contains an object that represents the time interval specified by
        /// <paramref name="input" />, or <see cref="Zero" /> if the conversion failed.
        /// This parameter is passed uninitialized.
        /// </param>
        /// <returns>
        /// true if <paramref name="input" /> was converted successfully; otherwise, false.
        /// </returns>
        public static bool TryParseExact(string input, string format, System.IFormatProvider formatProvider, out System.TimeSpan result) { result = default(System.TimeSpan); return default(bool); }
        /// <summary>
        /// Converts the specified string representation of a time interval to its <see cref="TimeSpan" />
        /// equivalent by using the specified formats, culture-specific format information, and styles,
        /// and returns a value that indicates whether the conversion succeeded. The format of the string
        /// representation must match one of the specified formats exactly.
        /// </summary>
        /// <param name="input">A string that specifies the time interval to convert.</param>
        /// <param name="formats">
        /// A array of standard or custom format strings that define the acceptable formats of <paramref name="input" />.
        /// </param>
        /// <param name="formatProvider">An object that supplies culture-specific formatting information.</param>
        /// <param name="styles">One or more enumeration values that indicate the style of <paramref name="input" />.</param>
        /// <param name="result">
        /// When this method returns, contains an object that represents the time interval specified by
        /// <paramref name="input" />, or <see cref="Zero" /> if the conversion failed.
        /// This parameter is passed uninitialized.
        /// </param>
        /// <returns>
        /// true if <paramref name="input" /> was converted successfully; otherwise, false.
        /// </returns>
        public static bool TryParseExact(string input, string[] formats, System.IFormatProvider formatProvider, System.Globalization.TimeSpanStyles styles, out System.TimeSpan result) { result = default(System.TimeSpan); return default(bool); }
        /// <summary>
        /// Converts the specified string representation of a time interval to its <see cref="TimeSpan" />
        /// equivalent by using the specified formats and culture-specific format information, and
        /// returns a value that indicates whether the conversion succeeded. The format of the string
        /// representation must match one of the specified formats exactly.
        /// </summary>
        /// <param name="input">A string that specifies the time interval to convert.</param>
        /// <param name="formats">
        /// A array of standard or custom format strings that define the acceptable formats of <paramref name="input" />.
        /// </param>
        /// <param name="formatProvider">An object that provides culture-specific formatting information.</param>
        /// <param name="result">
        /// When this method returns, contains an object that represents the time interval specified by
        /// <paramref name="input" />, or <see cref="Zero" /> if the conversion failed.
        /// This parameter is passed uninitialized.
        /// </param>
        /// <returns>
        /// true if <paramref name="input" /> was converted successfully; otherwise, false.
        /// </returns>
        public static bool TryParseExact(string input, string[] formats, System.IFormatProvider formatProvider, out System.TimeSpan result) { result = default(System.TimeSpan); return default(bool); }
    }
    /// <summary>
    /// Represents any time zone in the world.
    /// </summary>
    public sealed partial class TimeZoneInfo : System.IEquatable<System.TimeZoneInfo>
    {
        internal TimeZoneInfo() { }
        /// <summary>
        /// Gets the time difference between the current time zone's standard time and Coordinated Universal
        /// Time (UTC).
        /// </summary>
        /// <returns>
        /// An object that indicates the time difference between the current time zone's standard time
        /// and Coordinated Universal Time (UTC).
        /// </returns>
        public System.TimeSpan BaseUtcOffset { get { return default(System.TimeSpan); } }
        /// <summary>
        /// Gets the display name for the current time zone's daylight saving time.
        /// </summary>
        /// <returns>
        /// The display name for the time zone's daylight saving time.
        /// </returns>
        public string DaylightName { get { return default(string); } }
        /// <summary>
        /// Gets the general display name that represents the time zone.
        /// </summary>
        /// <returns>
        /// The time zone's general display name.
        /// </returns>
        public string DisplayName { get { return default(string); } }
        /// <summary>
        /// Gets the time zone identifier.
        /// </summary>
        /// <returns>
        /// The time zone identifier.
        /// </returns>
        public string Id { get { return default(string); } }
        /// <summary>
        /// Gets a <see cref="TimeZoneInfo" /> object that represents the local time zone.
        /// </summary>
        /// <returns>
        /// An object that represents the local time zone.
        /// </returns>
        public static System.TimeZoneInfo Local { get { return default(System.TimeZoneInfo); } }
        /// <summary>
        /// Gets the display name for the time zone's standard time.
        /// </summary>
        /// <returns>
        /// The display name of the time zone's standard time.
        /// </returns>
        public string StandardName { get { return default(string); } }
        /// <summary>
        /// Gets a value indicating whether the time zone has any daylight saving time rules.
        /// </summary>
        /// <returns>
        /// true if the time zone supports daylight saving time; otherwise, false.
        /// </returns>
        public bool SupportsDaylightSavingTime { get { return default(bool); } }
        /// <summary>
        /// Gets a <see cref="TimeZoneInfo" /> object that represents the Coordinated Universal
        /// Time (UTC) zone.
        /// </summary>
        /// <returns>
        /// An object that represents the Coordinated Universal Time (UTC) zone.
        /// </returns>
        public static System.TimeZoneInfo Utc { get { return default(System.TimeZoneInfo); } }
        /// <summary>
        /// Converts a time to the time in a particular time zone.
        /// </summary>
        /// <param name="dateTime">The date and time to convert.</param>
        /// <param name="destinationTimeZone">The time zone to convert <paramref name="dateTime" /> to.</param>
        /// <returns>
        /// The date and time in the destination time zone.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// The value of the <paramref name="dateTime" /> parameter represents an invalid time.
        /// </exception>
        /// <exception cref="ArgumentNullException">
        /// The value of the <paramref name="destinationTimeZone" /> parameter is null.
        /// </exception>
        public static System.DateTime ConvertTime(System.DateTime dateTime, System.TimeZoneInfo destinationTimeZone) { return default(System.DateTime); }
        /// <summary>
        /// Converts a time from one time zone to another.
        /// </summary>
        /// <param name="dateTime">The date and time to convert.</param>
        /// <param name="sourceTimeZone">The time zone of <paramref name="dateTime" />.</param>
        /// <param name="destinationTimeZone">The time zone to convert <paramref name="dateTime" /> to.</param>
        /// <returns>
        /// The date and time in the destination time zone that corresponds to the <paramref name="dateTime" />
        /// parameter in the source time zone.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// The <see cref="DateTime.Kind" /> property of the <paramref name="dateTime" /> parameter
        /// is <see cref="DateTimeKind.Local" />, but the <paramref name="sourceTimeZone" />
        /// parameter does not equal <see cref="DateTimeKind.Local" />. For more information,
        /// see the Remarks section. -or-The <see cref="DateTime.Kind" /> property of the <paramref name="dateTime" />
        /// parameter is <see cref="DateTimeKind.Utc" />, but the <paramref name="sourceTimeZone" />
        /// parameter does not equal <see cref="Utc" />.-or-The
        /// <paramref name="dateTime" /> parameter is an invalid time (that is, it represents a time that
        /// does not exist because of a time zone's adjustment rules).
        /// </exception>
        /// <exception cref="ArgumentNullException">
        /// The <paramref name="sourceTimeZone" /> parameter is null.-or-The <paramref name="destinationTimeZone" />
        /// parameter is null.
        /// </exception>
        public static System.DateTime ConvertTime(System.DateTime dateTime, System.TimeZoneInfo sourceTimeZone, System.TimeZoneInfo destinationTimeZone) { return default(System.DateTime); }
        /// <summary>
        /// Converts a time to the time in a particular time zone.
        /// </summary>
        /// <param name="dateTimeOffset">The date and time to convert.</param>
        /// <param name="destinationTimeZone">The time zone to convert <paramref name="dateTime" /> to.</param>
        /// <returns>
        /// The date and time in the destination time zone.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// The value of the <paramref name="destinationTimeZone" /> parameter is null.
        /// </exception>
        public static System.DateTimeOffset ConvertTime(System.DateTimeOffset dateTimeOffset, System.TimeZoneInfo destinationTimeZone) { return default(System.DateTimeOffset); }
        /// <summary>
        /// Determines whether the current <see cref="TimeZoneInfo" /> object and another
        /// <see cref="TimeZoneInfo" /> object are equal.
        /// </summary>
        /// <param name="other">A second object to compare with the current object.</param>
        /// <returns>
        /// true if the two <see cref="TimeZoneInfo" /> objects are equal; otherwise, false.
        /// </returns>
        public bool Equals(System.TimeZoneInfo other) { return default(bool); }
        /// <summary>
        /// Retrieves a <see cref="TimeZoneInfo" /> object from the registry based on its identifier.
        /// </summary>
        /// <param name="id">
        /// The time zone identifier, which corresponds to the <see cref="Id" />
        /// property.
        /// </param>
        /// <returns>
        /// An object whose identifier is the value of the <paramref name="id" /> parameter.
        /// </returns>
        /// <exception cref="OutOfMemoryException">
        /// The system does not have enough memory to hold information about the time zone.
        /// </exception>
        /// <exception cref="ArgumentNullException">The <paramref name="id" /> parameter is null.</exception>
        /// <exception cref="TimeZoneNotFoundException">
        /// The time zone identifier specified by <paramref name="id" /> was not found. This means that
        /// a registry key whose name matches <paramref name="id" /> does not exist, or that the key exists
        /// but does not contain any time zone data.
        /// </exception>
        /// <exception cref="Security.SecurityException">
        /// The process does not have the permissions required to read from the registry key that contains
        /// the time zone information.
        /// </exception>
        /// <exception cref="InvalidTimeZoneException">
        /// The time zone identifier was found, but the registry data is corrupted.
        /// </exception>
        public static System.TimeZoneInfo FindSystemTimeZoneById(string id) { return default(System.TimeZoneInfo); }
        /// <summary>
        /// Returns information about the possible dates and times that an ambiguous date and time can
        /// be mapped to.
        /// </summary>
        /// <param name="dateTime">A date and time.</param>
        /// <returns>
        /// An array of objects that represents possible Coordinated Universal Time (UTC) offsets that
        /// a particular date and time can be mapped to.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// <paramref name="dateTime" /> is not an ambiguous time.
        /// </exception>
        public System.TimeSpan[] GetAmbiguousTimeOffsets(System.DateTime dateTime) { return default(System.TimeSpan[]); }
        /// <summary>
        /// Returns information about the possible dates and times that an ambiguous date and time can
        /// be mapped to.
        /// </summary>
        /// <param name="dateTimeOffset">A date and time.</param>
        /// <returns>
        /// An array of objects that represents possible Coordinated Universal Time (UTC) offsets that
        /// a particular date and time can be mapped to.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// <paramref name="dateTimeOffset" /> is not an ambiguous time.
        /// </exception>
        public System.TimeSpan[] GetAmbiguousTimeOffsets(System.DateTimeOffset dateTimeOffset) { return default(System.TimeSpan[]); }
        /// <summary>
        /// Serves as a hash function for hashing algorithms and data structures such as hash tables.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer that serves as the hash code for this <see cref="TimeZoneInfo" />
        /// object.
        /// </returns>
        public override int GetHashCode() { return default(int); }
        /// <summary>
        /// Returns a sorted collection of all the time zones about which information is available on the
        /// local system.
        /// </summary>
        /// <returns>
        /// A read-only collection of <see cref="TimeZoneInfo" /> objects.
        /// </returns>
        /// <exception cref="OutOfMemoryException">
        /// There is insufficient memory to store all time zone information.
        /// </exception>
        /// <exception cref="Security.SecurityException">
        /// The user does not have permission to read from the registry keys that contain time zone information.
        /// </exception>
        public static System.Collections.ObjectModel.ReadOnlyCollection<System.TimeZoneInfo> GetSystemTimeZones() { return default(System.Collections.ObjectModel.ReadOnlyCollection<System.TimeZoneInfo>); }
        /// <summary>
        /// Calculates the offset or difference between the time in this time zone and Coordinated Universal
        /// Time (UTC) for a particular date and time.
        /// </summary>
        /// <param name="dateTime">The date and time to determine the offset for.</param>
        /// <returns>
        /// An object that indicates the time difference between the two time zones.
        /// </returns>
        public System.TimeSpan GetUtcOffset(System.DateTime dateTime) { return default(System.TimeSpan); }
        /// <summary>
        /// Calculates the offset or difference between the time in this time zone and Coordinated Universal
        /// Time (UTC) for a particular date and time.
        /// </summary>
        /// <param name="dateTimeOffset">The date and time to determine the offset for.</param>
        /// <returns>
        /// An object that indicates the time difference between Coordinated Universal Time (UTC) and the
        /// current time zone.
        /// </returns>
        public System.TimeSpan GetUtcOffset(System.DateTimeOffset dateTimeOffset) { return default(System.TimeSpan); }
        /// <summary>
        /// Determines whether a particular date and time in a particular time zone is ambiguous and can
        /// be mapped to two or more Coordinated Universal Time (UTC) times.
        /// </summary>
        /// <param name="dateTime">A date and time value.</param>
        /// <returns>
        /// true if the <paramref name="dateTime" /> parameter is ambiguous; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// The <see cref="DateTime.Kind" /> property of the <paramref name="dateTime" /> value
        /// is <see cref="DateTimeKind.Local" /> and <paramref name="dateTime" /> is an invalid
        /// time.
        /// </exception>
        public bool IsAmbiguousTime(System.DateTime dateTime) { return default(bool); }
        /// <summary>
        /// Determines whether a particular date and time in a particular time zone is ambiguous and can
        /// be mapped to two or more Coordinated Universal Time (UTC) times.
        /// </summary>
        /// <param name="dateTimeOffset">A date and time.</param>
        /// <returns>
        /// true if the <paramref name="dateTimeOffset" /> parameter is ambiguous in the current time
        /// zone; otherwise, false.
        /// </returns>
        public bool IsAmbiguousTime(System.DateTimeOffset dateTimeOffset) { return default(bool); }
        /// <summary>
        /// Indicates whether a specified date and time falls in the range of daylight saving time for
        /// the time zone of the current <see cref="TimeZoneInfo" /> object.
        /// </summary>
        /// <param name="dateTime">A date and time value.</param>
        /// <returns>
        /// true if the <paramref name="dateTime" /> parameter is a daylight saving time; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// The <see cref="DateTime.Kind" /> property of the <paramref name="dateTime" /> value
        /// is <see cref="DateTimeKind.Local" /> and <paramref name="dateTime" /> is an invalid
        /// time.
        /// </exception>
        public bool IsDaylightSavingTime(System.DateTime dateTime) { return default(bool); }
        /// <summary>
        /// Indicates whether a specified date and time falls in the range of daylight saving time for
        /// the time zone of the current <see cref="TimeZoneInfo" /> object.
        /// </summary>
        /// <param name="dateTimeOffset">A date and time value.</param>
        /// <returns>
        /// true if the <paramref name="dateTimeOffset" /> parameter is a daylight saving time; otherwise,
        /// false.
        /// </returns>
        public bool IsDaylightSavingTime(System.DateTimeOffset dateTimeOffset) { return default(bool); }
        /// <summary>
        /// Indicates whether a particular date and time is invalid.
        /// </summary>
        /// <param name="dateTime">A date and time value.</param>
        /// <returns>
        /// true if <paramref name="dateTime" /> is invalid; otherwise, false.
        /// </returns>
        public bool IsInvalidTime(System.DateTime dateTime) { return default(bool); }
        /// <summary>
        /// Returns the current <see cref="TimeZoneInfo" /> object's display name.
        /// </summary>
        /// <returns>
        /// The value of the <see cref="DisplayName" /> property of the current
        /// <see cref="TimeZoneInfo" /> object.
        /// </returns>
        public override string ToString() { return default(string); }
    }
    /// <summary>
    /// Provides static methods for creating tuple objects. To browse the .NET Framework source code
    /// for this type, see the Reference Source.
    /// </summary>
    public static partial class Tuple
    {
        /// <summary>
        /// Creates a new 1-tuple, or singleton.
        /// </summary>
        /// <param name="item1">The value of the only component of the tuple.</param>
        /// <typeparam name="T1">The type of the only component of the tuple.</typeparam>
        /// <returns>
        /// A tuple whose value is (<paramref name="item1" />).
        /// </returns>
        public static System.Tuple<T1> Create<T1>(T1 item1) { return default(System.Tuple<T1>); }
        /// <summary>
        /// Creates a new 2-tuple, or pair.
        /// </summary>
        /// <param name="item1">The value of the first component of the tuple.</param>
        /// <param name="item2">The value of the second component of the tuple.</param>
        /// <typeparam name="T1">The type of the first component of the tuple.</typeparam>
        /// <typeparam name="T2">The type of the second component of the tuple.</typeparam>
        /// <returns>
        /// A 2-tuple whose value is (<paramref name="item1" />, <paramref name="item2" />).
        /// </returns>
        public static System.Tuple<T1, T2> Create<T1, T2>(T1 item1, T2 item2) { return default(System.Tuple<T1, T2>); }
        /// <summary>
        /// Creates a new 3-tuple, or triple.
        /// </summary>
        /// <param name="item1">The value of the first component of the tuple.</param>
        /// <param name="item2">The value of the second component of the tuple.</param>
        /// <param name="item3">The value of the third component of the tuple.</param>
        /// <typeparam name="T1">The type of the first component of the tuple.</typeparam>
        /// <typeparam name="T2">The type of the second component of the tuple.</typeparam>
        /// <typeparam name="T3">The type of the third component of the tuple.</typeparam>
        /// <returns>
        /// A 3-tuple whose value is (<paramref name="item1" />, <paramref name="item2" />, <paramref name="item3" />
        /// ).
        /// </returns>
        public static System.Tuple<T1, T2, T3> Create<T1, T2, T3>(T1 item1, T2 item2, T3 item3) { return default(System.Tuple<T1, T2, T3>); }
        /// <summary>
        /// Creates a new 4-tuple, or quadruple.
        /// </summary>
        /// <param name="item1">The value of the first component of the tuple.</param>
        /// <param name="item2">The value of the second component of the tuple.</param>
        /// <param name="item3">The value of the third component of the tuple.</param>
        /// <param name="item4">The value of the fourth component of the tuple.</param>
        /// <typeparam name="T1">The type of the first component of the tuple.</typeparam>
        /// <typeparam name="T2">The type of the second component of the tuple.</typeparam>
        /// <typeparam name="T3">The type of the third component of the tuple.</typeparam>
        /// <typeparam name="T4">The type of the fourth component of the tuple.</typeparam>
        /// <returns>
        /// A 4-tuple whose value is (<paramref name="item1" />, <paramref name="item2" />, <paramref name="item3" />,
        /// <paramref name="item4" />).
        /// </returns>
        public static System.Tuple<T1, T2, T3, T4> Create<T1, T2, T3, T4>(T1 item1, T2 item2, T3 item3, T4 item4) { return default(System.Tuple<T1, T2, T3, T4>); }
        /// <summary>
        /// Creates a new 5-tuple, or quintuple.
        /// </summary>
        /// <param name="item1">The value of the first component of the tuple.</param>
        /// <param name="item2">The value of the second component of the tuple.</param>
        /// <param name="item3">The value of the third component of the tuple.</param>
        /// <param name="item4">The value of the fourth component of the tuple.</param>
        /// <param name="item5">The value of the fifth component of the tuple.</param>
        /// <typeparam name="T1">The type of the first component of the tuple.</typeparam>
        /// <typeparam name="T2">The type of the second component of the tuple.</typeparam>
        /// <typeparam name="T3">The type of the third component of the tuple.</typeparam>
        /// <typeparam name="T4">The type of the fourth component of the tuple.</typeparam>
        /// <typeparam name="T5">The type of the fifth component of the tuple.</typeparam>
        /// <returns>
        /// A 5-tuple whose value is (<paramref name="item1" />, <paramref name="item2" />, <paramref name="item3" />,
        /// <paramref name="item4" />, <paramref name="item5" />).
        /// </returns>
        public static System.Tuple<T1, T2, T3, T4, T5> Create<T1, T2, T3, T4, T5>(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5) { return default(System.Tuple<T1, T2, T3, T4, T5>); }
        /// <summary>
        /// Creates a new 6-tuple, or sextuple.
        /// </summary>
        /// <param name="item1">The value of the first component of the tuple.</param>
        /// <param name="item2">The value of the second component of the tuple.</param>
        /// <param name="item3">The value of the third component of the tuple.</param>
        /// <param name="item4">The value of the fourth component of the tuple.</param>
        /// <param name="item5">The value of the fifth component of the tuple.</param>
        /// <param name="item6">The value of the sixth component of the tuple.</param>
        /// <typeparam name="T1">The type of the first component of the tuple.</typeparam>
        /// <typeparam name="T2">The type of the second component of the tuple.</typeparam>
        /// <typeparam name="T3">The type of the third component of the tuple.</typeparam>
        /// <typeparam name="T4">The type of the fourth component of the tuple.</typeparam>
        /// <typeparam name="T5">The type of the fifth component of the tuple.</typeparam>
        /// <typeparam name="T6">The type of the sixth component of the tuple.</typeparam>
        /// <returns>
        /// A 6-tuple whose value is (<paramref name="item1" />, <paramref name="item2" />, <paramref name="item3" />,
        /// <paramref name="item4" />, <paramref name="item5" />, <paramref name="item6" />
        /// ).
        /// </returns>
        public static System.Tuple<T1, T2, T3, T4, T5, T6> Create<T1, T2, T3, T4, T5, T6>(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6) { return default(System.Tuple<T1, T2, T3, T4, T5, T6>); }
        /// <summary>
        /// Creates a new 7-tuple, or septuple.
        /// </summary>
        /// <param name="item1">The value of the first component of the tuple.</param>
        /// <param name="item2">The value of the second component of the tuple.</param>
        /// <param name="item3">The value of the third component of the tuple.</param>
        /// <param name="item4">The value of the fourth component of the tuple.</param>
        /// <param name="item5">The value of the fifth component of the tuple.</param>
        /// <param name="item6">The value of the sixth component of the tuple.</param>
        /// <param name="item7">The value of the seventh component of the tuple.</param>
        /// <typeparam name="T1">The type of the first component of the tuple.</typeparam>
        /// <typeparam name="T2">The type of the second component of the tuple.</typeparam>
        /// <typeparam name="T3">The type of the third component of the tuple.</typeparam>
        /// <typeparam name="T4">The type of the fourth component of the tuple.</typeparam>
        /// <typeparam name="T5">The type of the fifth component of the tuple.</typeparam>
        /// <typeparam name="T6">The type of the sixth component of the tuple.</typeparam>
        /// <typeparam name="T7">The type of the seventh component of the tuple.</typeparam>
        /// <returns>
        /// A 7-tuple whose value is (<paramref name="item1" />, <paramref name="item2" />, <paramref name="item3" />,
        /// <paramref name="item4" />, <paramref name="item5" />, <paramref name="item6" />,
        /// <paramref name="item7" />).
        /// </returns>
        public static System.Tuple<T1, T2, T3, T4, T5, T6, T7> Create<T1, T2, T3, T4, T5, T6, T7>(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7) { return default(System.Tuple<T1, T2, T3, T4, T5, T6, T7>); }
        /// <summary>
        /// Creates a new 8-tuple, or octuple.
        /// </summary>
        /// <param name="item1">The value of the first component of the tuple.</param>
        /// <param name="item2">The value of the second component of the tuple.</param>
        /// <param name="item3">The value of the third component of the tuple.</param>
        /// <param name="item4">The value of the fourth component of the tuple.</param>
        /// <param name="item5">The value of the fifth component of the tuple.</param>
        /// <param name="item6">The value of the sixth component of the tuple.</param>
        /// <param name="item7">The value of the seventh component of the tuple.</param>
        /// <param name="item8">The value of the eighth component of the tuple.</param>
        /// <typeparam name="T1">The type of the first component of the tuple.</typeparam>
        /// <typeparam name="T2">The type of the second component of the tuple.</typeparam>
        /// <typeparam name="T3">The type of the third component of the tuple.</typeparam>
        /// <typeparam name="T4">The type of the fourth component of the tuple.</typeparam>
        /// <typeparam name="T5">The type of the fifth component of the tuple.</typeparam>
        /// <typeparam name="T6">The type of the sixth component of the tuple.</typeparam>
        /// <typeparam name="T7">The type of the seventh component of the tuple.</typeparam>
        /// <typeparam name="T8">The type of the eighth component of the tuple.</typeparam>
        /// <returns>
        /// An 8-tuple (octuple) whose value is (<paramref name="item1" />, <paramref name="item2" />,
        /// <paramref name="item3" />, <paramref name="item4" />, <paramref name="item5" />, <paramref name="item6" />,
        /// <paramref name="item7" />, <paramref name="item8" />).
        /// </returns>
        public static System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8>> Create<T1, T2, T3, T4, T5, T6, T7, T8>(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8) { return default(System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8>>); }
    }
    /// <summary>
    /// Represents a 1-tuple, or singleton.
    /// </summary>
    /// <typeparam name="T1">The type of the tuple's only component.</typeparam>
    public partial class Tuple<T1> : System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.IComparable
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Tuple`1" /> class.
        /// </summary>
        /// <param name="item1">The value of the tuple's only component.</param>
        public Tuple(T1 item1) { }
        /// <summary>
        /// Gets the value of the <see cref="Tuple`1" /> object's single component.
        /// </summary>
        /// <returns>
        /// The value of the current <see cref="Tuple`1" /> object's single component.
        /// </returns>
        public T1 Item1 { get { return default(T1); } }
        /// <summary>
        /// Returns a value that indicates whether the current <see cref="Tuple`1" /> object
        /// is equal to a specified object.
        /// </summary>
        /// <param name="obj">The object to compare with this instance.</param>
        /// <returns>
        /// true if the current instance is equal to the specified object; otherwise, false.
        /// </returns>
        public override bool Equals(object obj) { return default(bool); }
        /// <summary>
        /// Returns the hash code for the current <see cref="Tuple`1" /> object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code.
        /// </returns>
        public override int GetHashCode() { return default(int); }
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer) { return default(int); }
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer) { return default(bool); }
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer) { return default(int); }
        int System.IComparable.CompareTo(object obj) { return default(int); }
        /// <summary>
        /// Returns a string that represents the value of this <see cref="Tuple`1" /> instance.
        /// </summary>
        /// <returns>
        /// The string representation of this <see cref="Tuple`1" /> object.
        /// </returns>
        public override string ToString() { return default(string); }
    }
    /// <summary>
    /// Represents a 2-tuple, or pair.
    /// </summary>
    /// <typeparam name="T1">The type of the tuple's first component.</typeparam>
    /// <typeparam name="T2">The type of the tuple's second component.</typeparam>
    public partial class Tuple<T1, T2> : System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.IComparable
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Tuple`2" /> class.
        /// </summary>
        /// <param name="item1">The value of the tuple's first component.</param>
        /// <param name="item2">The value of the tuple's second component.</param>
        public Tuple(T1 item1, T2 item2) { }
        /// <summary>
        /// Gets the value of the current <see cref="Tuple`2" /> object's first component.
        /// </summary>
        /// <returns>
        /// The value of the current <see cref="Tuple`2" /> object's first component.
        /// </returns>
        public T1 Item1 { get { return default(T1); } }
        /// <summary>
        /// Gets the value of the current <see cref="Tuple`2" /> object's second component.
        /// </summary>
        /// <returns>
        /// The value of the current <see cref="Tuple`2" /> object's second component.
        /// </returns>
        public T2 Item2 { get { return default(T2); } }
        /// <summary>
        /// Returns a value that indicates whether the current <see cref="Tuple`2" /> object
        /// is equal to a specified object.
        /// </summary>
        /// <param name="obj">The object to compare with this instance.</param>
        /// <returns>
        /// true if the current instance is equal to the specified object; otherwise, false.
        /// </returns>
        public override bool Equals(object obj) { return default(bool); }
        /// <summary>
        /// Returns the hash code for the current <see cref="Tuple`2" /> object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code.
        /// </returns>
        public override int GetHashCode() { return default(int); }
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer) { return default(int); }
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer) { return default(bool); }
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer) { return default(int); }
        int System.IComparable.CompareTo(object obj) { return default(int); }
        /// <summary>
        /// Returns a string that represents the value of this <see cref="Tuple`2" /> instance.
        /// </summary>
        /// <returns>
        /// The string representation of this <see cref="Tuple`2" /> object.
        /// </returns>
        public override string ToString() { return default(string); }
    }
    /// <summary>
    /// Represents a 3-tuple, or triple.
    /// </summary>
    /// <typeparam name="T1">The type of the tuple's first component.</typeparam>
    /// <typeparam name="T2">The type of the tuple's second component.</typeparam>
    /// <typeparam name="T3">The type of the tuple's third component.</typeparam>
    public partial class Tuple<T1, T2, T3> : System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.IComparable
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Tuple`3" /> class.
        /// </summary>
        /// <param name="item1">The value of the tuple's first component.</param>
        /// <param name="item2">The value of the tuple's second component.</param>
        /// <param name="item3">The value of the tuple's third component.</param>
        public Tuple(T1 item1, T2 item2, T3 item3) { }
        /// <summary>
        /// Gets the value of the current <see cref="Tuple`3" /> object's first component.
        /// </summary>
        /// <returns>
        /// The value of the current <see cref="Tuple`3" /> object's first component.
        /// </returns>
        public T1 Item1 { get { return default(T1); } }
        /// <summary>
        /// Gets the value of the current <see cref="Tuple`3" /> object's second component.
        /// </summary>
        /// <returns>
        /// The value of the current <see cref="Tuple`3" /> object's second component.
        /// </returns>
        public T2 Item2 { get { return default(T2); } }
        /// <summary>
        /// Gets the value of the current <see cref="Tuple`3" /> object's third component.
        /// </summary>
        /// <returns>
        /// The value of the current <see cref="Tuple`3" /> object's third component.
        /// </returns>
        public T3 Item3 { get { return default(T3); } }
        /// <summary>
        /// Returns a value that indicates whether the current <see cref="Tuple`3" /> object
        /// is equal to a specified object.
        /// </summary>
        /// <param name="obj">The object to compare with this instance.</param>
        /// <returns>
        /// true if the current instance is equal to the specified object; otherwise, false.
        /// </returns>
        public override bool Equals(object obj) { return default(bool); }
        /// <summary>
        /// Returns the hash code for the current <see cref="Tuple`3" /> object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code.
        /// </returns>
        public override int GetHashCode() { return default(int); }
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer) { return default(int); }
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer) { return default(bool); }
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer) { return default(int); }
        int System.IComparable.CompareTo(object obj) { return default(int); }
        /// <summary>
        /// Returns a string that represents the value of this <see cref="Tuple`3" /> instance.
        /// </summary>
        /// <returns>
        /// The string representation of this <see cref="Tuple`3" /> object.
        /// </returns>
        public override string ToString() { return default(string); }
    }
    /// <summary>
    /// Represents a 4-tuple, or quadruple.
    /// </summary>
    /// <typeparam name="T1">The type of the tuple's first component.</typeparam>
    /// <typeparam name="T2">The type of the tuple's second component.</typeparam>
    /// <typeparam name="T3">The type of the tuple's third component.</typeparam>
    /// <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
    public partial class Tuple<T1, T2, T3, T4> : System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.IComparable
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Tuple`4" /> class.
        /// </summary>
        /// <param name="item1">The value of the tuple's first component.</param>
        /// <param name="item2">The value of the tuple's second component.</param>
        /// <param name="item3">The value of the tuple's third component.</param>
        /// <param name="item4">The value of the tuple's fourth component</param>
        public Tuple(T1 item1, T2 item2, T3 item3, T4 item4) { }
        /// <summary>
        /// Gets the value of the current <see cref="Tuple`4" /> object's first component.
        /// </summary>
        /// <returns>
        /// The value of the current <see cref="Tuple`4" /> object's first component.
        /// </returns>
        public T1 Item1 { get { return default(T1); } }
        /// <summary>
        /// Gets the value of the current <see cref="Tuple`4" /> object's second component.
        /// </summary>
        /// <returns>
        /// The value of the current <see cref="Tuple`4" /> object's second component.
        /// </returns>
        public T2 Item2 { get { return default(T2); } }
        /// <summary>
        /// Gets the value of the current <see cref="Tuple`4" /> object's third component.
        /// </summary>
        /// <returns>
        /// The value of the current <see cref="Tuple`4" /> object's third component.
        /// </returns>
        public T3 Item3 { get { return default(T3); } }
        /// <summary>
        /// Gets the value of the current <see cref="Tuple`4" /> object's fourth component.
        /// </summary>
        /// <returns>
        /// The value of the current <see cref="Tuple`4" /> object's fourth component.
        /// </returns>
        public T4 Item4 { get { return default(T4); } }
        /// <summary>
        /// Returns a value that indicates whether the current <see cref="Tuple`4" /> object
        /// is equal to a specified object.
        /// </summary>
        /// <param name="obj">The object to compare with this instance.</param>
        /// <returns>
        /// true if the current instance is equal to the specified object; otherwise, false.
        /// </returns>
        public override bool Equals(object obj) { return default(bool); }
        /// <summary>
        /// Returns the hash code for the current <see cref="Tuple`4" /> object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code.
        /// </returns>
        public override int GetHashCode() { return default(int); }
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer) { return default(int); }
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer) { return default(bool); }
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer) { return default(int); }
        int System.IComparable.CompareTo(object obj) { return default(int); }
        /// <summary>
        /// Returns a string that represents the value of this <see cref="Tuple`4" /> instance.
        /// </summary>
        /// <returns>
        /// The string representation of this <see cref="Tuple`4" /> object.
        /// </returns>
        public override string ToString() { return default(string); }
    }
    /// <summary>
    /// Represents a 5-tuple, or quintuple.
    /// </summary>
    /// <typeparam name="T1">The type of the tuple's first component.</typeparam>
    /// <typeparam name="T2">The type of the tuple's second component.</typeparam>
    /// <typeparam name="T3">The type of the tuple's third component.</typeparam>
    /// <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
    /// <typeparam name="T5">The type of the tuple's fifth component.</typeparam>
    public partial class Tuple<T1, T2, T3, T4, T5> : System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.IComparable
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Tuple`5" /> class.
        /// </summary>
        /// <param name="item1">The value of the tuple's first component.</param>
        /// <param name="item2">The value of the tuple's second component.</param>
        /// <param name="item3">The value of the tuple's third component.</param>
        /// <param name="item4">The value of the tuple's fourth component</param>
        /// <param name="item5">The value of the tuple's fifth component.</param>
        public Tuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5) { }
        /// <summary>
        /// Gets the value of the current <see cref="Tuple`5" /> object's first component.
        /// </summary>
        /// <returns>
        /// The value of the current <see cref="Tuple`5" /> object's first component.
        /// </returns>
        public T1 Item1 { get { return default(T1); } }
        /// <summary>
        /// Gets the value of the current <see cref="Tuple`5" /> object's second component.
        /// </summary>
        /// <returns>
        /// The value of the current <see cref="Tuple`5" /> object's second component.
        /// </returns>
        public T2 Item2 { get { return default(T2); } }
        /// <summary>
        /// Gets the value of the current <see cref="Tuple`5" /> object's third component.
        /// </summary>
        /// <returns>
        /// The value of the current <see cref="Tuple`5" /> object's third component.
        /// </returns>
        public T3 Item3 { get { return default(T3); } }
        /// <summary>
        /// Gets the value of the current <see cref="Tuple`5" /> object's fourth component.
        /// </summary>
        /// <returns>
        /// The value of the current <see cref="Tuple`5" /> object's fourth component.
        /// </returns>
        public T4 Item4 { get { return default(T4); } }
        /// <summary>
        /// Gets the value of the current <see cref="Tuple`5" /> object's fifth component.
        /// </summary>
        /// <returns>
        /// The value of the current <see cref="Tuple`5" /> object's fifth component.
        /// </returns>
        public T5 Item5 { get { return default(T5); } }
        /// <summary>
        /// Returns a value that indicates whether the current <see cref="Tuple`5" /> object
        /// is equal to a specified object.
        /// </summary>
        /// <param name="obj">The object to compare with this instance.</param>
        /// <returns>
        /// true if the current instance is equal to the specified object; otherwise, false.
        /// </returns>
        public override bool Equals(object obj) { return default(bool); }
        /// <summary>
        /// Returns the hash code for the current <see cref="Tuple`5" /> object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code.
        /// </returns>
        public override int GetHashCode() { return default(int); }
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer) { return default(int); }
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer) { return default(bool); }
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer) { return default(int); }
        int System.IComparable.CompareTo(object obj) { return default(int); }
        /// <summary>
        /// Returns a string that represents the value of this <see cref="Tuple`5" /> instance.
        /// </summary>
        /// <returns>
        /// The string representation of this <see cref="Tuple`5" /> object.
        /// </returns>
        public override string ToString() { return default(string); }
    }
    /// <summary>
    /// Represents a 6-tuple, or sextuple.
    /// </summary>
    /// <typeparam name="T1">The type of the tuple's first component.</typeparam>
    /// <typeparam name="T2">The type of the tuple's second component.</typeparam>
    /// <typeparam name="T3">The type of the tuple's third component.</typeparam>
    /// <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
    /// <typeparam name="T5">The type of the tuple's fifth component.</typeparam>
    /// <typeparam name="T6">The type of the tuple's sixth component.</typeparam>
    public partial class Tuple<T1, T2, T3, T4, T5, T6> : System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.IComparable
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Tuple`6" /> class.
        /// </summary>
        /// <param name="item1">The value of the tuple's first component.</param>
        /// <param name="item2">The value of the tuple's second component.</param>
        /// <param name="item3">The value of the tuple's third component.</param>
        /// <param name="item4">The value of the tuple's fourth component</param>
        /// <param name="item5">The value of the tuple's fifth component.</param>
        /// <param name="item6">The value of the tuple's sixth component.</param>
        public Tuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6) { }
        /// <summary>
        /// Gets the value of the current <see cref="Tuple`6" /> object's first component.
        /// </summary>
        /// <returns>
        /// The value of the current <see cref="Tuple`6" /> object's first component.
        /// </returns>
        public T1 Item1 { get { return default(T1); } }
        /// <summary>
        /// Gets the value of the current <see cref="Tuple`6" /> object's second component.
        /// </summary>
        /// <returns>
        /// The value of the current <see cref="Tuple`6" /> object's second component.
        /// </returns>
        public T2 Item2 { get { return default(T2); } }
        /// <summary>
        /// Gets the value of the current <see cref="Tuple`6" /> object's third component.
        /// </summary>
        /// <returns>
        /// The value of the current <see cref="Tuple`6" /> object's third component.
        /// </returns>
        public T3 Item3 { get { return default(T3); } }
        /// <summary>
        /// Gets the value of the current <see cref="Tuple`6" /> object's fourth component.
        /// </summary>
        /// <returns>
        /// The value of the current <see cref="Tuple`6" /> object's fourth component.
        /// </returns>
        public T4 Item4 { get { return default(T4); } }
        /// <summary>
        /// Gets the value of the current <see cref="Tuple`6" /> object's fifth component.
        /// </summary>
        /// <returns>
        /// The value of the current <see cref="Tuple`6" /> object's fifth  component.
        /// </returns>
        public T5 Item5 { get { return default(T5); } }
        /// <summary>
        /// Gets the value of the current <see cref="Tuple`6" /> object's sixth component.
        /// </summary>
        /// <returns>
        /// The value of the current <see cref="Tuple`6" /> object's sixth component.
        /// </returns>
        public T6 Item6 { get { return default(T6); } }
        /// <summary>
        /// Returns a value that indicates whether the current <see cref="Tuple`6" /> object
        /// is equal to a specified object.
        /// </summary>
        /// <param name="obj">The object to compare with this instance.</param>
        /// <returns>
        /// true if the current instance is equal to the specified object; otherwise, false.
        /// </returns>
        public override bool Equals(object obj) { return default(bool); }
        /// <summary>
        /// Returns the hash code for the current <see cref="Tuple`6" /> object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code.
        /// </returns>
        public override int GetHashCode() { return default(int); }
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer) { return default(int); }
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer) { return default(bool); }
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer) { return default(int); }
        int System.IComparable.CompareTo(object obj) { return default(int); }
        /// <summary>
        /// Returns a string that represents the value of this <see cref="Tuple`6" /> instance.
        /// </summary>
        /// <returns>
        /// The string representation of this <see cref="Tuple`6" /> object.
        /// </returns>
        public override string ToString() { return default(string); }
    }
    /// <summary>
    /// Represents a 7-tuple, or septuple.
    /// </summary>
    /// <typeparam name="T1">The type of the tuple's first component.</typeparam>
    /// <typeparam name="T2">The type of the tuple's second component.</typeparam>
    /// <typeparam name="T3">The type of the tuple's third component.</typeparam>
    /// <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
    /// <typeparam name="T5">The type of the tuple's fifth component.</typeparam>
    /// <typeparam name="T6">The type of the tuple's sixth component.</typeparam>
    /// <typeparam name="T7">The type of the tuple's seventh component.</typeparam>
    public partial class Tuple<T1, T2, T3, T4, T5, T6, T7> : System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.IComparable
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Tuple`7" /> class.
        /// </summary>
        /// <param name="item1">The value of the tuple's first component.</param>
        /// <param name="item2">The value of the tuple's second component.</param>
        /// <param name="item3">The value of the tuple's third component.</param>
        /// <param name="item4">The value of the tuple's fourth component</param>
        /// <param name="item5">The value of the tuple's fifth component.</param>
        /// <param name="item6">The value of the tuple's sixth component.</param>
        /// <param name="item7">The value of the tuple's seventh component.</param>
        public Tuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7) { }
        /// <summary>
        /// Gets the value of the current <see cref="Tuple`7" /> object's first component.
        /// </summary>
        /// <returns>
        /// The value of the current <see cref="Tuple`7" /> object's first component.
        /// </returns>
        public T1 Item1 { get { return default(T1); } }
        /// <summary>
        /// Gets the value of the current <see cref="Tuple`7" /> object's second component.
        /// </summary>
        /// <returns>
        /// The value of the current <see cref="Tuple`7" /> object's second component.
        /// </returns>
        public T2 Item2 { get { return default(T2); } }
        /// <summary>
        /// Gets the value of the current <see cref="Tuple`7" /> object's third component.
        /// </summary>
        /// <returns>
        /// The value of the current <see cref="Tuple`7" /> object's third component.
        /// </returns>
        public T3 Item3 { get { return default(T3); } }
        /// <summary>
        /// Gets the value of the current <see cref="Tuple`7" /> object's fourth component.
        /// </summary>
        /// <returns>
        /// The value of the current <see cref="Tuple`7" /> object's fourth component.
        /// </returns>
        public T4 Item4 { get { return default(T4); } }
        /// <summary>
        /// Gets the value of the current <see cref="Tuple`7" /> object's fifth component.
        /// </summary>
        /// <returns>
        /// The value of the current <see cref="Tuple`7" /> object's fifth component.
        /// </returns>
        public T5 Item5 { get { return default(T5); } }
        /// <summary>
        /// Gets the value of the current <see cref="Tuple`7" /> object's sixth component.
        /// </summary>
        /// <returns>
        /// The value of the current <see cref="Tuple`7" /> object's sixth component.
        /// </returns>
        public T6 Item6 { get { return default(T6); } }
        /// <summary>
        /// Gets the value of the current <see cref="Tuple`7" /> object's seventh component.
        /// </summary>
        /// <returns>
        /// The value of the current <see cref="Tuple`7" /> object's seventh component.
        /// </returns>
        public T7 Item7 { get { return default(T7); } }
        /// <summary>
        /// Returns a value that indicates whether the current <see cref="Tuple`7" /> object
        /// is equal to a specified object.
        /// </summary>
        /// <param name="obj">The object to compare with this instance.</param>
        /// <returns>
        /// true if the current instance is equal to the specified object; otherwise, false.
        /// </returns>
        public override bool Equals(object obj) { return default(bool); }
        /// <summary>
        /// Returns the hash code for the current <see cref="Tuple`7" /> object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code.
        /// </returns>
        public override int GetHashCode() { return default(int); }
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer) { return default(int); }
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer) { return default(bool); }
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer) { return default(int); }
        int System.IComparable.CompareTo(object obj) { return default(int); }
        /// <summary>
        /// Returns a string that represents the value of this <see cref="Tuple`7" /> instance.
        /// </summary>
        /// <returns>
        /// The string representation of this <see cref="Tuple`7" /> object.
        /// </returns>
        public override string ToString() { return default(string); }
    }
    /// <summary>
    /// Represents an n-tuple, where n is 8 or greater.
    /// </summary>
    /// <typeparam name="T1">The type of the tuple's first component.</typeparam>
    /// <typeparam name="T2">The type of the tuple's second component.</typeparam>
    /// <typeparam name="T3">The type of the tuple's third component.</typeparam>
    /// <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
    /// <typeparam name="T5">The type of the tuple's fifth component.</typeparam>
    /// <typeparam name="T6">The type of the tuple's sixth component.</typeparam>
    /// <typeparam name="T7">The type of the tuple's seventh component.</typeparam>
    /// <typeparam name="TRest">
    /// Any generic Tuple object that defines the types of the tuple's remaining components.
    /// </typeparam>
    public partial class Tuple<T1, T2, T3, T4, T5, T6, T7, TRest> : System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.IComparable
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Tuple`8" /> class.
        /// </summary>
        /// <param name="item1">The value of the tuple's first component.</param>
        /// <param name="item2">The value of the tuple's second component.</param>
        /// <param name="item3">The value of the tuple's third component.</param>
        /// <param name="item4">The value of the tuple's fourth component</param>
        /// <param name="item5">The value of the tuple's fifth component.</param>
        /// <param name="item6">The value of the tuple's sixth component.</param>
        /// <param name="item7">The value of the tuple's seventh component.</param>
        /// <param name="rest">Any generic Tuple object that contains the values of the tuple's remaining components.</param>
        /// <exception cref="ArgumentException">
        /// <paramref name="rest" /> is not a generic Tuple object.
        /// </exception>
        public Tuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest) { }
        /// <summary>
        /// Gets the value of the current <see cref="Tuple`8" /> object's first component.
        /// </summary>
        /// <returns>
        /// The value of the current <see cref="Tuple`8" /> object's first component.
        /// </returns>
        public T1 Item1 { get { return default(T1); } }
        /// <summary>
        /// Gets the value of the current <see cref="Tuple`8" /> object's second component.
        /// </summary>
        /// <returns>
        /// The value of the current <see cref="Tuple`8" /> object's second component.
        /// </returns>
        public T2 Item2 { get { return default(T2); } }
        /// <summary>
        /// Gets the value of the current <see cref="Tuple`8" /> object's third component.
        /// </summary>
        /// <returns>
        /// The value of the current <see cref="Tuple`8" /> object's third component.
        /// </returns>
        public T3 Item3 { get { return default(T3); } }
        /// <summary>
        /// Gets the value of the current <see cref="Tuple`8" /> object's fourth component.
        /// </summary>
        /// <returns>
        /// The value of the current <see cref="Tuple`8" /> object's fourth component.
        /// </returns>
        public T4 Item4 { get { return default(T4); } }
        /// <summary>
        /// Gets the value of the current <see cref="Tuple`8" /> object's fifth component.
        /// </summary>
        /// <returns>
        /// The value of the current <see cref="Tuple`8" /> object's fifth component.
        /// </returns>
        public T5 Item5 { get { return default(T5); } }
        /// <summary>
        /// Gets the value of the current <see cref="Tuple`8" /> object's sixth component.
        /// </summary>
        /// <returns>
        /// The value of the current <see cref="Tuple`8" /> object's sixth component.
        /// </returns>
        public T6 Item6 { get { return default(T6); } }
        /// <summary>
        /// Gets the value of the current <see cref="Tuple`8" /> object's seventh component.
        /// </summary>
        /// <returns>
        /// The value of the current <see cref="Tuple`8" /> object's seventh component.
        /// </returns>
        public T7 Item7 { get { return default(T7); } }
        /// <summary>
        /// Gets the current <see cref="Tuple`8" /> object's remaining components.
        /// </summary>
        /// <returns>
        /// The value of the current <see cref="Tuple`8" /> object's remaining components.
        /// </returns>
        public TRest Rest { get { return default(TRest); } }
        /// <summary>
        /// Returns a value that indicates whether the current <see cref="Tuple`8" /> object
        /// is equal to a specified object.
        /// </summary>
        /// <param name="obj">The object to compare with this instance.</param>
        /// <returns>
        /// true if the current instance is equal to the specified object; otherwise, false.
        /// </returns>
        public override bool Equals(object obj) { return default(bool); }
        /// <summary>
        /// Calculates the hash code for the current <see cref="Tuple`8" /> object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code.
        /// </returns>
        public override int GetHashCode() { return default(int); }
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer) { return default(int); }
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer) { return default(bool); }
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer) { return default(int); }
        int System.IComparable.CompareTo(object obj) { return default(int); }
        /// <summary>
        /// Returns a string that represents the value of this <see cref="Tuple`8" /> instance.
        /// </summary>
        /// <returns>
        /// The string representation of this <see cref="Tuple`8" /> object.
        /// </returns>
        public override string ToString() { return default(string); }
    }
    /// <summary>
    /// Represents type declarations: class types, interface types, array types, value types, enumeration
    /// types, type parameters, generic type definitions, and open or closed constructed generic types.To
    /// browse the .NET Framework source code for this type, see the Reference Source.
    /// </summary>
    public abstract partial class Type
    {
        /// <summary>
        /// Represents an empty array of type <see cref="Type" />. This field is read-only.
        /// </summary>
        public static readonly System.Type[] EmptyTypes;
        /// <summary>
        /// Represents a missing value in the <see cref="Type" /> information. This field is
        /// read-only.
        /// </summary>
        public static readonly object Missing;
        /// <summary>
        /// Separates names in the namespace of the <see cref="Type" />. This field is read-only.
        /// </summary>
        public static readonly char Delimiter;
        internal Type() { }
        /// <summary>
        /// Gets the assembly-qualified name of the type, which includes the name of the assembly from
        /// which this <see cref="Type" />object was loaded.
        /// </summary>
        /// <returns>
        /// The assembly-qualified name of the <see cref="Type" />, which includes the name of
        /// the assembly from which the <see cref="Type" /> was loaded, or null if the current
        /// instance represents a generic type parameter.
        /// </returns>
        public abstract string AssemblyQualifiedName { get; }
        /// <summary>
        /// Gets the fully qualified name of the type, including its namespace but not its assembly.
        /// </summary>
        /// <returns>
        /// The fully qualified name of the type, including its namespace but not its assembly; or null
        /// if the current instance represents a generic type parameter, an array type, pointer type, or byref
        /// type based on a type parameter, or a generic type that is not a generic type definition but contains
        /// unresolved type parameters.
        /// </returns>
        public abstract string FullName { get; }
        /// <summary>
        /// Gets the position of the type parameter in the type parameter list of the generic type or
        /// method that declared the parameter, when the <see cref="Type" /> object represents
        /// a type parameter of a generic type or a generic method.
        /// </summary>
        /// <returns>
        /// The position of a type parameter in the type parameter list of the generic type or method that
        /// defines the parameter. Position numbers begin at 0.
        /// </returns>
        /// <exception cref="InvalidOperationException">
        /// The current type does not represent a type parameter. That is, <see cref="IsGenericParameter" />
        /// returns false.
        /// </exception>
        public abstract int GenericParameterPosition { get; }
        /// <summary>
        /// Gets an array of the generic type arguments for this type.
        /// </summary>
        /// <returns>
        /// An array of the generic type arguments for this type.
        /// </returns>
        public abstract System.Type[] GenericTypeArguments { get; }
        /// <summary>
        /// Gets a value indicating whether the current <see cref="Type" /> encompasses or refers
        /// to another type; that is, whether the current <see cref="Type" /> is an array, a
        /// pointer, or is passed by reference.
        /// </summary>
        /// <returns>
        /// true if the <see cref="Type" /> is an array, a pointer, or is passed by reference;
        /// otherwise, false.
        /// </returns>
        public bool HasElementType { get { return default(bool); } }
        /// <summary>
        /// Gets a value that indicates whether the type is an array.
        /// </summary>
        /// <returns>
        /// true if the current type is an array; otherwise, false.
        /// </returns>
        public virtual bool IsArray { get { return default(bool); } }
        /// <summary>
        /// Gets a value indicating whether the <see cref="Type" /> is passed by reference.
        /// </summary>
        /// <returns>
        /// true if the <see cref="Type" /> is passed by reference; otherwise, false.
        /// </returns>
        public virtual bool IsByRef { get { return default(bool); } }
        /// <summary>
        /// Gets a value that indicates whether this object represents a constructed generic type.You can
        /// create instances of a constructed generic type.
        /// </summary>
        /// <returns>
        /// true if this object represents a constructed generic type; otherwise, false.
        /// </returns>
        public abstract bool IsConstructedGenericType { get; }
        /// <summary>
        /// Gets a value indicating whether the current <see cref="Type" /> represents a type
        /// parameter in the definition of a generic type or method.
        /// </summary>
        /// <returns>
        /// true if the <see cref="Type" /> object represents a type parameter of a generic type
        /// definition or generic method definition; otherwise, false.
        /// </returns>
        public abstract bool IsGenericParameter { get; }
        /// <summary>
        /// Gets a value indicating whether the current <see cref="Type" /> object represents
        /// a type whose definition is nested inside the definition of another type.
        /// </summary>
        /// <returns>
        /// true if the <see cref="Type" /> is nested inside another type; otherwise, false.
        /// </returns>
        public bool IsNested { get { return default(bool); } }
        /// <summary>
        /// Gets a value indicating whether the <see cref="Type" /> is a pointer.
        /// </summary>
        /// <returns>
        /// true if the <see cref="Type" /> is a pointer; otherwise, false.
        /// </returns>
        public virtual bool IsPointer { get { return default(bool); } }
        /// <summary>
        /// Gets the namespace of the <see cref="Type" />.
        /// </summary>
        /// <returns>
        /// The namespace of the <see cref="Type" />; null if the current instance has no namespace
        /// or represents a generic parameter.
        /// </returns>
        public abstract string Namespace { get; }
        /// <summary>
        /// Gets the handle for the current <see cref="Type" />.
        /// </summary>
        /// <returns>
        /// The handle for the current <see cref="Type" />.
        /// </returns>
        /// <exception cref="NotSupportedException">
        /// The .NET Compact Framework does not currently support this property.
        /// </exception>
        public virtual System.RuntimeTypeHandle TypeHandle { get { return default(System.RuntimeTypeHandle); } }
        /// <summary>
        /// Determines if the underlying system type of the current <see cref="Type" /> object
        /// is the same as the underlying system type of the specified <see cref="Object" />.
        /// </summary>
        /// <param name="o">
        /// The object whose underlying system type is to be compared with the underlying system type
        /// of the current <see cref="Type" />. For the comparison to succeed, <paramref name="o" />
        /// must be able to be cast or converted to an object of type   <see cref="Type" />.
        /// </param>
        /// <returns>
        /// true if the underlying system type of <paramref name="o" /> is the same as the underlying
        /// system type of the current <see cref="Type" />; otherwise, false. This method also
        /// returns false if: .<paramref name="o" /> is null.<paramref name="o" /> cannot be cast or converted
        /// to a <see cref="Type" /> object.
        /// </returns>
        public override bool Equals(object o) { return default(bool); }
        /// <summary>
        /// Determines if the underlying system type of the current <see cref="Type" /> is the
        /// same as the underlying system type of the specified <see cref="Type" />.
        /// </summary>
        /// <param name="o">
        /// The object whose underlying system type is to be compared with the underlying system type
        /// of the current <see cref="Type" />.
        /// </param>
        /// <returns>
        /// true if the underlying system type of <paramref name="o" /> is the same as the underlying
        /// system type of the current <see cref="Type" />; otherwise, false.
        /// </returns>
        public bool Equals(System.Type o) { return default(bool); }
        /// <summary>
        /// Gets the number of dimensions in an array.
        /// </summary>
        /// <returns>
        /// An integer that contains the number of dimensions in the current type.
        /// </returns>
        /// <exception cref="NotSupportedException">
        /// The functionality of this method is unsupported in the base class and must be implemented in
        /// a derived class instead.
        /// </exception>
        /// <exception cref="ArgumentException">The current type is not an array.</exception>
        public abstract int GetArrayRank();
        /// <summary>
        /// When overridden in a derived class, returns the <see cref="Type" /> of the object
        /// encompassed or referred to by the current array, pointer or reference type.
        /// </summary>
        /// <returns>
        /// The <see cref="Type" /> of the object encompassed or referred to by the current array,
        /// pointer, or reference type, or null if the current <see cref="Type" /> is not an
        /// array or a pointer, or is not passed by reference, or represents a generic type or a type
        /// parameter in the definition of a generic type or generic method.
        /// </returns>
        public abstract System.Type GetElementType();
        /// <summary>
        /// Returns a <see cref="Type" /> object that represents a generic type definition from
        /// which the current generic type can be constructed.
        /// </summary>
        /// <returns>
        /// A <see cref="Type" /> object representing a generic type from which the current type
        /// can be constructed.
        /// </returns>
        /// <exception cref="InvalidOperationException">
        /// The current type is not a generic type.  That is, <see cref="Type.IsGenericType" />
        /// returns false.
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// The invoked method is not supported in the base class. Derived classes must provide an implementation.
        /// </exception>
        public abstract System.Type GetGenericTypeDefinition();
        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>
        /// The hash code for this instance.
        /// </returns>
        public override int GetHashCode() { return default(int); }
        /// <summary>
        /// Gets the <see cref="Type" /> with the specified name, performing a case-sensitive
        /// search.
        /// </summary>
        /// <param name="typeName">
        /// The assembly-qualified name of the type to get. See <see cref="AssemblyQualifiedName" />.
        /// If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient
        /// to supply the type name qualified by its namespace.
        /// </param>
        /// <returns>
        /// The type with the specified name, if found; otherwise, null.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="typeName" /> is null.</exception>
        /// <exception cref="Reflection.TargetInvocationException">
        /// A class initializer is invoked and throws an exception.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="typeName" /> represents a generic type that has a pointer type, a ByRef type,
        /// or <see cref="Void" /> as one of its type arguments.-or-<paramref name="typeName" />
        /// represents a generic type that has an incorrect number of type arguments.-or-<paramref name="typeName" />
        /// represents a generic type, and one of its type arguments does not satisfy
        /// the constraints for the corresponding type parameter.
        /// </exception>
        /// <exception cref="TypeLoadException">
        /// <paramref name="typeName" /> represents an array of <see cref="TypedReference" />.
        /// </exception>
        /// <exception cref="IO.FileLoadException">
        /// In the .NET for Windows Store apps or the Portable Class Library, catch the base class exception,
        /// <see cref="IO.IOException" />, instead.The assembly or one of its dependencies was
        /// found, but could not be loaded.
        /// </exception>
        /// <exception cref="BadImageFormatException">
        /// The assembly or one of its dependencies is not valid. -or-Version 2.0 or later of the common
        /// language runtime is currently loaded, and the assembly was compiled with a later version.
        /// </exception>
        public static System.Type GetType(string typeName) { return default(System.Type); }
        /// <summary>
        /// Gets the <see cref="Type" /> with the specified name, performing a case-sensitive
        /// search and specifying whether to throw an exception if the type is not found.
        /// </summary>
        /// <param name="typeName">
        /// The assembly-qualified name of the type to get. See <see cref="AssemblyQualifiedName" />.
        /// If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient
        /// to supply the type name qualified by its namespace.
        /// </param>
        /// <param name="throwOnError">
        /// true to throw an exception if the type cannot be found; false to return null. Specifying false
        /// also suppresses some other exception conditions, but not all of them. See the Exceptions section.
        /// </param>
        /// <returns>
        /// The type with the specified name. If the type is not found, the <paramref name="throwOnError" />
        /// parameter specifies whether null is returned or an exception is thrown. In some cases,
        /// an exception is thrown regardless of the value of <paramref name="throwOnError" />. See the
        /// Exceptions section.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="typeName" /> is null.</exception>
        /// <exception cref="Reflection.TargetInvocationException">
        /// A class initializer is invoked and throws an exception.
        /// </exception>
        /// <exception cref="TypeLoadException">
        /// <paramref name="throwOnError" /> is true and the type is not found. -or-<paramref name="throwOnError" />
        /// is true and <paramref name="typeName" /> contains invalid characters, such as an embedded
        /// tab.-or-<paramref name="throwOnError" /> is true and <paramref name="typeName" /> is an empty
        /// string.-or-<paramref name="throwOnError" /> is true and <paramref name="typeName" /> represents
        /// an array type with an invalid size. -or-<paramref name="typeName" /> represents an array of
        /// <see cref="TypedReference" />.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="throwOnError" /> is true and <paramref name="typeName" /> contains invalid
        /// syntax. For example, "MyType[,*,]".-or- <paramref name="typeName" /> represents a generic
        /// type that has a pointer type, a ByRef type, or <see cref="Void" /> as one of its
        /// type arguments.-or-<paramref name="typeName" /> represents a generic type that has an incorrect
        /// number of type arguments.-or-<paramref name="typeName" /> represents a generic type, and one
        /// of its type arguments does not satisfy the constraints for the corresponding type parameter.
        /// </exception>
        /// <exception cref="IO.FileNotFoundException">
        /// <paramref name="throwOnError" /> is true and the assembly or one of its dependencies was not
        /// found.
        /// </exception>
        /// <exception cref="IO.FileLoadException">
        /// In the .NET for Windows Store apps or the Portable Class Library, catch the base class exception,
        /// <see cref="IO.IOException" />, instead.The assembly or one of its dependencies was
        /// found, but could not be loaded.
        /// </exception>
        /// <exception cref="BadImageFormatException">
        /// The assembly or one of its dependencies is not valid. -or-Version 2.0 or later of the common
        /// language runtime is currently loaded, and the assembly was compiled with a later version.
        /// </exception>
        public static System.Type GetType(string typeName, bool throwOnError) { return default(System.Type); }
        /// <summary>
        /// Gets the <see cref="Type" /> with the specified name, specifying whether to throw
        /// an exception if the type is not found and whether to perform a case-sensitive search.
        /// </summary>
        /// <param name="typeName">
        /// The assembly-qualified name of the type to get. See <see cref="AssemblyQualifiedName" />.
        /// If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient
        /// to supply the type name qualified by its namespace.
        /// </param>
        /// <param name="throwOnError">
        /// true to throw an exception if the type cannot be found; false to return null.Specifying false
        /// also suppresses some other exception conditions, but not all of them. See the Exceptions section.
        /// </param>
        /// <param name="ignoreCase">
        /// true to perform a case-insensitive search for <paramref name="typeName" />, false to perform
        /// a case-sensitive search for <paramref name="typeName" />.
        /// </param>
        /// <returns>
        /// The type with the specified name. If the type is not found, the <paramref name="throwOnError" />
        /// parameter specifies whether null is returned or an exception is thrown. In some cases,
        /// an exception is thrown regardless of the value of <paramref name="throwOnError" />. See the
        /// Exceptions section.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="typeName" /> is null.</exception>
        /// <exception cref="Reflection.TargetInvocationException">
        /// A class initializer is invoked and throws an exception.
        /// </exception>
        /// <exception cref="TypeLoadException">
        /// <paramref name="throwOnError" /> is true and the type is not found. -or-<paramref name="throwOnError" />
        /// is true and <paramref name="typeName" /> contains invalid characters, such as an embedded
        /// tab.-or-<paramref name="throwOnError" /> is true and <paramref name="typeName" /> is an empty
        /// string.-or-<paramref name="throwOnError" /> is true and <paramref name="typeName" /> represents
        /// an array type with an invalid size. -or-<paramref name="typeName" /> represents an array of
        /// <see cref="TypedReference" />.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="throwOnError" /> is true and <paramref name="typeName" /> contains invalid
        /// syntax. For example, "MyType[,*,]".-or- <paramref name="typeName" /> represents a generic
        /// type that has a pointer type, a ByRef type, or <see cref="Void" /> as one of its
        /// type arguments.-or-<paramref name="typeName" /> represents a generic type that has an incorrect
        /// number of type arguments.-or-<paramref name="typeName" /> represents a generic type, and one
        /// of its type arguments does not satisfy the constraints for the corresponding type parameter.
        /// </exception>
        /// <exception cref="IO.FileNotFoundException">
        /// <paramref name="throwOnError" /> is true and the assembly or one of its dependencies was not
        /// found.
        /// </exception>
        /// <exception cref="IO.FileLoadException">
        /// The assembly or one of its dependencies was found, but could not be loaded.
        /// </exception>
        /// <exception cref="BadImageFormatException">
        /// The assembly or one of its dependencies is not valid. -or-Version 2.0 or later of the common
        /// language runtime is currently loaded, and the assembly was compiled with a later version.
        /// </exception>
        public static System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) { return default(System.Type); }
        /// <summary>
        /// Gets the underlying type code of the specified <see cref="Type" />.
        /// </summary>
        /// <param name="type">The type whose underlying type code to get.</param>
        /// <returns>
        /// The code of the underlying type, or <see cref="TypeCode.Empty" /> if <paramref name="type" />
        /// is null.
        /// </returns>
        public static System.TypeCode GetTypeCode(System.Type type) { return default(System.TypeCode); }
        /// <summary>
        /// Gets the type referenced by the specified type handle.
        /// </summary>
        /// <param name="handle">The object that refers to the type.</param>
        /// <returns>
        /// The type referenced by the specified <see cref="RuntimeTypeHandle" />, or null if
        /// the <see cref="RuntimeTypeHandle.Value" /> property of <paramref name="handle" />
        /// is null.
        /// </returns>
        /// <exception cref="Reflection.TargetInvocationException">
        /// A class initializer is invoked and throws an exception.
        /// </exception>
        public static System.Type GetTypeFromHandle(System.RuntimeTypeHandle handle) { return default(System.Type); }
        /// <summary>
        /// Returns a <see cref="Type" /> object representing a one-dimensional array of the
        /// current type, with a lower bound of zero.
        /// </summary>
        /// <returns>
        /// A <see cref="Type" /> object representing a one-dimensional array of the current
        /// type, with a lower bound of zero.
        /// </returns>
        /// <exception cref="NotSupportedException">
        /// The invoked method is not supported in the base class. Derived classes must provide an implementation.
        /// </exception>
        /// <exception cref="TypeLoadException">
        /// The current type is <see cref="TypedReference" />.-or-The current type is a ByRef
        /// type. That is, <see cref="IsByRef" /> returns true.
        /// </exception>
        public abstract System.Type MakeArrayType();
        /// <summary>
        /// Returns a <see cref="Type" /> object representing an array of the current type, with
        /// the specified number of dimensions.
        /// </summary>
        /// <param name="rank">The number of dimensions for the array. This number must be less than or equal to 32.</param>
        /// <returns>
        /// An object representing an array of the current type, with the specified number of dimensions.
        /// </returns>
        /// <exception cref="IndexOutOfRangeException">
        /// <paramref name="rank" /> is invalid. For example, 0 or negative.
        /// </exception>
        /// <exception cref="NotSupportedException">The invoked method is not supported in the base class.</exception>
        /// <exception cref="TypeLoadException">
        /// The current type is <see cref="TypedReference" />.-or-The current type is a ByRef
        /// type. That is, <see cref="IsByRef" /> returns true. -or-<paramref name="rank" />
        /// is greater than 32.
        /// </exception>
        public abstract System.Type MakeArrayType(int rank);
        /// <summary>
        /// Returns a <see cref="Type" /> object that represents the current type when passed
        /// as a ref parameter (ByRef parameter in Visual Basic).
        /// </summary>
        /// <returns>
        /// A <see cref="Type" /> object that represents the current type when passed as a ref
        /// parameter (ByRef parameter in Visual Basic).
        /// </returns>
        /// <exception cref="NotSupportedException">The invoked method is not supported in the base class.</exception>
        /// <exception cref="TypeLoadException">
        /// The current type is <see cref="TypedReference" />.-or-The current type is a ByRef
        /// type. That is, <see cref="IsByRef" /> returns true.
        /// </exception>
        public abstract System.Type MakeByRefType();
        /// <summary>
        /// Substitutes the elements of an array of types for the type parameters of the current generic
        /// type definition and returns a <see cref="Type" /> object representing the resulting
        /// constructed type.
        /// </summary>
        /// <param name="typeArguments">
        /// An array of types to be substituted for the type parameters of the current generic type.
        /// </param>
        /// <returns>
        /// A <see cref="Type" /> representing the constructed type formed by substituting the
        /// elements of <paramref name="typeArguments" /> for the type parameters of the current generic
        /// type.
        /// </returns>
        /// <exception cref="InvalidOperationException">
        /// The current type does not represent a generic type definition. That is,
        /// <see cref="Type.IsGenericTypeDefinition" /> returns false.
        /// </exception>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="typeArguments" /> is null.-or- Any element of <paramref name="typeArguments" />
        /// is null.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// The number of elements in <paramref name="typeArguments" /> is not the same as the number
        /// of type parameters in the current generic type definition.-or- Any element of <paramref name="typeArguments" />
        /// does not satisfy the constraints specified for the corresponding type parameter of the
        /// current generic type. -or- <paramref name="typeArguments" /> contains an element that is a
        /// pointer type (<see cref="IsPointer" /> returns true), a by-ref type (<see cref="IsByRef" />
        /// returns true), or <see cref="Void" />.
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// The invoked method is not supported in the base class. Derived classes must provide an implementation.
        /// </exception>
        public abstract System.Type MakeGenericType(params System.Type[] typeArguments);
        /// <summary>
        /// Returns a <see cref="Type" /> object that represents a pointer to the current type.
        /// </summary>
        /// <returns>
        /// A <see cref="Type" /> object that represents a pointer to the current type.
        /// </returns>
        /// <exception cref="NotSupportedException">The invoked method is not supported in the base class.</exception>
        /// <exception cref="TypeLoadException">
        /// The current type is <see cref="TypedReference" />.-or-The current type is a ByRef
        /// type. That is, <see cref="IsByRef" /> returns true.
        /// </exception>
        public abstract System.Type MakePointerType();
        /// <summary>
        /// Returns a String representing the name of the current Type.
        /// </summary>
        /// <returns>
        /// A <see cref="String" /> representing the name of the current <see cref="Type" />.
        /// </returns>
        public override string ToString() { return default(string); }
    }
    /// <summary>
    /// The exception that is thrown when a method attempts to use a type that it does not have access
    /// to.
    /// </summary>
    public partial class TypeAccessException : System.TypeLoadException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TypeAccessException" /> class with a
        /// system-supplied message that describes the error.
        /// </summary>
        public TypeAccessException() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="TypeAccessException" /> class with a
        /// specified message that describes the error.
        /// </summary>
        /// <param name="message">
        /// The message that describes the exception. The caller of this constructor must ensure that this
        /// string has been localized for the current system culture.
        /// </param>
        public TypeAccessException(string message) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="TypeAccessException" /> class with a
        /// specified error message and a reference to the inner exception that is the cause of this exception.
        /// </summary>
        /// <param name="message">
        /// The message that describes the exception. The caller of this constructor must ensure that this
        /// string has been localized for the current system culture.
        /// </param>
        /// <param name="inner">
        /// The exception that is the cause of the current exception. If the <paramref name="inner" />
        /// parameter is not null, the current exception is raised in a catch block that handles the inner
        /// exception.
        /// </param>
        public TypeAccessException(string message, System.Exception inner) { }
    }
    /// <summary>
    /// Specifies the type of an object.
    /// </summary>
    public enum TypeCode
    {
        /// <summary>
        /// A simple type representing Boolean values of true or false.
        /// </summary>
        Boolean = 3,
        /// <summary>
        /// An integral type representing unsigned 8-bit integers with values between 0 and 255.
        /// </summary>
        Byte = 6,
        /// <summary>
        /// An integral type representing unsigned 16-bit integers with values between 0 and 65535. The
        /// set of possible values for the <see cref="Char" /> type corresponds to the
        /// Unicode character set.
        /// </summary>
        Char = 4,
        /// <summary>
        /// A type representing a date and time value.
        /// </summary>
        DateTime = 16,
        /// <summary>
        /// A simple type representing values ranging from 1.0 x 10 -28 to approximately 7.9 x 10 28 with
        /// 28-29 significant digits.
        /// </summary>
        Decimal = 15,
        /// <summary>
        /// A floating point type representing values ranging from approximately 5.0 x 10 -324 to 1.7 x
        /// 10 308 with a precision of 15-16 digits.
        /// </summary>
        Double = 14,
        /// <summary>
        /// A null reference.
        /// </summary>
        Empty = 0,
        /// <summary>
        /// An integral type representing signed 16-bit integers with values between -32768 and 32767.
        /// </summary>
        Int16 = 7,
        /// <summary>
        /// An integral type representing signed 32-bit integers with values between -2147483648 and 2147483647.
        /// </summary>
        Int32 = 9,
        /// <summary>
        /// An integral type representing signed 64-bit integers with values between -9223372036854775808
        /// and 9223372036854775807.
        /// </summary>
        Int64 = 11,
        /// <summary>
        /// A general type representing any reference or value type not explicitly represented by another
        /// TypeCode.
        /// </summary>
        Object = 1,
        /// <summary>
        /// An integral type representing signed 8-bit integers with values between -128 and 127.
        /// </summary>
        SByte = 5,
        /// <summary>
        /// A floating point type representing values ranging from approximately 1.5 x 10 -45 to 3.4 x
        /// 10 38 with a precision of 7 digits.
        /// </summary>
        Single = 13,
        /// <summary>
        /// A sealed class type representing Unicode character strings.
        /// </summary>
        String = 18,
        /// <summary>
        /// An integral type representing unsigned 16-bit integers with values between 0 and 65535.
        /// </summary>
        UInt16 = 8,
        /// <summary>
        /// An integral type representing unsigned 32-bit integers with values between 0 and 4294967295.
        /// </summary>
        UInt32 = 10,
        /// <summary>
        /// An integral type representing unsigned 64-bit integers with values between 0 and 18446744073709551615.
        /// </summary>
        UInt64 = 12,
    }
    /// <summary>
    /// The exception that is thrown as a wrapper around the exception thrown by the class initializer.
    /// This class cannot be inherited.
    /// </summary>
    public sealed partial class TypeInitializationException : System.Exception
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TypeInitializationException" /> class
        /// with the default error message, the specified type name, and a reference to the inner exception
        /// that is the root cause of this exception.
        /// </summary>
        /// <param name="fullTypeName">The fully qualified name of the type that fails to initialize.</param>
        /// <param name="innerException">
        /// The exception that is the cause of the current exception. If the <paramref name="innerException" />
        /// parameter is not a null reference (Nothing in Visual Basic), the current exception is raised
        /// in a catch block that handles the inner exception.
        /// </param>
        public TypeInitializationException(string fullTypeName, System.Exception innerException) { }
        /// <summary>
        /// Gets the fully qualified name of the type that fails to initialize.
        /// </summary>
        /// <returns>
        /// The fully qualified name of the type that fails to initialize.
        /// </returns>
        public string TypeName { get { return default(string); } }
    }
    /// <summary>
    /// The exception that is thrown when type-loading failures occur.
    /// </summary>
    public partial class TypeLoadException : System.Exception
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TypeLoadException" /> class.
        /// </summary>
        public TypeLoadException() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="TypeLoadException" /> class with a specified
        /// error message.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        public TypeLoadException(string message) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="TypeLoadException" /> class with a specified
        /// error message and a reference to the inner exception that is the cause of this exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="inner">
        /// The exception that is the cause of the current exception. If the <paramref name="inner" />
        /// parameter is not null, the current exception is raised in a catch block that handles the inner
        /// exception.
        /// </param>
        public TypeLoadException(string message, System.Exception inner) { }
        /// <summary>
        /// Gets the error message for this exception.
        /// </summary>
        /// <returns>
        /// The error message string.
        /// </returns>
        public override string Message { get { return default(string); } }
        /// <summary>
        /// Gets the fully qualified name of the type that causes the exception.
        /// </summary>
        /// <returns>
        /// The fully qualified type name.
        /// </returns>
        public string TypeName { get { return default(string); } }
    }
    /// <summary>
    /// Represents a 16-bit unsigned integer.
    /// </summary>
    [System.CLSCompliantAttribute(false)]
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct UInt16 : System.IComparable, System.IComparable<ushort>, System.IConvertible, System.IEquatable<ushort>, System.IFormattable
    {
        /// <summary>
        /// Represents the largest possible value of <see cref="UInt16" />. This field is constant.
        /// </summary>
        public const ushort MaxValue = (ushort)65535;
        /// <summary>
        /// Represents the smallest possible value of <see cref="UInt16" />. This field is constant.
        /// </summary>
        public const ushort MinValue = (ushort)0;
        /// <summary>
        /// Compares this instance to a specified 16-bit unsigned integer and returns an indication of
        /// their relative values.
        /// </summary>
        /// <param name="value">An unsigned integer to compare.</param>
        /// <returns>
        /// A signed number indicating the relative values of this instance and <paramref name="value" />.
        /// Return Value Description Less than zero This instance is less than <paramref name="value" />.
        /// Zero This instance is equal to <paramref name="value" />. Greater than zero This instance
        /// is greater than <paramref name="value" />.
        /// </returns>
        public int CompareTo(ushort value) { return default(int); }
        /// <summary>
        /// Returns a value indicating whether this instance is equal to a specified object.
        /// </summary>
        /// <param name="obj">An object to compare to this instance.</param>
        /// <returns>
        /// true if <paramref name="obj" /> is an instance of <see cref="UInt16" /> and equals
        /// the value of this instance; otherwise, false.
        /// </returns>
        public override bool Equals(object obj) { return default(bool); }
        /// <summary>
        /// Returns a value indicating whether this instance is equal to a specified <see cref="UInt16" />
        /// value.
        /// </summary>
        /// <param name="obj">A 16-bit unsigned integer to compare to this instance.</param>
        /// <returns>
        /// true if <paramref name="obj" /> has the same value as this instance; otherwise, false.
        /// </returns>
        public bool Equals(ushort obj) { return default(bool); }
        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code.
        /// </returns>
        public override int GetHashCode() { return default(int); }
        /// <summary>
        /// Converts the string representation of a number to its 16-bit unsigned integer equivalent.
        /// </summary>
        /// <param name="s">A string that represents the number to convert.</param>
        /// <returns>
        /// A 16-bit unsigned integer equivalent to the number contained in <paramref name="s" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="FormatException"><paramref name="s" /> is not in the correct format.</exception>
        /// <exception cref="OverflowException">
        /// <paramref name="s" /> represents a number less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />.
        /// </exception>
        [System.CLSCompliantAttribute(false)]
        public static ushort Parse(string s) { return default(ushort); }
        /// <summary>
        /// Converts the string representation of a number in a specified style to its 16-bit unsigned
        /// integer equivalent.This method is not CLS-compliant. The CLS-compliant alternative is
        /// <see cref="Int32.Parse(String,Globalization.NumberStyles)" />.
        /// </summary>
        /// <param name="s">
        /// A string that represents the number to convert. The string is interpreted by using the style
        /// specified by the <paramref name="style" /> parameter.
        /// </param>
        /// <param name="style">
        /// A bitwise combination of the enumeration values that specify the permitted format of <paramref name="s" />.
        /// A typical value to specify is <see cref="Globalization.NumberStyles.Integer" />.
        /// </param>
        /// <returns>
        /// A 16-bit unsigned integer equivalent to the number specified in <paramref name="s" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="style" /> is not a <see cref="Globalization.NumberStyles" /> value.
        /// -or-<paramref name="style" /> is not a combination of
        /// <see cref="Globalization.NumberStyles.AllowHexSpecifier" /> and <see cref="Globalization.NumberStyles.HexNumber" /> values.
        /// </exception>
        /// <exception cref="FormatException">
        /// <paramref name="s" /> is not in a format compliant with <paramref name="style" />.
        /// </exception>
        /// <exception cref="OverflowException">
        /// <paramref name="s" /> represents a number less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />. -or-<paramref name="s" /> includes
        /// non-zero, fractional digits.
        /// </exception>
        [System.CLSCompliantAttribute(false)]
        public static ushort Parse(string s, System.Globalization.NumberStyles style) { return default(ushort); }
        /// <summary>
        /// Converts the string representation of a number in a specified style and culture-specific format
        /// to its 16-bit unsigned integer equivalent.
        /// </summary>
        /// <param name="s">
        /// A string that represents the number to convert. The string is interpreted by using the style
        /// specified by the <paramref name="style" /> parameter.
        /// </param>
        /// <param name="style">
        /// A bitwise combination of enumeration values that indicate the style elements that can be present
        /// in <paramref name="s" />. A typical value to specify is <see cref="Globalization.NumberStyles.Integer" />.
        /// </param>
        /// <param name="provider">
        /// An object that supplies culture-specific formatting information about <paramref name="s" />.
        /// </param>
        /// <returns>
        /// A 16-bit unsigned integer equivalent to the number specified in <paramref name="s" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="style" /> is not a <see cref="Globalization.NumberStyles" /> value.
        /// -or-<paramref name="style" /> is not a combination of
        /// <see cref="Globalization.NumberStyles.AllowHexSpecifier" /> and <see cref="Globalization.NumberStyles.HexNumber" /> values.
        /// </exception>
        /// <exception cref="FormatException">
        /// <paramref name="s" /> is not in a format compliant with <paramref name="style" />.
        /// </exception>
        /// <exception cref="OverflowException">
        /// <paramref name="s" /> represents a number that is less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />. -or-<paramref name="s" /> includes
        /// non-zero, fractional digits.
        /// </exception>
        [System.CLSCompliantAttribute(false)]
        public static ushort Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider) { return default(ushort); }
        /// <summary>
        /// Converts the string representation of a number in a specified culture-specific format to its
        /// 16-bit unsigned integer equivalent.
        /// </summary>
        /// <param name="s">A string that represents the number to convert.</param>
        /// <param name="provider">
        /// An object that supplies culture-specific formatting information about <paramref name="s" />.
        /// </param>
        /// <returns>
        /// A 16-bit unsigned integer equivalent to the number specified in <paramref name="s" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="FormatException"><paramref name="s" /> is not in the correct format.</exception>
        /// <exception cref="OverflowException">
        /// <paramref name="s" /> represents a number less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />.
        /// </exception>
        [System.CLSCompliantAttribute(false)]
        public static ushort Parse(string s, System.IFormatProvider provider) { return default(ushort); }
        int System.IComparable.CompareTo(object value) { return default(int); }
        System.TypeCode System.IConvertible.GetTypeCode() { return default(System.TypeCode); }
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) { return default(bool); }
        byte System.IConvertible.ToByte(System.IFormatProvider provider) { return default(byte); }
        char System.IConvertible.ToChar(System.IFormatProvider provider) { return default(char); }
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) { return default(System.DateTime); }
        decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) { return default(decimal); }
        double System.IConvertible.ToDouble(System.IFormatProvider provider) { return default(double); }
        short System.IConvertible.ToInt16(System.IFormatProvider provider) { return default(short); }
        int System.IConvertible.ToInt32(System.IFormatProvider provider) { return default(int); }
        long System.IConvertible.ToInt64(System.IFormatProvider provider) { return default(long); }
        sbyte System.IConvertible.ToSByte(System.IFormatProvider provider) { return default(sbyte); }
        float System.IConvertible.ToSingle(System.IFormatProvider provider) { return default(float); }
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) { return default(object); }
        ushort System.IConvertible.ToUInt16(System.IFormatProvider provider) { return default(ushort); }
        uint System.IConvertible.ToUInt32(System.IFormatProvider provider) { return default(uint); }
        ulong System.IConvertible.ToUInt64(System.IFormatProvider provider) { return default(ulong); }
        /// <summary>
        /// Converts the numeric value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// The string representation of the value of this instance, which consists of a sequence of digits
        /// ranging from 0 to 9, without a sign or leading zeros.
        /// </returns>
        public override string ToString() { return default(string); }
        /// <summary>
        /// Converts the numeric value of this instance to its equivalent string representation using the
        /// specified culture-specific format information.
        /// </summary>
        /// <param name="provider">An object that supplies culture-specific formatting information.</param>
        /// <returns>
        /// The string representation of the value of this instance, which consists of a sequence of digits
        /// ranging from 0 to 9, without a sign or leading zeros.
        /// </returns>
        public string ToString(System.IFormatProvider provider) { return default(string); }
        /// <summary>
        /// Converts the numeric value of this instance to its equivalent string representation using the
        /// specified format.
        /// </summary>
        /// <param name="format">A numeric format string.</param>
        /// <returns>
        /// The string representation of the value of this instance as specified by <paramref name="format" />.
        /// </returns>
        /// <exception cref="FormatException">The <paramref name="format" /> parameter is invalid.</exception>
        public string ToString(string format) { return default(string); }
        /// <summary>
        /// Converts the numeric value of this instance to its equivalent string representation using the
        /// specified format and culture-specific format information.
        /// </summary>
        /// <param name="format">A numeric format string.</param>
        /// <param name="provider">An object that supplies culture-specific formatting information.</param>
        /// <returns>
        /// The string representation of the value of this instance, as specified by <paramref name="format" />
        /// and <paramref name="provider" />.
        /// </returns>
        /// <exception cref="FormatException"><paramref name="format" /> is invalid.</exception>
        public string ToString(string format, System.IFormatProvider provider) { return default(string); }
        /// <summary>
        /// Tries to convert the string representation of a number in a specified style and culture-specific
        /// format to its 16-bit unsigned integer equivalent. A return value indicates whether the conversion
        /// succeeded or failed.
        /// </summary>
        /// <param name="s">
        /// A string that represents the number to convert. The string is interpreted by using the style
        /// specified by the <paramref name="style" /> parameter.
        /// </param>
        /// <param name="style">
        /// A bitwise combination of enumeration values that indicates the permitted format of <paramref name="s" />.
        /// A typical value to specify is <see cref="Globalization.NumberStyles.Integer" />.
        /// </param>
        /// <param name="provider">
        /// An object that supplies culture-specific formatting information about <paramref name="s" />.
        /// </param>
        /// <param name="result">
        /// When this method returns, contains the 16-bit unsigned integer value equivalent to the number
        /// contained in <paramref name="s" />, if the conversion succeeded, or zero if the conversion
        /// failed. The conversion fails if the <paramref name="s" /> parameter is null or <see cref="String.Empty" />,
        /// is not in a format compliant with <paramref name="style" />, or represents a number less
        /// than <see cref="MinValue" /> or greater than <see cref="MaxValue" />.
        /// This parameter is passed uninitialized; any value originally supplied in <paramref name="result" />
        /// will be overwritten.
        /// </param>
        /// <returns>
        /// true if <paramref name="s" /> was converted successfully; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// <paramref name="style" /> is not a <see cref="Globalization.NumberStyles" /> value.
        /// -or-<paramref name="style" /> is not a combination of
        /// <see cref="Globalization.NumberStyles.AllowHexSpecifier" /> and <see cref="Globalization.NumberStyles.HexNumber" /> values.
        /// </exception>
        [System.CLSCompliantAttribute(false)]
        public static bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out ushort result) { result = default(ushort); return default(bool); }
        /// <summary>
        /// Tries to convert the string representation of a number to its 16-bit unsigned integer equivalent.
        /// A return value indicates whether the conversion succeeded or failed.
        /// </summary>
        /// <param name="s">A string that represents the number to convert.</param>
        /// <param name="result">
        /// When this method returns, contains the 16-bit unsigned integer value that is equivalent to
        /// the number contained in <paramref name="s" />, if the conversion succeeded, or zero if the
        /// conversion failed. The conversion fails if the <paramref name="s" /> parameter is null or
        /// <see cref="String.Empty" />, is not in the correct format. , or represents a number
        /// less than <see cref="MinValue" /> or greater than <see cref="MaxValue" />.
        /// This parameter is passed uninitialized; any value originally supplied in <paramref name="result" />
        /// will be overwritten.
        /// </param>
        /// <returns>
        /// true if <paramref name="s" /> was converted successfully; otherwise, false.
        /// </returns>
        [System.CLSCompliantAttribute(false)]
        public static bool TryParse(string s, out ushort result) { result = default(ushort); return default(bool); }
    }
    /// <summary>
    /// Represents a 32-bit unsigned integer.
    /// </summary>
    [System.CLSCompliantAttribute(false)]
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct UInt32 : System.IComparable, System.IComparable<uint>, System.IConvertible, System.IEquatable<uint>, System.IFormattable
    {
        /// <summary>
        /// Represents the largest possible value of <see cref="UInt32" />. This field is constant.
        /// </summary>
        public const uint MaxValue = (uint)4294967295;
        /// <summary>
        /// Represents the smallest possible value of <see cref="UInt32" />. This field is constant.
        /// </summary>
        public const uint MinValue = (uint)0;
        /// <summary>
        /// Compares this instance to a specified 32-bit unsigned integer and returns an indication of
        /// their relative values.
        /// </summary>
        /// <param name="value">An unsigned integer to compare.</param>
        /// <returns>
        /// A signed number indicating the relative values of this instance and <paramref name="value" />.
        /// Return value Description Less than zero This instance is less than <paramref name="value" />.
        /// Zero This instance is equal to <paramref name="value" />. Greater than zero This instance
        /// is greater than <paramref name="value" />.
        /// </returns>
        public int CompareTo(uint value) { return default(int); }
        /// <summary>
        /// Returns a value indicating whether this instance is equal to a specified object.
        /// </summary>
        /// <param name="obj">An object to compare with this instance.</param>
        /// <returns>
        /// true if <paramref name="obj" /> is an instance of <see cref="UInt32" /> and equals
        /// the value of this instance; otherwise, false.
        /// </returns>
        public override bool Equals(object obj) { return default(bool); }
        /// <summary>
        /// Returns a value indicating whether this instance is equal to a specified <see cref="UInt32" />.
        /// </summary>
        /// <param name="obj">A value to compare to this instance.</param>
        /// <returns>
        /// true if <paramref name="obj" /> has the same value as this instance; otherwise, false.
        /// </returns>
        public bool Equals(uint obj) { return default(bool); }
        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code.
        /// </returns>
        public override int GetHashCode() { return default(int); }
        /// <summary>
        /// Converts the string representation of a number to its 32-bit unsigned integer equivalent.
        /// </summary>
        /// <param name="s">A string representing the number to convert.</param>
        /// <returns>
        /// A 32-bit unsigned integer equivalent to the number contained in <paramref name="s" />.
        /// </returns>
        /// <exception cref="ArgumentNullException">The <paramref name="s" /> parameter is null.</exception>
        /// <exception cref="FormatException">
        /// The <paramref name="s" /> parameter is not of the correct format.
        /// </exception>
        /// <exception cref="OverflowException">
        /// The <paramref name="s" /> parameter represents a number that is less than
        /// <see cref="MinValue" /> or greater than <see cref="MaxValue" />.
        /// </exception>
        [System.CLSCompliantAttribute(false)]
        public static uint Parse(string s) { return default(uint); }
        /// <summary>
        /// Converts the string representation of a number in a specified style to its 32-bit unsigned
        /// integer equivalent.
        /// </summary>
        /// <param name="s">
        /// A string representing the number to convert. The string is interpreted by using the style
        /// specified by the <paramref name="style" /> parameter.
        /// </param>
        /// <param name="style">
        /// A bitwise combination of the enumeration values that specify the permitted format of <paramref name="s" />.
        /// A typical value to specify is <see cref="Globalization.NumberStyles.Integer" />.
        /// </param>
        /// <returns>
        /// A 32-bit unsigned integer equivalent to the number specified in <paramref name="s" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="style" /> is not a <see cref="Globalization.NumberStyles" /> value.
        /// -or-<paramref name="style" /> is not a combination of
        /// <see cref="Globalization.NumberStyles.AllowHexSpecifier" /> and <see cref="Globalization.NumberStyles.HexNumber" /> values.
        /// </exception>
        /// <exception cref="FormatException">
        /// <paramref name="s" /> is not in a format compliant with <paramref name="style" />.
        /// </exception>
        /// <exception cref="OverflowException">
        /// <paramref name="s" /> represents a number that is less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />. -or-<paramref name="s" /> includes
        /// non-zero, fractional digits.
        /// </exception>
        [System.CLSCompliantAttribute(false)]
        public static uint Parse(string s, System.Globalization.NumberStyles style) { return default(uint); }
        /// <summary>
        /// Converts the string representation of a number in a specified style and culture-specific format
        /// to its 32-bit unsigned integer equivalent.
        /// </summary>
        /// <param name="s">
        /// A string representing the number to convert. The string is interpreted by using the style
        /// specified by the <paramref name="style" /> parameter.
        /// </param>
        /// <param name="style">
        /// A bitwise combination of enumeration values that indicates the style elements that can be
        /// present in <paramref name="s" />. A typical value to specify is
        /// <see cref="Globalization.NumberStyles.Integer" />.
        /// </param>
        /// <param name="provider">
        /// An object that supplies culture-specific formatting information about <paramref name="s" />.
        /// </param>
        /// <returns>
        /// A 32-bit unsigned integer equivalent to the number specified in <paramref name="s" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="style" /> is not a <see cref="Globalization.NumberStyles" /> value.
        /// -or-<paramref name="style" /> is not a combination of
        /// <see cref="Globalization.NumberStyles.AllowHexSpecifier" /> and <see cref="Globalization.NumberStyles.HexNumber" /> values.
        /// </exception>
        /// <exception cref="FormatException">
        /// <paramref name="s" /> is not in a format compliant with <paramref name="style" />.
        /// </exception>
        /// <exception cref="OverflowException">
        /// <paramref name="s" /> represents a number that is less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />. -or-<paramref name="s" /> includes
        /// non-zero, fractional digits.
        /// </exception>
        [System.CLSCompliantAttribute(false)]
        public static uint Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider) { return default(uint); }
        /// <summary>
        /// Converts the string representation of a number in a specified culture-specific format to its
        /// 32-bit unsigned integer equivalent.
        /// </summary>
        /// <param name="s">A string that represents the number to convert.</param>
        /// <param name="provider">
        /// An object that supplies culture-specific formatting information about <paramref name="s" />.
        /// </param>
        /// <returns>
        /// A 32-bit unsigned integer equivalent to the number specified in <paramref name="s" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="s" /> is null.</exception>
        /// <exception cref="FormatException"><paramref name="s" /> is not in the correct style.</exception>
        /// <exception cref="OverflowException">
        /// <paramref name="s" /> represents a number that is less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />.
        /// </exception>
        [System.CLSCompliantAttribute(false)]
        public static uint Parse(string s, System.IFormatProvider provider) { return default(uint); }
        int System.IComparable.CompareTo(object value) { return default(int); }
        System.TypeCode System.IConvertible.GetTypeCode() { return default(System.TypeCode); }
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) { return default(bool); }
        byte System.IConvertible.ToByte(System.IFormatProvider provider) { return default(byte); }
        char System.IConvertible.ToChar(System.IFormatProvider provider) { return default(char); }
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) { return default(System.DateTime); }
        decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) { return default(decimal); }
        double System.IConvertible.ToDouble(System.IFormatProvider provider) { return default(double); }
        short System.IConvertible.ToInt16(System.IFormatProvider provider) { return default(short); }
        int System.IConvertible.ToInt32(System.IFormatProvider provider) { return default(int); }
        long System.IConvertible.ToInt64(System.IFormatProvider provider) { return default(long); }
        sbyte System.IConvertible.ToSByte(System.IFormatProvider provider) { return default(sbyte); }
        float System.IConvertible.ToSingle(System.IFormatProvider provider) { return default(float); }
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) { return default(object); }
        ushort System.IConvertible.ToUInt16(System.IFormatProvider provider) { return default(ushort); }
        uint System.IConvertible.ToUInt32(System.IFormatProvider provider) { return default(uint); }
        ulong System.IConvertible.ToUInt64(System.IFormatProvider provider) { return default(ulong); }
        /// <summary>
        /// Converts the numeric value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// The string representation of the value of this instance, consisting of a sequence of digits
        /// ranging from 0 to 9, without a sign or leading zeroes.
        /// </returns>
        public override string ToString() { return default(string); }
        /// <summary>
        /// Converts the numeric value of this instance to its equivalent string representation using the
        /// specified culture-specific format information.
        /// </summary>
        /// <param name="provider">An object that supplies culture-specific formatting information.</param>
        /// <returns>
        /// The string representation of the value of this instance, which consists of a sequence of digits
        /// ranging from 0 to 9, without a sign or leading zeros.
        /// </returns>
        public string ToString(System.IFormatProvider provider) { return default(string); }
        /// <summary>
        /// Converts the numeric value of this instance to its equivalent string representation using the
        /// specified format.
        /// </summary>
        /// <param name="format">A numeric format string.</param>
        /// <returns>
        /// The string representation of the value of this instance as specified by <paramref name="format" />.
        /// </returns>
        /// <exception cref="FormatException">The <paramref name="format" /> parameter is invalid.</exception>
        public string ToString(string format) { return default(string); }
        /// <summary>
        /// Converts the numeric value of this instance to its equivalent string representation using the
        /// specified format and culture-specific format information.
        /// </summary>
        /// <param name="format">A numeric format string.</param>
        /// <param name="provider">An object that supplies culture-specific formatting information about this instance.</param>
        /// <returns>
        /// The string representation of the value of this instance as specified by <paramref name="format" />
        /// and <paramref name="provider" />.
        /// </returns>
        /// <exception cref="FormatException">The <paramref name="format" /> parameter is invalid.</exception>
        public string ToString(string format, System.IFormatProvider provider) { return default(string); }
        /// <summary>
        /// Tries to convert the string representation of a number in a specified style and culture-specific
        /// format to its 32-bit unsigned integer equivalent. A return value indicates whether the conversion
        /// succeeded or failed.
        /// </summary>
        /// <param name="s">
        /// A string that represents the number to convert. The string is interpreted by using the style
        /// specified by the <paramref name="style" /> parameter.
        /// </param>
        /// <param name="style">
        /// A bitwise combination of enumeration values that indicates the permitted format of <paramref name="s" />.
        /// A typical value to specify is <see cref="Globalization.NumberStyles.Integer" />.
        /// </param>
        /// <param name="provider">
        /// An object that supplies culture-specific formatting information about <paramref name="s" />.
        /// </param>
        /// <param name="result">
        /// When this method returns, contains the 32-bit unsigned integer value equivalent to the number
        /// contained in <paramref name="s" />, if the conversion succeeded, or zero if the conversion
        /// failed. The conversion fails if the <paramref name="s" /> parameter is null  or <see cref="String.Empty" />,
        /// is not in a format compliant with <paramref name="style" />, or represents a number that
        /// is less than <see cref="MinValue" /> or greater than <see cref="MaxValue" />.
        /// This parameter is passed uninitialized; any value originally supplied in <paramref name="result" />
        /// will be overwritten.
        /// </param>
        /// <returns>
        /// true if <paramref name="s" /> was converted successfully; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// <paramref name="style" /> is not a <see cref="Globalization.NumberStyles" /> value.
        /// -or-<paramref name="style" /> is not a combination of
        /// <see cref="Globalization.NumberStyles.AllowHexSpecifier" /> and <see cref="Globalization.NumberStyles.HexNumber" /> values.
        /// </exception>
        [System.CLSCompliantAttribute(false)]
        public static bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out uint result) { result = default(uint); return default(bool); }
        /// <summary>
        /// Tries to convert the string representation of a number to its 32-bit unsigned integer equivalent.
        /// A return value indicates whether the conversion succeeded or failed.
        /// </summary>
        /// <param name="s">A string that represents the number to convert.</param>
        /// <param name="result">
        /// When this method returns, contains the 32-bit unsigned integer value that is equivalent to
        /// the number contained in <paramref name="s" />, if the conversion succeeded, or zero if the
        /// conversion failed. The conversion fails if the <paramref name="s" /> parameter is null  or
        /// <see cref="String.Empty" />, is not of the correct format, or represents a number
        /// that is less than <see cref="MinValue" /> or greater than <see cref="MaxValue" />.
        /// This parameter is passed uninitialized; any value originally supplied in <paramref name="result" />
        /// will be overwritten.
        /// </param>
        /// <returns>
        /// true if <paramref name="s" /> was converted successfully; otherwise, false.
        /// </returns>
        [System.CLSCompliantAttribute(false)]
        public static bool TryParse(string s, out uint result) { result = default(uint); return default(bool); }
    }
    /// <summary>
    /// Represents a 64-bit unsigned integer.
    /// </summary>
    [System.CLSCompliantAttribute(false)]
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct UInt64 : System.IComparable, System.IComparable<ulong>, System.IConvertible, System.IEquatable<ulong>, System.IFormattable
    {
        /// <summary>
        /// Represents the largest possible value of <see cref="UInt64" />. This field is constant.
        /// </summary>
        public const ulong MaxValue = (ulong)18446744073709551615;
        /// <summary>
        /// Represents the smallest possible value of <see cref="UInt64" />. This field is constant.
        /// </summary>
        public const ulong MinValue = (ulong)0;
        /// <summary>
        /// Compares this instance to a specified 64-bit unsigned integer and returns an indication of
        /// their relative values.
        /// </summary>
        /// <param name="value">An unsigned integer to compare.</param>
        /// <returns>
        /// A signed number indicating the relative values of this instance and <paramref name="value" />.
        /// Return Value Description Less than zero This instance is less than <paramref name="value" />.
        /// Zero This instance is equal to <paramref name="value" />. Greater than zero This instance
        /// is greater than <paramref name="value" />.
        /// </returns>
        public int CompareTo(ulong value) { return default(int); }
        /// <summary>
        /// Returns a value indicating whether this instance is equal to a specified object.
        /// </summary>
        /// <param name="obj">An object to compare to this instance.</param>
        /// <returns>
        /// true if <paramref name="obj" /> is an instance of <see cref="UInt64" /> and equals
        /// the value of this instance; otherwise, false.
        /// </returns>
        public override bool Equals(object obj) { return default(bool); }
        /// <summary>
        /// Returns a value indicating whether this instance is equal to a specified <see cref="UInt64" />
        /// value.
        /// </summary>
        /// <param name="obj">A <see cref="UInt64" /> value to compare to this instance.</param>
        /// <returns>
        /// true if <paramref name="obj" /> has the same value as this instance; otherwise, false.
        /// </returns>
        public bool Equals(ulong obj) { return default(bool); }
        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code.
        /// </returns>
        public override int GetHashCode() { return default(int); }
        /// <summary>
        /// Converts the string representation of a number to its 64-bit unsigned integer equivalent.
        /// </summary>
        /// <param name="s">A string that represents the number to convert.</param>
        /// <returns>
        /// A 64-bit unsigned integer equivalent to the number contained in <paramref name="s" />.
        /// </returns>
        /// <exception cref="ArgumentNullException">The <paramref name="s" /> parameter is null.</exception>
        /// <exception cref="FormatException">
        /// The <paramref name="s" /> parameter is not in the correct format.
        /// </exception>
        /// <exception cref="OverflowException">
        /// The <paramref name="s" /> parameter represents a number less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />.
        /// </exception>
        [System.CLSCompliantAttribute(false)]
        public static ulong Parse(string s) { return default(ulong); }
        /// <summary>
        /// Converts the string representation of a number in a specified style to its 64-bit unsigned
        /// integer equivalent.
        /// </summary>
        /// <param name="s">
        /// A string that represents the number to convert. The string is interpreted by using the style
        /// specified by the <paramref name="style" /> parameter.
        /// </param>
        /// <param name="style">
        /// A bitwise combination of the enumeration values that specifies the permitted format of <paramref name="s" />.
        /// A typical value to specify is <see cref="Globalization.NumberStyles.Integer" />.
        /// </param>
        /// <returns>
        /// A 64-bit unsigned integer equivalent to the number specified in <paramref name="s" />.
        /// </returns>
        /// <exception cref="ArgumentNullException">The <paramref name="s" /> parameter is null.</exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="style" /> is not a <see cref="Globalization.NumberStyles" /> value.
        /// -or-<paramref name="style" /> is not a combination of
        /// <see cref="Globalization.NumberStyles.AllowHexSpecifier" /> and <see cref="Globalization.NumberStyles.HexNumber" /> values.
        /// </exception>
        /// <exception cref="FormatException">
        /// The <paramref name="s" /> parameter is not in a format compliant with <paramref name="style" />.
        /// </exception>
        /// <exception cref="OverflowException">
        /// The <paramref name="s" /> parameter represents a number less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />. -or-<paramref name="s" /> includes
        /// non-zero, fractional digits.
        /// </exception>
        [System.CLSCompliantAttribute(false)]
        public static ulong Parse(string s, System.Globalization.NumberStyles style) { return default(ulong); }
        /// <summary>
        /// Converts the string representation of a number in a specified style and culture-specific format
        /// to its 64-bit unsigned integer equivalent.
        /// </summary>
        /// <param name="s">
        /// A string that represents the number to convert. The string is interpreted by using the style
        /// specified by the <paramref name="style" /> parameter.
        /// </param>
        /// <param name="style">
        /// A bitwise combination of enumeration values that indicates the style elements that can be
        /// present in <paramref name="s" />. A typical value to specify is
        /// <see cref="Globalization.NumberStyles.Integer" />.
        /// </param>
        /// <param name="provider">
        /// An object that supplies culture-specific formatting information about <paramref name="s" />.
        /// </param>
        /// <returns>
        /// A 64-bit unsigned integer equivalent to the number specified in <paramref name="s" />.
        /// </returns>
        /// <exception cref="ArgumentNullException">The <paramref name="s" /> parameter is null.</exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="style" /> is not a <see cref="Globalization.NumberStyles" /> value.
        /// -or-<paramref name="style" /> is not a combination of
        /// <see cref="Globalization.NumberStyles.AllowHexSpecifier" /> and <see cref="Globalization.NumberStyles.HexNumber" /> values.
        /// </exception>
        /// <exception cref="FormatException">
        /// The <paramref name="s" /> parameter is not in a format compliant with <paramref name="style" />.
        /// </exception>
        /// <exception cref="OverflowException">
        /// The <paramref name="s" /> parameter represents a number less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />. -or-<paramref name="s" /> includes
        /// non-zero, fractional digits.
        /// </exception>
        [System.CLSCompliantAttribute(false)]
        public static ulong Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider) { return default(ulong); }
        /// <summary>
        /// Converts the string representation of a number in a specified culture-specific format to its
        /// 64-bit unsigned integer equivalent.
        /// </summary>
        /// <param name="s">A string that represents the number to convert.</param>
        /// <param name="provider">
        /// An object that supplies culture-specific formatting information about <paramref name="s" />.
        /// </param>
        /// <returns>
        /// A 64-bit unsigned integer equivalent to the number specified in <paramref name="s" />.
        /// </returns>
        /// <exception cref="ArgumentNullException">The <paramref name="s" /> parameter is null.</exception>
        /// <exception cref="FormatException">
        /// The <paramref name="s" /> parameter is not in the correct style.
        /// </exception>
        /// <exception cref="OverflowException">
        /// The <paramref name="s" /> parameter represents a number less than <see cref="MinValue" />
        /// or greater than <see cref="MaxValue" />.
        /// </exception>
        [System.CLSCompliantAttribute(false)]
        public static ulong Parse(string s, System.IFormatProvider provider) { return default(ulong); }
        int System.IComparable.CompareTo(object value) { return default(int); }
        System.TypeCode System.IConvertible.GetTypeCode() { return default(System.TypeCode); }
        bool System.IConvertible.ToBoolean(System.IFormatProvider provider) { return default(bool); }
        byte System.IConvertible.ToByte(System.IFormatProvider provider) { return default(byte); }
        char System.IConvertible.ToChar(System.IFormatProvider provider) { return default(char); }
        System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider) { return default(System.DateTime); }
        decimal System.IConvertible.ToDecimal(System.IFormatProvider provider) { return default(decimal); }
        double System.IConvertible.ToDouble(System.IFormatProvider provider) { return default(double); }
        short System.IConvertible.ToInt16(System.IFormatProvider provider) { return default(short); }
        int System.IConvertible.ToInt32(System.IFormatProvider provider) { return default(int); }
        long System.IConvertible.ToInt64(System.IFormatProvider provider) { return default(long); }
        sbyte System.IConvertible.ToSByte(System.IFormatProvider provider) { return default(sbyte); }
        float System.IConvertible.ToSingle(System.IFormatProvider provider) { return default(float); }
        object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider) { return default(object); }
        ushort System.IConvertible.ToUInt16(System.IFormatProvider provider) { return default(ushort); }
        uint System.IConvertible.ToUInt32(System.IFormatProvider provider) { return default(uint); }
        ulong System.IConvertible.ToUInt64(System.IFormatProvider provider) { return default(ulong); }
        /// <summary>
        /// Converts the numeric value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// The string representation of the value of this instance, consisting of a sequence of digits
        /// ranging from 0 to 9, without a sign or leading zeroes.
        /// </returns>
        public override string ToString() { return default(string); }
        /// <summary>
        /// Converts the numeric value of this instance to its equivalent string representation using the
        /// specified culture-specific format information.
        /// </summary>
        /// <param name="provider">An object that supplies culture-specific formatting information.</param>
        /// <returns>
        /// The string representation of the value of this instance, consisting of a sequence of digits
        /// ranging from 0 to 9, without a sign or leading zeros.
        /// </returns>
        public string ToString(System.IFormatProvider provider) { return default(string); }
        /// <summary>
        /// Converts the numeric value of this instance to its equivalent string representation using the
        /// specified format.
        /// </summary>
        /// <param name="format">A numeric format string.</param>
        /// <returns>
        /// The string representation of the value of this instance as specified by <paramref name="format" />.
        /// </returns>
        /// <exception cref="FormatException">The <paramref name="format" /> parameter is invalid.</exception>
        public string ToString(string format) { return default(string); }
        /// <summary>
        /// Converts the numeric value of this instance to its equivalent string representation using the
        /// specified format and culture-specific format information.
        /// </summary>
        /// <param name="format">A numeric format string.</param>
        /// <param name="provider">An object that supplies culture-specific formatting information about this instance.</param>
        /// <returns>
        /// The string representation of the value of this instance as specified by <paramref name="format" />
        /// and <paramref name="provider" />.
        /// </returns>
        /// <exception cref="FormatException">The <paramref name="format" /> parameter is invalid.</exception>
        public string ToString(string format, System.IFormatProvider provider) { return default(string); }
        /// <summary>
        /// Tries to convert the string representation of a number in a specified style and culture-specific
        /// format to its 64-bit unsigned integer equivalent. A return value indicates whether the conversion
        /// succeeded or failed.
        /// </summary>
        /// <param name="s">
        /// A string that represents the number to convert. The string is interpreted by using the style
        /// specified by the <paramref name="style" /> parameter.
        /// </param>
        /// <param name="style">
        /// A bitwise combination of enumeration values that indicates the permitted format of <paramref name="s" />.
        /// A typical value to specify is <see cref="Globalization.NumberStyles.Integer" />.
        /// </param>
        /// <param name="provider">
        /// An object that supplies culture-specific formatting information about <paramref name="s" />.
        /// </param>
        /// <param name="result">
        /// When this method returns, contains the 64-bit unsigned integer value equivalent to the number
        /// contained in <paramref name="s" />, if the conversion succeeded, or zero if the conversion
        /// failed. The conversion fails if the <paramref name="s" /> parameter is null  or <see cref="String.Empty" />,
        /// is not in a format compliant with <paramref name="style" />, or represents a number less
        /// than <see cref="MinValue" /> or greater than <see cref="MaxValue" />.
        /// This parameter is passed uninitialized; any value originally supplied in <paramref name="result" />
        /// will be overwritten.
        /// </param>
        /// <returns>
        /// true if <paramref name="s" /> was converted successfully; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// <paramref name="style" /> is not a <see cref="Globalization.NumberStyles" /> value.
        /// -or-<paramref name="style" /> is not a combination of
        /// <see cref="Globalization.NumberStyles.AllowHexSpecifier" /> and <see cref="Globalization.NumberStyles.HexNumber" /> values.
        /// </exception>
        [System.CLSCompliantAttribute(false)]
        public static bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, out ulong result) { result = default(ulong); return default(bool); }
        /// <summary>
        /// Tries to convert the string representation of a number to its 64-bit unsigned integer equivalent.
        /// A return value indicates whether the conversion succeeded or failed.
        /// </summary>
        /// <param name="s">A string that represents the number to convert.</param>
        /// <param name="result">
        /// When this method returns, contains the 64-bit unsigned integer value that is equivalent to
        /// the number contained in <paramref name="s" />, if the conversion succeeded, or zero if the
        /// conversion failed. The conversion fails if the <paramref name="s" /> parameter is null  or
        /// <see cref="String.Empty" />, is not of the correct format, or represents a number
        /// less than <see cref="MinValue" /> or greater than <see cref="MaxValue" />.
        /// This parameter is passed uninitialized; any value originally supplied in <paramref name="result" />
        /// will be overwritten.
        /// </param>
        /// <returns>
        /// true if <paramref name="s" /> was converted successfully; otherwise, false.
        /// </returns>
        [System.CLSCompliantAttribute(false)]
        public static bool TryParse(string s, out ulong result) { result = default(ulong); return default(bool); }
    }
    /// <summary>
    /// A platform-specific type that is used to represent a pointer or a handle.
    /// </summary>
    [System.CLSCompliantAttribute(false)]
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct UIntPtr
    {
        /// <summary>
        /// A read-only field that represents a pointer or handle that has been initialized to zero.
        /// </summary>
        public static readonly System.UIntPtr Zero;
        /// <summary>
        /// Initializes a new instance of the <see cref="UIntPtr" /> structure using the specified
        /// 32-bit pointer or handle.
        /// </summary>
        /// <param name="value">A pointer or handle contained in a 32-bit unsigned integer.</param>
        public UIntPtr(uint value) { throw new System.NotImplementedException(); }
        /// <summary>
        /// Initializes a new instance of <see cref="UIntPtr" /> using the specified 64-bit pointer
        /// or handle.
        /// </summary>
        /// <param name="value">A pointer or handle contained in a 64-bit unsigned integer.</param>
        /// <exception cref="OverflowException">
        /// On a 32-bit platform, <paramref name="value" /> is too large to represent as an <see cref="UIntPtr" />.
        /// </exception>
        public UIntPtr(ulong value) { throw new System.NotImplementedException(); }
        /// <summary>
        /// Initializes a new instance of <see cref="UIntPtr" /> using the specified pointer
        /// to an unspecified type.
        /// </summary>
        /// <param name="value">A pointer to an unspecified type.</param>
        [System.CLSCompliantAttribute(false)]
        [System.Security.SecurityCriticalAttribute]
        public unsafe UIntPtr(void* value) { throw new System.NotImplementedException(); }
        /// <summary>
        /// Gets the size of this instance.
        /// </summary>
        /// <returns>
        /// The size of a pointer or handle on this platform, measured in bytes. The value of this property
        /// is 4 on a 32-bit platform, and 8 on a 64-bit platform.
        /// </returns>
        public static int Size { get { return default(int); } }
        /// <summary>
        /// Adds an offset to the value of an unsigned pointer.
        /// </summary>
        /// <param name="pointer">The unsigned pointer to add the offset to.</param>
        /// <param name="offset">The offset to add.</param>
        /// <returns>
        /// A new unsigned pointer that reflects the addition of <paramref name="offset" /> to <paramref name="pointer" />.
        /// </returns>
        public static System.UIntPtr Add(System.UIntPtr pointer, int offset) { return default(System.UIntPtr); }
        /// <summary>
        /// Returns a value indicating whether this instance is equal to a specified object.
        /// </summary>
        /// <param name="obj">An object to compare with this instance or null.</param>
        /// <returns>
        /// true if <paramref name="obj" /> is an instance of <see cref="UIntPtr" /> and equals
        /// the value of this instance; otherwise, false.
        /// </returns>
        public override bool Equals(object obj) { return default(bool); }
        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code.
        /// </returns>
        public override int GetHashCode() { return default(int); }
        /// <summary>
        /// Adds an offset to the value of an unsigned pointer.
        /// </summary>
        /// <param name="pointer">The unsigned pointer to add the offset to.</param>
        /// <param name="offset">The offset to add.</param>
        /// <returns>
        /// A new unsigned pointer that reflects the addition of <paramref name="offset" /> to <paramref name="pointer" />.
        /// </returns>
        public static System.UIntPtr operator +(System.UIntPtr pointer, int offset) { return default(System.UIntPtr); }
        /// <summary>
        /// Determines whether two specified instances of <see cref="UIntPtr" /> are equal.
        /// </summary>
        /// <param name="value1">The first pointer or handle to compare.</param>
        /// <param name="value2">The second pointer or handle to compare.</param>
        /// <returns>
        /// true if <paramref name="value1" /> equals <paramref name="value2" />; otherwise, false.
        /// </returns>
        public static bool operator ==(System.UIntPtr value1, System.UIntPtr value2) { return default(bool); }
        /// <summary>
        /// Converts the value of a 32-bit unsigned integer to an <see cref="UIntPtr" />.
        /// </summary>
        /// <param name="value">A 32-bit unsigned integer.</param>
        /// <returns>
        /// A new instance of <see cref="UIntPtr" /> initialized to <paramref name="value" />.
        /// </returns>
        public static explicit operator System.UIntPtr(uint value) { return default(System.UIntPtr); }
        /// <summary>
        /// Converts the value of a 64-bit unsigned integer to an <see cref="UIntPtr" />.
        /// </summary>
        /// <param name="value">A 64-bit unsigned integer.</param>
        /// <returns>
        /// A new instance of <see cref="UIntPtr" /> initialized to <paramref name="value" />.
        /// </returns>
        /// <exception cref="OverflowException">
        /// On a 32-bit platform, <paramref name="value" /> is too large to represent as an <see cref="UIntPtr" />.
        /// </exception>
        public static explicit operator System.UIntPtr(ulong value) { return default(System.UIntPtr); }
        /// <summary>
        /// Converts the value of the specified <see cref="UIntPtr" /> to a 32-bit unsigned integer.
        /// </summary>
        /// <param name="value">The pointer or handle to convert.</param>
        /// <returns>
        /// The contents of <paramref name="value" />.
        /// </returns>
        /// <exception cref="OverflowException">
        /// On a 64-bit platform, the value of <paramref name="value" /> is too large to represent as
        /// a 32-bit unsigned integer.
        /// </exception>
        public static explicit operator uint(System.UIntPtr value) { return default(uint); }
        /// <summary>
        /// Converts the value of the specified <see cref="UIntPtr" /> to a 64-bit unsigned integer.
        /// </summary>
        /// <param name="value">The pointer or handle to convert.</param>
        /// <returns>
        /// The contents of <paramref name="value" />.
        /// </returns>
        public static explicit operator ulong(System.UIntPtr value) { return default(ulong); }
        /// <summary>
        /// Converts the value of the specified <see cref="UIntPtr" /> to a pointer to an unspecified
        /// type.
        /// </summary>
        /// <param name="value">The pointer or handle to convert.</param>
        /// <returns>
        /// The contents of <paramref name="value" />.
        /// </returns>
        [System.CLSCompliantAttribute(false)]
        [System.Security.SecurityCriticalAttribute]
        public unsafe static explicit operator void* (System.UIntPtr value) { return default(void*); }
        /// <summary>
        /// Converts the specified pointer to an unspecified type to a <see cref="UIntPtr" />.
        /// </summary>
        /// <param name="value">A pointer to an unspecified type.</param>
        /// <returns>
        /// A new instance of <see cref="UIntPtr" /> initialized to <paramref name="value" />.
        /// </returns>
        [System.CLSCompliantAttribute(false)]
        [System.Security.SecurityCriticalAttribute]
        public unsafe static explicit operator System.UIntPtr(void* value) { return default(System.UIntPtr); }
        /// <summary>
        /// Determines whether two specified instances of <see cref="UIntPtr" /> are not equal.
        /// </summary>
        /// <param name="value1">The first pointer or handle to compare.</param>
        /// <param name="value2">The second pointer or handle to compare.</param>
        /// <returns>
        /// true if <paramref name="value1" /> does not equal <paramref name="value2" />; otherwise, false.
        /// </returns>
        public static bool operator !=(System.UIntPtr value1, System.UIntPtr value2) { return default(bool); }
        /// <summary>
        /// Subtracts an offset from the value of an unsigned pointer.
        /// </summary>
        /// <param name="pointer">The unsigned pointer to subtract the offset from.</param>
        /// <param name="offset">The offset to subtract.</param>
        /// <returns>
        /// A new unsigned pointer that reflects the subtraction of <paramref name="offset" /> from
        /// <paramref name="pointer" />.
        /// </returns>
        public static System.UIntPtr operator -(System.UIntPtr pointer, int offset) { return default(System.UIntPtr); }
        /// <summary>
        /// Subtracts an offset from the value of an unsigned pointer.
        /// </summary>
        /// <param name="pointer">The unsigned pointer to subtract the offset from.</param>
        /// <param name="offset">The offset to subtract.</param>
        /// <returns>
        /// A new unsigned pointer that reflects the subtraction of <paramref name="offset" /> from
        /// <paramref name="pointer" />.
        /// </returns>
        public static System.UIntPtr Subtract(System.UIntPtr pointer, int offset) { return default(System.UIntPtr); }
        /// <summary>
        /// Converts the value of this instance to a pointer to an unspecified type.
        /// </summary>
        /// <returns>
        /// A pointer to <see cref="Void" />; that is, a pointer to memory containing data of
        /// an unspecified type.
        /// </returns>
        [System.CLSCompliantAttribute(false)]
        public unsafe void* ToPointer() { return default(void*); }
        /// <summary>
        /// Converts the numeric value of this instance to its equivalent string representation.
        /// </summary>
        /// <returns>
        /// The string representation of the value of this instance.
        /// </returns>
        public override string ToString() { return default(string); }
        /// <summary>
        /// Converts the value of this instance to a 32-bit unsigned integer.
        /// </summary>
        /// <returns>
        /// A 32-bit unsigned integer equal to the value of this instance.
        /// </returns>
        /// <exception cref="OverflowException">
        /// On a 64-bit platform, the value of this instance is too large to represent as a 32-bit unsigned
        /// integer.
        /// </exception>
        public uint ToUInt32() { return default(uint); }
        /// <summary>
        /// Converts the value of this instance to a 64-bit unsigned integer.
        /// </summary>
        /// <returns>
        /// A 64-bit unsigned integer equal to the value of this instance.
        /// </returns>
        public ulong ToUInt64() { return default(ulong); }
    }
    /// <summary>
    /// The exception that is thrown when the operating system denies access because of an I/O error
    /// or a specific type of security error.
    /// </summary>
    public partial class UnauthorizedAccessException : System.Exception
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="UnauthorizedAccessException" /> class.
        /// </summary>
        public UnauthorizedAccessException() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="UnauthorizedAccessException" /> class
        /// with a specified error message.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        public UnauthorizedAccessException(string message) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="UnauthorizedAccessException" /> class
        /// with a specified error message and a reference to the inner exception that is the cause of
        /// this exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="inner">
        /// The exception that is the cause of the current exception. If the <paramref name="inner" />
        /// parameter is not a null reference (Nothing in Visual Basic), the current exception is raised
        /// in a catch block that handles the inner exception.
        /// </param>
        public UnauthorizedAccessException(string message, System.Exception inner) { }
    }
    /// <summary>
    /// Provides an object representation of a uniform resource identifier (URI) and easy access to
    /// the parts of the URI.
    /// </summary>
    public partial class Uri
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Uri" /> class with the specified URI.
        /// </summary>
        /// <param name="uriString">A URI.</param>
        /// <exception cref="ArgumentNullException"><paramref name="uriString" /> is null.</exception>
        /// <exception cref="UriFormatException">
        /// In the .NET for Windows Store apps or the Portable Class Library, catch the base class exception,
        /// <see cref="FormatException" />, instead.<paramref name="uriString" /> is empty.-or-
        /// The scheme specified in <paramref name="uriString" /> is not correctly formed. See
        /// <see cref="Uri.CheckSchemeName(String)" />.-or- <paramref name="uriString" /> contains too many slashes.-or- The password specified
        /// in <paramref name="uriString" /> is not valid.-or- The host name specified in
        /// <paramref name="uriString" /> is not valid.-or- The file name specified in <paramref name="uriString" /> is not valid.
        /// -or- The user name specified in <paramref name="uriString" /> is not valid.-or- The host or
        /// authority name specified in <paramref name="uriString" /> cannot be terminated by backslashes.-or-
        /// The port number specified in <paramref name="uriString" /> is not valid or cannot be parsed.-or-
        /// The length of <paramref name="uriString" /> exceeds 65519 characters.-or- The length of the
        /// scheme specified in <paramref name="uriString" /> exceeds 1023 characters.-or- There is an
        /// invalid character sequence in <paramref name="uriString" />.-or- The MS-DOS path specified
        /// in <paramref name="uriString" /> must start with c:\\.
        /// </exception>
        public Uri(string uriString) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="Uri" /> class with the specified URI.
        /// This constructor allows you to specify if the URI string is a relative URI, absolute URI,
        /// or is indeterminate.
        /// </summary>
        /// <param name="uriString">
        /// A string that identifies the resource to be represented by the <see cref="Uri" />
        /// instance.
        /// </param>
        /// <param name="uriKind">Specifies whether the URI string is a relative URI, absolute URI, or is indeterminate.</param>
        /// <exception cref="ArgumentException"><paramref name="uriKind" /> is invalid.</exception>
        /// <exception cref="ArgumentNullException"><paramref name="uriString" /> is null.</exception>
        /// <exception cref="UriFormatException">
        /// In the .NET for Windows Store apps or the Portable Class Library, catch the base class exception,
        /// <see cref="FormatException" />, instead.<paramref name="uriString" /> contains a
        /// relative URI and <paramref name="uriKind" /> is <see cref="UriKind.Absolute" />.or<paramref name="uriString" />
        /// contains an absolute URI and <paramref name="uriKind" /> is <see cref="UriKind.Relative" />.
        /// or<paramref name="uriString" /> is empty.-or- The scheme specified in <paramref name="uriString" />
        /// is not correctly formed. See <see cref="Uri.CheckSchemeName(String)" />.-or-
        /// <paramref name="uriString" /> contains too many slashes.-or- The password specified in
        /// <paramref name="uriString" /> is not valid.-or- The host name specified in <paramref name="uriString" />
        /// is not valid.-or- The file name specified in <paramref name="uriString" /> is not valid.
        /// -or- The user name specified in <paramref name="uriString" /> is not valid.-or- The host or
        /// authority name specified in <paramref name="uriString" /> cannot be terminated by backslashes.-or-
        /// The port number specified in <paramref name="uriString" /> is not valid or cannot be parsed.-or-
        /// The length of <paramref name="uriString" /> exceeds 65519 characters.-or- The length of the
        /// scheme specified in <paramref name="uriString" /> exceeds 1023 characters.-or- There is an
        /// invalid character sequence in <paramref name="uriString" />.-or- The MS-DOS path specified
        /// in <paramref name="uriString" /> must start with c:\\.
        /// </exception>
        public Uri(string uriString, System.UriKind uriKind) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="Uri" /> class based on the specified
        /// base URI and relative URI string.
        /// </summary>
        /// <param name="baseUri">The base URI.</param>
        /// <param name="relativeUri">The relative URI to add to the base URI.</param>
        /// <exception cref="ArgumentNullException"><paramref name="baseUri" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="baseUri" /> is not an absolute <see cref="Uri" /> instance.
        /// </exception>
        /// <exception cref="UriFormatException">
        /// In the .NET for Windows Store apps or the Portable Class Library, catch the base class exception,
        /// <see cref="FormatException" />, instead.The URI formed by combining <paramref name="baseUri" />
        /// and <paramref name="relativeUri" /> is empty or contains only spaces.-or- The scheme specified
        /// in the URI formed by combining <paramref name="baseUri" /> and <paramref name="relativeUri" />
        /// is not valid.-or- The URI formed by combining <paramref name="baseUri" /> and <paramref name="relativeUri" />
        /// contains too many slashes.-or- The password specified in the URI formed
        /// by combining <paramref name="baseUri" /> and <paramref name="relativeUri" /> is not valid.-or-
        /// The host name specified in the URI formed by combining <paramref name="baseUri" /> and <paramref name="relativeUri" />
        /// is not valid.-or- The file name specified in the URI formed by combining
        /// <paramref name="baseUri" /> and <paramref name="relativeUri" /> is not valid. -or- The user
        /// name specified in the URI formed by combining <paramref name="baseUri" /> and <paramref name="relativeUri" />
        /// is not valid.-or- The host or authority name specified in the URI formed by combining <paramref name="baseUri" />
        /// and <paramref name="relativeUri" /> cannot be terminated by backslashes.-or-
        /// The port number specified in the URI formed by combining <paramref name="baseUri" /> and <paramref name="relativeUri" />
        /// is not valid or cannot be parsed.-or- The length of the URI formed by
        /// combining <paramref name="baseUri" /> and <paramref name="relativeUri" /> exceeds 65519 characters.-or-
        /// The length of the scheme specified in the URI formed by combining <paramref name="baseUri" />
        /// and <paramref name="relativeUri" /> exceeds 1023 characters.-or- There is an invalid character
        /// sequence in the URI formed by combining <paramref name="baseUri" /> and <paramref name="relativeUri" />.
        /// -or- The MS-DOS path specified in <paramref name="uriString" /> must start with c:\\.
        /// </exception>
        public Uri(System.Uri baseUri, string relativeUri) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="Uri" /> class based on the combination
        /// of a specified base <see cref="Uri" /> instance and a relative <see cref="Uri" />
        /// instance.
        /// </summary>
        /// <param name="baseUri">
        /// An absolute <see cref="Uri" /> that is the base for the new <see cref="Uri" />
        /// instance.
        /// </param>
        /// <param name="relativeUri">
        /// A relative <see cref="Uri" /> instance that is combined with <paramref name="baseUri" />.
        /// </param>
        /// <exception cref="ArgumentException">
        /// <paramref name="baseUri" /> is not an absolute <see cref="Uri" /> instance.
        /// </exception>
        /// <exception cref="ArgumentNullException"><paramref name="baseUri" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="baseUri" /> is not an absolute <see cref="Uri" /> instance.
        /// </exception>
        /// <exception cref="UriFormatException">
        /// In the .NET for Windows Store apps or the Portable Class Library, catch the base class exception,
        /// <see cref="FormatException" />, instead.The URI formed by combining <paramref name="baseUri" />
        /// and <paramref name="relativeUri" /> is empty or contains only spaces.-or- The scheme specified
        /// in the URI formed by combining <paramref name="baseUri" /> and <paramref name="relativeUri" />
        /// is not valid.-or- The URI formed by combining <paramref name="baseUri" /> and <paramref name="relativeUri" />
        /// contains too many slashes.-or- The password specified in the URI formed
        /// by combining <paramref name="baseUri" /> and <paramref name="relativeUri" /> is not valid.-or-
        /// The host name specified in the URI formed by combining <paramref name="baseUri" /> and <paramref name="relativeUri" />
        /// is not valid.-or- The file name specified in the URI formed by combining
        /// <paramref name="baseUri" /> and <paramref name="relativeUri" /> is not valid. -or- The user
        /// name specified in the URI formed by combining <paramref name="baseUri" /> and <paramref name="relativeUri" />
        /// is not valid.-or- The host or authority name specified in the URI formed by combining <paramref name="baseUri" />
        /// and <paramref name="relativeUri" /> cannot be terminated by backslashes.-or-
        /// The port number specified in the URI formed by combining <paramref name="baseUri" /> and <paramref name="relativeUri" />
        /// is not valid or cannot be parsed.-or- The length of the URI formed by
        /// combining <paramref name="baseUri" /> and <paramref name="relativeUri" /> exceeds 65519 characters.-or-
        /// The length of the scheme specified in the URI formed by combining <paramref name="baseUri" />
        /// and <paramref name="relativeUri" /> exceeds 1023 characters.-or- There is an invalid character
        /// sequence in the URI formed by combining <paramref name="baseUri" /> and <paramref name="relativeUri" />.
        /// -or- The MS-DOS path specified in <paramref name="uriString" /> must start with c:\\.
        /// </exception>
        public Uri(System.Uri baseUri, System.Uri relativeUri) { }
        /// <summary>
        /// Gets the absolute path of the URI.
        /// </summary>
        /// <returns>
        /// A <see cref="String" /> containing the absolute path to the resource.
        /// </returns>
        /// <exception cref="InvalidOperationException">
        /// This instance represents a relative URI, and this property is valid only for absolute URIs.
        /// </exception>
        public string AbsolutePath { get { return default(string); } }
        /// <summary>
        /// Gets the absolute URI.
        /// </summary>
        /// <returns>
        /// A <see cref="String" /> containing the entire URI.
        /// </returns>
        /// <exception cref="InvalidOperationException">
        /// This instance represents a relative URI, and this property is valid only for absolute URIs.
        /// </exception>
        public string AbsoluteUri { get { return default(string); } }
        /// <summary>
        /// Gets the Domain Name System (DNS) host name or IP address and the port number for a server.
        /// </summary>
        /// <returns>
        /// A <see cref="String" /> containing the authority component of the URI represented
        /// by this instance.
        /// </returns>
        /// <exception cref="InvalidOperationException">
        /// This instance represents a relative URI, and this property is valid only for absolute URIs.
        /// </exception>
        public string Authority { get { return default(string); } }
        /// <summary>
        /// Gets an unescaped host name that is safe to use for DNS resolution.
        /// </summary>
        /// <returns>
        /// A <see cref="String" /> that contains the unescaped host part of the URI that is
        /// suitable for DNS resolution; or the original unescaped host string, if it is already suitable
        /// for resolution.
        /// </returns>
        /// <exception cref="InvalidOperationException">
        /// This instance represents a relative URI, and this property is valid only for absolute URIs.
        /// </exception>
        public string DnsSafeHost { get { return default(string); } }
        /// <summary>
        /// Gets the escaped URI fragment.
        /// </summary>
        /// <returns>
        /// A <see cref="String" /> that contains any URI fragment information.
        /// </returns>
        /// <exception cref="InvalidOperationException">
        /// This instance represents a relative URI, and this property is valid only for absolute URIs.
        /// </exception>
        public string Fragment { get { return default(string); } }
        /// <summary>
        /// Gets the host component of this instance.
        /// </summary>
        /// <returns>
        /// A <see cref="String" /> that contains the host name. This is usually the DNS host
        /// name or IP address of the server.
        /// </returns>
        /// <exception cref="InvalidOperationException">
        /// This instance represents a relative URI, and this property is valid only for absolute URIs.
        /// </exception>
        public string Host { get { return default(string); } }
        /// <summary>
        /// Gets the type of the host name specified in the URI.
        /// </summary>
        /// <returns>
        /// A member of the <see cref="UriHostNameType" /> enumeration.
        /// </returns>
        /// <exception cref="InvalidOperationException">
        /// This instance represents a relative URI, and this property is valid only for absolute URIs.
        /// </exception>
        public System.UriHostNameType HostNameType { get { return default(System.UriHostNameType); } }
        /// <summary>
        /// The RFC 3490 compliant International Domain Name of the host, using Punycode as appropriate.
        /// </summary>
        /// <returns>
        /// Returns the hostname, formatted with Punycode according to the IDN standard.<see cref="String" />.
        /// </returns>
        public string IdnHost { get { return default(string); } }
        /// <summary>
        /// Gets whether the <see cref="Uri" /> instance is absolute.
        /// </summary>
        /// <returns>
        /// A <see cref="Boolean" /> value that is true if the <see cref="Uri" /> instance
        /// is absolute; otherwise, false.
        /// </returns>
        public bool IsAbsoluteUri { get { return default(bool); } }
        /// <summary>
        /// Gets whether the port value of the URI is the default for this scheme.
        /// </summary>
        /// <returns>
        /// A <see cref="Boolean" /> value that is true if the value in the <see cref="Port" />
        /// property is the default port for this scheme; otherwise, false.
        /// </returns>
        /// <exception cref="InvalidOperationException">
        /// This instance represents a relative URI, and this property is valid only for absolute URIs.
        /// </exception>
        public bool IsDefaultPort { get { return default(bool); } }
        /// <summary>
        /// Gets a value indicating whether the specified <see cref="Uri" /> is a file URI.
        /// </summary>
        /// <returns>
        /// A <see cref="Boolean" /> value that is true if the <see cref="Uri" /> is
        /// a file URI; otherwise, false.
        /// </returns>
        /// <exception cref="InvalidOperationException">
        /// This instance represents a relative URI, and this property is valid only for absolute URIs.
        /// </exception>
        public bool IsFile { get { return default(bool); } }
        /// <summary>
        /// Gets whether the specified <see cref="Uri" /> references the local host.
        /// </summary>
        /// <returns>
        /// A <see cref="Boolean" /> value that is true if this <see cref="Uri" /> references
        /// the local host; otherwise, false.
        /// </returns>
        /// <exception cref="InvalidOperationException">
        /// This instance represents a relative URI, and this property is valid only for absolute URIs.
        /// </exception>
        public bool IsLoopback { get { return default(bool); } }
        /// <summary>
        /// Gets whether the specified <see cref="Uri" /> is a universal naming convention (UNC)
        /// path.
        /// </summary>
        /// <returns>
        /// A <see cref="Boolean" /> value that is true if the <see cref="Uri" /> is
        /// a UNC path; otherwise, false.
        /// </returns>
        /// <exception cref="InvalidOperationException">
        /// This instance represents a relative URI, and this property is valid only for absolute URIs.
        /// </exception>
        public bool IsUnc { get { return default(bool); } }
        /// <summary>
        /// Gets a local operating-system representation of a file name.
        /// </summary>
        /// <returns>
        /// A <see cref="String" /> that contains the local operating-system representation of
        /// a file name.
        /// </returns>
        /// <exception cref="InvalidOperationException">
        /// This instance represents a relative URI, and this property is valid only for absolute URIs.
        /// </exception>
        public string LocalPath { get { return default(string); } }
        /// <summary>
        /// Gets the original URI string that was passed to the <see cref="Uri" /> constructor.
        /// </summary>
        /// <returns>
        /// A <see cref="String" /> containing the exact URI specified when this instance was
        /// constructed; otherwise, <see cref="String.Empty" />.
        /// </returns>
        /// <exception cref="InvalidOperationException">
        /// This instance represents a relative URI, and this property is valid only for absolute URIs.
        /// </exception>
        public string OriginalString { get { return default(string); } }
        /// <summary>
        /// Gets the <see cref="AbsolutePath" /> and <see cref="Query" /> properties
        /// separated by a question mark (?).
        /// </summary>
        /// <returns>
        /// A <see cref="String" /> that contains the <see cref="AbsolutePath" />
        /// and <see cref="Query" /> properties separated by a question mark (?).
        /// </returns>
        /// <exception cref="InvalidOperationException">
        /// This instance represents a relative URI, and this property is valid only for absolute URIs.
        /// </exception>
        public string PathAndQuery { get { return default(string); } }
        /// <summary>
        /// Gets the port number of this URI.
        /// </summary>
        /// <returns>
        /// An <see cref="Int32" /> value that contains the port number for this URI.
        /// </returns>
        /// <exception cref="InvalidOperationException">
        /// This instance represents a relative URI, and this property is valid only for absolute URIs.
        /// </exception>
        public int Port { get { return default(int); } }
        /// <summary>
        /// Gets any query information included in the specified URI.
        /// </summary>
        /// <returns>
        /// A <see cref="String" /> that contains any query information included in the specified
        /// URI.
        /// </returns>
        /// <exception cref="InvalidOperationException">
        /// This instance represents a relative URI, and this property is valid only for absolute URIs.
        /// </exception>
        public string Query { get { return default(string); } }
        /// <summary>
        /// Gets the scheme name for this URI.
        /// </summary>
        /// <returns>
        /// A <see cref="String" /> that contains the scheme for this URI, converted to lowercase.
        /// </returns>
        /// <exception cref="InvalidOperationException">
        /// This instance represents a relative URI, and this property is valid only for absolute URIs.
        /// </exception>
        public string Scheme { get { return default(string); } }
        /// <summary>
        /// Gets an array containing the path segments that make up the specified URI.
        /// </summary>
        /// <returns>
        /// A <see cref="String" /> array that contains the path segments that make up the specified
        /// URI.
        /// </returns>
        /// <exception cref="InvalidOperationException">
        /// This instance represents a relative URI, and this property is valid only for absolute URIs.
        /// </exception>
        public string[] Segments { get { return default(string[]); } }
        /// <summary>
        /// Indicates that the URI string was completely escaped before the <see cref="Uri" />
        /// instance was created.
        /// </summary>
        /// <returns>
        /// A <see cref="Boolean" /> value that is true if the <paramref name="dontEscape" />
        /// parameter was set to true when the <see cref="Uri" /> instance was created; otherwise,
        /// false.
        /// </returns>
        public bool UserEscaped { get { return default(bool); } }
        /// <summary>
        /// Gets the user name, password, or other user-specific information associated with the specified
        /// URI.
        /// </summary>
        /// <returns>
        /// A <see cref="String" /> that contains the user information associated with the URI.
        /// The returned value does not include the '@' character reserved for delimiting the user information
        /// part of the URI.
        /// </returns>
        /// <exception cref="InvalidOperationException">
        /// This instance represents a relative URI, and this property is valid only for absolute URIs.
        /// </exception>
        public string UserInfo { get { return default(string); } }
        /// <summary>
        /// Determines whether the specified host name is a valid DNS name.
        /// </summary>
        /// <param name="name">The host name to validate. This can be an IPv4 or IPv6 address or an Internet host name.</param>
        /// <returns>
        /// A <see cref="UriHostNameType" /> that indicates the type of the host name. If the
        /// type of the host name cannot be determined or if the host name is null or a zero-length string,
        /// this method returns <see cref="UriHostNameType.Unknown" />.
        /// </returns>
        public static System.UriHostNameType CheckHostName(string name) { return default(System.UriHostNameType); }
        /// <summary>
        /// Determines whether the specified scheme name is valid.
        /// </summary>
        /// <param name="schemeName">The scheme name to validate.</param>
        /// <returns>
        /// A <see cref="Boolean" /> value that is true if the scheme name is valid; otherwise,
        /// false.
        /// </returns>
        public static bool CheckSchemeName(string schemeName) { return default(bool); }
        /// <summary>
        /// Compares the specified parts of two URIs using the specified comparison rules.
        /// </summary>
        /// <param name="uri1">The first <see cref="Uri" />.</param>
        /// <param name="uri2">The second <see cref="Uri" />.</param>
        /// <param name="partsToCompare">
        /// A bitwise combination of the <see cref="UriComponents" /> values that specifies the
        /// parts of <paramref name="uri1" /> and <paramref name="uri2" /> to compare.
        /// </param>
        /// <param name="compareFormat">
        /// One of the <see cref="UriFormat" /> values that specifies the character escaping
        /// used when the URI components are compared.
        /// </param>
        /// <param name="comparisonType">One of the <see cref="StringComparison" /> values.</param>
        /// <returns>
        /// An <see cref="Int32" /> value that indicates the lexical relationship between the
        /// compared <see cref="Uri" /> components.ValueMeaningLess than zero<paramref name="uri1" />
        /// is less than <paramref name="uri2" />.Zero<paramref name="uri1" /> equals <paramref name="uri2" />.
        /// Greater than zero<paramref name="uri1" /> is greater than <paramref name="uri2" />.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// <paramref name="comparisonType" /> is not a valid <see cref="StringComparison" />
        /// value.
        /// </exception>
        public static int Compare(System.Uri uri1, System.Uri uri2, System.UriComponents partsToCompare, System.UriFormat compareFormat, System.StringComparison comparisonType) { return default(int); }
        /// <summary>
        /// Compares two <see cref="Uri" /> instances for equality.
        /// </summary>
        /// <param name="comparand">
        /// The <see cref="Uri" /> instance or a URI identifier to compare with the current instance.
        /// </param>
        /// <returns>
        /// A <see cref="Boolean" /> value that is true if the two instances represent the same
        /// URI; otherwise, false.
        /// </returns>
        public override bool Equals(object comparand) { return default(bool); }
        /// <summary>
        /// Converts a string to its escaped representation.
        /// </summary>
        /// <param name="stringToEscape">The string to escape.</param>
        /// <returns>
        /// A <see cref="String" /> that contains the escaped representation of <paramref name="stringToEscape" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="stringToEscape" /> is null.</exception>
        /// <exception cref="UriFormatException">
        /// In the .NET for Windows Store apps or the Portable Class Library, catch the base class exception,
        /// <see cref="FormatException" />, instead.The length of <paramref name="stringToEscape" />
        /// exceeds 32766 characters.
        /// </exception>
        public static string EscapeDataString(string stringToEscape) { return default(string); }
        /// <summary>
        /// Converts a URI string to its escaped representation.
        /// </summary>
        /// <param name="stringToEscape">The string to escape.</param>
        /// <returns>
        /// A <see cref="String" /> that contains the escaped representation of <paramref name="stringToEscape" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="stringToEscape" /> is null.</exception>
        /// <exception cref="UriFormatException">
        /// In the .NET for Windows Store apps or the Portable Class Library, catch the base class exception,
        /// <see cref="FormatException" />, instead.The length of <paramref name="stringToEscape" />
        /// exceeds 32766 characters.
        /// </exception>
        public static string EscapeUriString(string stringToEscape) { return default(string); }
        /// <summary>
        /// Gets the specified components of the current instance using the specified escaping for special
        /// characters.
        /// </summary>
        /// <param name="components">
        /// A bitwise combination of the <see cref="UriComponents" /> values that specifies which
        /// parts of the current instance to return to the caller.
        /// </param>
        /// <param name="format">
        /// One of the <see cref="UriFormat" /> values that controls how special characters are
        /// escaped.
        /// </param>
        /// <returns>
        /// A <see cref="String" /> that contains the components.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="uriComponents" /> is not a combination of valid <see cref="UriComponents" />
        /// values.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// The current <see cref="Uri" /> is not an absolute URI. Relative URIs cannot be used
        /// with this method.
        /// </exception>
        public string GetComponents(System.UriComponents components, System.UriFormat format) { return default(string); }
        /// <summary>
        /// Gets the hash code for the URI.
        /// </summary>
        /// <returns>
        /// An <see cref="Int32" /> containing the hash value generated for this URI.
        /// </returns>
        public override int GetHashCode() { return default(int); }
        /// <summary>
        /// Determines whether the current <see cref="Uri" /> instance is a base of the specified
        /// <see cref="Uri" /> instance.
        /// </summary>
        /// <param name="uri">The specified <see cref="Uri" /> instance to test.</param>
        /// <returns>
        /// true if the current <see cref="Uri" /> instance is a base of <paramref name="uri" />;
        /// otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="uri" /> is null.</exception>
        public bool IsBaseOf(System.Uri uri) { return default(bool); }
        /// <summary>
        /// Indicates whether the string used to construct this <see cref="Uri" /> was well-formed
        /// and is not required to be further escaped.
        /// </summary>
        /// <returns>
        /// A <see cref="Boolean" /> value that is true if the string was well-formed; else false.
        /// </returns>
        public bool IsWellFormedOriginalString() { return default(bool); }
        /// <summary>
        /// Indicates whether the string is well-formed by attempting to construct a URI with the string
        /// and ensures that the string does not require further escaping.
        /// </summary>
        /// <param name="uriString">The string used to attempt to construct a <see cref="Uri" />.</param>
        /// <param name="uriKind">The type of the <see cref="Uri" /> in <paramref name="uriString" />.</param>
        /// <returns>
        /// A <see cref="Boolean" /> value that is true if the string was well-formed; else false.
        /// </returns>
        public static bool IsWellFormedUriString(string uriString, System.UriKind uriKind) { return default(bool); }
        /// <summary>
        /// Determines the difference between two <see cref="Uri" /> instances.
        /// </summary>
        /// <param name="uri">The URI to compare to the current URI.</param>
        /// <returns>
        /// If the hostname and scheme of this URI instance and <paramref name="uri" /> are the same,
        /// then this method returns a relative <see cref="Uri" /> that, when appended to the
        /// current URI instance, yields <paramref name="uri" />.If the hostname or scheme is different,
        /// then this method returns a <see cref="Uri" />  that represents the <paramref name="uri" />
        /// parameter.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="uri" /> is null.</exception>
        /// <exception cref="InvalidOperationException">
        /// This instance represents a relative URI, and this property is valid only for absolute URIs.
        /// </exception>
        public System.Uri MakeRelativeUri(System.Uri uri) { return default(System.Uri); }
        /// <summary>
        /// Determines whether two <see cref="Uri" /> instances have the same value.
        /// </summary>
        /// <param name="uri1">A <see cref="Uri" /> instance to compare with <paramref name="uri2" />.</param>
        /// <param name="uri2">A <see cref="Uri" /> instance to compare with <paramref name="uri1" />.</param>
        /// <returns>
        /// A <see cref="Boolean" /> value that is true if the <see cref="Uri" /> instances
        /// are equivalent; otherwise, false.
        /// </returns>
        public static bool operator ==(System.Uri uri1, System.Uri uri2) { return default(bool); }
        /// <summary>
        /// Determines whether two <see cref="Uri" /> instances do not have the same value.
        /// </summary>
        /// <param name="uri1">A <see cref="Uri" /> instance to compare with <paramref name="uri2" />.</param>
        /// <param name="uri2">A <see cref="Uri" /> instance to compare with <paramref name="uri1" />.</param>
        /// <returns>
        /// A <see cref="Boolean" /> value that is true if the two <see cref="Uri" />
        /// instances are not equal; otherwise, false. If either parameter is null, this method returns
        /// true.
        /// </returns>
        public static bool operator !=(System.Uri uri1, System.Uri uri2) { return default(bool); }
        /// <summary>
        /// Gets a canonical string representation for the specified <see cref="Uri" /> instance.
        /// </summary>
        /// <returns>
        /// A <see cref="String" /> instance that contains the unescaped canonical representation
        /// of the <see cref="Uri" /> instance. All characters are unescaped except #, ?, and
        /// %.
        /// </returns>
        public override string ToString() { return default(string); }
        /// <summary>
        /// Creates a new <see cref="Uri" /> using the specified <see cref="String" />
        /// instance and a <see cref="UriKind" />.
        /// </summary>
        /// <param name="uriString">The <see cref="String" /> representing the <see cref="Uri" />.</param>
        /// <param name="uriKind">The type of the Uri.</param>
        /// <param name="result">When this method returns, contains the constructed <see cref="Uri" />.</param>
        /// <returns>
        /// A <see cref="Boolean" /> value that is true if the <see cref="Uri" /> was
        /// successfully created; otherwise, false.
        /// </returns>
        public static bool TryCreate(string uriString, System.UriKind uriKind, out System.Uri result) { result = default(System.Uri); return default(bool); }
        /// <summary>
        /// Creates a new <see cref="Uri" /> using the specified base and relative <see cref="String" />
        /// instances.
        /// </summary>
        /// <param name="baseUri">The base <see cref="Uri" />.</param>
        /// <param name="relativeUri">
        /// The relative <see cref="Uri" />, represented as a <see cref="String" />,
        /// to add to the base <see cref="Uri" />.
        /// </param>
        /// <param name="result">
        /// When this method returns, contains a <see cref="Uri" /> constructed from <paramref name="baseUri" />
        /// and <paramref name="relativeUri" />. This parameter is passed uninitialized.
        /// </param>
        /// <returns>
        /// A <see cref="Boolean" /> value that is true if the <see cref="Uri" /> was
        /// successfully created; otherwise, false.
        /// </returns>
        public static bool TryCreate(System.Uri baseUri, string relativeUri, out System.Uri result) { result = default(System.Uri); return default(bool); }
        /// <summary>
        /// Creates a new <see cref="Uri" /> using the specified base and relative <see cref="Uri" />
        /// instances.
        /// </summary>
        /// <param name="baseUri">The base <see cref="Uri" />.</param>
        /// <param name="relativeUri">
        /// The relative <see cref="Uri" /> to add to the base <see cref="Uri" />.
        /// </param>
        /// <param name="result">
        /// When this method returns, contains a <see cref="Uri" /> constructed from <paramref name="baseUri" />
        /// and <paramref name="relativeUri" />. This parameter is passed uninitialized.
        /// </param>
        /// <returns>
        /// A <see cref="Boolean" /> value that is true if the <see cref="Uri" /> was
        /// successfully created; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="baseUri" /> is null.</exception>
        public static bool TryCreate(System.Uri baseUri, System.Uri relativeUri, out System.Uri result) { result = default(System.Uri); return default(bool); }
        /// <summary>
        /// Converts a string to its unescaped representation.
        /// </summary>
        /// <param name="stringToUnescape">The string to unescape.</param>
        /// <returns>
        /// A <see cref="String" /> that contains the unescaped representation of
        /// <paramref name="stringToUnescape" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="stringToUnescape" /> is null.</exception>
        public static string UnescapeDataString(string stringToUnescape) { return default(string); }
    }
    /// <summary>
    /// Specifies the parts of a <see cref="Uri" />.
    /// </summary>
    [System.FlagsAttribute]
    public enum UriComponents
    {
        /// <summary>
        /// The <see cref="Uri.Scheme" />, <see cref="Uri.UserInfo" />, <see cref="Uri.Host" />,
        /// <see cref="Uri.Port" />, <see cref="Uri.LocalPath" />,
        /// <see cref="Uri.Query" />, and <see cref="Uri.Fragment" /> data.
        /// </summary>
        AbsoluteUri = 127,
        /// <summary>
        /// The <see cref="Uri.Fragment" /> data.
        /// </summary>
        Fragment = 64,
        /// <summary>
        /// The <see cref="Uri.Host" /> data.
        /// </summary>
        Host = 4,
        /// <summary>
        /// The <see cref="Uri.Host" /> and <see cref="Uri.Port" /> data. If no port
        /// data is in the Uri and a default port has been assigned to the <see cref="Uri.Scheme" />,
        /// the default port is returned. If there is no default port, -1 is returned.
        /// </summary>
        HostAndPort = 132,
        /// <summary>
        /// The <see cref="Uri.Scheme" />, <see cref="Uri.Host" />, <see cref="Uri.Port" />,
        /// <see cref="Uri.LocalPath" />, and <see cref="Uri.Query" /> data.
        /// </summary>
        HttpRequestUrl = 61,
        /// <summary>
        /// Specifies that the delimiter should be included.
        /// </summary>
        KeepDelimiter = 1073741824,
        /// <summary>
        /// The normalized form of the <see cref="Uri.Host" />.
        /// </summary>
        NormalizedHost = 256,
        /// <summary>
        /// The <see cref="Uri.LocalPath" /> data.
        /// </summary>
        Path = 16,
        /// <summary>
        /// The <see cref="Uri.LocalPath" /> and <see cref="Uri.Query" /> data. Also
        /// see <see cref="Uri.PathAndQuery" />.
        /// </summary>
        PathAndQuery = 48,
        /// <summary>
        /// The <see cref="Uri.Port" /> data.
        /// </summary>
        Port = 8,
        /// <summary>
        /// The <see cref="Uri.Query" /> data.
        /// </summary>
        Query = 32,
        /// <summary>
        /// The <see cref="Uri.Scheme" /> data.
        /// </summary>
        Scheme = 1,
        /// <summary>
        /// The <see cref="Uri.Scheme" />, <see cref="Uri.Host" />, and <see cref="Uri.Port" />
        /// data.
        /// </summary>
        SchemeAndServer = 13,
        /// <summary>
        /// The complete <see cref="Uri" /> context that is needed for Uri Serializers. The context
        /// includes the IPv6 scope.
        /// </summary>
        SerializationInfoString = -2147483648,
        /// <summary>
        /// The <see cref="Uri.UserInfo" />, <see cref="Uri.Host" />, and
        /// <see cref="Uri.Port" /> data. If no port data is in the <see cref="Uri" /> and a default port has been
        /// assigned to the <see cref="Uri.Scheme" />, the default port is returned. If there
        /// is no default port, -1 is returned.
        /// </summary>
        StrongAuthority = 134,
        /// <summary>
        /// The <see cref="Uri.Port" /> data. If no port data is in the <see cref="Uri" />
        /// and a default port has been assigned to the <see cref="Uri.Scheme" />, the default
        /// port is returned. If there is no default port, -1 is returned.
        /// </summary>
        StrongPort = 128,
        /// <summary>
        /// The <see cref="Uri.UserInfo" /> data.
        /// </summary>
        UserInfo = 2,
    }
    /// <summary>
    /// Controls how URI information is escaped.
    /// </summary>
    public enum UriFormat
    {
        /// <summary>
        /// Characters that have a reserved meaning in the requested URI components remain escaped. All
        /// others are not escaped. See Remarks.
        /// </summary>
        SafeUnescaped = 3,
        /// <summary>
        /// No escaping is performed.
        /// </summary>
        Unescaped = 2,
        /// <summary>
        /// Escaping is performed according to the rules in RFC 2396.
        /// </summary>
        UriEscaped = 1,
    }
    /// <summary>
    /// The exception that is thrown when an invalid Uniform Resource Identifier (URI) is detected.
    /// </summary>
    public partial class UriFormatException : System.FormatException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="UriFormatException" /> class.
        /// </summary>
        public UriFormatException() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="UriFormatException" /> class with the
        /// specified message.
        /// </summary>
        /// <param name="textString">The error message string.</param>
        public UriFormatException(string textString) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="UriFormatException" /> class with a
        /// specified error message and a reference to the inner exception that is the cause of this exception.
        /// </summary>
        /// <param name="textString">
        /// The message that describes the exception. The caller of this constructor is required to ensure
        /// that this string has been localized for the current system culture.
        /// </param>
        /// <param name="e">
        /// The exception that is the cause of the current exception. If the <paramref name="innerException" />
        /// parameter is not null, the current exception is raised in a catch block that handles the
        /// inner exception.
        /// </param>
        public UriFormatException(string textString, System.Exception e) { }
    }
    /// <summary>
    /// Defines host name types for the <see cref="Uri.CheckHostName(String)" /> method.
    /// </summary>
    public enum UriHostNameType
    {
        /// <summary>
        /// The host is set, but the type cannot be determined.
        /// </summary>
        Basic = 1,
        /// <summary>
        /// The host name is a domain name system (DNS) style host name.
        /// </summary>
        Dns = 2,
        /// <summary>
        /// The host name is an Internet Protocol (IP) version 4 host address.
        /// </summary>
        IPv4 = 3,
        /// <summary>
        /// The host name is an Internet Protocol (IP) version 6 host address.
        /// </summary>
        IPv6 = 4,
        /// <summary>
        /// The type of the host name is not supplied.
        /// </summary>
        Unknown = 0,
    }
    /// <summary>
    /// Defines the kinds of <see cref="Uri" />s for the
    /// <see cref="Uri.IsWellFormedUriString(String,UriKind)" /> and several <see cref="Overload:System.Uri.#ctor" /> methods.
    /// </summary>
    public enum UriKind
    {
        /// <summary>
        /// The Uri is an absolute Uri.
        /// </summary>
        Absolute = 1,
        /// <summary>
        /// The Uri is a relative Uri.
        /// </summary>
        Relative = 2,
        /// <summary>
        /// The kind of the Uri is indeterminate.
        /// </summary>
        RelativeOrAbsolute = 0,
    }
    /// <summary>
    /// Provides the base class for value types.
    /// </summary>
    public abstract partial class ValueType
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ValueType" /> class.
        /// </summary>
        protected ValueType() { }
        /// <summary>
        /// Indicates whether this instance and a specified object are equal.
        /// </summary>
        /// <param name="obj">The object to compare with the current instance.</param>
        /// <returns>
        /// true if <paramref name="obj" /> and this instance are the same type and represent the same
        /// value; otherwise, false.
        /// </returns>
        public override bool Equals(object obj) { return default(bool); }
        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer that is the hash code for this instance.
        /// </returns>
        public override int GetHashCode() { return default(int); }
        /// <summary>
        /// Returns the fully qualified type name of this instance.
        /// </summary>
        /// <returns>
        /// The fully qualified type name.
        /// </returns>
        public override string ToString() { return default(string); }
    }
    /// <summary>
    /// Represents the version number of an assembly, operating system, or the common language runtime.
    /// This class cannot be inherited.
    /// </summary>
    public sealed partial class Version : System.IComparable, System.IComparable<System.Version>, System.IEquatable<System.Version>
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Version" /> class using the specified
        /// major and minor values.
        /// </summary>
        /// <param name="major">The major version number.</param>
        /// <param name="minor">The minor version number.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="major" /> or <paramref name="minor" /> is less than zero.
        /// </exception>
        public Version(int major, int minor) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="Version" /> class using the specified
        /// major, minor, and build values.
        /// </summary>
        /// <param name="major">The major version number.</param>
        /// <param name="minor">The minor version number.</param>
        /// <param name="build">The build number.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="major" />, <paramref name="minor" />, or <paramref name="build" /> is less
        /// than zero.
        /// </exception>
        public Version(int major, int minor, int build) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="Version" /> class with the specified
        /// major, minor, build, and revision numbers.
        /// </summary>
        /// <param name="major">The major version number.</param>
        /// <param name="minor">The minor version number.</param>
        /// <param name="build">The build number.</param>
        /// <param name="revision">The revision number.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="major" />, <paramref name="minor" />, <paramref name="build" />, or
        /// <paramref name="revision" /> is less than zero.
        /// </exception>
        public Version(int major, int minor, int build, int revision) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="Version" /> class using the specified
        /// string.
        /// </summary>
        /// <param name="version">
        /// A string containing the major, minor, build, and revision numbers, where each number is delimited
        /// with a period character ('.').
        /// </param>
        /// <exception cref="ArgumentException">
        /// <paramref name="version" /> has fewer than two components or more than four components.
        /// </exception>
        /// <exception cref="ArgumentNullException"><paramref name="version" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// A major, minor, build, or revision component is less than zero.
        /// </exception>
        /// <exception cref="FormatException">
        /// At least one component of <paramref name="version" /> does not parse to an integer.
        /// </exception>
        /// <exception cref="OverflowException">
        /// At least one component of <paramref name="version" /> represents a number greater than
        /// <see cref="Int32.MaxValue" />.
        /// </exception>
        public Version(string version) { }
        /// <summary>
        /// Gets the value of the build component of the version number for the current <see cref="Version" />
        /// object.
        /// </summary>
        /// <returns>
        /// The build number, or -1 if the build number is undefined.
        /// </returns>
        public int Build { get { return default(int); } }
        /// <summary>
        /// Gets the value of the major component of the version number for the current <see cref="Version" />
        /// object.
        /// </summary>
        /// <returns>
        /// The major version number.
        /// </returns>
        public int Major { get { return default(int); } }
        /// <summary>
        /// Gets the high 16 bits of the revision number.
        /// </summary>
        /// <returns>
        /// A 16-bit signed integer.
        /// </returns>
        public short MajorRevision { get { return default(short); } }
        /// <summary>
        /// Gets the value of the minor component of the version number for the current <see cref="Version" />
        /// object.
        /// </summary>
        /// <returns>
        /// The minor version number.
        /// </returns>
        public int Minor { get { return default(int); } }
        /// <summary>
        /// Gets the low 16 bits of the revision number.
        /// </summary>
        /// <returns>
        /// A 16-bit signed integer.
        /// </returns>
        public short MinorRevision { get { return default(short); } }
        /// <summary>
        /// Gets the value of the revision component of the version number for the current <see cref="Version" />
        /// object.
        /// </summary>
        /// <returns>
        /// The revision number, or -1 if the revision number is undefined.
        /// </returns>
        public int Revision { get { return default(int); } }
        /// <summary>
        /// Compares the current <see cref="Version" /> object to a specified <see cref="Version" />
        /// object and returns an indication of their relative values.
        /// </summary>
        /// <param name="value">
        /// A <see cref="Version" /> object to compare to the current <see cref="Version" />
        /// object, or null.
        /// </param>
        /// <returns>
        /// A signed integer that indicates the relative values of the two objects, as shown in the following
        /// table.Return value Meaning Less than zero The current <see cref="Version" /> object
        /// is a version before <paramref name="value" />. Zero The current <see cref="Version" />
        /// object is the same version as <paramref name="value" />. Greater than zero The current
        /// <see cref="Version" /> object is a version subsequent to <paramref name="value" />.
        /// -or-<paramref name="value" /> is null.
        /// </returns>
        public int CompareTo(System.Version value) { return default(int); }
        /// <summary>
        /// Returns a value indicating whether the current <see cref="Version" /> object is equal
        /// to a specified object.
        /// </summary>
        /// <param name="obj">An object to compare with the current <see cref="Version" /> object, or null.</param>
        /// <returns>
        /// true if the current <see cref="Version" /> object and <paramref name="obj" /> are
        /// both <see cref="Version" /> objects, and every component of the current <see cref="Version" />
        /// object matches the corresponding component of <paramref name="obj" />; otherwise, false.
        /// </returns>
        public override bool Equals(object obj) { return default(bool); }
        /// <summary>
        /// Returns a value indicating whether the current <see cref="Version" /> object and
        /// a specified <see cref="Version" /> object represent the same value.
        /// </summary>
        /// <param name="obj">
        /// A <see cref="Version" /> object to compare to the current <see cref="Version" />
        /// object, or null.
        /// </param>
        /// <returns>
        /// true if every component of the current <see cref="Version" /> object matches the
        /// corresponding component of the <paramref name="obj" /> parameter; otherwise, false.
        /// </returns>
        public bool Equals(System.Version obj) { return default(bool); }
        /// <summary>
        /// Returns a hash code for the current <see cref="Version" /> object.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code.
        /// </returns>
        public override int GetHashCode() { return default(int); }
        /// <summary>
        /// Determines whether two specified <see cref="Version" /> objects are equal.
        /// </summary>
        /// <param name="v1">The first <see cref="Version" /> object.</param>
        /// <param name="v2">The second <see cref="Version" /> object.</param>
        /// <returns>
        /// true if <paramref name="v1" /> equals <paramref name="v2" />; otherwise, false.
        /// </returns>
        public static bool operator ==(System.Version v1, System.Version v2) { return default(bool); }
        /// <summary>
        /// Determines whether the first specified <see cref="Version" /> object is greater than
        /// the second specified <see cref="Version" /> object.
        /// </summary>
        /// <param name="v1">The first <see cref="Version" /> object.</param>
        /// <param name="v2">The second <see cref="Version" /> object.</param>
        /// <returns>
        /// true if <paramref name="v1" /> is greater than <paramref name="v2" />; otherwise, false.
        /// </returns>
        public static bool operator >(System.Version v1, System.Version v2) { return default(bool); }
        /// <summary>
        /// Determines whether the first specified <see cref="Version" /> object is greater than
        /// or equal to the second specified <see cref="Version" /> object.
        /// </summary>
        /// <param name="v1">The first <see cref="Version" /> object.</param>
        /// <param name="v2">The second <see cref="Version" /> object.</param>
        /// <returns>
        /// true if <paramref name="v1" /> is greater than or equal to <paramref name="v2" />; otherwise,
        /// false.
        /// </returns>
        public static bool operator >=(System.Version v1, System.Version v2) { return default(bool); }
        /// <summary>
        /// Determines whether two specified <see cref="Version" /> objects are not equal.
        /// </summary>
        /// <param name="v1">The first <see cref="Version" /> object.</param>
        /// <param name="v2">The second <see cref="Version" /> object.</param>
        /// <returns>
        /// true if <paramref name="v1" /> does not equal <paramref name="v2" />; otherwise, false.
        /// </returns>
        public static bool operator !=(System.Version v1, System.Version v2) { return default(bool); }
        /// <summary>
        /// Determines whether the first specified <see cref="Version" /> object is less than
        /// the second specified <see cref="Version" /> object.
        /// </summary>
        /// <param name="v1">The first <see cref="Version" /> object.</param>
        /// <param name="v2">The second <see cref="Version" /> object.</param>
        /// <returns>
        /// true if <paramref name="v1" /> is less than <paramref name="v2" />; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="v1" /> is null.</exception>
        public static bool operator <(System.Version v1, System.Version v2) { return default(bool); }
        /// <summary>
        /// Determines whether the first specified <see cref="Version" /> object is less than
        /// or equal to the second <see cref="Version" /> object.
        /// </summary>
        /// <param name="v1">The first <see cref="Version" /> object.</param>
        /// <param name="v2">The second <see cref="Version" /> object.</param>
        /// <returns>
        /// true if <paramref name="v1" /> is less than or equal to <paramref name="v2" />; otherwise,
        /// false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="v1" /> is null.</exception>
        public static bool operator <=(System.Version v1, System.Version v2) { return default(bool); }
        /// <summary>
        /// Converts the string representation of a version number to an equivalent <see cref="Version" />
        /// object.
        /// </summary>
        /// <param name="input">A string that contains a version number to convert.</param>
        /// <returns>
        /// An object that is equivalent to the version number specified in the <paramref name="input" />
        /// parameter.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="input" /> is null.</exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="input" /> has fewer than two or more than four version components.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// At least one component in <paramref name="input" /> is less than zero.
        /// </exception>
        /// <exception cref="FormatException">
        /// At least one component in <paramref name="input" /> is not an integer.
        /// </exception>
        /// <exception cref="OverflowException">
        /// At least one component in <paramref name="input" /> represents a number that is greater than
        /// <see cref="Int32.MaxValue" />.
        /// </exception>
        public static System.Version Parse(string input) { return default(System.Version); }
        int System.IComparable.CompareTo(object version) { return default(int); }
        /// <summary>
        /// Converts the value of the current <see cref="Version" /> object to its equivalent
        /// <see cref="String" /> representation.
        /// </summary>
        /// <returns>
        /// The <see cref="String" /> representation of the values of the major, minor, build,
        /// and revision components of the current <see cref="Version" /> object, as depicted
        /// in the following format. Each component is separated by a period character ('.'). Square brackets
        /// ('[' and ']') indicate a component that will not appear in the return value if the component
        /// is not defined: major.minor[.build[.revision]] For example, if you create a <see cref="Version" />
        /// object using the constructor Version(1,1), the returned string is "1.1". If you create
        /// a <see cref="Version" /> object using the constructor Version(1,3,4,2), the returned
        /// string is "1.3.4.2".
        /// </returns>
        public override string ToString() { return default(string); }
        /// <summary>
        /// Converts the value of the current <see cref="Version" /> object to its equivalent
        /// <see cref="String" /> representation. A specified count indicates the number of components
        /// to return.
        /// </summary>
        /// <param name="fieldCount">
        /// The number of components to return. The <paramref name="fieldCount" /> ranges from 0 to 4.
        /// </param>
        /// <returns>
        /// The <see cref="String" /> representation of the values of the major, minor, build,
        /// and revision components of the current <see cref="Version" /> object, each separated
        /// by a period character ('.'). The <paramref name="fieldCount" /> parameter determines how many
        /// components are returned.fieldCount Return Value 0 An empty string (""). 1 major 2 major.minor
        /// 3 major.minor.build 4 major.minor.build.revision For example, if you create <see cref="Version" />
        /// object using the constructor Version(1,3,5), ToString(2) returns "1.3" and ToString(4)
        /// throws an exception.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// <paramref name="fieldCount" /> is less than 0, or more than 4.-or- <paramref name="fieldCount" />
        /// is more than the number of components defined in the current <see cref="Version" />
        /// object.
        /// </exception>
        public string ToString(int fieldCount) { return default(string); }
        /// <summary>
        /// Tries to convert the string representation of a version number to an equivalent <see cref="Version" />
        /// object, and returns a value that indicates whether the conversion succeeded.
        /// </summary>
        /// <param name="input">A string that contains a version number to convert.</param>
        /// <param name="result">
        /// When this method returns, contains the <see cref="Version" /> equivalent of the number
        /// that is contained in <paramref name="input" />, if the conversion succeeded, or a <see cref="Version" />
        /// object whose major and minor version numbers are 0 if the conversion failed. If
        /// <paramref name="input" /> is null or <see cref="String.Empty" />, <paramref name="result" />
        /// is null when the method returns.
        /// </param>
        /// <returns>
        /// true if the <paramref name="input" /> parameter was converted successfully; otherwise, false.
        /// </returns>
        public static bool TryParse(string input, out System.Version result) { result = default(System.Version); return default(bool); }
    }
    /// <summary>
    /// Specifies a return value type for a method that does not return a value.
    /// </summary>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Size = 1)]
    public partial struct Void
    {
    }
    /// <summary>
    /// Represents a weak reference, which references an object while still allowing that object to
    /// be reclaimed by garbage collection.
    /// </summary>
    public partial class WeakReference
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="WeakReference" /> class, referencing
        /// the specified object.
        /// </summary>
        /// <param name="target">The object to track or null.</param>
        public WeakReference(object target) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="WeakReference" /> class, referencing
        /// the specified object and using the specified resurrection tracking.
        /// </summary>
        /// <param name="target">An object to track.</param>
        /// <param name="trackResurrection">
        /// Indicates when to stop tracking the object. If true, the object is tracked after finalization;
        /// if false, the object is only tracked until finalization.
        /// </param>
        public WeakReference(object target, bool trackResurrection) { }
        /// <summary>
        /// Gets an indication whether the object referenced by the current <see cref="WeakReference" />
        /// object has been garbage collected.
        /// </summary>
        /// <returns>
        /// true if the object referenced by the current <see cref="WeakReference" /> object
        /// has not been garbage collected and is still accessible; otherwise, false.
        /// </returns>
        public virtual bool IsAlive { get { return default(bool); } }
        /// <summary>
        /// Gets or sets the object (the target) referenced by the current <see cref="WeakReference" />
        /// object.
        /// </summary>
        /// <returns>
        /// null if the object referenced by the current <see cref="WeakReference" /> object
        /// has been garbage collected; otherwise, a reference to the object referenced by the current
        /// <see cref="WeakReference" /> object.
        /// </returns>
        /// <exception cref="InvalidOperationException">
        /// The reference to the target object is invalid. This exception can be thrown while setting this
        /// property if the value is a null reference or if the object has been finalized during the set operation.
        /// </exception>
        public virtual object Target { get { return default(object); } set { } }
        /// <summary>
        /// Gets an indication whether the object referenced by the current <see cref="WeakReference" />
        /// object is tracked after it is finalized.
        /// </summary>
        /// <returns>
        /// true if the object the current <see cref="WeakReference" /> object refers to is tracked
        /// after finalization; or false if the object is only tracked until finalization.
        /// </returns>
        public virtual bool TrackResurrection { get { return default(bool); } }
        /// <summary>
        /// Discards the reference to the target represented by the current <see cref="WeakReference" />
        /// object.
        /// </summary>
        ~WeakReference() { }
    }
    /// <summary>
    /// Represents a typed weak reference, which references an object while still allowing that object
    /// to be reclaimed by garbage collection.
    /// </summary>
    /// <typeparam name="T">The type of the object referenced.</typeparam>
    public sealed partial class WeakReference<T> where T : class
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="WeakReference`1" /> class that references
        /// the specified object.
        /// </summary>
        /// <param name="target">The object to reference, or null.</param>
        public WeakReference(T target) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="WeakReference`1" /> class that references
        /// the specified object and uses the specified resurrection tracking.
        /// </summary>
        /// <param name="target">The object to reference, or null.</param>
        /// <param name="trackResurrection">
        /// true to track the object after finalization; false to track the object only until finalization.
        /// </param>
        public WeakReference(T target, bool trackResurrection) { }
        /// <summary>
        /// Discards the reference to the target that is represented by the current <see cref="WeakReference`1" />
        /// object.
        /// </summary>
        ~WeakReference() { }
        /// <summary>
        /// Sets the target object that is referenced by this <see cref="WeakReference`1" />
        /// object.
        /// </summary>
        /// <param name="target">The new target object.</param>
        public void SetTarget(T target) { }
        /// <summary>
        /// Tries to retrieve the target object that is referenced by the current <see cref="WeakReference`1" />
        /// object.
        /// </summary>
        /// <param name="target">
        /// When this method returns, contains the target object, if it is available. This parameter is
        /// treated as uninitialized.
        /// </param>
        /// <returns>
        /// true if the target was retrieved; otherwise, false.
        /// </returns>
        public bool TryGetTarget(out T target) { target = default(T); return default(bool); }
    }
}
namespace System.Collections
{
    /// <summary>
    /// Defines a dictionary key/value pair that can be set or retrieved.
    /// </summary>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct DictionaryEntry
    {
        /// <summary>
        /// Initializes an instance of the <see cref="DictionaryEntry" /> type with
        /// the specified key and value.
        /// </summary>
        /// <param name="key">The object defined in each key/value pair.</param>
        /// <param name="value">The definition associated with <paramref name="key" />.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key" /> is null and the .NET Framework version is 1.0 or 1.1.
        /// </exception>
        public DictionaryEntry(object key, object value) { throw new System.NotImplementedException(); }
        /// <summary>
        /// Gets or sets the key in the key/value pair.
        /// </summary>
        /// <returns>
        /// The key in the key/value pair.
        /// </returns>
        public object Key { get { return default(object); } set { } }
        /// <summary>
        /// Gets or sets the value in the key/value pair.
        /// </summary>
        /// <returns>
        /// The value in the key/value pair.
        /// </returns>
        public object Value { get { return default(object); } set { } }
    }
    /// <summary>
    /// Defines size, enumerators, and synchronization methods for all nongeneric collections.
    /// </summary>
    public partial interface ICollection : System.Collections.IEnumerable
    {
        /// <summary>
        /// Gets the number of elements contained in the <see cref="ICollection" />.
        /// </summary>
        /// <returns>
        /// The number of elements contained in the <see cref="ICollection" />.
        /// </returns>
        int Count { get; }
        /// <summary>
        /// Gets a value indicating whether access to the <see cref="ICollection" />
        /// is synchronized (thread safe).
        /// </summary>
        /// <returns>
        /// true if access to the <see cref="ICollection" /> is synchronized (thread
        /// safe); otherwise, false.
        /// </returns>
        bool IsSynchronized { get; }
        /// <summary>
        /// Gets an object that can be used to synchronize access to the <see cref="ICollection" />.
        /// </summary>
        /// <returns>
        /// An object that can be used to synchronize access to the <see cref="ICollection" />.
        /// </returns>
        object SyncRoot { get; }
        /// <summary>
        /// Copies the elements of the <see cref="ICollection" /> to an <see cref="Array" />,
        /// starting at a particular <see cref="Array" /> index.
        /// </summary>
        /// <param name="array">
        /// The one-dimensional <see cref="Array" /> that is the destination of the elements
        /// copied from <see cref="ICollection" />. The <see cref="Array" />
        /// must have zero-based indexing.
        /// </param>
        /// <param name="index">The zero-based index in <paramref name="array" /> at which copying begins.</param>
        /// <exception cref="ArgumentNullException"><paramref name="array" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than zero.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="array" /> is multidimensional.-or- The number of elements in the source
        /// <see cref="ICollection" /> is greater than the available space from <paramref name="index" />
        /// to the end of the destination <paramref name="array" />.-or-The type of the
        /// source <see cref="ICollection" /> cannot be cast automatically to the
        /// type of the destination <paramref name="array" />.
        /// </exception>
        void CopyTo(System.Array array, int index);
    }
    /// <summary>
    /// Exposes a method that compares two objects.
    /// </summary>
    public partial interface IComparer
    {
        /// <summary>
        /// Compares two objects and returns a value indicating whether one is less than, equal to, or
        /// greater than the other.
        /// </summary>
        /// <param name="x">The first object to compare.</param>
        /// <param name="y">The second object to compare.</param>
        /// <returns>
        /// A signed integer that indicates the relative values of <paramref name="x" /> and <paramref name="y" />,
        /// as shown in the following table.Value Meaning Less than zero <paramref name="x" />
        /// is less than <paramref name="y" />. Zero <paramref name="x" /> equals <paramref name="y" />.
        /// Greater than zero <paramref name="x" /> is greater than <paramref name="y" />.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// Neither <paramref name="x" /> nor <paramref name="y" /> implements the <see cref="IComparable" />
        /// interface.-or- <paramref name="x" /> and <paramref name="y" /> are of different types and
        /// neither one can handle comparisons with the other.
        /// </exception>
        int Compare(object x, object y);
    }
    /// <summary>
    /// Represents a nongeneric collection of key/value pairs.
    /// </summary>
    public partial interface IDictionary : System.Collections.ICollection, System.Collections.IEnumerable
    {
        /// <summary>
        /// Gets a value indicating whether the <see cref="IDictionary" /> object
        /// has a fixed size.
        /// </summary>
        /// <returns>
        /// true if the <see cref="IDictionary" /> object has a fixed size; otherwise,
        /// false.
        /// </returns>
        bool IsFixedSize { get; }
        /// <summary>
        /// Gets a value indicating whether the <see cref="IDictionary" /> object
        /// is read-only.
        /// </summary>
        /// <returns>
        /// true if the <see cref="IDictionary" /> object is read-only; otherwise,
        /// false.
        /// </returns>
        bool IsReadOnly { get; }
        /// <summary>
        /// Gets or sets the element with the specified key.
        /// </summary>
        /// <param name="key">The key of the element to get or set.</param>
        /// <returns>
        /// The element with the specified key, or null if the key does not exist.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="key" /> is null.</exception>
        /// <exception cref="NotSupportedException">
        /// The property is set and the <see cref="IDictionary" /> object is read-only.-or-
        /// The property is set, <paramref name="key" /> does not exist in the collection, and the
        /// <see cref="IDictionary" /> has a fixed size.
        /// </exception>
        object this[object key] { get; set; }
        /// <summary>
        /// Gets an <see cref="System.Collections.ICollection" /> object containing the keys of the
        /// <see cref="System.Collections.IDictionary" /> object.
        /// </summary>
        /// <returns>
        /// An <see cref="System.Collections.ICollection" /> object containing the keys of the
        /// <see cref="System.Collections.IDictionary" /> object.
        /// </returns>
        System.Collections.ICollection Keys { get; }
        /// <summary>
        /// Gets an <see cref="System.Collections.ICollection" /> object containing the values in the
        /// <see cref="System.Collections.IDictionary" /> object.
        /// </summary>
        /// <returns>
        /// An <see cref="System.Collections.ICollection" /> object containing the values in the
        /// <see cref="System.Collections.IDictionary" /> object.
        /// </returns>
        System.Collections.ICollection Values { get; }
        /// <summary>
        /// Adds an element with the provided key and value to the <see cref="IDictionary" />
        /// object.
        /// </summary>
        /// <param name="key">The <see cref="Object" /> to use as the key of the element to add.</param>
        /// <param name="value">The <see cref="Object" /> to use as the value of the element to add.</param>
        /// <exception cref="ArgumentNullException"><paramref name="key" /> is null.</exception>
        /// <exception cref="ArgumentException">
        /// An element with the same key already exists in the <see cref="IDictionary" />
        /// object.
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// The <see cref="IDictionary" /> is read-only.-or- The
        /// <see cref="IDictionary" /> has a fixed size.
        /// </exception>
        void Add(object key, object value);
        /// <summary>
        /// Removes all elements from the <see cref="IDictionary" /> object.
        /// </summary>
        /// <exception cref="NotSupportedException">
        /// The <see cref="IDictionary" /> object is read-only.
        /// </exception>
        void Clear();
        /// <summary>
        /// Determines whether the <see cref="IDictionary" /> object contains an
        /// element with the specified key.
        /// </summary>
        /// <param name="key">The key to locate in the <see cref="IDictionary" /> object.</param>
        /// <returns>
        /// true if the <see cref="IDictionary" /> contains an element with the key;
        /// otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="key" /> is null.</exception>
        bool Contains(object key);
        /// <summary>
        /// Returns an <see cref="IDictionaryEnumerator" /> object for the
        /// <see cref="IDictionary" /> object.
        /// </summary>
        /// <returns>
        /// An <see cref="IDictionaryEnumerator" /> object for the
        /// <see cref="IDictionary" /> object.
        /// </returns>
        new System.Collections.IDictionaryEnumerator GetEnumerator();
        /// <summary>
        /// Removes the element with the specified key from the <see cref="IDictionary" />
        /// object.
        /// </summary>
        /// <param name="key">The key of the element to remove.</param>
        /// <exception cref="ArgumentNullException"><paramref name="key" /> is null.</exception>
        /// <exception cref="NotSupportedException">
        /// The <see cref="IDictionary" /> object is read-only.-or- The
        /// <see cref="IDictionary" /> has a fixed size.
        /// </exception>
        void Remove(object key);
    }
    /// <summary>
    /// Enumerates the elements of a nongeneric dictionary.
    /// </summary>
    public partial interface IDictionaryEnumerator : System.Collections.IEnumerator
    {
        /// <summary>
        /// Gets both the key and the value of the current dictionary entry.
        /// </summary>
        /// <returns>
        /// A <see cref="System.Collections.DictionaryEntry" /> containing both the key and the value
        /// of the current dictionary entry.
        /// </returns>
        /// <exception cref="System.InvalidOperationException">
        /// The <see cref="System.Collections.IDictionaryEnumerator" /> is positioned before the first
        /// entry of the dictionary or after the last entry.
        /// </exception>
        System.Collections.DictionaryEntry Entry { get; }
        /// <summary>
        /// Gets the key of the current dictionary entry.
        /// </summary>
        /// <returns>
        /// The key of the current element of the enumeration.
        /// </returns>
        /// <exception cref="InvalidOperationException">
        /// The <see cref="IDictionaryEnumerator" /> is positioned before the first
        /// entry of the dictionary or after the last entry.
        /// </exception>
        object Key { get; }
        /// <summary>
        /// Gets the value of the current dictionary entry.
        /// </summary>
        /// <returns>
        /// The value of the current element of the enumeration.
        /// </returns>
        /// <exception cref="InvalidOperationException">
        /// The <see cref="IDictionaryEnumerator" /> is positioned before the first
        /// entry of the dictionary or after the last entry.
        /// </exception>
        object Value { get; }
    }
    /// <summary>
    /// Exposes an enumerator, which supports a simple iteration over a non-generic collection.To browse
    /// the .NET Framework source code for this type, see the Reference Source.
    /// </summary>
    public partial interface IEnumerable
    {
        /// <summary>
        /// Returns an enumerator that iterates through a collection.
        /// </summary>
        /// <returns>
        /// An <see cref="System.Collections.IEnumerator" /> object that can be used to iterate through
        /// the collection.
        /// </returns>
        System.Collections.IEnumerator GetEnumerator();
    }
    /// <summary>
    /// Supports a simple iteration over a non-generic collection.
    /// </summary>
    public partial interface IEnumerator
    {
        /// <summary>
        /// Gets the current element in the collection.
        /// </summary>
        /// <returns>
        /// The current element in the collection.
        /// </returns>
        object Current { get; }
        /// <summary>
        /// Advances the enumerator to the next element of the collection.
        /// </summary>
        /// <returns>
        /// true if the enumerator was successfully advanced to the next element; false if the enumerator
        /// has passed the end of the collection.
        /// </returns>
        /// <exception cref="InvalidOperationException">
        /// The collection was modified after the enumerator was created.
        /// </exception>
        bool MoveNext();
        /// <summary>
        /// Sets the enumerator to its initial position, which is before the first element in the collection.
        /// </summary>
        /// <exception cref="InvalidOperationException">
        /// The collection was modified after the enumerator was created.
        /// </exception>
        void Reset();
    }
    /// <summary>
    /// Defines methods to support the comparison of objects for equality.
    /// </summary>
    public partial interface IEqualityComparer
    {
        /// <summary>
        /// Determines whether the specified objects are equal.
        /// </summary>
        /// <param name="x">The first object to compare.</param>
        /// <param name="y">The second object to compare.</param>
        /// <returns>
        /// true if the specified objects are equal; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// <paramref name="x" /> and <paramref name="y" /> are of different types and neither one can
        /// handle comparisons with the other.
        /// </exception>
        bool Equals(object x, object y);
        /// <summary>
        /// Returns a hash code for the specified object.
        /// </summary>
        /// <param name="obj">The <see cref="Object" /> for which a hash code is to be returned.</param>
        /// <returns>
        /// A hash code for the specified object.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// The type of <paramref name="obj" /> is a reference type and <paramref name="obj" /> is null.
        /// </exception>
        int GetHashCode(object obj);
    }
    /// <summary>
    /// Represents a non-generic collection of objects that can be individually accessed by index.
    /// </summary>
    public partial interface IList : System.Collections.ICollection, System.Collections.IEnumerable
    {
        /// <summary>
        /// Gets a value indicating whether the <see cref="IList" /> has a fixed
        /// size.
        /// </summary>
        /// <returns>
        /// true if the <see cref="IList" /> has a fixed size; otherwise, false.
        /// </returns>
        bool IsFixedSize { get; }
        /// <summary>
        /// Gets a value indicating whether the <see cref="IList" /> is read-only.
        /// </summary>
        /// <returns>
        /// true if the <see cref="IList" /> is read-only; otherwise, false.
        /// </returns>
        bool IsReadOnly { get; }
        /// <summary>
        /// Gets or sets the element at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index of the element to get or set.</param>
        /// <returns>
        /// The element at the specified index.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is not a valid index in the <see cref="IList" />.
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// The property is set and the <see cref="IList" /> is read-only.
        /// </exception>
        object this[int index] { get; set; }
        /// <summary>
        /// Adds an item to the <see cref="IList" />.
        /// </summary>
        /// <param name="value">The object to add to the <see cref="IList" />.</param>
        /// <returns>
        /// The position into which the new element was inserted, or -1 to indicate that the item was not
        /// inserted into the collection.
        /// </returns>
        /// <exception cref="NotSupportedException">
        /// The <see cref="IList" /> is read-only.-or- The <see cref="IList" />
        /// has a fixed size.
        /// </exception>
        int Add(object value);
        /// <summary>
        /// Removes all items from the <see cref="IList" />.
        /// </summary>
        /// <exception cref="NotSupportedException">
        /// The <see cref="IList" /> is read-only.
        /// </exception>
        void Clear();
        /// <summary>
        /// Determines whether the <see cref="IList" /> contains a specific value.
        /// </summary>
        /// <param name="value">The object to locate in the <see cref="IList" />.</param>
        /// <returns>
        /// true if the <see cref="Object" /> is found in the <see cref="IList" />;
        /// otherwise, false.
        /// </returns>
        bool Contains(object value);
        /// <summary>
        /// Determines the index of a specific item in the <see cref="IList" />.
        /// </summary>
        /// <param name="value">The object to locate in the <see cref="IList" />.</param>
        /// <returns>
        /// The index of <paramref name="value" /> if found in the list; otherwise, -1.
        /// </returns>
        int IndexOf(object value);
        /// <summary>
        /// Inserts an item to the <see cref="IList" /> at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index at which <paramref name="value" /> should be inserted.</param>
        /// <param name="value">The object to insert into the <see cref="IList" />.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is not a valid index in the <see cref="IList" />.
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// The <see cref="IList" /> is read-only.-or- The <see cref="IList" />
        /// has a fixed size.
        /// </exception>
        /// <exception cref="NullReferenceException">
        /// <paramref name="value" /> is null reference in the <see cref="IList" />.
        /// </exception>
        void Insert(int index, object value);
        /// <summary>
        /// Removes the first occurrence of a specific object from the <see cref="IList" />.
        /// </summary>
        /// <param name="value">The object to remove from the <see cref="IList" />.</param>
        /// <exception cref="NotSupportedException">
        /// The <see cref="IList" /> is read-only.-or- The <see cref="IList" />
        /// has a fixed size.
        /// </exception>
        void Remove(object value);
        /// <summary>
        /// Removes the <see cref="IList" /> item at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index of the item to remove.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is not a valid index in the <see cref="IList" />.
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// The <see cref="IList" /> is read-only.-or- The <see cref="IList" />
        /// has a fixed size.
        /// </exception>
        void RemoveAt(int index);
    }
    /// <summary>
    /// Supports the structural comparison of collection objects.
    /// </summary>
    public partial interface IStructuralComparable
    {
        /// <summary>
        /// Determines whether the current collection object precedes, occurs in the same position as,
        /// or follows another object in the sort order.
        /// </summary>
        /// <param name="other">The object to compare with the current instance.</param>
        /// <param name="comparer">
        /// An object that compares members of the current collection object with the corresponding members
        /// of <paramref name="other" />.
        /// </param>
        /// <returns>
        /// An integer that indicates the relationship of the current collection object to <paramref name="other" />,
        /// as shown in the following table.Return valueDescription-1The current instance precedes
        /// <paramref name="other" />.0The current instance and <paramref name="other" /> are equal.1The
        /// current instance follows <paramref name="other" />.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// This instance and <paramref name="other" /> are not the same type.
        /// </exception>
        int CompareTo(object other, System.Collections.IComparer comparer);
    }
    /// <summary>
    /// Defines methods to support the comparison of objects for structural equality.
    /// </summary>
    public partial interface IStructuralEquatable
    {
        /// <summary>
        /// Determines whether an object is structurally equal to the current instance.
        /// </summary>
        /// <param name="other">The object to compare with the current instance.</param>
        /// <param name="comparer">
        /// An object that determines whether the current instance and <paramref name="other" /> are equal.
        /// </param>
        /// <returns>
        /// true if the two objects are equal; otherwise, false.
        /// </returns>
        bool Equals(object other, System.Collections.IEqualityComparer comparer);
        /// <summary>
        /// Returns a hash code for the current instance.
        /// </summary>
        /// <param name="comparer">An object that computes the hash code of the current object.</param>
        /// <returns>
        /// The hash code for the current instance.
        /// </returns>
        int GetHashCode(System.Collections.IEqualityComparer comparer);
    }
}
namespace System.Collections.Generic
{
    /// <summary>
    /// Defines methods to manipulate generic collections.
    /// </summary>
    /// <typeparam name="T">The type of the elements in the collection.</typeparam>
    public partial interface ICollection<T> : System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable
    {
        /// <summary>
        /// Gets the number of elements contained in the <see cref="Generic.ICollection`1" />.
        /// </summary>
        /// <returns>
        /// The number of elements contained in the <see cref="Generic.ICollection`1" />.
        /// </returns>
        int Count { get; }
        /// <summary>
        /// Gets a value indicating whether the <see cref="Generic.ICollection`1" />
        /// is read-only.
        /// </summary>
        /// <returns>
        /// true if the <see cref="Generic.ICollection`1" /> is read-only; otherwise,
        /// false.
        /// </returns>
        bool IsReadOnly { get; }
        /// <summary>
        /// Adds an item to the <see cref="Generic.ICollection`1" />.
        /// </summary>
        /// <param name="item">The object to add to the <see cref="Generic.ICollection`1" />.</param>
        /// <exception cref="NotSupportedException">
        /// The <see cref="Generic.ICollection`1" /> is read-only.
        /// </exception>
        void Add(T item);
        /// <summary>
        /// Removes all items from the <see cref="Generic.ICollection`1" />.
        /// </summary>
        /// <exception cref="NotSupportedException">
        /// The <see cref="Generic.ICollection`1" /> is read-only.
        /// </exception>
        void Clear();
        /// <summary>
        /// Determines whether the <see cref="Generic.ICollection`1" /> contains
        /// a specific value.
        /// </summary>
        /// <param name="item">The object to locate in the <see cref="Generic.ICollection`1" />.</param>
        /// <returns>
        /// true if <paramref name="item" /> is found in the <see cref="Generic.ICollection`1" />;
        /// otherwise, false.
        /// </returns>
        bool Contains(T item);
        /// <summary>
        /// Copies the elements of the <see cref="Generic.ICollection`1" /> to an
        /// <see cref="Array" />, starting at a particular <see cref="Array" /> index.
        /// </summary>
        /// <param name="array">
        /// The one-dimensional <see cref="Array" /> that is the destination of the elements
        /// copied from <see cref="Generic.ICollection`1" />. The <see cref="Array" />
        /// must have zero-based indexing.
        /// </param>
        /// <param name="arrayIndex">The zero-based index in <paramref name="array" /> at which copying begins.</param>
        /// <exception cref="ArgumentNullException"><paramref name="array" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="arrayIndex" /> is less than 0.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// The number of elements in the source <see cref="Generic.ICollection`1" />
        /// is greater than the available space from <paramref name="arrayIndex" /> to the end of the
        /// destination <paramref name="array" />.
        /// </exception>
        void CopyTo(T[] array, int arrayIndex);
        /// <summary>
        /// Removes the first occurrence of a specific object from the
        /// <see cref="Generic.ICollection`1" />.
        /// </summary>
        /// <param name="item">The object to remove from the <see cref="Generic.ICollection`1" />.</param>
        /// <returns>
        /// true if <paramref name="item" /> was successfully removed from the
        /// <see cref="Generic.ICollection`1" />; otherwise, false. This method also returns false if <paramref name="item" /> is not found
        /// in the original <see cref="Generic.ICollection`1" />.
        /// </returns>
        /// <exception cref="NotSupportedException">
        /// The <see cref="Generic.ICollection`1" /> is read-only.
        /// </exception>
        bool Remove(T item);
    }
    /// <summary>
    /// Defines a method that a type implements to compare two objects.
    /// </summary>
    /// <typeparam name="T">The type of objects to compare.</typeparam>
    public partial interface IComparer<in T>
    {
        /// <summary>
        /// Compares two objects and returns a value indicating whether one is less than, equal to, or
        /// greater than the other.
        /// </summary>
        /// <param name="x">The first object to compare.</param>
        /// <param name="y">The second object to compare.</param>
        /// <returns>
        /// A signed integer that indicates the relative values of <paramref name="x" /> and <paramref name="y" />,
        /// as shown in the following table.Value Meaning Less than zero<paramref name="x" />
        /// is less than <paramref name="y" />.Zero<paramref name="x" /> equals <paramref name="y" />.
        /// Greater than zero<paramref name="x" /> is greater than <paramref name="y" />.
        /// </returns>
        int Compare(T x, T y);
    }
    /// <summary>
    /// Represents a generic collection of key/value pairs.
    /// </summary>
    /// <typeparam name="TKey">The type of keys in the dictionary.</typeparam>
    /// <typeparam name="TValue">The type of values in the dictionary.</typeparam>
    public partial interface IDictionary<TKey, TValue> : System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.IEnumerable
    {
        /// <summary>
        /// Gets or sets the element with the specified key.
        /// </summary>
        /// <param name="key">The key of the element to get or set.</param>
        /// <returns>
        /// The element with the specified key.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="key" /> is null.</exception>
        /// <exception cref="KeyNotFoundException">
        /// The property is retrieved and <paramref name="key" /> is not found.
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// The property is set and the <see cref="Generic.IDictionary`2" /> is read-only.
        /// </exception>
        TValue this[TKey key] { get; set; }
        /// <summary>
        /// Gets an <see cref="System.Collections.Generic.ICollection`1" /> containing the keys of the
        /// <see cref="System.Collections.Generic.IDictionary`2" />.
        /// </summary>
        /// <returns>
        /// An <see cref="System.Collections.Generic.ICollection`1" /> containing the keys of the object
        /// that implements <see cref="System.Collections.Generic.IDictionary`2" />.
        /// </returns>
        System.Collections.Generic.ICollection<TKey> Keys { get; }
        /// <summary>
        /// Gets an <see cref="System.Collections.Generic.ICollection`1" /> containing the values in
        /// the <see cref="System.Collections.Generic.IDictionary`2" />.
        /// </summary>
        /// <returns>
        /// An <see cref="System.Collections.Generic.ICollection`1" /> containing the values in the
        /// object that implements <see cref="System.Collections.Generic.IDictionary`2" />.
        /// </returns>
        System.Collections.Generic.ICollection<TValue> Values { get; }
        /// <summary>
        /// Adds an element with the provided key and value to the
        /// <see cref="Generic.IDictionary`2" />.
        /// </summary>
        /// <param name="key">The object to use as the key of the element to add.</param>
        /// <param name="value">The object to use as the value of the element to add.</param>
        /// <exception cref="ArgumentNullException"><paramref name="key" /> is null.</exception>
        /// <exception cref="ArgumentException">
        /// An element with the same key already exists in the <see cref="Generic.IDictionary`2" />.
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// The <see cref="Generic.IDictionary`2" /> is read-only.
        /// </exception>
        void Add(TKey key, TValue value);
        /// <summary>
        /// Determines whether the <see cref="Generic.IDictionary`2" /> contains
        /// an element with the specified key.
        /// </summary>
        /// <param name="key">The key to locate in the <see cref="Generic.IDictionary`2" />.</param>
        /// <returns>
        /// true if the <see cref="Generic.IDictionary`2" /> contains an element
        /// with the key; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="key" /> is null.</exception>
        bool ContainsKey(TKey key);
        /// <summary>
        /// Removes the element with the specified key from the <see cref="Generic.IDictionary`2" />.
        /// </summary>
        /// <param name="key">The key of the element to remove.</param>
        /// <returns>
        /// true if the element is successfully removed; otherwise, false.  This method also returns false
        /// if <paramref name="key" /> was not found in the original <see cref="Generic.IDictionary`2" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="key" /> is null.</exception>
        /// <exception cref="NotSupportedException">
        /// The <see cref="Generic.IDictionary`2" /> is read-only.
        /// </exception>
        bool Remove(TKey key);
        /// <summary>
        /// Gets the value associated with the specified key.
        /// </summary>
        /// <param name="key">The key whose value to get.</param>
        /// <param name="value">
        /// When this method returns, the value associated with the specified key, if the key is found;
        /// otherwise, the default value for the type of the <paramref name="value" /> parameter. This
        /// parameter is passed uninitialized.
        /// </param>
        /// <returns>
        /// true if the object that implements <see cref="Generic.IDictionary`2" />
        /// contains an element with the specified key; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="key" /> is null.</exception>
        bool TryGetValue(TKey key, out TValue value);
    }
    /// <summary>
    /// Exposes the enumerator, which supports a simple iteration over a collection of a specified
    /// type.To browse the .NET Framework source code for this type, see the Reference Source.
    /// </summary>
    /// <typeparam name="T">The type of objects to enumerate.</typeparam>
    public partial interface IEnumerable<out T> : System.Collections.IEnumerable
    {
        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>
        /// An enumerator that can be used to iterate through the collection.
        /// </returns>
        new System.Collections.Generic.IEnumerator<T> GetEnumerator();
    }
    /// <summary>
    /// Supports a simple iteration over a generic collection.
    /// </summary>
    /// <typeparam name="T">The type of objects to enumerate.</typeparam>
    public partial interface IEnumerator<out T> : System.Collections.IEnumerator, System.IDisposable
    {
        /// <summary>
        /// Gets the element in the collection at the current position of the enumerator.
        /// </summary>
        /// <returns>
        /// The element in the collection at the current position of the enumerator.
        /// </returns>
        new T Current { get; }
    }
    /// <summary>
    /// Defines methods to support the comparison of objects for equality.
    /// </summary>
    /// <typeparam name="T">The type of objects to compare.</typeparam>
    public partial interface IEqualityComparer<in T>
    {
        /// <summary>
        /// Determines whether the specified objects are equal.
        /// </summary>
        /// <param name="x">The first object of type <paramref name="T" /> to compare.</param>
        /// <param name="y">The second object of type <paramref name="T" /> to compare.</param>
        /// <returns>
        /// true if the specified objects are equal; otherwise, false.
        /// </returns>
        bool Equals(T x, T y);
        /// <summary>
        /// Returns a hash code for the specified object.
        /// </summary>
        /// <param name="obj">The <see cref="Object" /> for which a hash code is to be returned.</param>
        /// <returns>
        /// A hash code for the specified object.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// The type of <paramref name="obj" /> is a reference type and <paramref name="obj" /> is null.
        /// </exception>
        int GetHashCode(T obj);
    }
    /// <summary>
    /// Represents a collection of objects that can be individually accessed by index.
    /// </summary>
    /// <typeparam name="T">The type of elements in the list.</typeparam>
    public partial interface IList<T> : System.Collections.Generic.ICollection<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable
    {
        /// <summary>
        /// Gets or sets the element at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index of the element to get or set.</param>
        /// <returns>
        /// The element at the specified index.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is not a valid index in the <see cref="Generic.IList`1" />.
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// The property is set and the <see cref="Generic.IList`1" /> is read-only.
        /// </exception>
        T this[int index] { get; set; }
        /// <summary>
        /// Determines the index of a specific item in the <see cref="Generic.IList`1" />.
        /// </summary>
        /// <param name="item">The object to locate in the <see cref="Generic.IList`1" />.</param>
        /// <returns>
        /// The index of <paramref name="item" /> if found in the list; otherwise, -1.
        /// </returns>
        int IndexOf(T item);
        /// <summary>
        /// Inserts an item to the <see cref="Generic.IList`1" /> at the specified
        /// index.
        /// </summary>
        /// <param name="index">The zero-based index at which <paramref name="item" /> should be inserted.</param>
        /// <param name="item">The object to insert into the <see cref="Generic.IList`1" />.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is not a valid index in the <see cref="Generic.IList`1" />.
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// The <see cref="Generic.IList`1" /> is read-only.
        /// </exception>
        void Insert(int index, T item);
        /// <summary>
        /// Removes the <see cref="Generic.IList`1" /> item at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index of the item to remove.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is not a valid index in the <see cref="Generic.IList`1" />.
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// The <see cref="Generic.IList`1" /> is read-only.
        /// </exception>
        void RemoveAt(int index);
    }
    /// <summary>
    /// Represents a strongly-typed, read-only collection of elements.
    /// </summary>
    /// <typeparam name="T">The type of the elements.</typeparam>
    public partial interface IReadOnlyCollection<out T> : System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable
    {
        /// <summary>
        /// Gets the number of elements in the collection.
        /// </summary>
        /// <returns>
        /// The number of elements in the collection.
        /// </returns>
        int Count { get; }
    }
    /// <summary>
    /// Represents a generic read-only collection of key/value pairs.
    /// </summary>
    /// <typeparam name="TKey">The type of keys in the read-only dictionary.</typeparam>
    /// <typeparam name="TValue">The type of values in the read-only dictionary.</typeparam>
    public partial interface IReadOnlyDictionary<TKey, TValue> : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.Generic.IReadOnlyCollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.IEnumerable
    {
        /// <summary>
        /// Gets the element that has the specified key in the read-only dictionary.
        /// </summary>
        /// <param name="key">The key to locate.</param>
        /// <returns>
        /// The element that has the specified key in the read-only dictionary.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="key" /> is null.</exception>
        /// <exception cref="KeyNotFoundException">
        /// The property is retrieved and <paramref name="key" /> is not found.
        /// </exception>
        TValue this[TKey key] { get; }
        /// <summary>
        /// Gets an enumerable collection that contains the keys in the read-only dictionary.
        /// </summary>
        /// <returns>
        /// An enumerable collection that contains the keys in the read-only dictionary.
        /// </returns>
        System.Collections.Generic.IEnumerable<TKey> Keys { get; }
        /// <summary>
        /// Gets an enumerable collection that contains the values in the read-only dictionary.
        /// </summary>
        /// <returns>
        /// An enumerable collection that contains the values in the read-only dictionary.
        /// </returns>
        System.Collections.Generic.IEnumerable<TValue> Values { get; }
        /// <summary>
        /// Determines whether the read-only dictionary contains an element that has the specified key.
        /// </summary>
        /// <param name="key">The key to locate.</param>
        /// <returns>
        /// true if the read-only dictionary contains an element that has the specified key; otherwise,
        /// false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="key" /> is null.</exception>
        bool ContainsKey(TKey key);
        /// <summary>
        /// Gets the value that is associated with the specified key.
        /// </summary>
        /// <param name="key">The key to locate.</param>
        /// <param name="value">
        /// When this method returns, the value associated with the specified key, if the key is found;
        /// otherwise, the default value for the type of the <paramref name="value" /> parameter. This
        /// parameter is passed uninitialized.
        /// </param>
        /// <returns>
        /// true if the object that implements the <see cref="Generic.IReadOnlyDictionary`2" />
        /// interface contains an element that has the specified key; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="key" /> is null.</exception>
        bool TryGetValue(TKey key, out TValue value);
    }
    /// <summary>
    /// Represents a read-only collection of elements that can be accessed by index.
    /// </summary>
    /// <typeparam name="T">The type of elements in the read-only list.</typeparam>
    public partial interface IReadOnlyList<out T> : System.Collections.Generic.IEnumerable<T>, System.Collections.Generic.IReadOnlyCollection<T>, System.Collections.IEnumerable
    {
        /// <summary>
        /// Gets the element at the specified index in the read-only list.
        /// </summary>
        /// <param name="index">The zero-based index of the element to get.</param>
        /// <returns>
        /// The element at the specified index in the read-only list.
        /// </returns>
        T this[int index] { get; }
    }
    /// <summary>
    /// Provides the base interface for the abstraction of sets.
    /// </summary>
    /// <typeparam name="T">The type of elements in the set.</typeparam>
    public partial interface ISet<T> : System.Collections.Generic.ICollection<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable
    {
        /// <summary>
        /// Adds an element to the current set and returns a value to indicate if the element was successfully
        /// added.
        /// </summary>
        /// <param name="item">The element to add to the set.</param>
        /// <returns>
        /// true if the element is added to the set; false if the element is already in the set.
        /// </returns>
        new bool Add(T item);
        /// <summary>
        /// Removes all elements in the specified collection from the current set.
        /// </summary>
        /// <param name="other">The collection of items to remove from the set.</param>
        /// <exception cref="ArgumentNullException"><paramref name="other" /> is null.</exception>
        void ExceptWith(System.Collections.Generic.IEnumerable<T> other);
        /// <summary>
        /// Modifies the current set so that it contains only elements that are also in a specified collection.
        /// </summary>
        /// <param name="other">The collection to compare to the current set.</param>
        /// <exception cref="ArgumentNullException"><paramref name="other" /> is null.</exception>
        void IntersectWith(System.Collections.Generic.IEnumerable<T> other);
        /// <summary>
        /// Determines whether the current set is a proper (strict) subset of a specified collection.
        /// </summary>
        /// <param name="other">The collection to compare to the current set.</param>
        /// <returns>
        /// true if the current set is a proper subset of <paramref name="other" />; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="other" /> is null.</exception>
        bool IsProperSubsetOf(System.Collections.Generic.IEnumerable<T> other);
        /// <summary>
        /// Determines whether the current set is a proper (strict) superset of a specified collection.
        /// </summary>
        /// <param name="other">The collection to compare to the current set.</param>
        /// <returns>
        /// true if the current set is a proper superset of <paramref name="other" />; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="other" /> is null.</exception>
        bool IsProperSupersetOf(System.Collections.Generic.IEnumerable<T> other);
        /// <summary>
        /// Determines whether a set is a subset of a specified collection.
        /// </summary>
        /// <param name="other">The collection to compare to the current set.</param>
        /// <returns>
        /// true if the current set is a subset of <paramref name="other" />; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="other" /> is null.</exception>
        bool IsSubsetOf(System.Collections.Generic.IEnumerable<T> other);
        /// <summary>
        /// Determines whether the current set is a superset of a specified collection.
        /// </summary>
        /// <param name="other">The collection to compare to the current set.</param>
        /// <returns>
        /// true if the current set is a superset of <paramref name="other" />; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="other" /> is null.</exception>
        bool IsSupersetOf(System.Collections.Generic.IEnumerable<T> other);
        /// <summary>
        /// Determines whether the current set overlaps with the specified collection.
        /// </summary>
        /// <param name="other">The collection to compare to the current set.</param>
        /// <returns>
        /// true if the current set and <paramref name="other" /> share at least one common element; otherwise,
        /// false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="other" /> is null.</exception>
        bool Overlaps(System.Collections.Generic.IEnumerable<T> other);
        /// <summary>
        /// Determines whether the current set and the specified collection contain the same elements.
        /// </summary>
        /// <param name="other">The collection to compare to the current set.</param>
        /// <returns>
        /// true if the current set is equal to <paramref name="other" />; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="other" /> is null.</exception>
        bool SetEquals(System.Collections.Generic.IEnumerable<T> other);
        /// <summary>
        /// Modifies the current set so that it contains only elements that are present either in the current
        /// set or in the specified collection, but not both.
        /// </summary>
        /// <param name="other">The collection to compare to the current set.</param>
        /// <exception cref="ArgumentNullException"><paramref name="other" /> is null.</exception>
        void SymmetricExceptWith(System.Collections.Generic.IEnumerable<T> other);
        /// <summary>
        /// Modifies the current set so that it contains all elements that are present in the current set,
        /// in the specified collection, or in both.
        /// </summary>
        /// <param name="other">The collection to compare to the current set.</param>
        /// <exception cref="ArgumentNullException"><paramref name="other" /> is null.</exception>
        void UnionWith(System.Collections.Generic.IEnumerable<T> other);
    }
    /// <summary>
    /// The exception that is thrown when the key specified for accessing an element in a collection
    /// does not match any key in the collection.
    /// </summary>
    public partial class KeyNotFoundException : System.Exception
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="KeyNotFoundException" />
        /// class using default property values.
        /// </summary>
        public KeyNotFoundException() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="KeyNotFoundException" />
        /// class with the specified error message.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        public KeyNotFoundException(string message) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="KeyNotFoundException" />
        /// class with the specified error message and a reference to the inner exception that is the
        /// cause of this exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="innerException">
        /// The exception that is the cause of the current exception. If the <paramref name="innerException" />
        /// parameter is not null, the current exception is raised in a catch block that handles the
        /// inner exception.
        /// </param>
        public KeyNotFoundException(string message, System.Exception innerException) { }
    }
    /// <summary>
    /// Defines a key/value pair that can be set or retrieved.
    /// </summary>
    /// <typeparam name="TKey">The type of the key.</typeparam>
    /// <typeparam name="TValue">The type of the value.</typeparam>
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct KeyValuePair<TKey, TValue>
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Generic.KeyValuePair`2" />
        /// structure with the specified key and value.
        /// </summary>
        /// <param name="key">The object defined in each key/value pair.</param>
        /// <param name="value">The definition associated with <paramref name="key" />.</param>
        public KeyValuePair(TKey key, TValue value) { throw new System.NotImplementedException(); }
        /// <summary>
        /// Gets the key in the key/value pair.
        /// </summary>
        /// <returns>
        /// A <paramref name="TKey" /> that is the key of the <see cref="Generic.KeyValuePair`2" />.
        /// </returns>
        public TKey Key { get { return default(TKey); } }
        /// <summary>
        /// Gets the value in the key/value pair.
        /// </summary>
        /// <returns>
        /// A <paramref name="TValue" /> that is the value of the
        /// <see cref="Generic.KeyValuePair`2" />.
        /// </returns>
        public TValue Value { get { return default(TValue); } }
        /// <summary>
        /// Returns a string representation of the <see cref="Generic.KeyValuePair`2" />,
        /// using the string representations of the key and value.
        /// </summary>
        /// <returns>
        /// A string representation of the <see cref="Generic.KeyValuePair`2" />,
        /// which includes the string representations of the key and value.
        /// </returns>
        public override string ToString() { return default(string); }
    }
}
namespace System.Collections.ObjectModel
{
    /// <summary>
    /// Provides the base class for a generic collection.
    /// </summary>
    /// <typeparam name="T">The type of elements in the collection.</typeparam>
    public partial class Collection<T> : System.Collections.Generic.ICollection<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.Generic.IList<T>, System.Collections.Generic.IReadOnlyCollection<T>, System.Collections.Generic.IReadOnlyList<T>, System.Collections.ICollection, System.Collections.IEnumerable, System.Collections.IList
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ObjectModel.Collection`1" />
        /// class that is empty.
        /// </summary>
        public Collection() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ObjectModel.Collection`1" />
        /// class as a wrapper for the specified list.
        /// </summary>
        /// <param name="list">The list that is wrapped by the new collection.</param>
        /// <exception cref="ArgumentNullException"><paramref name="list" /> is null.</exception>
        public Collection(System.Collections.Generic.IList<T> list) { }
        /// <summary>
        /// Gets the number of elements actually contained in the
        /// <see cref="ObjectModel.Collection`1" />.
        /// </summary>
        /// <returns>
        /// The number of elements actually contained in the <see cref="ObjectModel.Collection`1" />.
        /// </returns>
        public int Count { get { return default(int); } }
        /// <summary>
        /// Gets or sets the element at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index of the element to get or set.</param>
        /// <returns>
        /// The element at the specified index.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than zero.-or-<paramref name="index" /> is equal to or greater
        /// than <see cref="ObjectModel.Collection`1.Count" />.
        /// </exception>
        public T this[int index] { get { return default(T); } set { } }
        /// <summary>
        /// Gets a <see cref="Generic.IList`1" /> wrapper around the
        /// <see cref="ObjectModel.Collection`1" />.
        /// </summary>
        /// <returns>
        /// A <see cref="Generic.IList`1" /> wrapper around the
        /// <see cref="ObjectModel.Collection`1" />.
        /// </returns>
        protected System.Collections.Generic.IList<T> Items { get { return default(System.Collections.Generic.IList<T>); } }
        bool System.Collections.Generic.ICollection<T>.IsReadOnly { get { return default(bool); } }
        bool System.Collections.ICollection.IsSynchronized { get { return default(bool); } }
        object System.Collections.ICollection.SyncRoot { get { return default(object); } }
        bool System.Collections.IList.IsFixedSize { get { return default(bool); } }
        bool System.Collections.IList.IsReadOnly { get { return default(bool); } }
        object System.Collections.IList.this[int index] { get { return default(object); } set { } }
        /// <summary>
        /// Adds an object to the end of the <see cref="ObjectModel.Collection`1" />.
        /// </summary>
        /// <param name="item">
        /// The object to be added to the end of the <see cref="ObjectModel.Collection`1" />.
        /// The value can be null for reference types.
        /// </param>
        public void Add(T item) { }
        /// <summary>
        /// Removes all elements from the <see cref="ObjectModel.Collection`1" />.
        /// </summary>
        public void Clear() { }
        /// <summary>
        /// Removes all elements from the <see cref="ObjectModel.Collection`1" />.
        /// </summary>
        protected virtual void ClearItems() { }
        /// <summary>
        /// Determines whether an element is in the <see cref="ObjectModel.Collection`1" />.
        /// </summary>
        /// <param name="item">
        /// The object to locate in the <see cref="ObjectModel.Collection`1" />.
        /// The value can be null for reference types.
        /// </param>
        /// <returns>
        /// true if <paramref name="item" /> is found in the <see cref="ObjectModel.Collection`1" />;
        /// otherwise, false.
        /// </returns>
        public bool Contains(T item) { return default(bool); }
        /// <summary>
        /// Copies the entire <see cref="ObjectModel.Collection`1" /> to a compatible
        /// one-dimensional <see cref="Array" />, starting at the specified index of the target
        /// array.
        /// </summary>
        /// <param name="array">
        /// The one-dimensional <see cref="Array" /> that is the destination of the elements
        /// copied from <see cref="ObjectModel.Collection`1" />. The <see cref="Array" />
        /// must have zero-based indexing.
        /// </param>
        /// <param name="index">The zero-based index in <paramref name="array" /> at which copying begins.</param>
        /// <exception cref="ArgumentNullException"><paramref name="array" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than zero.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// The number of elements in the source <see cref="ObjectModel.Collection`1" />
        /// is greater than the available space from <paramref name="index" /> to the end of the destination
        /// <paramref name="array" />.
        /// </exception>
        public void CopyTo(T[] array, int index) { }
        /// <summary>
        /// Returns an enumerator that iterates through the <see cref="ObjectModel.Collection`1" />.
        /// </summary>
        /// <returns>
        /// An <see cref="Generic.IEnumerator`1" /> for the
        /// <see cref="ObjectModel.Collection`1" />.
        /// </returns>
        public System.Collections.Generic.IEnumerator<T> GetEnumerator() { return default(System.Collections.Generic.IEnumerator<T>); }
        /// <summary>
        /// Searches for the specified object and returns the zero-based index of the first occurrence
        /// within the entire <see cref="ObjectModel.Collection`1" />.
        /// </summary>
        /// <param name="item">
        /// The object to locate in the <see cref="Generic.List`1" />. The value
        /// can be null for reference types.
        /// </param>
        /// <returns>
        /// The zero-based index of the first occurrence of <paramref name="item" /> within the entire
        /// <see cref="ObjectModel.Collection`1" />, if found; otherwise, -1.
        /// </returns>
        public int IndexOf(T item) { return default(int); }
        /// <summary>
        /// Inserts an element into the <see cref="ObjectModel.Collection`1" /> at
        /// the specified index.
        /// </summary>
        /// <param name="index">The zero-based index at which <paramref name="item" /> should be inserted.</param>
        /// <param name="item">The object to insert. The value can be null for reference types.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than zero.-or-<paramref name="index" /> is greater than
        /// <see cref="ObjectModel.Collection`1.Count" />.
        /// </exception>
        public void Insert(int index, T item) { }
        /// <summary>
        /// Inserts an element into the <see cref="ObjectModel.Collection`1" /> at
        /// the specified index.
        /// </summary>
        /// <param name="index">The zero-based index at which <paramref name="item" /> should be inserted.</param>
        /// <param name="item">The object to insert. The value can be null for reference types.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than zero.-or-<paramref name="index" /> is greater than
        /// <see cref="ObjectModel.Collection`1.Count" />.
        /// </exception>
        protected virtual void InsertItem(int index, T item) { }
        /// <summary>
        /// Removes the first occurrence of a specific object from the
        /// <see cref="ObjectModel.Collection`1" />.
        /// </summary>
        /// <param name="item">
        /// The object to remove from the <see cref="ObjectModel.Collection`1" />.
        /// The value can be null for reference types.
        /// </param>
        /// <returns>
        /// true if <paramref name="item" /> is successfully removed; otherwise, false.  This method also
        /// returns false if <paramref name="item" /> was not found in the original
        /// <see cref="ObjectModel.Collection`1" />.
        /// </returns>
        public bool Remove(T item) { return default(bool); }
        /// <summary>
        /// Removes the element at the specified index of the <see cref="ObjectModel.Collection`1" />.
        /// </summary>
        /// <param name="index">The zero-based index of the element to remove.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than zero.-or-<paramref name="index" /> is equal to or greater
        /// than <see cref="ObjectModel.Collection`1.Count" />.
        /// </exception>
        public void RemoveAt(int index) { }
        /// <summary>
        /// Removes the element at the specified index of the <see cref="ObjectModel.Collection`1" />.
        /// </summary>
        /// <param name="index">The zero-based index of the element to remove.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than zero.-or-<paramref name="index" /> is equal to or greater
        /// than <see cref="ObjectModel.Collection`1.Count" />.
        /// </exception>
        protected virtual void RemoveItem(int index) { }
        /// <summary>
        /// Replaces the element at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index of the element to replace.</param>
        /// <param name="item">
        /// The new value for the element at the specified index. The value can be null for reference types.
        /// </param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than zero.-or-<paramref name="index" /> is greater than
        /// <see cref="ObjectModel.Collection`1.Count" />.
        /// </exception>
        protected virtual void SetItem(int index, T item) { }
        void System.Collections.ICollection.CopyTo(System.Array array, int index) { }
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { return default(System.Collections.IEnumerator); }
        int System.Collections.IList.Add(object value) { return default(int); }
        bool System.Collections.IList.Contains(object value) { return default(bool); }
        int System.Collections.IList.IndexOf(object value) { return default(int); }
        void System.Collections.IList.Insert(int index, object value) { }
        void System.Collections.IList.Remove(object value) { }
    }
    /// <summary>
    /// Provides the base class for a generic read-only collection.
    /// </summary>
    /// <typeparam name="T">The type of elements in the collection.</typeparam>
    public partial class ReadOnlyCollection<T> : System.Collections.Generic.ICollection<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.Generic.IList<T>, System.Collections.Generic.IReadOnlyCollection<T>, System.Collections.Generic.IReadOnlyList<T>, System.Collections.ICollection, System.Collections.IEnumerable, System.Collections.IList
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ObjectModel.ReadOnlyCollection`1" />
        /// class that is a read-only wrapper around the specified list.
        /// </summary>
        /// <param name="list">The list to wrap.</param>
        /// <exception cref="ArgumentNullException"><paramref name="list" /> is null.</exception>
        public ReadOnlyCollection(System.Collections.Generic.IList<T> list) { }
        /// <summary>
        /// Gets the number of elements contained in the
        /// <see cref="ObjectModel.ReadOnlyCollection`1" /> instance.
        /// </summary>
        /// <returns>
        /// The number of elements contained in the <see cref="ObjectModel.ReadOnlyCollection`1" />
        /// instance.
        /// </returns>
        public int Count { get { return default(int); } }
        /// <summary>
        /// Gets the element at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index of the element to get.</param>
        /// <returns>
        /// The element at the specified index.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than zero.-or-<paramref name="index" /> is equal to or greater
        /// than <see cref="ObjectModel.ReadOnlyCollection`1.Count" />.
        /// </exception>
        public T this[int index] { get { return default(T); } }
        /// <summary>
        /// Returns the <see cref="Generic.IList`1" /> that the
        /// <see cref="ObjectModel.ReadOnlyCollection`1" /> wraps.
        /// </summary>
        /// <returns>
        /// The <see cref="Generic.IList`1" /> that the
        /// <see cref="ObjectModel.ReadOnlyCollection`1" /> wraps.
        /// </returns>
        protected System.Collections.Generic.IList<T> Items { get { return default(System.Collections.Generic.IList<T>); } }
        bool System.Collections.Generic.ICollection<T>.IsReadOnly { get { return default(bool); } }
        T System.Collections.Generic.IList<T>.this[int index] { get { return default(T); } set { } }
        bool System.Collections.ICollection.IsSynchronized { get { return default(bool); } }
        object System.Collections.ICollection.SyncRoot { get { return default(object); } }
        bool System.Collections.IList.IsFixedSize { get { return default(bool); } }
        bool System.Collections.IList.IsReadOnly { get { return default(bool); } }
        object System.Collections.IList.this[int index] { get { return default(object); } set { } }
        /// <summary>
        /// Determines whether an element is in the <see cref="ObjectModel.ReadOnlyCollection`1" />.
        /// </summary>
        /// <param name="value">
        /// The object to locate in the <see cref="ObjectModel.ReadOnlyCollection`1" />.
        /// The value can be null for reference types.
        /// </param>
        /// <returns>
        /// true if <paramref name="value" /> is found in the
        /// <see cref="ObjectModel.ReadOnlyCollection`1" />; otherwise, false.
        /// </returns>
        public bool Contains(T value) { return default(bool); }
        /// <summary>
        /// Copies the entire <see cref="ObjectModel.ReadOnlyCollection`1" /> to
        /// a compatible one-dimensional <see cref="Array" />, starting at the specified index
        /// of the target array.
        /// </summary>
        /// <param name="array">
        /// The one-dimensional <see cref="Array" /> that is the destination of the elements
        /// copied from <see cref="ObjectModel.ReadOnlyCollection`1" />. The <see cref="Array" />
        /// must have zero-based indexing.
        /// </param>
        /// <param name="index">The zero-based index in <paramref name="array" /> at which copying begins.</param>
        /// <exception cref="ArgumentNullException"><paramref name="array" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than zero.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// The number of elements in the source <see cref="ObjectModel.ReadOnlyCollection`1" />
        /// is greater than the available space from <paramref name="index" /> to the end of the destination
        /// <paramref name="array" />.
        /// </exception>
        public void CopyTo(T[] array, int index) { }
        /// <summary>
        /// Returns an enumerator that iterates through the
        /// <see cref="ObjectModel.ReadOnlyCollection`1" />.
        /// </summary>
        /// <returns>
        /// An <see cref="Generic.IEnumerator`1" /> for the
        /// <see cref="ObjectModel.ReadOnlyCollection`1" />.
        /// </returns>
        public System.Collections.Generic.IEnumerator<T> GetEnumerator() { return default(System.Collections.Generic.IEnumerator<T>); }
        /// <summary>
        /// Searches for the specified object and returns the zero-based index of the first occurrence
        /// within the entire <see cref="ObjectModel.ReadOnlyCollection`1" />.
        /// </summary>
        /// <param name="value">
        /// The object to locate in the <see cref="Generic.List`1" />. The value
        /// can be null for reference types.
        /// </param>
        /// <returns>
        /// The zero-based index of the first occurrence of <paramref name="item" /> within the entire
        /// <see cref="ObjectModel.ReadOnlyCollection`1" />, if found; otherwise,
        /// -1.
        /// </returns>
        public int IndexOf(T value) { return default(int); }
        void System.Collections.Generic.ICollection<T>.Add(T value) { }
        void System.Collections.Generic.ICollection<T>.Clear() { }
        bool System.Collections.Generic.ICollection<T>.Remove(T value) { return default(bool); }
        void System.Collections.Generic.IList<T>.Insert(int index, T value) { }
        void System.Collections.Generic.IList<T>.RemoveAt(int index) { }
        void System.Collections.ICollection.CopyTo(System.Array array, int index) { }
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { return default(System.Collections.IEnumerator); }
        int System.Collections.IList.Add(object value) { return default(int); }
        void System.Collections.IList.Clear() { }
        bool System.Collections.IList.Contains(object value) { return default(bool); }
        int System.Collections.IList.IndexOf(object value) { return default(int); }
        void System.Collections.IList.Insert(int index, object value) { }
        void System.Collections.IList.Remove(object value) { }
        void System.Collections.IList.RemoveAt(int index) { }
    }
}
namespace System.ComponentModel
{
    /// <summary>
    /// Specifies the default value for a property.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(32767))]
    public partial class DefaultValueAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultValueAttribute" />
        /// class using a <see cref="Boolean" /> value.
        /// </summary>
        /// <param name="value">A <see cref="Boolean" /> that is the default value.</param>
        public DefaultValueAttribute(bool value) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultValueAttribute" />
        /// class using an 8-bit unsigned integer.
        /// </summary>
        /// <param name="value">An 8-bit unsigned integer that is the default value.</param>
        public DefaultValueAttribute(byte value) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultValueAttribute" />
        /// class using a Unicode character.
        /// </summary>
        /// <param name="value">A Unicode character that is the default value.</param>
        public DefaultValueAttribute(char value) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultValueAttribute" />
        /// class using a double-precision floating point number.
        /// </summary>
        /// <param name="value">A double-precision floating point number that is the default value.</param>
        public DefaultValueAttribute(double value) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultValueAttribute" />
        /// class using a 16-bit signed integer.
        /// </summary>
        /// <param name="value">A 16-bit signed integer that is the default value.</param>
        public DefaultValueAttribute(short value) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultValueAttribute" />
        /// class using a 32-bit signed integer.
        /// </summary>
        /// <param name="value">A 32-bit signed integer that is the default value.</param>
        public DefaultValueAttribute(int value) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultValueAttribute" />
        /// class using a 64-bit signed integer.
        /// </summary>
        /// <param name="value">A 64-bit signed integer that is the default value.</param>
        public DefaultValueAttribute(long value) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultValueAttribute" />
        /// class.
        /// </summary>
        /// <param name="value">An <see cref="Object" /> that represents the default value.</param>
        public DefaultValueAttribute(object value) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultValueAttribute" />
        /// class using a single-precision floating point number.
        /// </summary>
        /// <param name="value">A single-precision floating point number that is the default value.</param>
        public DefaultValueAttribute(float value) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultValueAttribute" />
        /// class using a <see cref="String" />.
        /// </summary>
        /// <param name="value">A <see cref="String" /> that is the default value.</param>
        public DefaultValueAttribute(string value) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultValueAttribute" />
        /// class, converting the specified value to the specified type, and using an invariant culture
        /// as the translation context.
        /// </summary>
        /// <param name="type">A <see cref="Type" /> that represents the type to convert the value to.</param>
        /// <param name="value">
        /// A <see cref="String" /> that can be converted to the type using the
        /// <see cref="ComponentModel.TypeConverter" /> for the type and the U.S. English culture.
        /// </param>
        public DefaultValueAttribute(System.Type type, string value) { }
        /// <summary>
        /// Gets the default value of the property this attribute is bound to.
        /// </summary>
        /// <returns>
        /// An <see cref="Object" /> that represents the default value of the property this attribute
        /// is bound to.
        /// </returns>
        public virtual object Value { get { return default(object); } }
        /// <summary>
        /// Returns whether the value of the given object is equal to the current
        /// <see cref="DefaultValueAttribute" />.
        /// </summary>
        /// <param name="obj">The object to test the value equality of.</param>
        /// <returns>
        /// true if the value of the given object is equal to that of the current; otherwise, false.
        /// </returns>
        public override bool Equals(object obj) { return default(bool); }
        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code.
        /// </returns>
        public override int GetHashCode() { return default(int); }
    }
    /// <summary>
    /// Specifies that a property or method is viewable in an editor. This class cannot be inherited.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(6140))]
    public sealed partial class EditorBrowsableAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="EditorBrowsableAttribute" />
        /// class with an <see cref="EditorBrowsableState" />.
        /// </summary>
        /// <param name="state">
        /// The <see cref="EditorBrowsableState" /> to set
        /// <see cref="State" /> to.
        /// </param>
        public EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState state) { }
        /// <summary>
        /// Gets the browsable state of the property or method.
        /// </summary>
        /// <returns>
        /// An <see cref="EditorBrowsableState" /> that is the browsable state
        /// of the property or method.
        /// </returns>
        public System.ComponentModel.EditorBrowsableState State { get { return default(System.ComponentModel.EditorBrowsableState); } }
        /// <summary>
        /// Returns whether the value of the given object is equal to the current
        /// <see cref="EditorBrowsableAttribute" />.
        /// </summary>
        /// <param name="obj">The object to test the value equality of.</param>
        /// <returns>
        /// true if the value of the given object is equal to that of the current; otherwise, false.
        /// </returns>
        public override bool Equals(object obj) { return default(bool); }
        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>
        /// A 32-bit signed integer hash code.
        /// </returns>
        public override int GetHashCode() { return default(int); }
    }
    /// <summary>
    /// Specifies the browsable state of a property or method from within an editor.
    /// </summary>
    public enum EditorBrowsableState
    {
        /// <summary>
        /// The property or method is a feature that only advanced users should see. An editor can either
        /// show or hide such properties.
        /// </summary>
        Advanced = 2,
        /// <summary>
        /// The property or method is always browsable from within an editor.
        /// </summary>
        Always = 0,
        /// <summary>
        /// The property or method is never browsable from within an editor.
        /// </summary>
        Never = 1,
    }
}
namespace System.Diagnostics
{
    /// <summary>
    /// Indicates to compilers that a method call or attribute should be ignored unless a specified
    /// conditional compilation symbol is defined.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(68), AllowMultiple = true)]
    public sealed partial class ConditionalAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ConditionalAttribute" />
        /// class.
        /// </summary>
        /// <param name="conditionString">
        /// A string that specifies the case-sensitive conditional compilation symbol that is associated
        /// with the attribute.
        /// </param>
        public ConditionalAttribute(string conditionString) { }
        /// <summary>
        /// Gets the conditional compilation symbol that is associated with the
        /// <see cref="ConditionalAttribute" /> attribute.
        /// </summary>
        /// <returns>
        /// A string that specifies the case-sensitive conditional compilation symbol that is associated
        /// with the <see cref="ConditionalAttribute" /> attribute.
        /// </returns>
        public string ConditionString { get { return default(string); } }
    }
    /// <summary>
    /// Modifies code generation for runtime just-in-time (JIT) debugging. This class cannot be inherited.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(3), AllowMultiple = false)]
    public sealed partial class DebuggableAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DebuggableAttribute" />
        /// class, using the specified debugging modes for the just-in-time (JIT) compiler.
        /// </summary>
        /// <param name="modes">
        /// A bitwise combination of the <see cref="DebuggingModes" />
        /// values specifying the debugging mode for the JIT compiler.
        /// </param>
        public DebuggableAttribute(System.Diagnostics.DebuggableAttribute.DebuggingModes modes) { }
        /// <summary>
        /// Specifies the debugging mode for the just-in-time (JIT) compiler.
        /// </summary>
        [System.FlagsAttribute]
        public enum DebuggingModes
        {
            /// <summary>
            /// Instructs the just-in-time (JIT) compiler to use its default behavior, which includes enabling
            /// optimizations, disabling Edit and Continue support, and using symbol store sequence points if present.
            /// Starting with the .NET Framework version 2.0, JIT tracking information, the Microsoft intermediate
            /// language (MSIL) offset to the native-code offset within a method, is always generated.
            /// </summary>
            Default = 1,
            /// <summary>
            /// Disable optimizations performed by the compiler to make your output file smaller, faster, and
            /// more efficient. Optimizations result in code rearrangement in the output file, which can make debugging
            /// difficult. Typically optimization should be disabled while debugging. In versions 2.0 or later,
            /// combine this value with Default (Default | DisableOptimizations) to enable JIT tracking and disable
            /// optimizations.
            /// </summary>
            DisableOptimizations = 256,
            /// <summary>
            /// Enable edit and continue. Edit and continue enables you to make changes to your source code
            /// while your program is in break mode. The ability to edit and continue is compiler dependent.
            /// </summary>
            EnableEditAndContinue = 4,
            /// <summary>
            /// Use the implicit MSIL sequence points, not the program database (PDB) sequence points. The
            /// symbolic information normally includes at least one Microsoft intermediate language (MSIL) offset for
            /// each source line. When the just-in-time (JIT) compiler is about to compile a method, it asks the profiling
            /// services for a list of MSIL offsets that should be preserved. These MSIL offsets are called
            /// sequence points.
            /// </summary>
            IgnoreSymbolStoreSequencePoints = 2,
            /// <summary>
            /// Starting with the .NET Framework version 2.0, JIT tracking information is always generated,
            /// and this flag has the same effect as <see cref="Default" />,
            /// except that it sets the <see cref="DebuggableAttribute.IsJITTrackingEnabled" />
            /// property to false. However, because JIT tracking is always enabled, the property value
            /// is ignored in version 2.0 or later. Note that, unlike the
            /// <see cref="None" /> flag, the <see cref="None" /> flag
            /// cannot be used to disable JIT optimizations.
            /// </summary>
            None = 0,
        }
    }
}
namespace System.Globalization
{
    /// <summary>
    /// Defines the formatting options that customize string parsing for some date and time parsing
    /// methods.
    /// </summary>
    [System.FlagsAttribute]
    public enum DateTimeStyles
    {
        /// <summary>
        /// Date and time are returned as a Coordinated Universal Time (UTC). If the input string denotes
        /// a local time, through a time zone specifier or <see cref="AssumeLocal" />,
        /// the date and time are converted from the local time to UTC. If the input string denotes
        /// a UTC time, through a time zone specifier or <see cref="AssumeUniversal" />,
        /// no conversion occurs. If the input string does not denote a local or UTC time, no conversion
        /// occurs and the resulting <see cref="DateTime.Kind" /> property is
        /// <see cref="DateTimeKind.Unspecified" />.
        /// </summary>
        AdjustToUniversal = 16,
        /// <summary>
        /// Extra white-space characters in the middle of the string must be ignored during parsing, except
        /// if they occur in the <see cref="DateTimeFormatInfo" /> format patterns.
        /// </summary>
        AllowInnerWhite = 4,
        /// <summary>
        /// Leading white-space characters must be ignored during parsing, except if they occur in the
        /// <see cref="DateTimeFormatInfo" /> format patterns.
        /// </summary>
        AllowLeadingWhite = 1,
        /// <summary>
        /// Trailing white-space characters must be ignored during parsing, except if they occur in the
        /// <see cref="DateTimeFormatInfo" /> format patterns.
        /// </summary>
        AllowTrailingWhite = 2,
        /// <summary>
        /// Extra white-space characters anywhere in the string must be ignored during parsing, except
        /// if they occur in the <see cref="DateTimeFormatInfo" /> format patterns.
        /// This value is a combination of the <see cref="AllowLeadingWhite" />,
        /// <see cref="AllowTrailingWhite" />, and
        /// <see cref="AllowInnerWhite" /> values.
        /// </summary>
        AllowWhiteSpaces = 7,
        /// <summary>
        /// If no time zone is specified in the parsed string, the string is assumed to denote a local
        /// time.
        /// </summary>
        AssumeLocal = 32,
        /// <summary>
        /// If no time zone is specified in the parsed string, the string is assumed to denote a UTC.
        /// </summary>
        AssumeUniversal = 64,
        /// <summary>
        /// If the parsed string contains only the time and not the date, the parsing methods assume the
        /// Gregorian date with year = 1, month = 1, and day = 1. If this value is not used, the current date
        /// is assumed.
        /// </summary>
        NoCurrentDateDefault = 8,
        /// <summary>
        /// Default formatting options must be used. This value represents the default style for the
        /// <see cref="DateTime.Parse(String)" />,
        /// <see cref="DateTime.ParseExact(String,String,IFormatProvider)" />, and <see cref="DateTime.TryParse(String,DateTime@)" /> methods.
        /// </summary>
        None = 0,
        /// <summary>
        /// The <see cref="DateTimeKind" /> field of a date is preserved when a <see cref="DateTime" />
        /// object is converted to a string using the "o" or "r" standard format specifier, and the
        /// string is then converted back to a <see cref="DateTime" /> object.
        /// </summary>
        RoundtripKind = 128,
    }
    /// <summary>
    /// Determines the styles permitted in numeric string arguments that are passed to the Parse and
    /// TryParse methods of the integral and floating-point numeric types.
    /// </summary>
    [System.FlagsAttribute]
    public enum NumberStyles
    {
        /// <summary>
        /// Indicates that the numeric string can contain a currency symbol. Valid currency symbols are
        /// determined by the <see cref="NumberFormatInfo.CurrencySymbol" /> property.
        /// </summary>
        AllowCurrencySymbol = 256,
        /// <summary>
        /// Indicates that the numeric string can have a decimal point. If the
        /// <see cref="NumberStyles" /> value includes the <see cref="AllowCurrencySymbol" />
        /// flag and the parsed string includes a currency symbol, the decimal separator character
        /// is determined by the <see cref="NumberFormatInfo.CurrencyDecimalSeparator" />
        /// property. Otherwise, the decimal separator character is determined by the
        /// <see cref="NumberFormatInfo.NumberDecimalSeparator" /> property.
        /// </summary>
        AllowDecimalPoint = 32,
        /// <summary>
        /// Indicates that the numeric string can be in exponential notation. The
        /// <see cref="AllowExponent" /> flag allows the parsed string to contain an exponent that begins with the "E" or "e" character
        /// and that is followed by an optional positive or negative sign and an integer. In other words,
        /// it successfully parses strings in the form nnnExx, nnnE+xx, and nnnE-xx. It does not allow
        /// a decimal separator or sign in the significand or mantissa; to allow these elements in the
        /// string to be parsed, use the <see cref="AllowDecimalPoint" />
        /// and <see cref="AllowLeadingSign" /> flags, or use a
        /// composite style that includes these individual flags.
        /// </summary>
        AllowExponent = 128,
        /// <summary>
        /// Indicates that the numeric string represents a hexadecimal value. Valid hexadecimal values
        /// include the numeric digits 0-9 and the hexadecimal digits A-F and a-f. Strings that are parsed
        /// using this style cannot be prefixed with "0x" or "&amp;h". A string that is parsed with the
        /// <see cref="AllowHexSpecifier" /> style will always be
        /// interpreted as a hexadecimal value. The only flags that can be combined with
        /// <see cref="AllowHexSpecifier" /> are <see cref="AllowLeadingWhite" /> and
        /// <see cref="AllowTrailingWhite" />. The <see cref="NumberStyles" /> enumeration includes a composite
        /// style, <see cref="HexNumber" />, that consists of these
        /// three flags.
        /// </summary>
        AllowHexSpecifier = 512,
        /// <summary>
        /// Indicates that the numeric string can have a leading sign. Valid leading sign characters are
        /// determined by the <see cref="NumberFormatInfo.PositiveSign" /> and
        /// <see cref="NumberFormatInfo.NegativeSign" /> properties.
        /// </summary>
        AllowLeadingSign = 4,
        /// <summary>
        /// Indicates that leading white-space characters can be present in the parsed string. Valid white-space
        /// characters have the Unicode values U+0009, U+000A, U+000B, U+000C, U+000D, and U+0020. Note
        /// that this is a subset of the characters for which the <see cref="Char.IsWhiteSpace(Char)" />
        /// method returns true.
        /// </summary>
        AllowLeadingWhite = 1,
        /// <summary>
        /// Indicates that the numeric string can have one pair of parentheses enclosing the number. The
        /// parentheses indicate that the string to be parsed represents a negative number.
        /// </summary>
        AllowParentheses = 16,
        /// <summary>
        /// Indicates that the numeric string can have group separators, such as symbols that separate
        /// hundreds from thousands. If the <see cref="NumberStyles" /> value includes
        /// the <see cref="AllowCurrencySymbol" /> flag and the string
        /// to be parsed includes a currency symbol, the valid group separator character is determined
        /// by the <see cref="NumberFormatInfo.CurrencyGroupSeparator" /> property,
        /// and the number of digits in each group is determined by the <see cref="NumberFormatInfo.CurrencyGroupSizes" />
        /// property. Otherwise, the valid group separator character is determined by the
        /// <see cref="NumberFormatInfo.NumberGroupSeparator" /> property, and the number of digits in each group is determined by the
        /// <see cref="NumberFormatInfo.NumberGroupSizes" /> property.
        /// </summary>
        AllowThousands = 64,
        /// <summary>
        /// Indicates that the numeric string can have a trailing sign. Valid trailing sign characters
        /// are determined by the <see cref="NumberFormatInfo.PositiveSign" />
        /// and <see cref="NumberFormatInfo.NegativeSign" /> properties.
        /// </summary>
        AllowTrailingSign = 8,
        /// <summary>
        /// Indicates that trailing white-space characters can be present in the parsed string. Valid
        /// white-space characters have the Unicode values U+0009, U+000A, U+000B, U+000C, U+000D, and
        /// U+0020. Note that this is a subset of the characters for which the <see cref="Char.IsWhiteSpace(Char)" />
        /// method returns true.
        /// </summary>
        AllowTrailingWhite = 2,
        /// <summary>
        /// Indicates that all styles except <see cref="AllowHexSpecifier" />
        /// are used. This is a composite number style.
        /// </summary>
        Any = 511,
        /// <summary>
        /// Indicates that all styles except <see cref="AllowExponent" />
        /// and <see cref="AllowHexSpecifier" /> are used. This
        /// is a composite number style.
        /// </summary>
        Currency = 383,
        /// <summary>
        /// Indicates that the <see cref="AllowLeadingWhite" />,
        /// <see cref="AllowTrailingWhite" />,
        /// <see cref="AllowLeadingSign" />, <see cref="AllowDecimalPoint" />, and
        /// <see cref="AllowExponent" /> styles are used. This is a composite number style.
        /// </summary>
        Float = 167,
        /// <summary>
        /// Indicates that the <see cref="AllowLeadingWhite" />,
        /// <see cref="AllowTrailingWhite" />, and
        /// <see cref="AllowHexSpecifier" /> styles are used. This is a composite number style.
        /// </summary>
        HexNumber = 515,
        /// <summary>
        /// Indicates that the <see cref="AllowLeadingWhite" />,
        /// <see cref="AllowTrailingWhite" />, and
        /// <see cref="AllowLeadingSign" /> styles are used. This is a composite number style.
        /// </summary>
        Integer = 7,
        /// <summary>
        /// Indicates that no style elements, such as leading or trailing white space, thousands separators,
        /// or a decimal separator, can be present in the parsed string. The string to be parsed must consist
        /// of integral decimal digits only.
        /// </summary>
        None = 0,
        /// <summary>
        /// Indicates that the <see cref="AllowLeadingWhite" />,
        /// <see cref="AllowTrailingWhite" />,
        /// <see cref="AllowLeadingSign" />, <see cref="AllowTrailingSign" />,
        /// <see cref="AllowDecimalPoint" />, and <see cref="AllowThousands" /> styles are used.
        /// This is a composite number style.
        /// </summary>
        Number = 111,
    }
    /// <summary>
    /// Defines the formatting options that customize string parsing for the
    /// <see cref="Overload:System.TimeSpan.ParseExact" /> and <see cref="Overload:System.TimeSpan.TryParseExact" /> methods.
    /// </summary>
    [System.FlagsAttribute]
    public enum TimeSpanStyles
    {
        /// <summary>
        /// Indicates that input is always interpreted as a negative time interval.
        /// </summary>
        AssumeNegative = 1,
        /// <summary>
        /// Indicates that input is interpreted as a negative time interval only if a negative sign is
        /// present.
        /// </summary>
        None = 0,
    }
}
namespace System.IO
{
    /// <summary>
    /// The exception that is thrown when part of a file or directory cannot be found.
    /// </summary>
    public partial class DirectoryNotFoundException : System.IO.IOException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DirectoryNotFoundException" /> class
        /// with its message string set to a system-supplied message and its HRESULT set to COR_E_DIRECTORYNOTFOUND.
        /// </summary>
        public DirectoryNotFoundException() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="DirectoryNotFoundException" /> class
        /// with its message string set to <paramref name="message" /> and its HRESULT set to COR_E_DIRECTORYNOTFOUND.
        /// </summary>
        /// <param name="message">
        /// A <see cref="String" /> that describes the error. The content of <paramref name="message" />
        /// is intended to be understood by humans. The caller of this constructor is required to ensure
        /// that this string has been localized for the current system culture.
        /// </param>
        public DirectoryNotFoundException(string message) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="DirectoryNotFoundException" /> class
        /// with a specified error message and a reference to the inner exception that is the cause of
        /// this exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="innerException">
        /// The exception that is the cause of the current exception. If the <paramref name="innerException" />
        /// parameter is not null, the current exception is raised in a catch block that handles the
        /// inner exception.
        /// </param>
        public DirectoryNotFoundException(string message, System.Exception innerException) { }
    }
    /// <summary>
    /// The exception that is thrown when a managed assembly is found but cannot be loaded.
    /// </summary>
    public partial class FileLoadException : System.IO.IOException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="FileLoadException" /> class, setting
        /// the <see cref="Exception.Message" /> property of the new instance to a system-supplied
        /// message that describes the error, such as "Could not load the specified file." This message
        /// takes into account the current system culture.
        /// </summary>
        public FileLoadException() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="FileLoadException" /> class with
        /// the specified error message.
        /// </summary>
        /// <param name="message">
        /// A <see cref="String" /> that describes the error. The content of <paramref name="message" />
        /// is intended to be understood by humans. The caller of this constructor is required to ensure
        /// that this string has been localized for the current system culture.
        /// </param>
        public FileLoadException(string message) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="FileLoadException" /> class with
        /// a specified error message and a reference to the inner exception that is the cause of this
        /// exception.
        /// </summary>
        /// <param name="message">
        /// A <see cref="String" /> that describes the error. The content of <paramref name="message" />
        /// is intended to be understood by humans. The caller of this constructor is required to ensure
        /// that this string has been localized for the current system culture.
        /// </param>
        /// <param name="inner">
        /// The exception that is the cause of the current exception. If the <paramref name="inner" />
        /// parameter is not null, the current exception is raised in a catch block that handles the inner
        /// exception.
        /// </param>
        public FileLoadException(string message, System.Exception inner) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="FileLoadException" /> class with
        /// a specified error message and the name of the file that could not be loaded.
        /// </summary>
        /// <param name="message">
        /// A <see cref="String" /> that describes the error. The content of <paramref name="message" />
        /// is intended to be understood by humans. The caller of this constructor is required to ensure
        /// that this string has been localized for the current system culture.
        /// </param>
        /// <param name="fileName">A <see cref="String" /> containing the name of the file that was not loaded.</param>
        public FileLoadException(string message, string fileName) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="FileLoadException" /> class with
        /// a specified error message, the name of the file that could not be loaded, and a reference
        /// to the inner exception that is the cause of this exception.
        /// </summary>
        /// <param name="message">
        /// A <see cref="String" /> that describes the error. The content of <paramref name="message" />
        /// is intended to be understood by humans. The caller of this constructor is required to ensure
        /// that this string has been localized for the current system culture.
        /// </param>
        /// <param name="fileName">A <see cref="String" /> containing the name of the file that was not loaded.</param>
        /// <param name="inner">
        /// The exception that is the cause of the current exception. If the <paramref name="inner" />
        /// parameter is not null, the current exception is raised in a catch block that handles the inner
        /// exception.
        /// </param>
        public FileLoadException(string message, string fileName, System.Exception inner) { }
        /// <summary>
        /// Gets the name of the file that causes this exception.
        /// </summary>
        /// <returns>
        /// A <see cref="String" /> containing the name of the file with the invalid image, or
        /// a null reference if no file name was passed to the constructor for the current instance.
        /// </returns>
        public string FileName { get { return default(string); } }
        /// <summary>
        /// Gets the error message and the name of the file that caused this exception.
        /// </summary>
        /// <returns>
        /// A string containing the error message and the name of the file that caused this exception.
        /// </returns>
        public override string Message { get { return default(string); } }
        /// <summary>
        /// Returns the fully qualified name of the current exception, and possibly the error message,
        /// the name of the inner exception, and the stack trace.
        /// </summary>
        /// <returns>
        /// A string containing the fully qualified name of this exception, and possibly the error message,
        /// the name of the inner exception, and the stack trace, depending on which
        /// <see cref="FileLoadException" /> constructor is used.
        /// </returns>
        public override string ToString() { return default(string); }
    }
    /// <summary>
    /// The exception that is thrown when an attempt to access a file that does not exist on disk fails.
    /// </summary>
    public partial class FileNotFoundException : System.IO.IOException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="FileNotFoundException" /> class with
        /// its message string set to a system-supplied message and its HRESULT set to COR_E_FILENOTFOUND.
        /// </summary>
        public FileNotFoundException() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="FileNotFoundException" /> class with
        /// its message string set to <paramref name="message" /> and its HRESULT set to COR_E_FILENOTFOUND.
        /// </summary>
        /// <param name="message">
        /// A description of the error. The content of <paramref name="message" /> is intended to be understood
        /// by humans. The caller of this constructor is required to ensure that this string has been
        /// localized for the current system culture.
        /// </param>
        public FileNotFoundException(string message) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="FileNotFoundException" /> class with
        /// a specified error message and a reference to the inner exception that is the cause of this
        /// exception.
        /// </summary>
        /// <param name="message">
        /// A description of the error. The content of <paramref name="message" /> is intended to be understood
        /// by humans. The caller of this constructor is required to ensure that this string has been
        /// localized for the current system culture.
        /// </param>
        /// <param name="innerException">
        /// The exception that is the cause of the current exception. If the <paramref name="innerException" />
        /// parameter is not null, the current exception is raised in a catch block that handles the
        /// inner exception.
        /// </param>
        public FileNotFoundException(string message, System.Exception innerException) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="FileNotFoundException" /> class with
        /// its message string set to <paramref name="message" />, specifying the file name that cannot
        /// be found, and its HRESULT set to COR_E_FILENOTFOUND.
        /// </summary>
        /// <param name="message">
        /// A description of the error. The content of <paramref name="message" /> is intended to be understood
        /// by humans. The caller of this constructor is required to ensure that this string has been
        /// localized for the current system culture.
        /// </param>
        /// <param name="fileName">The full name of the file with the invalid image.</param>
        public FileNotFoundException(string message, string fileName) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="FileNotFoundException" /> class with
        /// a specified error message and a reference to the inner exception that is the cause of this
        /// exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="fileName">The full name of the file with the invalid image.</param>
        /// <param name="innerException">
        /// The exception that is the cause of the current exception. If the <paramref name="innerException" />
        /// parameter is not null, the current exception is raised in a catch block that handles the
        /// inner exception.
        /// </param>
        public FileNotFoundException(string message, string fileName, System.Exception innerException) { }
        /// <summary>
        /// Gets the name of the file that cannot be found.
        /// </summary>
        /// <returns>
        /// The name of the file, or null if no file name was passed to the constructor for this instance.
        /// </returns>
        public string FileName { get { return default(string); } }
        /// <summary>
        /// Gets the error message that explains the reason for the exception.
        /// </summary>
        /// <returns>
        /// The error message.
        /// </returns>
        public override string Message { get { return default(string); } }
        /// <summary>
        /// Returns the fully qualified name of this exception and possibly the error message, the name
        /// of the inner exception, and the stack trace.
        /// </summary>
        /// <returns>
        /// The fully qualified name of this exception and possibly the error message, the name of the
        /// inner exception, and the stack trace.
        /// </returns>
        public override string ToString() { return default(string); }
    }
    /// <summary>
    /// The exception that is thrown when an I/O error occurs.
    /// </summary>
    public partial class IOException : System.Exception
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="IOException" /> class with its message
        /// string set to the empty string (""), its HRESULT set to COR_E_IO, and its inner exception
        /// set to a null reference.
        /// </summary>
        public IOException() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="IOException" /> class with its message
        /// string set to <paramref name="message" />, its HRESULT set to COR_E_IO, and its inner exception
        /// set to null.
        /// </summary>
        /// <param name="message">
        /// A <see cref="String" /> that describes the error. The content of <paramref name="message" />
        /// is intended to be understood by humans. The caller of this constructor is required to ensure
        /// that this string has been localized for the current system culture.
        /// </param>
        public IOException(string message) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="IOException" /> class with a specified
        /// error message and a reference to the inner exception that is the cause of this exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="innerException">
        /// The exception that is the cause of the current exception. If the <paramref name="innerException" />
        /// parameter is not null, the current exception is raised in a catch block that handles the
        /// inner exception.
        /// </param>
        public IOException(string message, System.Exception innerException) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="IOException" /> class with its message
        /// string set to <paramref name="message" /> and its HRESULT user-defined.
        /// </summary>
        /// <param name="message">
        /// A <see cref="String" /> that describes the error. The content of <paramref name="message" />
        /// is intended to be understood by humans. The caller of this constructor is required to ensure
        /// that this string has been localized for the current system culture.
        /// </param>
        /// <param name="hresult">An integer identifying the error that has occurred.</param>
        public IOException(string message, int hresult) { }
    }
    /// <summary>
    /// The exception that is thrown when a path or file name is longer than the system-defined maximum
    /// length.
    /// </summary>
    public partial class PathTooLongException : System.IO.IOException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="PathTooLongException" /> class with
        /// its HRESULT set to COR_E_PATHTOOLONG.
        /// </summary>
        public PathTooLongException() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="PathTooLongException" /> class with
        /// its message string set to <paramref name="message" /> and its HRESULT set to COR_E_PATHTOOLONG.
        /// </summary>
        /// <param name="message">
        /// A <see cref="String" /> that describes the error. The content of <paramref name="message" />
        /// is intended to be understood by humans. The caller of this constructor is required to ensure
        /// that this string has been localized for the current system culture.
        /// </param>
        public PathTooLongException(string message) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="PathTooLongException" /> class with
        /// a specified error message and a reference to the inner exception that is the cause of this
        /// exception.
        /// </summary>
        /// <param name="message">
        /// A <see cref="String" /> that describes the error. The content of <paramref name="message" />
        /// is intended to be understood by humans. The caller of this constructor is required to ensure
        /// that this string has been localized for the current system culture.
        /// </param>
        /// <param name="innerException">
        /// The exception that is the cause of the current exception. If the <paramref name="innerException" />
        /// parameter is not null, the current exception is raised in a catch block that handles the
        /// inner exception.
        /// </param>
        public PathTooLongException(string message, System.Exception innerException) { }
    }
}
namespace System.Reflection
{
    /// <summary>
    /// Defines a company name custom attribute for an assembly manifest.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(1), Inherited = false)]
    public sealed partial class AssemblyCompanyAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="AssemblyCompanyAttribute" />
        /// class.
        /// </summary>
        /// <param name="company">The company name information.</param>
        public AssemblyCompanyAttribute(string company) { }
        /// <summary>
        /// Gets company name information.
        /// </summary>
        /// <returns>
        /// A string containing the company name.
        /// </returns>
        public string Company { get { return default(string); } }
    }
    /// <summary>
    /// Specifies the build configuration, such as retail or debug, for an assembly.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(1), Inherited = false)]
    public sealed partial class AssemblyConfigurationAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="AssemblyConfigurationAttribute" />
        /// class.
        /// </summary>
        /// <param name="configuration">The assembly configuration.</param>
        public AssemblyConfigurationAttribute(string configuration) { }
        /// <summary>
        /// Gets assembly configuration information.
        /// </summary>
        /// <returns>
        /// A string containing the assembly configuration information.
        /// </returns>
        public string Configuration { get { return default(string); } }
    }
    /// <summary>
    /// Defines a copyright custom attribute for an assembly manifest.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(1), Inherited = false)]
    public sealed partial class AssemblyCopyrightAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="AssemblyCopyrightAttribute" />
        /// class.
        /// </summary>
        /// <param name="copyright">The copyright information.</param>
        public AssemblyCopyrightAttribute(string copyright) { }
        /// <summary>
        /// Gets copyright information.
        /// </summary>
        /// <returns>
        /// A string containing the copyright information.
        /// </returns>
        public string Copyright { get { return default(string); } }
    }
    /// <summary>
    /// Specifies which culture the assembly supports.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(1), Inherited = false)]
    public sealed partial class AssemblyCultureAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="AssemblyCultureAttribute" />
        /// class with the culture supported by the assembly being attributed.
        /// </summary>
        /// <param name="culture">The culture supported by the attributed assembly.</param>
        public AssemblyCultureAttribute(string culture) { }
        /// <summary>
        /// Gets the supported culture of the attributed assembly.
        /// </summary>
        /// <returns>
        /// A string containing the name of the supported culture.
        /// </returns>
        public string Culture { get { return default(string); } }
    }
    /// <summary>
    /// Defines a friendly default alias for an assembly manifest.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(1), Inherited = false)]
    public sealed partial class AssemblyDefaultAliasAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="AssemblyDefaultAliasAttribute" />
        /// class.
        /// </summary>
        /// <param name="defaultAlias">The assembly default alias information.</param>
        public AssemblyDefaultAliasAttribute(string defaultAlias) { }
        /// <summary>
        /// Gets default alias information.
        /// </summary>
        /// <returns>
        /// A string containing the default alias information.
        /// </returns>
        public string DefaultAlias { get { return default(string); } }
    }
    /// <summary>
    /// Specifies that the assembly is not fully signed when created.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(1), Inherited = false)]
    public sealed partial class AssemblyDelaySignAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="AssemblyDelaySignAttribute" />
        /// class.
        /// </summary>
        /// <param name="delaySign">true if the feature this attribute represents is activated; otherwise, false.</param>
        public AssemblyDelaySignAttribute(bool delaySign) { }
        /// <summary>
        /// Gets a value indicating the state of the attribute.
        /// </summary>
        /// <returns>
        /// true if this assembly has been built as delay-signed; otherwise, false.
        /// </returns>
        public bool DelaySign { get { return default(bool); } }
    }
    /// <summary>
    /// Provides a text description for an assembly.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(1), Inherited = false)]
    public sealed partial class AssemblyDescriptionAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="AssemblyDescriptionAttribute" />
        /// class.
        /// </summary>
        /// <param name="description">The assembly description.</param>
        public AssemblyDescriptionAttribute(string description) { }
        /// <summary>
        /// Gets assembly description information.
        /// </summary>
        /// <returns>
        /// A string containing the assembly description.
        /// </returns>
        public string Description { get { return default(string); } }
    }
    /// <summary>
    /// Instructs a compiler to use a specific version number for the Win32 file version resource.
    /// The Win32 file version is not required to be the same as the assembly's version number.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(1), Inherited = false)]
    public sealed partial class AssemblyFileVersionAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="AssemblyFileVersionAttribute" />
        /// class, specifying the file version.
        /// </summary>
        /// <param name="version">The file version.</param>
        /// <exception cref="ArgumentNullException"><paramref name="version" /> is null.</exception>
        public AssemblyFileVersionAttribute(string version) { }
        /// <summary>
        /// Gets the Win32 file version resource name.
        /// </summary>
        /// <returns>
        /// A string containing the file version resource name.
        /// </returns>
        public string Version { get { return default(string); } }
    }
    /// <summary>
    /// Specifies a bitwise combination of <see cref="AssemblyNameFlags" /> flags
    /// for an assembly, describing just-in-time (JIT) compiler options, whether the assembly is retargetable,
    /// and whether it has a full or tokenized public key. This class cannot be inherited.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(1), Inherited = false)]
    public sealed partial class AssemblyFlagsAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="AssemblyFlagsAttribute" />
        /// class with the specified combination of <see cref="AssemblyNameFlags" />
        /// flags.
        /// </summary>
        /// <param name="assemblyFlags">
        /// A bitwise combination of <see cref="AssemblyNameFlags" /> flags representing
        /// just-in-time (JIT) compiler options, longevity, whether an assembly is retargetable, and whether
        /// it has a full or tokenized public key.
        /// </param>
        public AssemblyFlagsAttribute(System.Reflection.AssemblyNameFlags assemblyFlags) { }
        /// <summary>
        /// Gets an integer value representing the combination of <see cref="AssemblyNameFlags" />
        /// flags specified when this attribute instance was created.
        /// </summary>
        /// <returns>
        /// An integer value representing a bitwise combination of <see cref="AssemblyNameFlags" />
        /// flags.
        /// </returns>
        public int AssemblyFlags { get { return default(int); } }
    }
    /// <summary>
    /// Defines additional version information for an assembly manifest.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(1), Inherited = false)]
    public sealed partial class AssemblyInformationalVersionAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="AssemblyInformationalVersionAttribute" />
        /// class.
        /// </summary>
        /// <param name="informationalVersion">The assembly version information.</param>
        public AssemblyInformationalVersionAttribute(string informationalVersion) { }
        /// <summary>
        /// Gets version information.
        /// </summary>
        /// <returns>
        /// A string containing the version information.
        /// </returns>
        public string InformationalVersion { get { return default(string); } }
    }
    /// <summary>
    /// Specifies the name of a file containing the key pair used to generate a strong name.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(1), Inherited = false)]
    public sealed partial class AssemblyKeyFileAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the AssemblyKeyFileAttribute class with the name of the file
        /// containing the key pair to generate a strong name for the assembly being attributed.
        /// </summary>
        /// <param name="keyFile">The name of the file containing the key pair.</param>
        public AssemblyKeyFileAttribute(string keyFile) { }
        /// <summary>
        /// Gets the name of the file containing the key pair used to generate a strong name for the attributed
        /// assembly.
        /// </summary>
        /// <returns>
        /// A string containing the name of the file that contains the key pair.
        /// </returns>
        public string KeyFile { get { return default(string); } }
    }
    /// <summary>
    /// Specifies the name of a key container within the CSP containing the key pair used to generate
    /// a strong name.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(1), Inherited = false)]
    public sealed partial class AssemblyKeyNameAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="AssemblyKeyNameAttribute" />
        /// class with the name of the container holding the key pair used to generate a strong name
        /// for the assembly being attributed.
        /// </summary>
        /// <param name="keyName">The name of the container containing the key pair.</param>
        public AssemblyKeyNameAttribute(string keyName) { }
        /// <summary>
        /// Gets the name of the container having the key pair that is used to generate a strong name for
        /// the attributed assembly.
        /// </summary>
        /// <returns>
        /// A string containing the name of the container that has the relevant key pair.
        /// </returns>
        public string KeyName { get { return default(string); } }
    }
    /// <summary>
    /// Defines a key/value metadata pair for the decorated assembly.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(1), AllowMultiple = true, Inherited = false)]
    public sealed partial class AssemblyMetadataAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="AssemblyMetadataAttribute" />
        /// class by using the specified metadata key and value.
        /// </summary>
        /// <param name="key">The metadata key.</param>
        /// <param name="value">The metadata value.</param>
        public AssemblyMetadataAttribute(string key, string value) { }
        /// <summary>
        /// Gets the metadata key.
        /// </summary>
        /// <returns>
        /// The metadata key.
        /// </returns>
        public string Key { get { return default(string); } }
        /// <summary>
        /// Gets the metadata value.
        /// </summary>
        /// <returns>
        /// The metadata value.
        /// </returns>
        public string Value { get { return default(string); } }
    }
    /// <summary>
    /// Provides information about an <see cref="Assembly" /> reference.
    /// </summary>
    [System.FlagsAttribute]
    public enum AssemblyNameFlags
    {
        /// <summary>
        /// Specifies that no flags are in effect.
        /// </summary>
        None = 0,
        /// <summary>
        /// Specifies that a public key is formed from the full public key rather than the public key token.
        /// </summary>
        PublicKey = 1,
        /// <summary>
        /// Specifies that the assembly can be retargeted at runtime to an assembly from a different publisher.
        /// This value supports the .NET Framework infrastructure and is not intended to be used directly
        /// from your code.
        /// </summary>
        Retargetable = 256,
    }
    /// <summary>
    /// Defines a product name custom attribute for an assembly manifest.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(1), Inherited = false)]
    public sealed partial class AssemblyProductAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="AssemblyProductAttribute" />
        /// class.
        /// </summary>
        /// <param name="product">The product name information.</param>
        public AssemblyProductAttribute(string product) { }
        /// <summary>
        /// Gets product name information.
        /// </summary>
        /// <returns>
        /// A string containing the product name.
        /// </returns>
        public string Product { get { return default(string); } }
    }
    /// <summary>
    /// Provides migration from an older, simpler strong name key to a larger key with a stronger hashing
    /// algorithm.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(1), Inherited = false, AllowMultiple = false)]
    public sealed partial class AssemblySignatureKeyAttribute : System.Attribute
    {
        /// <summary>
        /// Creates a new instance of the <see cref="AssemblySignatureKeyAttribute" />
        /// class by using the specified public key and countersignature.
        /// </summary>
        /// <param name="publicKey">The public or identity key.</param>
        /// <param name="countersignature">
        /// The countersignature, which is the signature key portion of the strong-name key.
        /// </param>
        public AssemblySignatureKeyAttribute(string publicKey, string countersignature) { }
        /// <summary>
        /// Gets the countersignature for the strong name for this assembly.
        /// </summary>
        /// <returns>
        /// The countersignature for this signature key.
        /// </returns>
        public string Countersignature { get { return default(string); } }
        /// <summary>
        /// Gets the public key for the strong name used to sign the assembly.
        /// </summary>
        /// <returns>
        /// The public key for this assembly.
        /// </returns>
        public string PublicKey { get { return default(string); } }
    }
    /// <summary>
    /// Specifies a description for an assembly.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(1), Inherited = false)]
    public sealed partial class AssemblyTitleAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="AssemblyTitleAttribute" />
        /// class.
        /// </summary>
        /// <param name="title">The assembly title.</param>
        public AssemblyTitleAttribute(string title) { }
        /// <summary>
        /// Gets assembly title information.
        /// </summary>
        /// <returns>
        /// The assembly title.
        /// </returns>
        public string Title { get { return default(string); } }
    }
    /// <summary>
    /// Defines a trademark custom attribute for an assembly manifest.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(1), Inherited = false)]
    public sealed partial class AssemblyTrademarkAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="AssemblyTrademarkAttribute" />
        /// class.
        /// </summary>
        /// <param name="trademark">The trademark information.</param>
        public AssemblyTrademarkAttribute(string trademark) { }
        /// <summary>
        /// Gets trademark information.
        /// </summary>
        /// <returns>
        /// A String containing trademark information.
        /// </returns>
        public string Trademark { get { return default(string); } }
    }
    /// <summary>
    /// Specifies the version of the assembly being attributed.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(1), Inherited = false)]
    public sealed partial class AssemblyVersionAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the AssemblyVersionAttribute class with the version number of
        /// the assembly being attributed.
        /// </summary>
        /// <param name="version">The version number of the attributed assembly.</param>
        public AssemblyVersionAttribute(string version) { }
        /// <summary>
        /// Gets the version number of the attributed assembly.
        /// </summary>
        /// <returns>
        /// A string containing the assembly version number.
        /// </returns>
        public string Version { get { return default(string); } }
    }
    /// <summary>
    /// Defines the member of a type that is the default member used by
    /// <see cref="Type.InvokeMember(String,BindingFlags,Binder,Object,Object[],ParameterModifier[],Globalization.CultureInfo,String[])" />.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(1036))]
    public sealed partial class DefaultMemberAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DefaultMemberAttribute" />
        /// class.
        /// </summary>
        /// <param name="memberName">
        /// A String containing the name of the member to invoke. This may be a constructor, method, property,
        /// or field. A suitable invocation attribute must be specified when the member is invoked. The
        /// default member of a class can be specified by passing an empty String as the name of the member.The
        /// default member of a type is marked with the DefaultMemberAttribute custom attribute or marked in COM
        /// in the usual way.
        /// </param>
        public DefaultMemberAttribute(string memberName) { }
        /// <summary>
        /// Gets the name from the attribute.
        /// </summary>
        /// <returns>
        /// A string representing the member name.
        /// </returns>
        public string MemberName { get { return default(string); } }
    }
    /// <summary>
    /// Identifies the processor and bits-per-word of the platform targeted by an executable.
    /// </summary>
    public enum ProcessorArchitecture
    {
        /// <summary>
        /// A 64-bit AMD processor only.
        /// </summary>
        Amd64 = 4,
        /// <summary>
        /// An ARM processor.
        /// </summary>
        Arm = 5,
        /// <summary>
        /// A 64-bit Intel processor only.
        /// </summary>
        IA64 = 3,
        /// <summary>
        /// Neutral with respect to processor and bits-per-word.
        /// </summary>
        MSIL = 1,
        /// <summary>
        /// An unknown or unspecified combination of processor and bits-per-word.
        /// </summary>
        None = 0,
        /// <summary>
        /// A 32-bit Intel processor, either native or in the Windows on Windows environment on a 64-bit
        /// platform (WOW64).
        /// </summary>
        X86 = 2,
    }
}
namespace System.Runtime
{
    /// <summary>
    /// [Supported in the .NET Framework 4.5.1 and later versions] Indicates whether the next blocking
    /// garbage collection compacts the large object heap (LOH).
    /// </summary>
    public enum GCLargeObjectHeapCompactionMode
    {
        /// <summary>
        /// The large object heap (LOH) will be compacted during the next blocking generation 2 garbage
        /// collection.
        /// </summary>
        CompactOnce = 2,
        /// <summary>
        /// The large object heap (LOH) is not compacted.
        /// </summary>
        Default = 1,
    }
    /// <summary>
    /// Adjusts the time that the garbage collector intrudes in your application.
    /// </summary>
    public enum GCLatencyMode
    {
        /// <summary>
        /// Disables garbage collection concurrency and reclaims objects in a batch call. This is the most
        /// intrusive mode.
        /// </summary>
        Batch = 0,
        /// <summary>
        /// Enables garbage collection concurrency and reclaims objects while the application is running.
        /// This is the default mode for garbage collection on a workstation and is less intrusive than
        /// <see cref="Batch" />. It balances responsiveness with throughput.
        /// </summary>
        Interactive = 1,
        /// <summary>
        /// Enables garbage collection that is more conservative in reclaiming objects. Full collections
        /// occur only if the system is under memory pressure, whereas generation 0 and generation 1 collections
        /// might occur more frequently
        /// </summary>
        LowLatency = 2,
        /// <summary>
        /// Enables garbage collection that tries to minimize latency over an extended period. The collector
        /// tries to perform only generation 0, generation 1, and concurrent generation 2 collections. Full
        /// blocking collections may still occur if the system is under memory pressure.
        /// </summary>
        SustainedLowLatency = 3,
    }
    /// <summary>
    /// Specifies the garbage collection settings for the current process.
    /// </summary>
    public static partial class GCSettings
    {
        /// <summary>
        /// Gets a value that indicates whether server garbage collection is enabled.
        /// </summary>
        /// <returns>
        /// true if server garbage collection is enabled; otherwise, false.
        /// </returns>
        public static bool IsServerGC { get { return default(bool); } }
        /// <summary>
        /// [Supported in the .NET Framework 4.5.1 and later versions] Gets or sets a value that indicates
        /// whether a full blocking garbage collection compacts the large object heap (LOH).
        /// </summary>
        /// <returns>
        /// One of the enumeration values that indicates whether a full blocking garbage collection compacts
        /// the LOH.
        /// </returns>
        public static System.Runtime.GCLargeObjectHeapCompactionMode LargeObjectHeapCompactionMode { get { return default(System.Runtime.GCLargeObjectHeapCompactionMode); } [System.Security.SecurityCriticalAttribute]set { } }
        /// <summary>
        /// Gets or sets the current latency mode for garbage collection.
        /// </summary>
        /// <returns>
        /// One of the enumeration values that specifies the latency mode.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The <see cref="LatencyMode" /> property is being set to an invalid
        /// value. -or-The <see cref="LatencyMode" /> property cannot be set
        /// to <see cref="GCLatencyMode.NoGCRegion" />.
        /// </exception>
        public static System.Runtime.GCLatencyMode LatencyMode { get { return default(System.Runtime.GCLatencyMode); } [System.Security.SecurityCriticalAttribute]set { } }
    }
}
namespace System.Runtime.CompilerServices
{
    /// <summary>
    /// Specifies the name of the property that accesses the attributed field.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(256))]
    public sealed partial class AccessedThroughPropertyAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the AccessedThroughPropertyAttribute class with the name of the
        /// property used to access the attributed field.
        /// </summary>
        /// <param name="propertyName">The name of the property used to access the attributed field.</param>
        public AccessedThroughPropertyAttribute(string propertyName) { }
        /// <summary>
        /// Gets the name of the property used to access the attributed field.
        /// </summary>
        /// <returns>
        /// The name of the property used to access the attributed field.
        /// </returns>
        public string PropertyName { get { return default(string); } }
    }
    /// <summary>
    /// Indicates whether a method is marked with either the Async (Visual Basic) or async (C# Reference)
    /// modifier.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(64), Inherited = false, AllowMultiple = false)]
    public sealed partial class AsyncStateMachineAttribute : System.Runtime.CompilerServices.StateMachineAttribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="AsyncStateMachineAttribute" />
        /// class.
        /// </summary>
        /// <param name="stateMachineType">
        /// The type object for the underlying state machine type that's used to implement a state machine
        /// method.
        /// </param>
        public AsyncStateMachineAttribute(System.Type stateMachineType) : base(default(System.Type)) { }
    }
    /// <summary>
    /// Allows you to obtain the full path of the source file that contains the caller. This is the
    /// file path at the time of compile.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(2048), Inherited = false)]
    public sealed partial class CallerFilePathAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="CallerFilePathAttribute" />
        /// class.
        /// </summary>
        public CallerFilePathAttribute() { }
    }
    /// <summary>
    /// Allows you to obtain the line number in the source file at which the method is called.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(2048), Inherited = false)]
    public sealed partial class CallerLineNumberAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="CallerLineNumberAttribute" />
        /// class.
        /// </summary>
        public CallerLineNumberAttribute() { }
    }
    /// <summary>
    /// Allows you to obtain the method or property name of the caller to the method.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(2048), Inherited = false)]
    public sealed partial class CallerMemberNameAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="CallerMemberNameAttribute" />
        /// class.
        /// </summary>
        public CallerMemberNameAttribute() { }
    }
    /// <summary>
    /// Controls the strictness of the code generated by the common language runtime's just-in-time
    /// (JIT) compiler.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(71))]
    public partial class CompilationRelaxationsAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the
        /// <see cref="CompilationRelaxationsAttribute" /> class with the specified compilation relaxations.
        /// </summary>
        /// <param name="relaxations">The compilation relaxations.</param>
        public CompilationRelaxationsAttribute(int relaxations) { }
        /// <summary>
        /// Gets the compilation relaxations specified when the current object was constructed.
        /// </summary>
        /// <returns>
        /// The compilation relaxations specified when the current object was constructed.Use the
        /// <see cref="CompilerServices.CompilationRelaxations" /> enumeration with the
        /// <see cref="CompilationRelaxations" />
        /// property.
        /// </returns>
        public int CompilationRelaxations { get { return default(int); } }
    }
    /// <summary>
    /// Distinguishes a compiler-generated element from a user-generated element. This class cannot
    /// be inherited.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(32767), Inherited = true)]
    public sealed partial class CompilerGeneratedAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="CompilerGeneratedAttribute" />
        /// class.
        /// </summary>
        public CompilerGeneratedAttribute() { }
    }
    /// <summary>
    /// Enables compilers to dynamically attach object fields to managed objects.
    /// </summary>
    /// <typeparam name="TKey">The reference type to which the field is attached.</typeparam>
    /// <typeparam name="TValue">The field's type. This must be a reference type.</typeparam>
    public sealed partial class ConditionalWeakTable<TKey, TValue> where TKey : class where TValue : class
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="CompilerServices.ConditionalWeakTable`2" />
        /// class.
        /// </summary>
        public ConditionalWeakTable() { }
        /// <summary>
        /// Adds a key to the table.
        /// </summary>
        /// <param name="key">
        /// The key to add. <paramref name="key" /> represents the object to which the property is attached.
        /// </param>
        /// <param name="value">The key's property value.</param>
        /// <exception cref="ArgumentNullException"><paramref name="key" /> is null.</exception>
        /// <exception cref="ArgumentException"><paramref name="key" /> already exists.</exception>
        public void Add(TKey key, TValue value) { }
        /// <summary>
        /// Ensures that resources are freed and other cleanup operations are performed when the garbage
        /// collector reclaims the <see cref="CompilerServices.ConditionalWeakTable`2" />
        /// object.
        /// </summary>
        ~ConditionalWeakTable() { }
        /// <summary>
        /// Atomically searches for a specified key in the table and returns the corresponding value. If
        /// the key does not exist in the table, the method invokes the default constructor of the class that
        /// represents the table's value to create a value that is bound to the specified key.
        /// </summary>
        /// <param name="key">
        /// The key to search for. <paramref name="key" /> represents the object to which the property
        /// is attached.
        /// </param>
        /// <returns>
        /// The value that corresponds to <paramref name="key" />, if <paramref name="key" /> already
        /// exists in the table; otherwise, a new value created by the default constructor of the class
        /// defined by the <paramref name="TValue" /> generic type parameter.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="key" /> is null.</exception>
        /// <exception cref="MissingMethodException">
        /// In the .NET for Windows Store apps or the Portable Class Library, catch the base class exception,
        /// <see cref="MissingMemberException" />, instead.The class that represents the table's
        /// value does not define a default constructor.
        /// </exception>
        public TValue GetOrCreateValue(TKey key) { return default(TValue); }
        /// <summary>
        /// Atomically searches for a specified key in the table and returns the corresponding value. If
        /// the key does not exist in the table, the method invokes a callback method to create a value that is
        /// bound to the specified key.
        /// </summary>
        /// <param name="key">
        /// The key to search for. <paramref name="key" /> represents the object to which the property
        /// is attached.
        /// </param>
        /// <param name="createValueCallback">
        /// A delegate to a method that can create a value for the given <paramref name="key" />. It has
        /// a single parameter of type <paramref name="TKey" />, and returns a value of type <paramref name="TValue" />.
        /// </param>
        /// <returns>
        /// The value attached to <paramref name="key" />, if <paramref name="key" /> already exists in
        /// the table; otherwise, the new value returned by the <paramref name="createValueCallback" />
        /// delegate.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key" /> or <paramref name="createValueCallback" /> is null.
        /// </exception>
        public TValue GetValue(TKey key, System.Runtime.CompilerServices.ConditionalWeakTable<TKey, TValue>.CreateValueCallback createValueCallback) { return default(TValue); }
        /// <summary>
        /// Removes a key and its value from the table.
        /// </summary>
        /// <param name="key">The key to remove.</param>
        /// <returns>
        /// true if the key is found and removed; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="key" /> is null.</exception>
        public bool Remove(TKey key) { return default(bool); }
        /// <summary>
        /// Gets the value of the specified key.
        /// </summary>
        /// <param name="key">The key that represents an object with an attached property.</param>
        /// <param name="value">
        /// When this method returns, contains the attached property value. If <paramref name="key" />
        /// is not found, <paramref name="value" /> contains the default value.
        /// </param>
        /// <returns>
        /// true if <paramref name="key" /> is found; otherwise, false.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="key" /> is null.</exception>
        public bool TryGetValue(TKey key, out TValue value) { value = default(TValue); return default(bool); }
        /// <summary>
        /// Represents a method that creates a non-default value to add as part of a key/value pair to
        /// a <see cref="CompilerServices.ConditionalWeakTable`2" /> object.
        /// </summary>
        /// <param name="key">The key that belongs to the value to create.</param>
        /// <returns>
        /// An instance of a reference type that represents the value to attach to the specified key.
        /// </returns>
        public delegate TValue CreateValueCallback(TKey key);
    }
    /// <summary>
    /// Defines a constant value that a compiler can persist for a field or method parameter.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(2304), Inherited = false)]
    public abstract partial class CustomConstantAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="CustomConstantAttribute" />
        /// class.
        /// </summary>
        protected CustomConstantAttribute() { }
        /// <summary>
        /// Gets the constant value stored by this attribute.
        /// </summary>
        /// <returns>
        /// The constant value stored by this attribute.
        /// </returns>
        public abstract object Value { get; }
    }
    /// <summary>
    /// Persists an 8-byte <see cref="DateTime" /> constant for a field or parameter.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(2304), Inherited = false)]
    public sealed partial class DateTimeConstantAttribute : System.Runtime.CompilerServices.CustomConstantAttribute
    {
        /// <summary>
        /// Initializes a new instance of the DateTimeConstantAttribute class with the number of 100-nanosecond
        /// ticks that represent the date and time of this instance.
        /// </summary>
        /// <param name="ticks">The number of 100-nanosecond ticks that represent the date and time of this instance.</param>
        public DateTimeConstantAttribute(long ticks) { }
        /// <summary>
        /// Gets the number of 100-nanosecond ticks that represent the date and time of this instance.
        /// </summary>
        /// <returns>
        /// The number of 100-nanosecond ticks that represent the date and time of this instance.
        /// </returns>
        public override object Value { get { return default(object); } }
    }
    /// <summary>
    /// Stores the value of a <see cref="Decimal" /> constant in metadata. This class cannot
    /// be inherited.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(2304), Inherited = false)]
    public sealed partial class DecimalConstantAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DecimalConstantAttribute" />
        /// class with the specified signed integer values.
        /// </summary>
        /// <param name="scale">
        /// The power of 10 scaling factor that indicates the number of digits to the right of the decimal
        /// point. Valid values are 0 through 28 inclusive.
        /// </param>
        /// <param name="sign">A value of 0 indicates a positive value, and a value of 1 indicates a negative value.</param>
        /// <param name="hi">
        /// The high 32 bits of the 96-bit <see cref="Value" />.
        /// </param>
        /// <param name="mid">
        /// The middle 32 bits of the 96-bit
        /// <see cref="Value" />.
        /// </param>
        /// <param name="low">
        /// The low 32 bits of the 96-bit <see cref="Value" />.
        /// </param>
        public DecimalConstantAttribute(byte scale, byte sign, int hi, int mid, int low) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="DecimalConstantAttribute" />
        /// class with the specified unsigned integer values.
        /// </summary>
        /// <param name="scale">
        /// The power of 10 scaling factor that indicates the number of digits to the right of the decimal
        /// point. Valid values are 0 through 28 inclusive.
        /// </param>
        /// <param name="sign">A value of 0 indicates a positive value, and a value of 1 indicates a negative value.</param>
        /// <param name="hi">
        /// The high 32 bits of the 96-bit <see cref="Value" />.
        /// </param>
        /// <param name="mid">
        /// The middle 32 bits of the 96-bit
        /// <see cref="Value" />.
        /// </param>
        /// <param name="low">
        /// The low 32 bits of the 96-bit <see cref="Value" />.
        /// </param>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="scale" /> &gt; 28.</exception>
        [System.CLSCompliantAttribute(false)]
        public DecimalConstantAttribute(byte scale, byte sign, uint hi, uint mid, uint low) { }
        /// <summary>
        /// Gets the decimal constant stored in this attribute.
        /// </summary>
        /// <returns>
        /// The decimal constant stored in this attribute.
        /// </returns>
        public decimal Value { get { return default(decimal); } }
    }
    /// <summary>
    /// Indicates that any private members contained in an assembly's types are not available to reflection.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(1), AllowMultiple = false, Inherited = false)]
    public sealed partial class DisablePrivateReflectionAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instances of the
        /// <see cref="DisablePrivateReflectionAttribute" /> class.
        /// </summary>
        public DisablePrivateReflectionAttribute() { }
    }
    /// <summary>
    /// Indicates that a method is an extension method, or that a class or assembly contains extension
    /// methods.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(69))]
    public sealed partial class ExtensionAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ExtensionAttribute" />
        /// class.
        /// </summary>
        public ExtensionAttribute() { }
    }
    /// <summary>
    /// Indicates that a field should be treated as containing a fixed number of elements of the specified
    /// primitive type. This class cannot be inherited.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(256), Inherited = false)]
    public sealed partial class FixedBufferAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="FixedBufferAttribute" />
        /// class.
        /// </summary>
        /// <param name="elementType">The type of the elements contained in the buffer.</param>
        /// <param name="length">The number of elements in the buffer.</param>
        public FixedBufferAttribute(System.Type elementType, int length) { }
        /// <summary>
        /// Gets the type of the elements contained in the fixed buffer.
        /// </summary>
        /// <returns>
        /// The type of the elements.
        /// </returns>
        public System.Type ElementType { get { return default(System.Type); } }
        /// <summary>
        /// Gets the number of elements in the fixed buffer.
        /// </summary>
        /// <returns>
        /// The number of elements in the fixed buffer.
        /// </returns>
        public int Length { get { return default(int); } }
    }
    /// <summary>
    /// Provides a static method to create a <see cref="FormattableString" /> object from
    /// a composite format string and its arguments.
    /// </summary>
    public static partial class FormattableStringFactory
    {
        /// <summary>
        /// Creates a <see cref="FormattableString" /> instance from a composite format string
        /// and its arguments.
        /// </summary>
        /// <param name="format">A composite format string.</param>
        /// <param name="arguments">The arguments whose string representations are to be inserted in the result string.</param>
        /// <returns>
        /// The object that represents the composite format string and its arguments.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="format" /> is null. -or-<paramref name="arguments" /> is null.
        /// </exception>
        public static System.FormattableString Create(string format, params object[] arguments) { return default(System.FormattableString); }
    }
    /// <summary>
    /// Indicates the name by which an indexer is known in programming languages that do not support
    /// indexers directly.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(128), Inherited = true)]
    public sealed partial class IndexerNameAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="IndexerNameAttribute" />
        /// class.
        /// </summary>
        /// <param name="indexerName">The name of the indexer, as shown to other languages.</param>
        public IndexerNameAttribute(string indexerName) { }
    }
    /// <summary>
    /// Specifies that types that are ordinarily visible only within the current assembly are visible
    /// to a specified assembly.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(1), AllowMultiple = true, Inherited = false)]
    public sealed partial class InternalsVisibleToAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="InternalsVisibleToAttribute" />
        /// class with the name of the specified friend assembly.
        /// </summary>
        /// <param name="assemblyName">The name of a friend assembly.</param>
        public InternalsVisibleToAttribute(string assemblyName) { }
        /// <summary>
        /// Gets the name of the friend assembly to which all types and type members that are marked with
        /// the internal keyword are to be made visible.
        /// </summary>
        /// <returns>
        /// A string that represents the name of the friend assembly.
        /// </returns>
        public string AssemblyName { get { return default(string); } }
    }
    /// <summary>
    /// Indicates that the modified type has a const modifier. This class cannot be inherited.
    /// </summary>
    public static partial class IsConst
    {
    }
    /// <summary>
    /// Defines a property for accessing the value that an object references.
    /// </summary>
    public partial interface IStrongBox
    {
        /// <summary>
        /// Gets or sets the value that an object references.
        /// </summary>
        /// <returns>
        /// The value that the object references.
        /// </returns>
        object Value { get; set; }
    }
    /// <summary>
    /// Marks a field as volatile. This class cannot be inherited.
    /// </summary>
    public static partial class IsVolatile
    {
    }
    /// <summary>
    /// Indicates whether a method in Visual Basic is marked with the Iterator modifier.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(64), Inherited = false, AllowMultiple = false)]
    public sealed partial class IteratorStateMachineAttribute : System.Runtime.CompilerServices.StateMachineAttribute
    {
        /// <summary>
        /// Initializes a new instance of the
        /// <see cref="IteratorStateMachineAttribute" /> class.
        /// </summary>
        /// <param name="stateMachineType">
        /// The type object for the underlying state machine type that's used to implement a state machine
        /// method.
        /// </param>
        public IteratorStateMachineAttribute(System.Type stateMachineType) : base(default(System.Type)) { }
    }
    /// <summary>
    /// Specifies the details of how a method is implemented. This class cannot be inherited.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(96), Inherited = false)]
    public sealed partial class MethodImplAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="MethodImplAttribute" />
        /// class with the specified <see cref="MethodImplOptions" />
        /// value.
        /// </summary>
        /// <param name="methodImplOptions">
        /// A <see cref="MethodImplOptions" /> value specifying properties
        /// of the attributed method.
        /// </param>
        public MethodImplAttribute(System.Runtime.CompilerServices.MethodImplOptions methodImplOptions) { }
        /// <summary>
        /// Gets the <see cref="MethodImplOptions" /> value describing
        /// the attributed method.
        /// </summary>
        /// <returns>
        /// The <see cref="MethodImplOptions" /> value describing the
        /// attributed method.
        /// </returns>
        public System.Runtime.CompilerServices.MethodImplOptions Value { get { return default(System.Runtime.CompilerServices.MethodImplOptions); } }
    }
    /// <summary>
    /// Defines the details of how a method is implemented.
    /// </summary>
    [System.FlagsAttribute]
    public enum MethodImplOptions
    {
        /// <summary>
        /// The method should be inlined if possible.
        /// </summary>
        AggressiveInlining = 256,
        /// <summary>
        /// The method cannot be inlined. Inlining is an optimization by which a method call is replaced
        /// with the method body.
        /// </summary>
        NoInlining = 8,
        /// <summary>
        /// The method is not optimized by the just-in-time (JIT) compiler or by native code generation
        /// (see ) when debugging possible code generation problems.
        /// </summary>
        NoOptimization = 64,
        /// <summary>
        /// The method signature is exported exactly as declared.
        /// </summary>
        PreserveSig = 128,
    }
    /// <summary>
    /// Identifies an assembly as a reference assembly, which contains metadata but no executable code.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(1), AllowMultiple = false)]
    public sealed partial class ReferenceAssemblyAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ReferenceAssemblyAttribute" />
        /// class.
        /// </summary>
        public ReferenceAssemblyAttribute() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="ReferenceAssemblyAttribute" />
        /// class by using the specified description.
        /// </summary>
        /// <param name="description">The description of the reference assembly.</param>
        public ReferenceAssemblyAttribute(string description) { }
        /// <summary>
        /// Gets the description of the reference assembly.
        /// </summary>
        /// <returns>
        /// The description of the reference assembly.
        /// </returns>
        public string Description { get { return default(string); } }
    }
    /// <summary>
    /// Specifies whether to wrap exceptions that do not derive from the <see cref="Exception" />
    /// class with a <see cref="RuntimeWrappedException" /> object.
    /// This class cannot be inherited.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(1), Inherited = false, AllowMultiple = false)]
    public sealed partial class RuntimeCompatibilityAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the
        /// <see cref="RuntimeCompatibilityAttribute" /> class.
        /// </summary>
        public RuntimeCompatibilityAttribute() { }
        /// <summary>
        /// Gets or sets a value that indicates whether to wrap exceptions that do not derive from the
        /// <see cref="Exception" /> class with a <see cref="RuntimeWrappedException" />
        /// object.
        /// </summary>
        /// <returns>
        /// true if exceptions that do not derive from the <see cref="Exception" /> class should
        /// appear wrapped with a <see cref="RuntimeWrappedException" />
        /// object; otherwise, false.
        /// </returns>
        public bool WrapNonExceptionThrows { get { return default(bool); } set { } }
    }
    /// <summary>
    /// Provides a set of static methods and properties that provide support for compilers. This class
    /// cannot be inherited.
    /// </summary>
    public static partial class RuntimeHelpers
    {
        /// <summary>
        /// Gets the offset, in bytes, to the data in the given string.
        /// </summary>
        /// <returns>
        /// The byte offset, from the start of the <see cref="String" /> object to the first
        /// character in the string.
        /// </returns>
        public static int OffsetToStringData { get { return default(int); } }
        /// <summary>
        /// Ensures that the remaining stack space is large enough to execute the average .NET Framework
        /// function.
        /// </summary>
        /// <exception cref="InsufficientExecutionStackException">
        /// The available stack space is insufficient to execute the average .NET Framework function.
        /// </exception>
        public static void EnsureSufficientExecutionStack() { }
        /// <summary>
        /// Serves as a hash function for a particular object, and is suitable for use in algorithms and
        /// data structures that use hash codes, such as a hash table.
        /// </summary>
        /// <param name="o">An object to retrieve the hash code for.</param>
        /// <returns>
        /// A hash code for the object identified by the <paramref name="o" /> parameter.
        /// </returns>
        public static int GetHashCode(object o) { return default(int); }
        /// <summary>
        /// Boxes a value type.
        /// </summary>
        /// <param name="obj">The value type to be boxed.</param>
        /// <returns>
        /// A boxed copy of <paramref name="obj" /> if it is a value class; otherwise, <paramref name="obj" />
        /// itself.
        /// </returns>
        public static object GetObjectValue(object obj) { return default(object); }
        /// <summary>
        /// Provides a fast way to initialize an array from data that is stored in a module.
        /// </summary>
        /// <param name="array">The array to be initialized.</param>
        /// <param name="fldHandle">A field handle that specifies the location of the data used to initialize the array.</param>
        public static void InitializeArray(System.Array array, System.RuntimeFieldHandle fldHandle) { }
        /// <summary>
        /// Runs a specified class constructor method.
        /// </summary>
        /// <param name="type">A type handle that specifies the class constructor method to run.</param>
        /// <exception cref="TypeInitializationException">The class initializer throws an exception.</exception>
        public static void RunClassConstructor(System.RuntimeTypeHandle type) { }
    }
    /// <summary>
    /// Allows you to determine whether a method is a state machine method.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(64), Inherited = false, AllowMultiple = false)]
    public partial class StateMachineAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="StateMachineAttribute" />
        /// class.
        /// </summary>
        /// <param name="stateMachineType">
        /// The type object for the underlying state machine type that was generated by the compiler to
        /// implement the state machine method.
        /// </param>
        public StateMachineAttribute(System.Type stateMachineType) { }
        /// <summary>
        /// Returns the type object for the underlying state machine type that was generated by the compiler
        /// to implement the state machine method.
        /// </summary>
        /// <returns>
        /// Gets the type object for the underlying state machine type that was generated by the compiler
        /// to implement the state machine method.
        /// </returns>
        public System.Type StateMachineType { get { return default(System.Type); } }
    }
    /// <summary>
    /// Holds a reference to a value.
    /// </summary>
    /// <typeparam name="T">
    /// The type of the value that the <see cref="CompilerServices.StrongBox`1" />
    /// references.
    /// </typeparam>
    public partial class StrongBox<T> : System.Runtime.CompilerServices.IStrongBox
    {
        /// <summary>
        /// Represents the value that the <see cref="CompilerServices.StrongBox`1" />
        /// references.
        /// </summary>
        public T Value;
        /// <summary>
        /// Initializes a new StrongBox which can receive a value when used in a reference call.
        /// </summary>
        public StrongBox() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="CompilerServices.StrongBox`1" />
        /// class by using the supplied value.
        /// </summary>
        /// <param name="value">
        /// A value that the <see cref="CompilerServices.StrongBox`1" /> will reference.
        /// </param>
        public StrongBox(T value) { }
        object System.Runtime.CompilerServices.IStrongBox.Value { get { return default(object); } set { } }
    }
    /// <summary>
    /// Specifies a source <see cref="Type" /> in another assembly.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(5148), Inherited = false, AllowMultiple = false)]
    public sealed partial class TypeForwardedFromAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TypeForwardedFromAttribute" />
        /// class.
        /// </summary>
        /// <param name="assemblyFullName">The source <see cref="Type" /> in another assembly.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="assemblyFullName" /> is null or empty.
        /// </exception>
        public TypeForwardedFromAttribute(string assemblyFullName) { }
        /// <summary>
        /// Gets the assembly-qualified name of the source type.
        /// </summary>
        /// <returns>
        /// The assembly-qualified name of the source type.
        /// </returns>
        public string AssemblyFullName { get { return default(string); } }
    }
    /// <summary>
    /// Specifies a destination <see cref="Type" /> in another assembly.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(1), AllowMultiple = true, Inherited = false)]
    public sealed partial class TypeForwardedToAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TypeForwardedToAttribute" />
        /// class specifying a destination <see cref="Type" />.
        /// </summary>
        /// <param name="destination">The destination <see cref="Type" /> in another assembly.</param>
        public TypeForwardedToAttribute(System.Type destination) { }
        /// <summary>
        /// Gets the destination <see cref="Type" /> in another assembly.
        /// </summary>
        /// <returns>
        /// The destination <see cref="Type" /> in another assembly.
        /// </returns>
        public System.Type Destination { get { return default(System.Type); } }
    }
    /// <summary>
    /// Specifies that a type contains an unmanaged array that might potentially overflow. This class
    /// cannot be inherited.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(8))]
    public sealed partial class UnsafeValueTypeAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="UnsafeValueTypeAttribute" />
        /// class.
        /// </summary>
        public UnsafeValueTypeAttribute() { }
    }
}
namespace System.Runtime.ExceptionServices
{
    /// <summary>
    /// Represents an exception whose state is captured at a certain point in code.
    /// </summary>
    public sealed partial class ExceptionDispatchInfo
    {
        internal ExceptionDispatchInfo() { }
        /// <summary>
        /// Gets the exception that is represented by the current instance.
        /// </summary>
        /// <returns>
        /// The exception that is represented by the current instance.
        /// </returns>
        public System.Exception SourceException { get { return default(System.Exception); } }
        /// <summary>
        /// Creates an <see cref="ExceptionDispatchInfo" /> object
        /// that represents the specified exception at the current point in code.
        /// </summary>
        /// <param name="source">The exception whose state is captured, and which is represented by the returned object.</param>
        /// <returns>
        /// An object that represents the specified exception at the current point in code.
        /// </returns>
        /// <exception cref="ArgumentException"><paramref name="source" /> is null.</exception>
        public static System.Runtime.ExceptionServices.ExceptionDispatchInfo Capture(System.Exception source) { return default(System.Runtime.ExceptionServices.ExceptionDispatchInfo); }
        /// <summary>
        /// Throws the exception that is represented by the current
        /// <see cref="ExceptionDispatchInfo" /> object, after restoring the state that was saved when the exception was captured.
        /// </summary>
        public void Throw() { }
    }
}
namespace System.Runtime.InteropServices
{
    /// <summary>
    /// Dictates which character set marshaled strings should use.
    /// </summary>
    public enum CharSet
    {
        /// <summary>
        /// Marshal strings as multiple-byte character strings.
        /// </summary>
        Ansi = 2,
        /// <summary>
        /// Marshal strings as Unicode 2-byte characters.
        /// </summary>
        Unicode = 3,
    }
    /// <summary>
    /// Controls accessibility of an individual managed type or member, or of all types within an assembly,
    /// to COM.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(5597), Inherited = false)]
    public sealed partial class ComVisibleAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the ComVisibleAttribute class.
        /// </summary>
        /// <param name="visibility">
        /// true to indicate that the type is visible to COM; otherwise, false. The default is true.
        /// </param>
        public ComVisibleAttribute(bool visibility) { }
        /// <summary>
        /// Gets a value that indicates whether the COM type is visible.
        /// </summary>
        /// <returns>
        /// true if the type is visible; otherwise, false. The default value is true.
        /// </returns>
        public bool Value { get { return default(bool); } }
    }
    /// <summary>
    /// Indicates the physical position of fields within the unmanaged representation of a class or
    /// structure.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(256), Inherited = false)]
    public sealed partial class FieldOffsetAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="FieldOffsetAttribute" />
        /// class with the offset in the structure to the beginning of the field.
        /// </summary>
        /// <param name="offset">The offset in bytes from the beginning of the structure to the beginning of the field.</param>
        public FieldOffsetAttribute(int offset) { }
        /// <summary>
        /// Gets the offset from the beginning of the structure to the beginning of the field.
        /// </summary>
        /// <returns>
        /// The offset from the beginning of the structure to the beginning of the field.
        /// </returns>
        public int Value { get { return default(int); } }
    }
    /// <summary>
    /// Controls the layout of an object when exported to unmanaged code.
    /// </summary>
    public enum LayoutKind
    {
        /// <summary>
        /// The runtime automatically chooses an appropriate layout for the members of an object in unmanaged
        /// memory. Objects defined with this enumeration member cannot be exposed outside of managed code.
        /// Attempting to do so generates an exception.
        /// </summary>
        Auto = 3,
        /// <summary>
        /// The precise position of each member of an object in unmanaged memory is explicitly controlled,
        /// subject to the setting of the <see cref="StructLayoutAttribute.Pack" />
        /// field. Each member must use the <see cref="FieldOffsetAttribute" />
        /// to indicate the position of that field within the type.
        /// </summary>
        Explicit = 2,
        /// <summary>
        /// The members of the object are laid out sequentially, in the order in which they appear when
        /// exported to unmanaged memory. The members are laid out according to the packing specified
        /// in <see cref="StructLayoutAttribute.Pack" />, and can be
        /// noncontiguous.
        /// </summary>
        Sequential = 0,
    }
    /// <summary>
    /// Indicates that data should be marshaled from callee back to caller.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(2048), Inherited = false)]
    public sealed partial class OutAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="OutAttribute" />
        /// class.
        /// </summary>
        public OutAttribute() { }
    }
    /// <summary>
    /// Lets you control the physical layout of the data fields of a class or structure in memory.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(12), Inherited = false)]
    public sealed partial class StructLayoutAttribute : System.Attribute
    {
        /// <summary>
        /// Indicates whether string data fields within the class should be marshaled as LPWSTR or LPSTR
        /// by default.
        /// </summary>
        public System.Runtime.InteropServices.CharSet CharSet;
        /// <summary>
        /// Controls the alignment of data fields of a class or structure in memory.
        /// </summary>
        public int Pack;
        /// <summary>
        /// Indicates the absolute size of the class or structure.
        /// </summary>
        public int Size;
        /// <summary>
        /// Initalizes a new instance of the <see cref="StructLayoutAttribute" />
        /// class with the specified <see cref="LayoutKind" /> enumeration
        /// member.
        /// </summary>
        /// <param name="layoutKind">
        /// One of the enumeration values that specifes how the class or structure should be arranged.
        /// </param>
        public StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind layoutKind) { }
        /// <summary>
        /// Gets the <see cref="LayoutKind" /> value that specifies how
        /// the class or structure is arranged.
        /// </summary>
        /// <returns>
        /// One of the enumeration values that specifies how the class or structure is arranged.
        /// </returns>
        public System.Runtime.InteropServices.LayoutKind Value { get { return default(System.Runtime.InteropServices.LayoutKind); } }
    }
}
namespace System.Runtime.Versioning
{
    /// <summary>
    /// Identifies the version of the .NET Framework that a particular assembly was compiled against.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(1), AllowMultiple = false, Inherited = false)]
    public sealed partial class TargetFrameworkAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes an instance of the <see cref="TargetFrameworkAttribute" />
        /// class by specifying the .NET Framework version against which an assembly was built.
        /// </summary>
        /// <param name="frameworkName">The version of the .NET Framework against which the assembly was built.</param>
        /// <exception cref="ArgumentNullException"><paramref name="frameworkName" /> is null.</exception>
        public TargetFrameworkAttribute(string frameworkName) { }
        /// <summary>
        /// Gets the display name of the .NET Framework version against which an assembly was built.
        /// </summary>
        /// <returns>
        /// The display name of the .NET Framework version.
        /// </returns>
        public string FrameworkDisplayName { get { return default(string); } set { } }
        /// <summary>
        /// Gets the name of the .NET Framework version against which a particular assembly was compiled.
        /// </summary>
        /// <returns>
        /// The name of the .NET Framework version with which the assembly was compiled.
        /// </returns>
        public string FrameworkName { get { return default(string); } }
    }
}
namespace System.Security
{
    /// <summary>
    /// Allows an assembly to be called by partially trusted code. Without this declaration, only fully
    /// trusted callers are able to use the assembly. This class cannot be inherited.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(1), AllowMultiple = false, Inherited = false)]
    public sealed partial class AllowPartiallyTrustedCallersAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="AllowPartiallyTrustedCallersAttribute" />
        /// class.
        /// </summary>
        public AllowPartiallyTrustedCallersAttribute() { }
    }
    /// <summary>
    /// Specifies that code or an assembly performs security-critical operations.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(5501), AllowMultiple = false, Inherited = false)]
    public sealed partial class SecurityCriticalAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SecurityCriticalAttribute" />
        /// class.
        /// </summary>
        public SecurityCriticalAttribute() { }
    }
    /// <summary>
    /// The exception that is thrown when a security error is detected.
    /// </summary>
    public partial class SecurityException : System.Exception
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SecurityException" /> class
        /// with default properties.
        /// </summary>
        public SecurityException() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="SecurityException" /> class
        /// with a specified error message.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        public SecurityException(string message) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="SecurityException" /> class
        /// with a specified error message and a reference to the inner exception that is the cause of
        /// this exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="inner">
        /// The exception that is the cause of the current exception. If the <paramref name="inner" />
        /// parameter is not null, the current exception is raised in a catch block that handles the inner
        /// exception.
        /// </param>
        public SecurityException(string message, System.Exception inner) { }
        /// <summary>
        /// Returns a representation of the current <see cref="SecurityException" />.
        /// </summary>
        /// <returns>
        /// A string representation of the current <see cref="SecurityException" />.
        /// </returns>
        public override string ToString() { return default(string); }
    }
    /// <summary>
    /// Identifies types or members as security-critical and safely accessible by transparent code.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(5500), AllowMultiple = false, Inherited = false)]
    public sealed partial class SecuritySafeCriticalAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SecuritySafeCriticalAttribute" />
        /// class.
        /// </summary>
        public SecuritySafeCriticalAttribute() { }
    }
    /// <summary>
    /// Specifies that an assembly cannot cause an elevation of privilege.
    /// </summary>
    [System.AttributeUsageAttribute((System.AttributeTargets)(1), AllowMultiple = false, Inherited = false)]
    public sealed partial class SecurityTransparentAttribute : System.Attribute
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SecurityTransparentAttribute" />
        /// class.
        /// </summary>
        public SecurityTransparentAttribute() { }
    }
    /// <summary>
    /// The exception that is thrown when the security policy requires code to be type safe and the
    /// verification process is unable to verify that the code is type safe.
    /// </summary>
    public partial class VerificationException : System.Exception
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="VerificationException" /> class
        /// with default properties.
        /// </summary>
        public VerificationException() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="VerificationException" /> class
        /// with an explanatory message.
        /// </summary>
        /// <param name="message">A message indicating the reason the exception occurred.</param>
        public VerificationException(string message) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="VerificationException" /> class
        /// with a specified error message and a reference to the inner exception that is the cause of
        /// this exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="innerException">
        /// The exception that is the cause of the current exception. If the <paramref name="innerException" />
        /// parameter is not null, the current exception is raised in a catch block that handles the
        /// inner exception.
        /// </param>
        public VerificationException(string message, System.Exception innerException) { }
    }
}
namespace System.Text
{
    /// <summary>
    /// Represents a mutable string of characters. This class cannot be inherited.To browse the .NET
    /// Framework source code for this type, see the Reference Source.
    /// </summary>
    public sealed partial class StringBuilder
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="StringBuilder" /> class.
        /// </summary>
        public StringBuilder() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="StringBuilder" /> class using the
        /// specified capacity.
        /// </summary>
        /// <param name="capacity">The suggested starting size of this instance.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="capacity" /> is less than zero.
        /// </exception>
        public StringBuilder(int capacity) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="StringBuilder" /> class that starts
        /// with a specified capacity and can grow to a specified maximum.
        /// </summary>
        /// <param name="capacity">The suggested starting size of the <see cref="StringBuilder" />.</param>
        /// <param name="maxCapacity">The maximum number of characters the current string can contain.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="maxCapacity" /> is less than one, <paramref name="capacity" /> is less than
        /// zero, or <paramref name="capacity" /> is greater than <paramref name="maxCapacity" />.
        /// </exception>
        public StringBuilder(int capacity, int maxCapacity) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="StringBuilder" /> class using the
        /// specified string.
        /// </summary>
        /// <param name="value">
        /// The string used to initialize the value of the instance. If <paramref name="value" /> is null,
        /// the new <see cref="StringBuilder" /> will contain the empty string (that is,
        /// it contains <see cref="String.Empty" />).
        /// </param>
        public StringBuilder(string value) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="StringBuilder" /> class using the
        /// specified string and capacity.
        /// </summary>
        /// <param name="value">
        /// The string used to initialize the value of the instance. If <paramref name="value" /> is null,
        /// the new <see cref="StringBuilder" /> will contain the empty string (that is,
        /// it contains <see cref="String.Empty" />).
        /// </param>
        /// <param name="capacity">The suggested starting size of the <see cref="StringBuilder" />.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="capacity" /> is less than zero.
        /// </exception>
        public StringBuilder(string value, int capacity) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="StringBuilder" /> class from the
        /// specified substring and capacity.
        /// </summary>
        /// <param name="value">
        /// The string that contains the substring used to initialize the value of this instance. If
        /// <paramref name="value" /> is null, the new <see cref="StringBuilder" /> will contain the
        /// empty string (that is, it contains <see cref="String.Empty" />).
        /// </param>
        /// <param name="startIndex">The position within <paramref name="value" /> where the substring begins.</param>
        /// <param name="length">The number of characters in the substring.</param>
        /// <param name="capacity">The suggested starting size of the <see cref="StringBuilder" />.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="capacity" /> is less than zero.-or- <paramref name="startIndex" /> plus
        /// <paramref name="length" /> is not a position within <paramref name="value" />.
        /// </exception>
        public StringBuilder(string value, int startIndex, int length, int capacity) { }
        /// <summary>
        /// Gets or sets the maximum number of characters that can be contained in the memory allocated
        /// by the current instance.
        /// </summary>
        /// <returns>
        /// The maximum number of characters that can be contained in the memory allocated by the current
        /// instance. Its value can range from <see cref="Length" /> to
        /// <see cref="MaxCapacity" />.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The value specified for a set operation is less than the current length of this instance.-or-
        /// The value specified for a set operation is greater than the maximum capacity.
        /// </exception>
        public int Capacity { get { return default(int); } set { } }
        /// <summary>
        /// Gets or sets the character at the specified character position in this instance.
        /// </summary>
        /// <param name="index">The position of the character.</param>
        /// <returns>
        /// The Unicode character at position <paramref name="index" />.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is outside the bounds of this instance while setting a character.
        /// </exception>
        /// <exception cref="IndexOutOfRangeException">
        /// <paramref name="index" /> is outside the bounds of this instance while getting a character.
        /// </exception>
        [System.Runtime.CompilerServices.IndexerName("Chars")]
        public char this[int index] { get { return default(char); } set { } }
        /// <summary>
        /// Gets or sets the length of the current <see cref="StringBuilder" /> object.
        /// </summary>
        /// <returns>
        /// The length of this instance.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The value specified for a set operation is less than zero or greater than
        /// <see cref="MaxCapacity" />.
        /// </exception>
        public int Length { get { return default(int); } set { } }
        /// <summary>
        /// Gets the maximum capacity of this instance.
        /// </summary>
        /// <returns>
        /// The maximum number of characters this instance can hold.
        /// </returns>
        public int MaxCapacity { get { return default(int); } }
        /// <summary>
        /// Appends the string representation of a specified Boolean value to this instance.
        /// </summary>
        /// <param name="value">The Boolean value to append.</param>
        /// <returns>
        /// A reference to this instance after the append operation has completed.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// Enlarging the value of this instance would exceed <see cref="MaxCapacity" />.
        /// </exception>
        public System.Text.StringBuilder Append(bool value) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Appends the string representation of a specified 8-bit unsigned integer to this instance.
        /// </summary>
        /// <param name="value">The value to append.</param>
        /// <returns>
        /// A reference to this instance after the append operation has completed.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// Enlarging the value of this instance would exceed <see cref="MaxCapacity" />.
        /// </exception>
        public System.Text.StringBuilder Append(byte value) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Appends the string representation of a specified <see cref="Char" /> object to this
        /// instance.
        /// </summary>
        /// <param name="value">The UTF-16-encoded code unit to append.</param>
        /// <returns>
        /// A reference to this instance after the append operation has completed.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// Enlarging the value of this instance would exceed <see cref="MaxCapacity" />.
        /// </exception>
        public System.Text.StringBuilder Append(char value) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Appends an array of Unicode characters starting at a specified address to this instance.
        /// </summary>
        /// <param name="value">A pointer to an array of characters.</param>
        /// <param name="valueCount">The number of characters in the array.</param>
        /// <returns>
        /// A reference to this instance after the append operation has completed.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="valueCount" /> is less than zero. -or-Enlarging the value of this instance
        /// would exceed <see cref="MaxCapacity" />.
        /// </exception>
        /// <exception cref="NullReferenceException"><paramref name="value" /> is a null pointer.</exception>
        [System.CLSCompliantAttribute(false)]
        [System.Security.SecurityCriticalAttribute]
        public unsafe System.Text.StringBuilder Append(char* value, int valueCount) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Appends a specified number of copies of the string representation of a Unicode character to
        /// this instance.
        /// </summary>
        /// <param name="value">The character to append.</param>
        /// <param name="repeatCount">The number of times to append <paramref name="value" />.</param>
        /// <returns>
        /// A reference to this instance after the append operation has completed.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="repeatCount" /> is less than zero.-or- Enlarging the value of this instance
        /// would exceed <see cref="MaxCapacity" />.
        /// </exception>
        /// <exception cref="OutOfMemoryException">Out of memory.</exception>
        public System.Text.StringBuilder Append(char value, int repeatCount) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Appends the string representation of the Unicode characters in a specified array to this instance.
        /// </summary>
        /// <param name="value">The array of characters to append.</param>
        /// <returns>
        /// A reference to this instance after the append operation has completed.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// Enlarging the value of this instance would exceed <see cref="MaxCapacity" />.
        /// </exception>
        public System.Text.StringBuilder Append(char[] value) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Appends the string representation of a specified subarray of Unicode characters to this instance.
        /// </summary>
        /// <param name="value">A character array.</param>
        /// <param name="startIndex">The starting position in <paramref name="value" />.</param>
        /// <param name="charCount">The number of characters to append.</param>
        /// <returns>
        /// A reference to this instance after the append operation has completed.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="value" /> is null, and <paramref name="startIndex" /> and <paramref name="charCount" />
        /// are not zero.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="charCount" /> is less than zero.-or- <paramref name="startIndex" /> is less
        /// than zero.-or- <paramref name="startIndex" /> + <paramref name="charCount" /> is greater than
        /// the length of <paramref name="value" />.-or- Enlarging the value of this instance would exceed
        /// <see cref="MaxCapacity" />.
        /// </exception>
        public System.Text.StringBuilder Append(char[] value, int startIndex, int charCount) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Appends the string representation of a specified decimal number to this instance.
        /// </summary>
        /// <param name="value">The value to append.</param>
        /// <returns>
        /// A reference to this instance after the append operation has completed.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// Enlarging the value of this instance would exceed <see cref="MaxCapacity" />.
        /// </exception>
        public System.Text.StringBuilder Append(decimal value) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Appends the string representation of a specified double-precision floating-point number to
        /// this instance.
        /// </summary>
        /// <param name="value">The value to append.</param>
        /// <returns>
        /// A reference to this instance after the append operation has completed.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// Enlarging the value of this instance would exceed <see cref="MaxCapacity" />.
        /// </exception>
        public System.Text.StringBuilder Append(double value) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Appends the string representation of a specified 16-bit signed integer to this instance.
        /// </summary>
        /// <param name="value">The value to append.</param>
        /// <returns>
        /// A reference to this instance after the append operation has completed.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// Enlarging the value of this instance would exceed <see cref="MaxCapacity" />.
        /// </exception>
        public System.Text.StringBuilder Append(short value) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Appends the string representation of a specified 32-bit signed integer to this instance.
        /// </summary>
        /// <param name="value">The value to append.</param>
        /// <returns>
        /// A reference to this instance after the append operation has completed.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// Enlarging the value of this instance would exceed <see cref="MaxCapacity" />.
        /// </exception>
        public System.Text.StringBuilder Append(int value) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Appends the string representation of a specified 64-bit signed integer to this instance.
        /// </summary>
        /// <param name="value">The value to append.</param>
        /// <returns>
        /// A reference to this instance after the append operation has completed.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// Enlarging the value of this instance would exceed <see cref="MaxCapacity" />.
        /// </exception>
        public System.Text.StringBuilder Append(long value) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Appends the string representation of a specified object to this instance.
        /// </summary>
        /// <param name="value">The object to append.</param>
        /// <returns>
        /// A reference to this instance after the append operation has completed.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// Enlarging the value of this instance would exceed <see cref="MaxCapacity" />.
        /// </exception>
        public System.Text.StringBuilder Append(object value) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Appends the string representation of a specified 8-bit signed integer to this instance.
        /// </summary>
        /// <param name="value">The value to append.</param>
        /// <returns>
        /// A reference to this instance after the append operation has completed.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// Enlarging the value of this instance would exceed <see cref="MaxCapacity" />.
        /// </exception>
        [System.CLSCompliantAttribute(false)]
        public System.Text.StringBuilder Append(sbyte value) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Appends the string representation of a specified single-precision floating-point number to
        /// this instance.
        /// </summary>
        /// <param name="value">The value to append.</param>
        /// <returns>
        /// A reference to this instance after the append operation has completed.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// Enlarging the value of this instance would exceed <see cref="MaxCapacity" />.
        /// </exception>
        public System.Text.StringBuilder Append(float value) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Appends a copy of the specified string to this instance.
        /// </summary>
        /// <param name="value">The string to append.</param>
        /// <returns>
        /// A reference to this instance after the append operation has completed.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// Enlarging the value of this instance would exceed <see cref="MaxCapacity" />.
        /// </exception>
        public System.Text.StringBuilder Append(string value) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Appends a copy of a specified substring to this instance.
        /// </summary>
        /// <param name="value">The string that contains the substring to append.</param>
        /// <param name="startIndex">The starting position of the substring within <paramref name="value" />.</param>
        /// <param name="count">The number of characters in <paramref name="value" /> to append.</param>
        /// <returns>
        /// A reference to this instance after the append operation has completed.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="value" /> is null, and <paramref name="startIndex" /> and <paramref name="count" />
        /// are not zero.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="count" /> less than zero.-or- <paramref name="startIndex" /> less than zero.-or-
        /// <paramref name="startIndex" /> + <paramref name="count" /> is greater than the length of <paramref name="value" />.
        /// -or- Enlarging the value of this instance would exceed
        /// <see cref="MaxCapacity" />.
        /// </exception>
        public System.Text.StringBuilder Append(string value, int startIndex, int count) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Appends the string representation of a specified 16-bit unsigned integer to this instance.
        /// </summary>
        /// <param name="value">The value to append.</param>
        /// <returns>
        /// A reference to this instance after the append operation has completed.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// Enlarging the value of this instance would exceed <see cref="MaxCapacity" />.
        /// </exception>
        [System.CLSCompliantAttribute(false)]
        public System.Text.StringBuilder Append(ushort value) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Appends the string representation of a specified 32-bit unsigned integer to this instance.
        /// </summary>
        /// <param name="value">The value to append.</param>
        /// <returns>
        /// A reference to this instance after the append operation has completed.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// Enlarging the value of this instance would exceed <see cref="MaxCapacity" />.
        /// </exception>
        [System.CLSCompliantAttribute(false)]
        public System.Text.StringBuilder Append(uint value) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Appends the string representation of a specified 64-bit unsigned integer to this instance.
        /// </summary>
        /// <param name="value">The value to append.</param>
        /// <returns>
        /// A reference to this instance after the append operation has completed.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// Enlarging the value of this instance would exceed <see cref="MaxCapacity" />.
        /// </exception>
        [System.CLSCompliantAttribute(false)]
        public System.Text.StringBuilder Append(ulong value) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Appends the string returned by processing a composite format string, which contains zero or
        /// more format items, to this instance. Each format item is replaced by the string representation of a
        /// single argument using a specified format provider.
        /// </summary>
        /// <param name="provider">An object that supplies culture-specific formatting information.</param>
        /// <param name="format">A composite format string (see Remarks).</param>
        /// <param name="arg0">The object to format.</param>
        /// <returns>
        /// A reference to this instance after the append operation has completed. After the append operation,
        /// this instance contains any data that existed before the operation, suffixed by a copy of
        /// <paramref name="format" /> in which any format specification is replaced by the string representation
        /// of <paramref name="arg0" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="format" /> is null.</exception>
        /// <exception cref="FormatException">
        /// <paramref name="format" /> is invalid. -or-The index of a format item is less than 0 (zero),
        /// or greater than or equal to one (1).
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The length of the expanded string would exceed <see cref="MaxCapacity" />.
        /// </exception>
        public System.Text.StringBuilder AppendFormat(System.IFormatProvider provider, string format, object arg0) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Appends the string returned by processing a composite format string, which contains zero or
        /// more format items, to this instance. Each format item is replaced by the string representation of either
        /// of two arguments using a specified format provider.
        /// </summary>
        /// <param name="provider">An object that supplies culture-specific formatting information.</param>
        /// <param name="format">A composite format string (see Remarks).</param>
        /// <param name="arg0">The first object to format.</param>
        /// <param name="arg1">The second object to format.</param>
        /// <returns>
        /// A reference to this instance after the append operation has completed. After the append operation,
        /// this instance contains any data that existed before the operation, suffixed by a copy of
        /// <paramref name="format" /> where any format specification is replaced by the string representation of
        /// the corresponding object argument.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="format" /> is null.</exception>
        /// <exception cref="FormatException">
        /// <paramref name="format" /> is invalid. -or-The index of a format item is less than 0 (zero),
        /// or greater than or equal to 2 (two).
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The length of the expanded string would exceed <see cref="MaxCapacity" />.
        /// </exception>
        public System.Text.StringBuilder AppendFormat(System.IFormatProvider provider, string format, object arg0, object arg1) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Appends the string returned by processing a composite format string, which contains zero or
        /// more format items, to this instance. Each format item is replaced by the string representation of either
        /// of three arguments using a specified format provider.
        /// </summary>
        /// <param name="provider">An object that supplies culture-specific formatting information.</param>
        /// <param name="format">A composite format string (see Remarks).</param>
        /// <param name="arg0">The first object to format.</param>
        /// <param name="arg1">The second object to format.</param>
        /// <param name="arg2">The third object to format.</param>
        /// <returns>
        /// A reference to this instance after the append operation has completed. After the append operation,
        /// this instance contains any data that existed before the operation, suffixed by a copy of
        /// <paramref name="format" /> where any format specification is replaced by the string representation of
        /// the corresponding object argument.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="format" /> is null.</exception>
        /// <exception cref="FormatException">
        /// <paramref name="format" /> is invalid. -or-The index of a format item is less than 0 (zero),
        /// or greater than or equal to 3 (three).
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The length of the expanded string would exceed <see cref="MaxCapacity" />.
        /// </exception>
        public System.Text.StringBuilder AppendFormat(System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Appends the string returned by processing a composite format string, which contains zero or
        /// more format items, to this instance. Each format item is replaced by the string representation of a
        /// corresponding argument in a parameter array using a specified format provider.
        /// </summary>
        /// <param name="provider">An object that supplies culture-specific formatting information.</param>
        /// <param name="format">A composite format string (see Remarks).</param>
        /// <param name="args">An array of objects to format.</param>
        /// <returns>
        /// A reference to this instance after the append operation has completed. After the append operation,
        /// this instance contains any data that existed before the operation, suffixed by a copy of
        /// <paramref name="format" /> where any format specification is replaced by the string representation of
        /// the corresponding object argument.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="format" /> is null.</exception>
        /// <exception cref="FormatException">
        /// <paramref name="format" /> is invalid. -or-The index of a format item is less than 0 (zero),
        /// or greater than or equal to the length of the <paramref name="args" /> array.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The length of the expanded string would exceed <see cref="MaxCapacity" />.
        /// </exception>
        public System.Text.StringBuilder AppendFormat(System.IFormatProvider provider, string format, params object[] args) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Appends the string returned by processing a composite format string, which contains zero or
        /// more format items, to this instance. Each format item is replaced by the string representation of a
        /// single argument.
        /// </summary>
        /// <param name="format">A composite format string (see Remarks).</param>
        /// <param name="arg0">An object to format.</param>
        /// <returns>
        /// A reference to this instance with <paramref name="format" /> appended. Each format item in
        /// <paramref name="format" /> is replaced by the string representation of <paramref name="arg0" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="format" /> is null.</exception>
        /// <exception cref="FormatException">
        /// <paramref name="format" /> is invalid. -or-The index of a format item is less than 0 (zero),
        /// or greater than or equal to 1.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The length of the expanded string would exceed <see cref="MaxCapacity" />.
        /// </exception>
        public System.Text.StringBuilder AppendFormat(string format, object arg0) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Appends the string returned by processing a composite format string, which contains zero or
        /// more format items, to this instance. Each format item is replaced by the string representation of either
        /// of two arguments.
        /// </summary>
        /// <param name="format">A composite format string (see Remarks).</param>
        /// <param name="arg0">The first object to format.</param>
        /// <param name="arg1">The second object to format.</param>
        /// <returns>
        /// A reference to this instance with <paramref name="format" /> appended. Each format item in
        /// <paramref name="format" /> is replaced by the string representation of the corresponding object
        /// argument.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="format" /> is null.</exception>
        /// <exception cref="FormatException">
        /// <paramref name="format" /> is invalid.-or-The index of a format item is less than 0 (zero),
        /// or greater than or equal to 2.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The length of the expanded string would exceed <see cref="MaxCapacity" />.
        /// </exception>
        public System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Appends the string returned by processing a composite format string, which contains zero or
        /// more format items, to this instance. Each format item is replaced by the string representation of either
        /// of three arguments.
        /// </summary>
        /// <param name="format">A composite format string (see Remarks).</param>
        /// <param name="arg0">The first object to format.</param>
        /// <param name="arg1">The second object to format.</param>
        /// <param name="arg2">The third object to format.</param>
        /// <returns>
        /// A reference to this instance with <paramref name="format" /> appended. Each format item in
        /// <paramref name="format" /> is replaced by the string representation of the corresponding object
        /// argument.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="format" /> is null.</exception>
        /// <exception cref="FormatException">
        /// <paramref name="format" /> is invalid.-or-The index of a format item is less than 0 (zero),
        /// or greater than or equal to 3.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The length of the expanded string would exceed <see cref="MaxCapacity" />.
        /// </exception>
        public System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Appends the string returned by processing a composite format string, which contains zero or
        /// more format items, to this instance. Each format item is replaced by the string representation of a
        /// corresponding argument in a parameter array.
        /// </summary>
        /// <param name="format">A composite format string (see Remarks).</param>
        /// <param name="args">An array of objects to format.</param>
        /// <returns>
        /// A reference to this instance with <paramref name="format" /> appended. Each format item in
        /// <paramref name="format" /> is replaced by the string representation of the corresponding object
        /// argument.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="format" /> or <paramref name="args" /> is null.
        /// </exception>
        /// <exception cref="FormatException">
        /// <paramref name="format" /> is invalid. -or-The index of a format item is less than 0 (zero),
        /// or greater than or equal to the length of the <paramref name="args" /> array.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The length of the expanded string would exceed <see cref="MaxCapacity" />.
        /// </exception>
        public System.Text.StringBuilder AppendFormat(string format, params object[] args) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Appends the default line terminator to the end of the current <see cref="StringBuilder" />
        /// object.
        /// </summary>
        /// <returns>
        /// A reference to this instance after the append operation has completed.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// Enlarging the value of this instance would exceed <see cref="MaxCapacity" />.
        /// </exception>
        public System.Text.StringBuilder AppendLine() { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Appends a copy of the specified string followed by the default line terminator to the end
        /// of the current <see cref="StringBuilder" /> object.
        /// </summary>
        /// <param name="value">The string to append.</param>
        /// <returns>
        /// A reference to this instance after the append operation has completed.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// Enlarging the value of this instance would exceed <see cref="MaxCapacity" />.
        /// </exception>
        public System.Text.StringBuilder AppendLine(string value) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Removes all characters from the current <see cref="StringBuilder" /> instance.
        /// </summary>
        /// <returns>
        /// An object whose <see cref="Length" /> is 0 (zero).
        /// </returns>
        public System.Text.StringBuilder Clear() { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Copies the characters from a specified segment of this instance to a specified segment of
        /// a destination <see cref="Char" /> array.
        /// </summary>
        /// <param name="sourceIndex">
        /// The starting position in this instance where characters will be copied from. The index is zero-based.
        /// </param>
        /// <param name="destination">The array where characters will be copied.</param>
        /// <param name="destinationIndex">
        /// The starting position in <paramref name="destination" /> where characters will be copied.
        /// The index is zero-based.
        /// </param>
        /// <param name="count">The number of characters to be copied.</param>
        /// <exception cref="ArgumentNullException"><paramref name="destination" /> is null.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="sourceIndex" />, <paramref name="destinationIndex" />, or <paramref name="count" />,
        /// is less than zero.-or-<paramref name="sourceIndex" /> is greater than the length of this
        /// instance.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="sourceIndex" /> + <paramref name="count" /> is greater than the length of
        /// this instance.-or-<paramref name="destinationIndex" /> + <paramref name="count" /> is greater
        /// than the length of <paramref name="destination" />.
        /// </exception>
        public void CopyTo(int sourceIndex, char[] destination, int destinationIndex, int count) { }
        /// <summary>
        /// Ensures that the capacity of this instance of <see cref="StringBuilder" /> is
        /// at least the specified value.
        /// </summary>
        /// <param name="capacity">The minimum capacity to ensure.</param>
        /// <returns>
        /// The new capacity of this instance.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="capacity" /> is less than zero.-or- Enlarging the value of this instance would
        /// exceed <see cref="MaxCapacity" />.
        /// </exception>
        public int EnsureCapacity(int capacity) { return default(int); }
        /// <summary>
        /// Returns a value indicating whether this instance is equal to a specified object.
        /// </summary>
        /// <param name="sb">An object to compare with this instance, or null.</param>
        /// <returns>
        /// true if this instance and <paramref name="sb" /> have equal string,
        /// <see cref="Capacity" />, and <see cref="MaxCapacity" /> values; otherwise, false.
        /// </returns>
        public bool Equals(System.Text.StringBuilder sb) { return default(bool); }
        /// <summary>
        /// Inserts the string representation of a Boolean value into this instance at the specified character
        /// position.
        /// </summary>
        /// <param name="index">The position in this instance where insertion begins.</param>
        /// <param name="value">The value to insert.</param>
        /// <returns>
        /// A reference to this instance after the insert operation has completed.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than zero or greater than the length of this instance.
        /// </exception>
        /// <exception cref="OutOfMemoryException">
        /// Enlarging the value of this instance would exceed <see cref="MaxCapacity" />.
        /// </exception>
        public System.Text.StringBuilder Insert(int index, bool value) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Inserts the string representation of a specified 8-bit unsigned integer into this instance
        /// at the specified character position.
        /// </summary>
        /// <param name="index">The position in this instance where insertion begins.</param>
        /// <param name="value">The value to insert.</param>
        /// <returns>
        /// A reference to this instance after the insert operation has completed.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than zero or greater than the length of this instance.
        /// </exception>
        /// <exception cref="OutOfMemoryException">
        /// Enlarging the value of this instance would exceed <see cref="MaxCapacity" />.
        /// </exception>
        public System.Text.StringBuilder Insert(int index, byte value) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Inserts the string representation of a specified Unicode character into this instance at the
        /// specified character position.
        /// </summary>
        /// <param name="index">The position in this instance where insertion begins.</param>
        /// <param name="value">The value to insert.</param>
        /// <returns>
        /// A reference to this instance after the insert operation has completed.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than zero or greater than the length of this instance.-or-
        /// Enlarging the value of this instance would exceed <see cref="MaxCapacity" />.
        /// </exception>
        public System.Text.StringBuilder Insert(int index, char value) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Inserts the string representation of a specified array of Unicode characters into this instance
        /// at the specified character position.
        /// </summary>
        /// <param name="index">The position in this instance where insertion begins.</param>
        /// <param name="value">The character array to insert.</param>
        /// <returns>
        /// A reference to this instance after the insert operation has completed.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than zero or greater than the length of this instance.-or-
        /// Enlarging the value of this instance would exceed <see cref="MaxCapacity" />.
        /// </exception>
        public System.Text.StringBuilder Insert(int index, char[] value) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Inserts the string representation of a specified subarray of Unicode characters into this instance
        /// at the specified character position.
        /// </summary>
        /// <param name="index">The position in this instance where insertion begins.</param>
        /// <param name="value">A character array.</param>
        /// <param name="startIndex">The starting index within <paramref name="value" />.</param>
        /// <param name="charCount">The number of characters to insert.</param>
        /// <returns>
        /// A reference to this instance after the insert operation has completed.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="value" /> is null, and <paramref name="startIndex" /> and <paramref name="charCount" />
        /// are not zero.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" />, <paramref name="startIndex" />, or <paramref name="charCount" />
        /// is less than zero.-or- <paramref name="index" /> is greater than the length of this instance.-or-
        /// <paramref name="startIndex" /> plus <paramref name="charCount" /> is not a position within
        /// <paramref name="value" />.-or- Enlarging the value of this instance would exceed
        /// <see cref="MaxCapacity" />.
        /// </exception>
        public System.Text.StringBuilder Insert(int index, char[] value, int startIndex, int charCount) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Inserts the string representation of a decimal number into this instance at the specified character
        /// position.
        /// </summary>
        /// <param name="index">The position in this instance where insertion begins.</param>
        /// <param name="value">The value to insert.</param>
        /// <returns>
        /// A reference to this instance after the insert operation has completed.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than zero or greater than the length of this instance.
        /// </exception>
        /// <exception cref="OutOfMemoryException">
        /// Enlarging the value of this instance would exceed <see cref="MaxCapacity" />.
        /// </exception>
        public System.Text.StringBuilder Insert(int index, decimal value) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Inserts the string representation of a double-precision floating-point number into this instance
        /// at the specified character position.
        /// </summary>
        /// <param name="index">The position in this instance where insertion begins.</param>
        /// <param name="value">The value to insert.</param>
        /// <returns>
        /// A reference to this instance after the insert operation has completed.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than zero or greater than the length of this instance.
        /// </exception>
        /// <exception cref="OutOfMemoryException">
        /// Enlarging the value of this instance would exceed <see cref="MaxCapacity" />.
        /// </exception>
        public System.Text.StringBuilder Insert(int index, double value) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Inserts the string representation of a specified 16-bit signed integer into this instance at
        /// the specified character position.
        /// </summary>
        /// <param name="index">The position in this instance where insertion begins.</param>
        /// <param name="value">The value to insert.</param>
        /// <returns>
        /// A reference to this instance after the insert operation has completed.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than zero or greater than the length of this instance.
        /// </exception>
        /// <exception cref="OutOfMemoryException">
        /// Enlarging the value of this instance would exceed <see cref="MaxCapacity" />.
        /// </exception>
        public System.Text.StringBuilder Insert(int index, short value) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Inserts the string representation of a specified 32-bit signed integer into this instance at
        /// the specified character position.
        /// </summary>
        /// <param name="index">The position in this instance where insertion begins.</param>
        /// <param name="value">The value to insert.</param>
        /// <returns>
        /// A reference to this instance after the insert operation has completed.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than zero or greater than the length of this instance.
        /// </exception>
        /// <exception cref="OutOfMemoryException">
        /// Enlarging the value of this instance would exceed <see cref="MaxCapacity" />.
        /// </exception>
        public System.Text.StringBuilder Insert(int index, int value) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Inserts the string representation of a 64-bit signed integer into this instance at the specified
        /// character position.
        /// </summary>
        /// <param name="index">The position in this instance where insertion begins.</param>
        /// <param name="value">The value to insert.</param>
        /// <returns>
        /// A reference to this instance after the insert operation has completed.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than zero or greater than the length of this instance.
        /// </exception>
        /// <exception cref="OutOfMemoryException">
        /// Enlarging the value of this instance would exceed <see cref="MaxCapacity" />.
        /// </exception>
        public System.Text.StringBuilder Insert(int index, long value) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Inserts the string representation of an object into this instance at the specified character
        /// position.
        /// </summary>
        /// <param name="index">The position in this instance where insertion begins.</param>
        /// <param name="value">The object to insert, or null.</param>
        /// <returns>
        /// A reference to this instance after the insert operation has completed.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than zero or greater than the length of this instance.
        /// </exception>
        /// <exception cref="OutOfMemoryException">
        /// Enlarging the value of this instance would exceed <see cref="MaxCapacity" />.
        /// </exception>
        public System.Text.StringBuilder Insert(int index, object value) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Inserts the string representation of a specified 8-bit signed integer into this instance at
        /// the specified character position.
        /// </summary>
        /// <param name="index">The position in this instance where insertion begins.</param>
        /// <param name="value">The value to insert.</param>
        /// <returns>
        /// A reference to this instance after the insert operation has completed.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than zero or greater than the length of this instance.
        /// </exception>
        /// <exception cref="OutOfMemoryException">
        /// Enlarging the value of this instance would exceed <see cref="MaxCapacity" />.
        /// </exception>
        [System.CLSCompliantAttribute(false)]
        public System.Text.StringBuilder Insert(int index, sbyte value) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Inserts the string representation of a single-precision floating point number into this instance
        /// at the specified character position.
        /// </summary>
        /// <param name="index">The position in this instance where insertion begins.</param>
        /// <param name="value">The value to insert.</param>
        /// <returns>
        /// A reference to this instance after the insert operation has completed.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than zero or greater than the length of this instance.
        /// </exception>
        /// <exception cref="OutOfMemoryException">
        /// Enlarging the value of this instance would exceed <see cref="MaxCapacity" />.
        /// </exception>
        public System.Text.StringBuilder Insert(int index, float value) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Inserts a string into this instance at the specified character position.
        /// </summary>
        /// <param name="index">The position in this instance where insertion begins.</param>
        /// <param name="value">The string to insert.</param>
        /// <returns>
        /// A reference to this instance after the insert operation has completed.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than zero or greater than the current length of this instance.
        /// -or-The current length of this <see cref="StringBuilder" /> object plus the
        /// length of <paramref name="value" /> exceeds <see cref="MaxCapacity" />.
        /// </exception>
        public System.Text.StringBuilder Insert(int index, string value) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Inserts one or more copies of a specified string into this instance at the specified character
        /// position.
        /// </summary>
        /// <param name="index">The position in this instance where insertion begins.</param>
        /// <param name="value">The string to insert.</param>
        /// <param name="count">The number of times to insert <paramref name="value" />.</param>
        /// <returns>
        /// A reference to this instance after insertion has completed.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than zero or greater than the current length of this instance.-or-
        /// <paramref name="count" /> is less than zero.
        /// </exception>
        /// <exception cref="OutOfMemoryException">
        /// The current length of this <see cref="StringBuilder" /> object plus the length
        /// of <paramref name="value" /> times <paramref name="count" /> exceeds
        /// <see cref="MaxCapacity" />.
        /// </exception>
        public System.Text.StringBuilder Insert(int index, string value, int count) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Inserts the string representation of a 16-bit unsigned integer into this instance at the specified
        /// character position.
        /// </summary>
        /// <param name="index">The position in this instance where insertion begins.</param>
        /// <param name="value">The value to insert.</param>
        /// <returns>
        /// A reference to this instance after the insert operation has completed.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than zero or greater than the length of this instance.
        /// </exception>
        /// <exception cref="OutOfMemoryException">
        /// Enlarging the value of this instance would exceed <see cref="MaxCapacity" />.
        /// </exception>
        [System.CLSCompliantAttribute(false)]
        public System.Text.StringBuilder Insert(int index, ushort value) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Inserts the string representation of a 32-bit unsigned integer into this instance at the specified
        /// character position.
        /// </summary>
        /// <param name="index">The position in this instance where insertion begins.</param>
        /// <param name="value">The value to insert.</param>
        /// <returns>
        /// A reference to this instance after the insert operation has completed.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than zero or greater than the length of this instance.
        /// </exception>
        /// <exception cref="OutOfMemoryException">
        /// Enlarging the value of this instance would exceed <see cref="MaxCapacity" />.
        /// </exception>
        [System.CLSCompliantAttribute(false)]
        public System.Text.StringBuilder Insert(int index, uint value) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Inserts the string representation of a 64-bit unsigned integer into this instance at the specified
        /// character position.
        /// </summary>
        /// <param name="index">The position in this instance where insertion begins.</param>
        /// <param name="value">The value to insert.</param>
        /// <returns>
        /// A reference to this instance after the insert operation has completed.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index" /> is less than zero or greater than the length of this instance.
        /// </exception>
        /// <exception cref="OutOfMemoryException">
        /// Enlarging the value of this instance would exceed <see cref="MaxCapacity" />.
        /// </exception>
        [System.CLSCompliantAttribute(false)]
        public System.Text.StringBuilder Insert(int index, ulong value) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Removes the specified range of characters from this instance.
        /// </summary>
        /// <param name="startIndex">The zero-based position in this instance where removal begins.</param>
        /// <param name="length">The number of characters to remove.</param>
        /// <returns>
        /// A reference to this instance after the excise operation has completed.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// If <paramref name="startIndex" /> or <paramref name="length" /> is less than zero, or
        /// <paramref name="startIndex" /> + <paramref name="length" /> is greater than the length of this instance.
        /// </exception>
        public System.Text.StringBuilder Remove(int startIndex, int length) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Replaces all occurrences of a specified character in this instance with another specified character.
        /// </summary>
        /// <param name="oldChar">The character to replace.</param>
        /// <param name="newChar">The character that replaces <paramref name="oldChar" />.</param>
        /// <returns>
        /// A reference to this instance with <paramref name="oldChar" /> replaced by <paramref name="newChar" />.
        /// </returns>
        public System.Text.StringBuilder Replace(char oldChar, char newChar) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Replaces, within a substring of this instance, all occurrences of a specified character with
        /// another specified character.
        /// </summary>
        /// <param name="oldChar">The character to replace.</param>
        /// <param name="newChar">The character that replaces <paramref name="oldChar" />.</param>
        /// <param name="startIndex">The position in this instance where the substring begins.</param>
        /// <param name="count">The length of the substring.</param>
        /// <returns>
        /// A reference to this instance with <paramref name="oldChar" /> replaced by <paramref name="newChar" />
        /// in the range from <paramref name="startIndex" /> to <paramref name="startIndex" /> +
        /// <paramref name="count" /> -1.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="startIndex" /> + <paramref name="count" /> is greater than the length of the
        /// value of this instance.-or- <paramref name="startIndex" /> or <paramref name="count" /> is
        /// less than zero.
        /// </exception>
        public System.Text.StringBuilder Replace(char oldChar, char newChar, int startIndex, int count) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Replaces all occurrences of a specified string in this instance with another specified string.
        /// </summary>
        /// <param name="oldValue">The string to replace.</param>
        /// <param name="newValue">The string that replaces <paramref name="oldValue" />, or null.</param>
        /// <returns>
        /// A reference to this instance with all instances of <paramref name="oldValue" /> replaced by
        /// <paramref name="newValue" />.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="oldValue" /> is null.</exception>
        /// <exception cref="ArgumentException">The length of <paramref name="oldValue" /> is zero.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// Enlarging the value of this instance would exceed <see cref="MaxCapacity" />.
        /// </exception>
        public System.Text.StringBuilder Replace(string oldValue, string newValue) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Replaces, within a substring of this instance, all occurrences of a specified string with another
        /// specified string.
        /// </summary>
        /// <param name="oldValue">The string to replace.</param>
        /// <param name="newValue">The string that replaces <paramref name="oldValue" />, or null.</param>
        /// <param name="startIndex">The position in this instance where the substring begins.</param>
        /// <param name="count">The length of the substring.</param>
        /// <returns>
        /// A reference to this instance with all instances of <paramref name="oldValue" /> replaced by
        /// <paramref name="newValue" /> in the range from <paramref name="startIndex" /> to <paramref name="startIndex" />
        /// + <paramref name="count" /> - 1.
        /// </returns>
        /// <exception cref="ArgumentNullException"><paramref name="oldValue" /> is null.</exception>
        /// <exception cref="ArgumentException">The length of <paramref name="oldValue" /> is zero.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="startIndex" /> or <paramref name="count" /> is less than zero.-or-
        /// <paramref name="startIndex" /> plus <paramref name="count" /> indicates a character position not within
        /// this instance.-or- Enlarging the value of this instance would exceed <see cref="MaxCapacity" />.
        /// </exception>
        public System.Text.StringBuilder Replace(string oldValue, string newValue, int startIndex, int count) { return default(System.Text.StringBuilder); }
        /// <summary>
        /// Converts the value of this instance to a <see cref="String" />.
        /// </summary>
        /// <returns>
        /// A string whose value is the same as this instance.
        /// </returns>
        public override string ToString() { return default(string); }
        /// <summary>
        /// Converts the value of a substring of this instance to a <see cref="String" />.
        /// </summary>
        /// <param name="startIndex">The starting position of the substring in this instance.</param>
        /// <param name="length">The length of the substring.</param>
        /// <returns>
        /// A string whose value is the same as the specified substring of this instance.
        /// </returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="startIndex" /> or <paramref name="length" /> is less than zero.-or- The sum
        /// of <paramref name="startIndex" /> and <paramref name="length" /> is greater than the length
        /// of the current instance.
        /// </exception>
        public string ToString(int startIndex, int length) { return default(string); }
    }
}
namespace System.Threading
{
    /// <summary>
    /// Specifies how a <see cref="System.Lazy`1" /> instance synchronizes access among multiple
    /// threads.
    /// </summary>
    public enum LazyThreadSafetyMode
    {
        /// <summary>
        /// Locks are used to ensure that only a single thread can initialize a <see cref="System.Lazy`1" />
        /// instance in a thread-safe manner. If the initialization method (or the default constructor,
        /// if there is no initialization method) uses locks internally, deadlocks can occur. If you use
        /// a <see cref="System.Lazy`1" /> constructor that specifies an initialization method (<paramref name="valueFactory" />
        /// parameter), and if that initialization method throws an exception (or
        /// fails to handle an exception) the first time you call the <see cref="System.Lazy`1.Value" />
        /// property, then the exception is cached and thrown again on subsequent calls to the <see cref="System.Lazy`1.Value" />
        /// property. If you use a <see cref="System.Lazy`1" /> constructor
        /// that does not specify an initialization method, exceptions that are thrown by the default
        /// constructor for <paramref name="T" /> are not cached. In that case, a subsequent call to the
        /// <see cref="System.Lazy`1.Value" /> property might successfully initialize the <see cref="System.Lazy`1" />
        /// instance. If the initialization method recursively accesses the <see cref="System.Lazy`1.Value" />
        /// property of the <see cref="System.Lazy`1" /> instance, an <see cref="InvalidOperationException" />
        /// is thrown.
        /// </summary>
        ExecutionAndPublication = 2,
        /// <summary>
        /// The <see cref="System.Lazy`1" /> instance is not thread safe; if the instance is accessed
        /// from multiple threads, its behavior is undefined. Use this mode only when high performance
        /// is crucial and the <see cref="System.Lazy`1" /> instance is guaranteed never to be initialized
        /// from more than one thread. If you use a <see cref="System.Lazy`1" /> constructor that specifies
        /// an initialization method (<paramref name="valueFactory" /> parameter), and if that initialization
        /// method throws an exception (or fails to handle an exception) the first time you call the <see cref="System.Lazy`1.Value" />
        /// property, then the exception is cached and thrown again on
        /// subsequent calls to the <see cref="System.Lazy`1.Value" /> property. If you use a <see cref="System.Lazy`1" />
        /// constructor that does not specify an initialization method, exceptions that are thrown
        /// by the default constructor for <paramref name="T" /> are not cached. In that case, a subsequent
        /// call to the <see cref="System.Lazy`1.Value" /> property might successfully initialize the
        /// <see cref="System.Lazy`1" /> instance. If the initialization method recursively accesses
        /// the <see cref="System.Lazy`1.Value" /> property of the <see cref="System.Lazy`1" /> instance,
        /// an <see cref="InvalidOperationException" /> is thrown.
        /// </summary>
        None = 0,
        /// <summary>
        /// When multiple threads try to initialize a <see cref="System.Lazy`1" /> instance simultaneously,
        /// all threads are allowed to run the initialization method (or the default constructor, if there
        /// is no initialization method). The first thread to complete initialization sets the value of
        /// the <see cref="System.Lazy`1" /> instance. That value is returned to any other threads that
        /// were simultaneously running the initialization method, unless the initialization method throws
        /// exceptions on those threads. Any instances of <paramref name="T" /> that were created by the
        /// competing threads are discarded. If the initialization method throws an exception on any thread,
        /// the exception is propagated out of the <see cref="System.Lazy`1.Value" /> property on that
        /// thread. The exception is not cached. The value of the <see cref="System.Lazy`1.IsValueCreated" />
        /// property remains false, and subsequent calls to the <see cref="System.Lazy`1.Value" />
        /// property, either by the thread where the exception was thrown or by other threads, cause the
        /// initialization method to run again. If the initialization method recursively accesses the
        /// <see cref="System.Lazy`1.Value" /> property of the <see cref="System.Lazy`1" /> instance,
        /// no exception is thrown.
        /// </summary>
        PublicationOnly = 1,
    }
    /// <summary>
    /// Contains constants that specify infinite time-out intervals. This class cannot be inherited.
    /// </summary>
    public static partial class Timeout
    {
        /// <summary>
        /// A constant used to specify an infinite waiting period, for threading methods that accept an
        /// <see cref="Int32" /> parameter.
        /// </summary>
        public const int Infinite = -1;
        /// <summary>
        /// A constant used to specify an infinite waiting period, for methods that accept a
        /// <see cref="TimeSpan" /> parameter.
        /// </summary>
        public static readonly System.TimeSpan InfiniteTimeSpan;
    }
    /// <summary>
    /// Encapsulates operating systemspecific objects that wait for exclusive access to shared resources.
    /// </summary>
    public abstract partial class WaitHandle : System.IDisposable
    {
        /// <summary>
        /// Represents an invalid native operating system handle. This field is read-only.
        /// </summary>
        protected static readonly System.IntPtr InvalidHandle;
        /// <summary>
        /// Indicates that a
        /// <see cref="WaitHandle.WaitAny(WaitHandle[],Int32,Boolean)" /> operation timed out before any of the wait handles were signaled. This field is constant.
        /// </summary>
        public const int WaitTimeout = 258;
        /// <summary>
        /// Initializes a new instance of the <see cref="WaitHandle" /> class.
        /// </summary>
        protected WaitHandle() { }
        /// <summary>
        /// Releases all resources used by the current instance of the <see cref="WaitHandle" />
        /// class.
        /// </summary>
        public void Dispose() { }
        /// <summary>
        /// When overridden in a derived class, releases the unmanaged resources used by the
        /// <see cref="WaitHandle" />, and optionally releases the managed resources.
        /// </summary>
        /// <param name="explicitDisposing">
        /// true to release both managed and unmanaged resources; false to release only unmanaged resources.
        /// </param>
        protected virtual void Dispose(bool explicitDisposing) { }
        /// <summary>
        /// Waits for all the elements in the specified array to receive a signal.
        /// </summary>
        /// <param name="waitHandles">
        /// A WaitHandle array containing the objects for which the current instance will wait. This array
        /// cannot contain multiple references to the same object.
        /// </param>
        /// <returns>
        /// true when every element in <paramref name="waitHandles" /> has received a signal; otherwise
        /// the method never returns.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// The <paramref name="waitHandles" /> parameter is null. -or- One or more of the objects in
        /// the <paramref name="waitHandles" /> array are null. -or-<paramref name="waitHandles" /> is
        /// an array with no elements and the .NET Framework version is 2.0 or later.
        /// </exception>
        /// <exception cref="DuplicateWaitObjectException">
        /// In the .NET for Windows Store apps or the Portable Class Library, catch the base class exception,
        /// <see cref="ArgumentException" />, instead.The <paramref name="waitHandles" /> array
        /// contains elements that are duplicates.
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// The number of objects in <paramref name="waitHandles" /> is greater than the system permits.-or-
        /// The <see cref="STAThreadAttribute" /> attribute is applied to the thread procedure
        /// for the current thread, and <paramref name="waitHandles" /> contains more than one element.
        /// </exception>
        /// <exception cref="ApplicationException">
        /// <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version
        /// is 1.0 or 1.1.
        /// </exception>
        /// <exception cref="AbandonedMutexException">
        /// The wait terminated because a thread exited without releasing a mutex. This exception is not
        /// thrown on Windows 98 or Windows Millennium Edition.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// The <paramref name="waitHandles" /> array contains a transparent proxy for a
        /// <see cref="WaitHandle" /> in another application domain.
        /// </exception>
        public static bool WaitAll(System.Threading.WaitHandle[] waitHandles) { return default(bool); }
        /// <summary>
        /// Waits for all the elements in the specified array to receive a signal, using an <see cref="Int32" />
        /// value to specify the time interval.
        /// </summary>
        /// <param name="waitHandles">
        /// A WaitHandle array containing the objects for which the current instance will wait. This array
        /// cannot contain multiple references to the same object (duplicates).
        /// </param>
        /// <param name="millisecondsTimeout">
        /// The number of milliseconds to wait, or <see cref="Timeout.Infinite" />
        /// (-1) to wait indefinitely.
        /// </param>
        /// <returns>
        /// true when every element in <paramref name="waitHandles" /> has received a signal; otherwise,
        /// false.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// The <paramref name="waitHandles" /> parameter is null.-or- One or more of the objects in the
        /// <paramref name="waitHandles" /> array is null. -or-<paramref name="waitHandles" /> is an array
        /// with no elements.
        /// </exception>
        /// <exception cref="DuplicateWaitObjectException">
        /// In the .NET for Windows Store apps or the Portable Class Library, catch the base class exception,
        /// <see cref="ArgumentException" />, instead.The <paramref name="waitHandles" /> array
        /// contains elements that are duplicates.
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// The number of objects in <paramref name="waitHandles" /> is greater than the system permits.-or-
        /// The <see cref="STAThreadAttribute" /> attribute is applied to the thread procedure
        /// for the current thread, and <paramref name="waitHandles" /> contains more than one element.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents
        /// an infinite time-out.
        /// </exception>
        /// <exception cref="AbandonedMutexException">
        /// The wait completed because a thread exited without releasing a mutex. This exception is not
        /// thrown on Windows 98 or Windows Millennium Edition.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// The <paramref name="waitHandles" /> array contains a transparent proxy for a
        /// <see cref="WaitHandle" /> in another application domain.
        /// </exception>
        public static bool WaitAll(System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout) { return default(bool); }
        /// <summary>
        /// Waits for all the elements in the specified array to receive a signal, using a <see cref="TimeSpan" />
        /// value to specify the time interval.
        /// </summary>
        /// <param name="waitHandles">
        /// A WaitHandle array containing the objects for which the current instance will wait. This array
        /// cannot contain multiple references to the same object.
        /// </param>
        /// <param name="timeout">
        /// A <see cref="TimeSpan" /> that represents the number of milliseconds to wait, or
        /// a <see cref="TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.
        /// </param>
        /// <returns>
        /// true when every element in <paramref name="waitHandles" /> has received a signal; otherwise,
        /// false.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// The <paramref name="waitHandles" /> parameter is null. -or- One or more of the objects in
        /// the <paramref name="waitHandles" /> array is null. -or-<paramref name="waitHandles" /> is
        /// an array with no elements.
        /// </exception>
        /// <exception cref="DuplicateWaitObjectException">
        /// In the .NET for Windows Store apps or the Portable Class Library, catch the base class exception,
        /// <see cref="ArgumentException" />, instead.The <paramref name="waitHandles" /> array
        /// contains elements that are duplicates.
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// The number of objects in <paramref name="waitHandles" /> is greater than the system permits.-or-
        /// The <see cref="STAThreadAttribute" /> attribute is applied to the thread procedure
        /// for the current thread, and <paramref name="waitHandles" /> contains more than one element.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents
        /// an infinite time-out. -or-<paramref name="timeout" /> is greater than <see cref="Int32.MaxValue" />.
        /// </exception>
        /// <exception cref="AbandonedMutexException">
        /// The wait terminated because a thread exited without releasing a mutex. This exception is not
        /// thrown on Windows 98 or Windows Millennium Edition.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// The <paramref name="waitHandles" /> array contains a transparent proxy for a
        /// <see cref="WaitHandle" /> in another application domain.
        /// </exception>
        public static bool WaitAll(System.Threading.WaitHandle[] waitHandles, System.TimeSpan timeout) { return default(bool); }
        /// <summary>
        /// Waits for any of the elements in the specified array to receive a signal.
        /// </summary>
        /// <param name="waitHandles">
        /// A WaitHandle array containing the objects for which the current instance will wait.
        /// </param>
        /// <returns>
        /// The array index of the object that satisfied the wait.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// The <paramref name="waitHandles" /> parameter is null.-or-One or more of the objects in the
        /// <paramref name="waitHandles" /> array is null.
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// The number of objects in <paramref name="waitHandles" /> is greater than the system permits.
        /// </exception>
        /// <exception cref="ApplicationException">
        /// <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version
        /// is 1.0 or 1.1.
        /// </exception>
        /// <exception cref="AbandonedMutexException">
        /// The wait completed because a thread exited without releasing a mutex. This exception is not
        /// thrown on Windows 98 or Windows Millennium Edition.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version
        /// is 2.0 or later.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// The <paramref name="waitHandles" /> array contains a transparent proxy for a
        /// <see cref="WaitHandle" /> in another application domain.
        /// </exception>
        public static int WaitAny(System.Threading.WaitHandle[] waitHandles) { return default(int); }
        /// <summary>
        /// Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed
        /// integer to specify the time interval.
        /// </summary>
        /// <param name="waitHandles">
        /// A WaitHandle array containing the objects for which the current instance will wait.
        /// </param>
        /// <param name="millisecondsTimeout">
        /// The number of milliseconds to wait, or <see cref="Timeout.Infinite" />
        /// (-1) to wait indefinitely.
        /// </param>
        /// <returns>
        /// The array index of the object that satisfied the wait, or
        /// <see cref="WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to
        /// <paramref name="millisecondsTimeout" /> has passed.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// The <paramref name="waitHandles" /> parameter is null.-or-One or more of the objects in the
        /// <paramref name="waitHandles" /> array is null.
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// The number of objects in <paramref name="waitHandles" /> is greater than the system permits.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents
        /// an infinite time-out.
        /// </exception>
        /// <exception cref="AbandonedMutexException">
        /// The wait completed because a thread exited without releasing a mutex. This exception is not
        /// thrown on Windows 98 or Windows Millennium Edition.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="waitHandles" /> is an array with no elements.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// The <paramref name="waitHandles" /> array contains a transparent proxy for a
        /// <see cref="WaitHandle" /> in another application domain.
        /// </exception>
        public static int WaitAny(System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout) { return default(int); }
        /// <summary>
        /// Waits for any of the elements in the specified array to receive a signal, using a
        /// <see cref="TimeSpan" /> to specify the time interval.
        /// </summary>
        /// <param name="waitHandles">
        /// A WaitHandle array containing the objects for which the current instance will wait.
        /// </param>
        /// <param name="timeout">
        /// A <see cref="TimeSpan" /> that represents the number of milliseconds to wait, or
        /// a <see cref="TimeSpan" /> that represents -1 milliseconds to wait indefinitely.
        /// </param>
        /// <returns>
        /// The array index of the object that satisfied the wait, or
        /// <see cref="WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" />
        /// has passed.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// The <paramref name="waitHandles" /> parameter is null.-or-One or more of the objects in the
        /// <paramref name="waitHandles" /> array is null.
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// The number of objects in <paramref name="waitHandles" /> is greater than the system permits.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents
        /// an infinite time-out. -or-<paramref name="timeout" /> is greater than <see cref="Int32.MaxValue" />.
        /// </exception>
        /// <exception cref="AbandonedMutexException">
        /// The wait completed because a thread exited without releasing a mutex. This exception is not
        /// thrown on Windows 98 or Windows Millennium Edition.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="waitHandles" /> is an array with no elements.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// The <paramref name="waitHandles" /> array contains a transparent proxy for a
        /// <see cref="WaitHandle" /> in another application domain.
        /// </exception>
        public static int WaitAny(System.Threading.WaitHandle[] waitHandles, System.TimeSpan timeout) { return default(int); }
        /// <summary>
        /// Blocks the current thread until the current <see cref="WaitHandle" /> receives
        /// a signal.
        /// </summary>
        /// <returns>
        /// true if the current instance receives a signal. If the current instance is never signaled,
        /// <see cref="WaitHandle.WaitOne(Int32,Boolean)" /> never returns.
        /// </returns>
        /// <exception cref="ObjectDisposedException">The current instance has already been disposed.</exception>
        /// <exception cref="AbandonedMutexException">
        /// The wait completed because a thread exited without releasing a mutex. This exception is not
        /// thrown on Windows 98 or Windows Millennium Edition.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// The current instance is a transparent proxy for a <see cref="WaitHandle" />
        /// in another application domain.
        /// </exception>
        public virtual bool WaitOne() { return default(bool); }
        /// <summary>
        /// Blocks the current thread until the current <see cref="WaitHandle" /> receives
        /// a signal, using a 32-bit signed integer to specify the time interval in milliseconds.
        /// </summary>
        /// <param name="millisecondsTimeout">
        /// The number of milliseconds to wait, or <see cref="Timeout.Infinite" />
        /// (-1) to wait indefinitely.
        /// </param>
        /// <returns>
        /// true if the current instance receives a signal; otherwise, false.
        /// </returns>
        /// <exception cref="ObjectDisposedException">The current instance has already been disposed.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents
        /// an infinite time-out.
        /// </exception>
        /// <exception cref="AbandonedMutexException">
        /// The wait completed because a thread exited without releasing a mutex. This exception is not
        /// thrown on Windows 98 or Windows Millennium Edition.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// The current instance is a transparent proxy for a <see cref="WaitHandle" />
        /// in another application domain.
        /// </exception>
        public virtual bool WaitOne(int millisecondsTimeout) { return default(bool); }
        /// <summary>
        /// Blocks the current thread until the current instance receives a signal, using a
        /// <see cref="TimeSpan" /> to specify the time interval.
        /// </summary>
        /// <param name="timeout">
        /// A <see cref="TimeSpan" /> that represents the number of milliseconds to wait, or
        /// a <see cref="TimeSpan" /> that represents -1 milliseconds to wait indefinitely.
        /// </param>
        /// <returns>
        /// true if the current instance receives a signal; otherwise, false.
        /// </returns>
        /// <exception cref="ObjectDisposedException">The current instance has already been disposed.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents
        /// an infinite time-out.-or-<paramref name="timeout" /> is greater than <see cref="Int32.MaxValue" />.
        /// </exception>
        /// <exception cref="AbandonedMutexException">
        /// The wait completed because a thread exited without releasing a mutex. This exception is not
        /// thrown on Windows 98 or Windows Millennium Edition.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// The current instance is a transparent proxy for a <see cref="WaitHandle" />
        /// in another application domain.
        /// </exception>
        public virtual bool WaitOne(System.TimeSpan timeout) { return default(bool); }
    }
}
