using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Xml;
using Microsoft.Build.Framework;

namespace Microsoft.DotNet.Build.Tasks
{
    public class GenerateSlnFile : BuildTask
    {
        [Required]
        public string PathToGenerate { get; set; }
        [Required]
        public string TemplateFile { get; set; }

        private const string CONFIGURATION_PROPS = "Configurations.props";
        public override bool Execute()
        {
            /** 
             * Notes about sln generation:
             * Based on Template Sln File generated by VS2015
             * Some projects don't have file names matching their sln file
             * Some projects don't have test projects or src projects
             * All projects within solution must have a ProjectGUID
             * Depprojs, PkgProjs shouldn't be added to the sln file
            **/
            //expected location of the solution files
            List<string> slnFileLocations = Directory.EnumerateDirectories(PathToGenerate).ToList();
            List<string> slnExclusionList = new List<string>()
            {
                "src\\Native",
                "src\\shims",
                "Microsoft.TargetingPack.Private.CoreCLR",
                "Microsoft.TargetingPack.Private.WinRT",
                "mscorlib.WinRT-Facade",
                "System.Composition.",
                "System.Diagnostics.PerformanceCounter",
                "System.Net.Http.Rtc",
                "System.Numerics.Vectors",
                "System.Relection.Primitives",
                "System.Runtime.CompilerServices.VisualC",
                "System.Runtime.InteropServices.WindowsRuntime",
                "System.Runtime.WindowsRuntime",
                "System.Text.Encoding",
                "System.Xml.ReaderWriter",
                "System.Xml.XDocument",
                "Tools"
            };

            foreach (var slnFile in slnFileLocations)
            {
                if (slnExclusionList.Any(x => slnFile.Contains(x)))
                {
                    continue;
                }
                string fileTemplateContent = File.ReadAllText(TemplateFile);
                //not including ref
                //TODO:Add ref back
                //string pathToRef = "ref";
                string pathToSrc = "src";
                string pathToTest = "tests";
                //will not work on Linux (expected)
                string pathToPerfTest = "tests\\Performance";

                //order of projects
                List<string> projectTypeOrder = new List<string>() { pathToTest, pathToPerfTest, pathToSrc };

                Dictionary<string, ProjectType> mapOfProjectTypes = new Dictionary<string, ProjectType>();

                mapOfProjectTypes.Add(pathToSrc, new ProjectType());
                mapOfProjectTypes.Add(pathToTest, new ProjectType(new List<string>() { "src" }, true, new List<string> { "Performance" }));
                mapOfProjectTypes.Add(pathToPerfTest, new ProjectType(new List<string>() { "src" }));

                Dictionary<string, List<string>> headers = new Dictionary<string, List<string>>();
                string header = string.Empty;

                Dictionary<string, List<SlnProject>> mapOfProjectsToTypes = new Dictionary<string, List<SlnProject>>();

                Dictionary<string, ProjectType> transientMapOfProjectTypes = new Dictionary<string, ProjectType>();
                foreach (var projectType in mapOfProjectTypes)
                {
                    string currentDirectory = Path.Combine(slnFile, projectType.Key);
                    ProjectType currentProjectType = projectType.Value;
                    currentProjectType.Type = projectType.Key;
                    if (Directory.Exists(currentDirectory))
                    {
                        List<string> projFiles =
                            Directory.EnumerateFiles(currentDirectory, "*proj", currentProjectType.SearchRecursively ? SearchOption.AllDirectories : SearchOption.TopDirectoryOnly).ToList();
                        foreach (var projFile in projFiles)
                        {
                            if (currentProjectType.ExclusionStrings != null)
                            {
                                if (currentProjectType.ExclusionStrings.Any(x => projFile.Contains(x)))
                                {
                                    continue;
                                }
                            }
                            currentProjectType.InUse = true;
                            SlnProject currentProject = new SlnProject(ReadProjectGuid(projFile));
                            string configurationProps = Path.Combine(Path.GetDirectoryName(projFile), CONFIGURATION_PROPS);
                            currentProject.configurations = ReadConfigurations(configurationProps);
                            currentProject.Type = projectType.Key;
                            List<SlnProject> projectGuids = new List<SlnProject>();
                            if (mapOfProjectsToTypes.ContainsKey(projectType.Key))
                            {
                                mapOfProjectsToTypes.TryGetValue(projectType.Key, out projectGuids);
                                projectGuids.Add(currentProject);
                            }
                            else
                            {
                                projectGuids.Add(currentProject);
                                mapOfProjectsToTypes[currentProject.Type] = projectGuids;
                            }
                            //ProjectTypeGuids for different projects, pulled from the Visual Studio regkeys
                            //TODO: Clean up or map these to actual projects, this is fragile
                            string slnGuid = "FAE04EC0-301F-11D3-BF4B-00C04F79EFBC"; // Windows (C#)
                            if (projFile.Contains("VisualBasic.vbproj"))
                            {
                                slnGuid = "F184B08F-C81C-45F6-A57F-5ABD9991F28F"; //Windows (VB.NET)
                            }
                            if (projFile.Contains("TestNativeService")) //Windows (Visual C++) 
                            {
                                slnGuid = "8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942";
                            }
                            if (projFile.Contains("WebServer.csproj")) //Web Application
                            {
                                slnGuid = "349C5851-65DF-11DA-9384-00065B846F21";
                            }

                            string projectName = Path.GetFileNameWithoutExtension(projFile);
                            string relativePathFromCurrentDirectory = projFile.Replace(slnFile + Path.DirectorySeparatorChar, "");
                            string projectDefn =
                                $"Project(\"{{{slnGuid}}}\") = \"{projectName}\", \"{relativePathFromCurrentDirectory}\", \"{{{currentProject.projectId}}}\"\r\n";

                            string projectDependency = string.Empty;
                            if (currentProjectType.DependsOn != null)
                            {
                                foreach (var dependency in currentProjectType.DependsOn)
                                {
                                    if (mapOfProjectTypes[dependency].InUse)
                                    {
                                        List<SlnProject> depProjects = null;
                                        mapOfProjectsToTypes.TryGetValue(dependency, out depProjects);
                                        foreach (var depProject in depProjects)
                                        {
                                            string depProjectId = depProject.projectId;
                                            projectDependency =
                                                $"\tProjectSection(ProjectDependencies) = postProject\r\n\t\t{{{depProjectId}}} = {{{depProjectId}}}\r\n";
                                        }
                                    }
                                }
                                if (!string.IsNullOrEmpty(projectDependency))
                                {
                                    projectDependency += "\tEndProjectSection\r\n";
                                }
                            }

                            if (headers.ContainsKey(projectType.Key))
                            {
                                headers[projectType.Key].Add(projectDefn + projectDependency + "EndProject\r\n");
                            }
                            else
                            {
                                headers.Add(projectType.Key, new List<string>() { projectDefn + projectDependency + "EndProject\r\n" });
                            }
                        }
                    }
                    if (transientMapOfProjectTypes.ContainsKey(projectType.Key))
                    {
                        transientMapOfProjectTypes[projectType.Key] = currentProjectType;
                    }
                    else
                    {
                        transientMapOfProjectTypes.Add(projectType.Key, currentProjectType);
                    }
                }

                //resetting order
                mapOfProjectTypes = new Dictionary<string, ProjectType>();
                foreach (var project in projectTypeOrder)
                {
                    mapOfProjectTypes.Add(project, transientMapOfProjectTypes[project]);
                }

                //tests are startup projects
                foreach (var projectType in projectTypeOrder)
                {
                    if (headers.ContainsKey(projectType))
                    {
                        header += string.Join("", headers[projectType].OrderByDescending(i => i).ToArray());
                    }
                }

                string global = "Global\r\n";

                //Generate solution configs
                List<SlnConfig> slnConfigsList = new List<SlnConfig>();

                foreach (var projectType in mapOfProjectTypes)
                {
                    if (mapOfProjectsToTypes.ContainsKey(projectType.Key))
                    {
                        List<SlnProject> projects = mapOfProjectsToTypes[projectType.Key];
                        foreach (var project in projects)
                        {
                            List<string> configsList = project.configurations;
                            if (slnConfigsList.Count > 0)
                            {
                                List<SlnConfig> copySlnConfigsList = new List<SlnConfig>();
                                bool allowAppendToSlnConfig = false;
                                foreach (string config in configsList)
                                {
                                    foreach (SlnConfig slnConfig in slnConfigsList)
                                    {
                                        SlnConfig newSlnConfig = new SlnConfig(slnConfig);
                                        //In case this is a second project with a different set of configurations
                                        if (newSlnConfig.MapTypeToConfig.ContainsKey(projectType.Key))
                                        {
                                            //need to make copies to allow overwriting this value.
                                            allowAppendToSlnConfig = true;
                                            break;
                                        }
                                        newSlnConfig.AddConfigToType(projectType.Key, config.Trim());
                                        copySlnConfigsList.Add(newSlnConfig);
                                    }
                                    if (allowAppendToSlnConfig)
                                    {
                                        break;
                                    }
                                }
                                if (allowAppendToSlnConfig)
                                {
                                    GenerateSlnConfigs(configsList, projectTypeOrder, projectType, copySlnConfigsList);
                                }
                                if (copySlnConfigsList.Count > 0)
                                {
                                    if (allowAppendToSlnConfig)
                                    {
                                        allowAppendToSlnConfig = false;
                                        slnConfigsList.AddRange(copySlnConfigsList);
                                    }
                                    else
                                    {
                                        slnConfigsList = new List<SlnConfig>(copySlnConfigsList);
                                    }
                                }
                            }
                            else
                            {
                                GenerateSlnConfigs(configsList, projectTypeOrder, projectType, slnConfigsList);
                            }
                        }
                    }
                }

                string globalSectionForSlnConfiguration = "\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\r\n";
                List<string> sequencingSlnConfigurationList = new List<string>();
                foreach (var slnConfig in slnConfigsList)
                {
                    sequencingSlnConfigurationList.Add($"\t\t{slnConfig.ToString()} = {slnConfig.ToString()}\r\n");
                }
                globalSectionForSlnConfiguration += string.Join("", sequencingSlnConfigurationList.OrderBy(i => i).ToArray());
                globalSectionForSlnConfiguration += "\tEndGlobalSection\r\n";

                //generate mapping of project to config
                string globalSectionForProjectConfiguration =
                    "\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\r\n";

                foreach (var projectType in projectTypeOrder)
                {
                    List<string> sequencingProjectConfigurationList = new List<string>();
                    if (mapOfProjectsToTypes.ContainsKey(projectType))
                    {
                        List<SlnProject> projectsInType = mapOfProjectsToTypes[projectType];
                        foreach (SlnProject projectInType in projectsInType)
                        {
                            foreach (var slnConfig in slnConfigsList)
                            {
                                if (projectInType.configurations != null)
                                {
                                    foreach (var projectConfiguration in projectInType.configurations)
                                    {
                                        if (slnConfig.MapTypeToConfig[projectInType.Type].Equals(projectConfiguration))
                                        {
                                            sequencingProjectConfigurationList.Add(
                                                $"\t\t{{{projectInType.projectId}}}.{slnConfig.ToString()}.ActiveCfg = {slnConfig.MapTypeToConfig[projectInType.Type]}-{slnConfig.configurationGroup}|Any CPU\r\n");
                                            sequencingProjectConfigurationList.Add(
                                                $"\t\t{{{projectInType.projectId}}}.{slnConfig.ToString()}.Build.0 = {slnConfig.MapTypeToConfig[projectInType.Type]}-{slnConfig.configurationGroup}|Any CPU\r\n");
                                        }
                                        else
                                        {
                                            if (mapOfProjectsToTypes[projectType].Count > 1)
                                            {
                                                sequencingProjectConfigurationList.Add(
                                                    $"\t\t{{{projectInType.projectId}}}.{slnConfig.ToString()}.ActiveCfg = {projectConfiguration}-Release|Any CPU\r\n");
                                                sequencingProjectConfigurationList.Add(
                                                    $"\t\t{{{projectInType.projectId}}}.{slnConfig.ToString()}.Build.0 = {projectConfiguration}-Release|Any CPU\r\n");
                                            }
                                        }
                                    }
                                }
                                else
                                {
                                    sequencingProjectConfigurationList.Add(
                                                $"\t\t{{{projectInType.projectId}}}.{slnConfig.ToString()}.ActiveCfg = {slnConfig.configurationGroup}|Any CPU\r\n");
                                    sequencingProjectConfigurationList.Add(
                                        $"\t\t{{{projectInType.projectId}}}.{slnConfig.ToString()}.Build.0 = {slnConfig.configurationGroup}|Any CPU\r\n");
                                }
                            }
                        }
                    }
                    globalSectionForProjectConfiguration += string.Join("", sequencingProjectConfigurationList.OrderBy(i => i).ToArray());
                }
                globalSectionForProjectConfiguration += "\tEndGlobalSection";

                //Write section
                string fileTemplateContentPre = fileTemplateContent.Substring(0, fileTemplateContent.IndexOf(global));
                string fileTemplateContentPost = fileTemplateContent.Substring(fileTemplateContentPre.Length + global.Length - 1, fileTemplateContent.Length - fileTemplateContentPre.Length - global.Length + 1);
                fileTemplateContent = fileTemplateContentPre + header + global + globalSectionForSlnConfiguration + globalSectionForProjectConfiguration + fileTemplateContentPost;
                File.WriteAllText(Path.Combine(slnFile, Path.GetFileName(slnFile) + ".sln"), fileTemplateContent);
            }

            return !Log.HasLoggedErrors;
        }

        private void GenerateSlnConfigs(List<string> configsList, List<string> projectTypeOrder, KeyValuePair<string, ProjectType> projectType,
            List<SlnConfig> slnConfigsList)
        {
            foreach (string config in configsList)
            {
                SlnConfig newSlnConfigDebug = new SlnConfig();
                newSlnConfigDebug.projectOrder = projectTypeOrder;
                newSlnConfigDebug.AddConfigToType(projectType.Key, config.Trim());
                //Defaulting Execution to NETCoreApp
                newSlnConfigDebug.AddConfigToType("runner", "NETCoreApp");
                newSlnConfigDebug.configurationGroup = "Debug";
                slnConfigsList.Add(newSlnConfigDebug);

                SlnConfig newSlnConfigRelease = new SlnConfig();
                newSlnConfigRelease.projectOrder = projectTypeOrder;
                newSlnConfigRelease.AddConfigToType(projectType.Key, config.Trim());
                //Defaulting Execution to NETCoreApp
                newSlnConfigRelease.AddConfigToType("runner", "NETCoreApp");
                newSlnConfigRelease.configurationGroup = "Release";
                slnConfigsList.Add(newSlnConfigRelease);
            }
        }

        private static string ReadProjectGuid(string projFile)
        {
            XmlDocument xmldoc = new XmlDocument();
            string value = string.Empty;
            using (TextReader reader = new StreamReader(File.OpenRead(projFile)))
            {
                xmldoc.Load(reader);
                XmlNamespaceManager mgr = new XmlNamespaceManager(xmldoc.NameTable);
                mgr.AddNamespace("x", "http://schemas.microsoft.com/developer/msbuild/2003");
                try
                {
                    value = xmldoc.SelectSingleNode("//x:ProjectGuid", mgr).InnerText;
                    value = value.Substring(1, value.Length - 2);
                }
                catch (System.NullReferenceException)
                {
                    value = AddProjectGuid(projFile, xmldoc);
                }
            }
            return value;
        }

        private static string AddProjectGuid(string projFile, XmlDocument xmldoc)
        {
            string value = System.Guid.NewGuid().ToString().ToUpper();
            //add projectguid to projFile
            XmlElement propertyGroup = xmldoc.CreateElement("PropertyGroup", xmldoc.DocumentElement.NamespaceURI);
            XmlElement projectGuid = xmldoc.CreateElement("ProjectGuid", xmldoc.DocumentElement.NamespaceURI);
            projectGuid.InnerText = $"{{{value}}}";
            propertyGroup.AppendChild(projectGuid);
            xmldoc.DocumentElement.AppendChild(propertyGroup);
            using (TextWriter reader = new StreamWriter(File.OpenWrite(projFile)))
            {
                xmldoc.Save(reader);
            }
            return value;
        }

        private static List<string> ReadConfigurations(string srcConfigurationProps)
        {
            List<string> vsConfigs = new List<string>();
            if (File.Exists(srcConfigurationProps))
            {
                string projConfigurationContents = File.ReadAllText(srcConfigurationProps);

                var configCollection = Regex.Matches(projConfigurationContents,
                    "<BuildConfigurations>(.*?)</BuildConfigurations>", RegexOptions.Singleline);

                string[] configs = null;
                foreach (Match configGroup in configCollection)
                {
                    configs = configGroup.Groups[1].Value.Replace("\r\n", "")
                        .Trim()
                        .Split(new char[] { ';' }, System.StringSplitOptions.RemoveEmptyEntries);
                }
                foreach (var config in configs)
                {
                    if (!config.Contains("Empty") && !config.Contains("empty") && !config.Contains("!--") &&
                        !config.Contains("even need it"))
                    {
                        vsConfigs.Add(config.Trim());
                    }
                }
            }
            return vsConfigs;
        }
    }

    internal class ProjectType
    {
        public string Type { get; set; }
        public bool InUse { get; set; }
        public List<string> DependsOn;
        public bool SearchRecursively;
        public List<string> ExclusionStrings;
        public ProjectType(List<string> dependsOnList = null, bool searchRecursively = false, List<string> exclusionStrings = null)
        {
            InUse = false;
            DependsOn = dependsOnList;
            SearchRecursively = searchRecursively;
            ExclusionStrings = exclusionStrings;
        }
    }

    internal class SlnProject
    {
        public string Type { get; set; }
        public string projectId { get; }
        public List<string> configurations { get; set; }

        public SlnProject(string guid)
        {
            projectId = guid;
        }
    }

    internal class SlnConfig
    {
        public Dictionary<string, string> MapTypeToConfig = new Dictionary<string, string>();
        public string configurationGroup { get; set; }

        public List<string> projectOrder = new List<string>();

        public SlnConfig()
        {

        }
        public SlnConfig(SlnConfig prevSlnConfig)
        {
            MapTypeToConfig = new Dictionary<string, string>(prevSlnConfig.MapTypeToConfig);
            configurationGroup = prevSlnConfig.configurationGroup;
            projectOrder = new List<string>(prevSlnConfig.projectOrder);
        }

        public override string ToString()
        {
            string configString = string.Empty;
            if (MapTypeToConfig.ContainsKey("runner"))
            {
                configString += MapTypeToConfig["runner"];
            }
            if (projectOrder.Count > 0)
            {
                foreach (var type in projectOrder)
                {
                    if (MapTypeToConfig.ContainsKey(type))
                    {
                        configString += MapTypeToConfig[type];
                    }
                }

            }
            else
            {
                foreach (var type in MapTypeToConfig)
                {
                    configString += type.Value;
                }
            }
            return $"{configurationGroup}{configString}|AnyCPU";
        }

        public void AddConfigToType(string config, string type)
        {
            MapTypeToConfig.Add(config, type);
        }
    }
}
