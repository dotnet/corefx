//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34014
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Resources {
    using System;
    using System.Reflection;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Strings {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Strings() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Resources.Strings", typeof(Strings).GetTypeInfo().Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to FileStream will not open Win32 devices such as disk partitions and tape drives. Avoid use of &apos;\\.\&apos; in the path..
        /// </summary>
        internal static string Arg_DevicesNotSupported {
            get {
                return ResourceManager.GetString("Arg_DevicesNotSupported", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The target file &apos;{0}&apos; is a directory, not a file..
        /// </summary>
        internal static string Arg_FileIsDirectory_Name {
            get {
                return ResourceManager.GetString("Arg_FileIsDirectory_Name", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Handle does not support asynchronous operations. The parameters to the FileStream constructor may need to be changed to indicate that the handle was opened synchronously (that is, it was not opened for overlapped I/O)..
        /// </summary>
        internal static string Arg_HandleNotAsync {
            get {
                return ResourceManager.GetString("Arg_HandleNotAsync", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Handle does not support synchronous operations. The parameters to the FileStream constructor may need to be changed to indicate that the handle was opened asynchronously (that is, it was opened explicitly for overlapped I/O)..
        /// </summary>
        internal static string Arg_HandleNotSync {
            get {
                return ResourceManager.GetString("Arg_HandleNotSync", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Invalid File or Directory attributes value..
        /// </summary>
        internal static string Arg_InvalidFileAttrs {
            get {
                return ResourceManager.GetString("Arg_InvalidFileAttrs", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Invalid handle..
        /// </summary>
        internal static string Arg_InvalidHandle {
            get {
                return ResourceManager.GetString("Arg_InvalidHandle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Search pattern cannot contain &apos;..&apos; to move up directories and can be contained only internally in file/directory names, as in &apos;a..b&apos;..
        /// </summary>
        internal static string Arg_InvalidSearchPattern {
            get {
                return ResourceManager.GetString("Arg_InvalidSearchPattern", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Second path fragment must not be a drive or UNC name..
        /// </summary>
        internal static string Arg_Path2IsRooted {
            get {
                return ResourceManager.GetString("Arg_Path2IsRooted", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Path must not be a drive..
        /// </summary>
        internal static string Arg_PathIsVolume {
            get {
                return ResourceManager.GetString("Arg_PathIsVolume", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to IAsyncResult object did not come from the corresponding async method on this type..
        /// </summary>
        internal static string Arg_WrongAsyncResult {
            get {
                return ResourceManager.GetString("Arg_WrongAsyncResult", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Empty file name is not legal..
        /// </summary>
        internal static string Argument_EmptyFileName {
            get {
                return ResourceManager.GetString("Argument_EmptyFileName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Empty path name is not legal..
        /// </summary>
        internal static string Argument_EmptyPath {
            get {
                return ResourceManager.GetString("Argument_EmptyPath", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Append access can be requested only in write-only mode..
        /// </summary>
        internal static string Argument_InvalidAppendMode {
            get {
                return ResourceManager.GetString("Argument_InvalidAppendMode", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Combining FileMode: {0} with FileAccess: {1} is invalid..
        /// </summary>
        internal static string Argument_InvalidFileModeAndAccessCombo {
            get {
                return ResourceManager.GetString("Argument_InvalidFileModeAndAccessCombo", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection..
        /// </summary>
        internal static string Argument_InvalidOffLen {
            get {
                return ResourceManager.GetString("Argument_InvalidOffLen", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Illegal characters in path..
        /// </summary>
        internal static string Argument_InvalidPathChars {
            get {
                return ResourceManager.GetString("Argument_InvalidPathChars", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Invalid seek origin..
        /// </summary>
        internal static string Argument_InvalidSeekOrigin {
            get {
                return ResourceManager.GetString("Argument_InvalidSeekOrigin", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The directory specified, &apos;{0}&apos;, is not a subdirectory of &apos;{1}&apos;..
        /// </summary>
        internal static string Argument_InvalidSubPath {
            get {
                return ResourceManager.GetString("Argument_InvalidSubPath", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Path cannot be the empty string or all whitespace..
        /// </summary>
        internal static string Argument_PathEmpty {
            get {
                return ResourceManager.GetString("Argument_PathEmpty", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The given path&apos;s format is not supported..
        /// </summary>
        internal static string Argument_PathFormatNotSupported {
            get {
                return ResourceManager.GetString("Argument_PathFormatNotSupported", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Buffer cannot be null..
        /// </summary>
        internal static string ArgumentNull_Buffer {
            get {
                return ResourceManager.GetString("ArgumentNull_Buffer", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to File name cannot be null..
        /// </summary>
        internal static string ArgumentNull_FileName {
            get {
                return ResourceManager.GetString("ArgumentNull_FileName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Path cannot be null..
        /// </summary>
        internal static string ArgumentNull_Path {
            get {
                return ResourceManager.GetString("ArgumentNull_Path", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Enum value was out of legal range..
        /// </summary>
        internal static string ArgumentOutOfRange_Enum {
            get {
                return ResourceManager.GetString("ArgumentOutOfRange_Enum", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Specified file length was too large for the file system..
        /// </summary>
        internal static string ArgumentOutOfRange_FileLengthTooBig {
            get {
                return ResourceManager.GetString("ArgumentOutOfRange_FileLengthTooBig", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Specified handle value was out of range for the file system..
        /// </summary>
        internal static string ArgumentOutOfRange_NeedNonNegInt32Range {
            get {
                return ResourceManager.GetString("ArgumentOutOfRange_NeedNonNegInt32Range", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Non-negative number required..
        /// </summary>
        internal static string ArgumentOutOfRange_NeedNonNegNum {
            get {
                return ResourceManager.GetString("ArgumentOutOfRange_NeedNonNegNum", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Positive number required..
        /// </summary>
        internal static string ArgumentOutOfRange_NeedPosNum {
            get {
                return ResourceManager.GetString("ArgumentOutOfRange_NeedPosNum", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Probable I/O race condition detected while copying memory. The I/O package is not thread safe by default. In multithreaded applications, a stream must be accessed in a thread-safe way, such as a thread-safe wrapper returned by TextReader&apos;s or TextWriter&apos;s Synchronized methods. This also applies to classes like StreamWriter and StreamReader..
        /// </summary>
        internal static string IndexOutOfRange_IORaceCondition {
            get {
                return ResourceManager.GetString("IndexOutOfRange_IORaceCondition", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to EndRead can only be called once for each asynchronous operation..
        /// </summary>
        internal static string InvalidOperation_EndReadCalledMultiple {
            get {
                return ResourceManager.GetString("InvalidOperation_EndReadCalledMultiple", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to EndWrite can only be called once for each asynchronous operation..
        /// </summary>
        internal static string InvalidOperation_EndWriteCalledMultiple {
            get {
                return ResourceManager.GetString("InvalidOperation_EndWriteCalledMultiple", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Either the IAsyncResult object did not come from the corresponding async method on this type, or EndRead was called multiple times with the same IAsyncResult..
        /// </summary>
        internal static string InvalidOperation_WrongAsyncResultOrEndReadCalledMultiple {
            get {
                return ResourceManager.GetString("InvalidOperation_WrongAsyncResultOrEndReadCalledMultiple", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Either the IAsyncResult object did not come from the corresponding async method on this type, or EndWrite was called multiple times with the same IAsyncResult..
        /// </summary>
        internal static string InvalidOperation_WrongAsyncResultOrEndWriteCalledMultiple {
            get {
                return ResourceManager.GetString("InvalidOperation_WrongAsyncResultOrEndWriteCalledMultiple", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Cannot create &apos;{0}&apos; because a file or directory with the same name already exists..
        /// </summary>
        internal static string IO_AlreadyExists_Name {
            get {
                return ResourceManager.GetString("IO_AlreadyExists_Name", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to BindHandle for ThreadPool failed on this handle..
        /// </summary>
        internal static string IO_BindHandleFailed {
            get {
                return ResourceManager.GetString("IO_BindHandleFailed", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The specified directory &apos;{0}&apos; cannot be created..
        /// </summary>
        internal static string IO_CannotCreateDirectory {
            get {
                return ResourceManager.GetString("IO_CannotCreateDirectory", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unable to read beyond the end of the stream..
        /// </summary>
        internal static string IO_EOF_ReadBeyondEOF {
            get {
                return ResourceManager.GetString("IO_EOF_ReadBeyondEOF", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The file &apos;{0}&apos; already exists..
        /// </summary>
        internal static string IO_FileExists_Name {
            get {
                return ResourceManager.GetString("IO_FileExists_Name", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unable to find the specified file..
        /// </summary>
        internal static string IO_FileNotFound {
            get {
                return ResourceManager.GetString("IO_FileNotFound", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Could not find file &apos;{0}&apos;..
        /// </summary>
        internal static string IO_FileNotFound_FileName {
            get {
                return ResourceManager.GetString("IO_FileNotFound_FileName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The OS handle&apos;s position is not what FileStream expected. Do not use a handle simultaneously in one FileStream and in Win32 code or another FileStream. This may cause data loss..
        /// </summary>
        internal static string IO_FileStreamHandlePosition {
            get {
                return ResourceManager.GetString("IO_FileStreamHandlePosition", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The file is too long. This operation is currently limited to supporting files less than 2 gigabytes in size..
        /// </summary>
        internal static string IO_FileTooLong2GB {
            get {
                return ResourceManager.GetString("IO_FileTooLong2GB", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to IO operation will not work. Most likely the file will become too long or the handle was not opened to support synchronous IO operations..
        /// </summary>
        internal static string IO_FileTooLongOrHandleNotSync {
            get {
                return ResourceManager.GetString("IO_FileTooLongOrHandleNotSync", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Could not find a part of the path..
        /// </summary>
        internal static string IO_PathNotFound_NoPathName {
            get {
                return ResourceManager.GetString("IO_PathNotFound_NoPathName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Could not find a part of the path &apos;{0}&apos;..
        /// </summary>
        internal static string IO_PathNotFound_Path {
            get {
                return ResourceManager.GetString("IO_PathNotFound_Path", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The specified path, file name, or both are too long. The fully qualified file name must be less than 260 characters, and the directory name must be less than 248 characters..
        /// </summary>
        internal static string IO_PathTooLong {
            get {
                return ResourceManager.GetString("IO_PathTooLong", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unable seek backward to overwrite data that previously existed in a file opened in Append mode..
        /// </summary>
        internal static string IO_SeekAppendOverwrite {
            get {
                return ResourceManager.GetString("IO_SeekAppendOverwrite", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unable to truncate data that previously existed in a file opened in Append mode..
        /// </summary>
        internal static string IO_SetLengthAppendTruncate {
            get {
                return ResourceManager.GetString("IO_SetLengthAppendTruncate", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The process cannot access the file &apos;{0}&apos; because it is being used by another process..
        /// </summary>
        internal static string IO_SharingViolation_File {
            get {
                return ResourceManager.GetString("IO_SharingViolation_File", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The process cannot access the file because it is being used by another process..
        /// </summary>
        internal static string IO_SharingViolation_NoFileName {
            get {
                return ResourceManager.GetString("IO_SharingViolation_NoFileName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Source and destination path must be different..
        /// </summary>
        internal static string IO_SourceDestMustBeDifferent {
            get {
                return ResourceManager.GetString("IO_SourceDestMustBeDifferent", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Source and destination path must have identical roots. Move will not work across volumes..
        /// </summary>
        internal static string IO_SourceDestMustHaveSameRoot {
            get {
                return ResourceManager.GetString("IO_SourceDestMustHaveSameRoot", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Synchronous operations should not be performed on the UI thread.  Consider wrapping this method in Task.Run..
        /// </summary>
        internal static string IO_SyncOpOnUIThread {
            get {
                return ResourceManager.GetString("IO_SyncOpOnUIThread", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to [Unknown].
        /// </summary>
        internal static string IO_UnknownFileName {
            get {
                return ResourceManager.GetString("IO_UnknownFileName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to FileStream was asked to open a device that was not a file. For support for devices like &apos;com1:&apos; or &apos;lpt1:&apos;, call CreateFile, then use the FileStream constructors that take an OS handle as an IntPtr..
        /// </summary>
        internal static string NotSupported_FileStreamOnNonFiles {
            get {
                return ResourceManager.GetString("NotSupported_FileStreamOnNonFiles", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Stream does not support reading..
        /// </summary>
        internal static string NotSupported_UnreadableStream {
            get {
                return ResourceManager.GetString("NotSupported_UnreadableStream", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Stream does not support seeking..
        /// </summary>
        internal static string NotSupported_UnseekableStream {
            get {
                return ResourceManager.GetString("NotSupported_UnseekableStream", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Stream does not support writing..
        /// </summary>
        internal static string NotSupported_UnwritableStream {
            get {
                return ResourceManager.GetString("NotSupported_UnwritableStream", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Cannot access a closed file..
        /// </summary>
        internal static string ObjectDisposed_FileClosed {
            get {
                return ResourceManager.GetString("ObjectDisposed_FileClosed", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Access to the path is denied..
        /// </summary>
        internal static string UnauthorizedAccess_IODenied_NoPathName {
            get {
                return ResourceManager.GetString("UnauthorizedAccess_IODenied_NoPathName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Access to the path &apos;{0}&apos; is denied..
        /// </summary>
        internal static string UnauthorizedAccess_IODenied_Path {
            get {
                return ResourceManager.GetString("UnauthorizedAccess_IODenied_Path", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unknown error &apos;{0}&apos;..
        /// </summary>
        internal static string UnknownError_Num {
            get {
                return ResourceManager.GetString("UnknownError_Num", resourceCulture);
            }
        }
    }
}
