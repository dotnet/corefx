// This is auto generated file. Please donâ€™t modify manually.
// The file is generated as part of the build through the ResourceGenerator tool 
// which takes the project resx resource file and generated this source code file.
// By default the tool will use Resources\Strings.resx but projects can customize
// that by overriding the StringResourcesPath property group.
namespace System
{
    internal static partial class SR
    {
#pragma warning disable 0414
        private const string s_resourcesName = "System.Collections.Concurrent.resources"; // assembly Name + .resources
#pragma warning restore 0414

#if !DEBUGRESOURCES
        internal static string BlockingCollection_Add_ConcurrentCompleteAdd {
              get { return SR.GetResourceString("BlockingCollection_Add_ConcurrentCompleteAdd", null); }
        }
        internal static string BlockingCollection_Add_Failed {
              get { return SR.GetResourceString("BlockingCollection_Add_Failed", null); }
        }
        internal static string BlockingCollection_CantAddAnyWhenCompleted {
              get { return SR.GetResourceString("BlockingCollection_CantAddAnyWhenCompleted", null); }
        }
        internal static string BlockingCollection_CantTakeAnyWhenAllDone {
              get { return SR.GetResourceString("BlockingCollection_CantTakeAnyWhenAllDone", null); }
        }
        internal static string BlockingCollection_CantTakeWhenDone {
              get { return SR.GetResourceString("BlockingCollection_CantTakeWhenDone", null); }
        }
        internal static string BlockingCollection_Completed {
              get { return SR.GetResourceString("BlockingCollection_Completed", null); }
        }
        internal static string BlockingCollection_CopyTo_IncorrectType {
              get { return SR.GetResourceString("BlockingCollection_CopyTo_IncorrectType", null); }
        }
        internal static string BlockingCollection_CopyTo_MultiDim {
              get { return SR.GetResourceString("BlockingCollection_CopyTo_MultiDim", null); }
        }
        internal static string BlockingCollection_CopyTo_NonNegative {
              get { return SR.GetResourceString("BlockingCollection_CopyTo_NonNegative", null); }
        }
        internal static string BlockingCollection_CopyTo_TooManyElems {
              get { return SR.GetResourceString("BlockingCollection_CopyTo_TooManyElems", null); }
        }
        internal static string BlockingCollection_ctor_BoundedCapacityRange {
              get { return SR.GetResourceString("BlockingCollection_ctor_BoundedCapacityRange", null); }
        }
        internal static string BlockingCollection_ctor_CountMoreThanCapacity {
              get { return SR.GetResourceString("BlockingCollection_ctor_CountMoreThanCapacity", null); }
        }
        internal static string BlockingCollection_Disposed {
              get { return SR.GetResourceString("BlockingCollection_Disposed", null); }
        }
        internal static string BlockingCollection_Take_CollectionModified {
              get { return SR.GetResourceString("BlockingCollection_Take_CollectionModified", null); }
        }
        internal static string BlockingCollection_TimeoutInvalid {
              get { return SR.GetResourceString("BlockingCollection_TimeoutInvalid", null); }
        }
        internal static string BlockingCollection_ValidateCollectionsArray_DispElems {
              get { return SR.GetResourceString("BlockingCollection_ValidateCollectionsArray_DispElems", null); }
        }
        internal static string BlockingCollection_ValidateCollectionsArray_LargeSize {
              get { return SR.GetResourceString("BlockingCollection_ValidateCollectionsArray_LargeSize", null); }
        }
        internal static string BlockingCollection_ValidateCollectionsArray_NullElems {
              get { return SR.GetResourceString("BlockingCollection_ValidateCollectionsArray_NullElems", null); }
        }
        internal static string BlockingCollection_ValidateCollectionsArray_ZeroSize {
              get { return SR.GetResourceString("BlockingCollection_ValidateCollectionsArray_ZeroSize", null); }
        }
        internal static string Common_OperationCanceled {
              get { return SR.GetResourceString("Common_OperationCanceled", null); }
        }
        internal static string ConcurrentBag_Ctor_ArgumentNullException {
              get { return SR.GetResourceString("ConcurrentBag_Ctor_ArgumentNullException", null); }
        }
        internal static string ConcurrentBag_CopyTo_ArgumentNullException {
              get { return SR.GetResourceString("ConcurrentBag_CopyTo_ArgumentNullException", null); }
        }
        internal static string ConcurrentBag_CopyTo_ArgumentOutOfRangeException {
              get { return SR.GetResourceString("ConcurrentBag_CopyTo_ArgumentOutOfRangeException", null); }
        }
        internal static string ConcurrentCollection_SyncRoot_NotSupported {
              get { return SR.GetResourceString("ConcurrentCollection_SyncRoot_NotSupported", null); }
        }
        internal static string ConcurrentDictionary_ArrayIncorrectType {
              get { return SR.GetResourceString("ConcurrentDictionary_ArrayIncorrectType", null); }
        }
        internal static string ConcurrentDictionary_SourceContainsDuplicateKeys {
              get { return SR.GetResourceString("ConcurrentDictionary_SourceContainsDuplicateKeys", null); }
        }
        internal static string ConcurrentDictionary_ConcurrencyLevelMustBePositive {
              get { return SR.GetResourceString("ConcurrentDictionary_ConcurrencyLevelMustBePositive", null); }
        }
        internal static string ConcurrentDictionary_CapacityMustNotBeNegative {
              get { return SR.GetResourceString("ConcurrentDictionary_CapacityMustNotBeNegative", null); }
        }
        internal static string ConcurrentDictionary_IndexIsNegative {
              get { return SR.GetResourceString("ConcurrentDictionary_IndexIsNegative", null); }
        }
        internal static string ConcurrentDictionary_ArrayNotLargeEnough {
              get { return SR.GetResourceString("ConcurrentDictionary_ArrayNotLargeEnough", null); }
        }
        internal static string ConcurrentDictionary_KeyAlreadyExisted {
              get { return SR.GetResourceString("ConcurrentDictionary_KeyAlreadyExisted", null); }
        }
        internal static string ConcurrentDictionary_ItemKeyIsNull {
              get { return SR.GetResourceString("ConcurrentDictionary_ItemKeyIsNull", null); }
        }
        internal static string ConcurrentDictionary_TypeOfKeyIncorrect {
              get { return SR.GetResourceString("ConcurrentDictionary_TypeOfKeyIncorrect", null); }
        }
        internal static string ConcurrentDictionary_TypeOfValueIncorrect {
              get { return SR.GetResourceString("ConcurrentDictionary_TypeOfValueIncorrect", null); }
        }
        internal static string ConcurrentStack_PushPopRange_CountOutOfRange {
              get { return SR.GetResourceString("ConcurrentStack_PushPopRange_CountOutOfRange", null); }
        }
        internal static string ConcurrentStack_PushPopRange_InvalidCount {
              get { return SR.GetResourceString("ConcurrentStack_PushPopRange_InvalidCount", null); }
        }
        internal static string ConcurrentStack_PushPopRange_StartOutOfRange {
              get { return SR.GetResourceString("ConcurrentStack_PushPopRange_StartOutOfRange", null); }
        }
        internal static string Partitioner_DynamicPartitionsNotSupported {
              get { return SR.GetResourceString("Partitioner_DynamicPartitionsNotSupported", null); }
        }
        internal static string PartitionerStatic_CanNotCallGetEnumeratorAfterSourceHasBeenDisposed {
              get { return SR.GetResourceString("PartitionerStatic_CanNotCallGetEnumeratorAfterSourceHasBeenDisposed", null); }
        }
        internal static string PartitionerStatic_CurrentCalledBeforeMoveNext {
              get { return SR.GetResourceString("PartitionerStatic_CurrentCalledBeforeMoveNext", null); }
        }
#else
        internal static string BlockingCollection_Add_ConcurrentCompleteAdd {
              get { return SR.GetResourceString("BlockingCollection_Add_ConcurrentCompleteAdd", @"CompleteAdding may not be used concurrently with additions to the collection."); }
        }
        internal static string BlockingCollection_Add_Failed {
              get { return SR.GetResourceString("BlockingCollection_Add_Failed", @"The underlying collection didn't accept the item."); }
        }
        internal static string BlockingCollection_CantAddAnyWhenCompleted {
              get { return SR.GetResourceString("BlockingCollection_CantAddAnyWhenCompleted", @"At least one of the specified collections is marked as complete with regards to additions."); }
        }
        internal static string BlockingCollection_CantTakeAnyWhenAllDone {
              get { return SR.GetResourceString("BlockingCollection_CantTakeAnyWhenAllDone", @"All collections are marked as complete with regards to additions."); }
        }
        internal static string BlockingCollection_CantTakeWhenDone {
              get { return SR.GetResourceString("BlockingCollection_CantTakeWhenDone", @"The collection argument is empty and has been marked as complete with regards to additions."); }
        }
        internal static string BlockingCollection_Completed {
              get { return SR.GetResourceString("BlockingCollection_Completed", @"The collection has been marked as complete with regards to additions."); }
        }
        internal static string BlockingCollection_CopyTo_IncorrectType {
              get { return SR.GetResourceString("BlockingCollection_CopyTo_IncorrectType", @"The array argument is of the incorrect type."); }
        }
        internal static string BlockingCollection_CopyTo_MultiDim {
              get { return SR.GetResourceString("BlockingCollection_CopyTo_MultiDim", @"The array argument is multidimensional."); }
        }
        internal static string BlockingCollection_CopyTo_NonNegative {
              get { return SR.GetResourceString("BlockingCollection_CopyTo_NonNegative", @"The index argument must be greater than or equal zero."); }
        }
        internal static string BlockingCollection_CopyTo_TooManyElems {
              get { return SR.GetResourceString("BlockingCollection_CopyTo_TooManyElems", @"The number of elements in the collection is greater than the available space from index to the end of the destination array."); }
        }
        internal static string BlockingCollection_ctor_BoundedCapacityRange {
              get { return SR.GetResourceString("BlockingCollection_ctor_BoundedCapacityRange", @"The boundedCapacity argument must be positive."); }
        }
        internal static string BlockingCollection_ctor_CountMoreThanCapacity {
              get { return SR.GetResourceString("BlockingCollection_ctor_CountMoreThanCapacity", @"The collection argument contains more items than are allowed by the boundedCapacity."); }
        }
        internal static string BlockingCollection_Disposed {
              get { return SR.GetResourceString("BlockingCollection_Disposed", @"The collection has been disposed."); }
        }
        internal static string BlockingCollection_Take_CollectionModified {
              get { return SR.GetResourceString("BlockingCollection_Take_CollectionModified", @"The underlying collection was modified from outside of the BlockingCollection<T>."); }
        }
        internal static string BlockingCollection_TimeoutInvalid {
              get { return SR.GetResourceString("BlockingCollection_TimeoutInvalid", @"The specified timeout must represent a value between -1 and {0}, inclusive."); }
        }
        internal static string BlockingCollection_ValidateCollectionsArray_DispElems {
              get { return SR.GetResourceString("BlockingCollection_ValidateCollectionsArray_DispElems", @"The collections argument contains at least one disposed element."); }
        }
        internal static string BlockingCollection_ValidateCollectionsArray_LargeSize {
              get { return SR.GetResourceString("BlockingCollection_ValidateCollectionsArray_LargeSize", @"The collections length is greater than the supported range for 32 bit machine."); }
        }
        internal static string BlockingCollection_ValidateCollectionsArray_NullElems {
              get { return SR.GetResourceString("BlockingCollection_ValidateCollectionsArray_NullElems", @"The collections argument contains at least one null element."); }
        }
        internal static string BlockingCollection_ValidateCollectionsArray_ZeroSize {
              get { return SR.GetResourceString("BlockingCollection_ValidateCollectionsArray_ZeroSize", @"The collections argument is a zero-length array."); }
        }
        internal static string Common_OperationCanceled {
              get { return SR.GetResourceString("Common_OperationCanceled", @"The operation was canceled."); }
        }
        internal static string ConcurrentBag_Ctor_ArgumentNullException {
              get { return SR.GetResourceString("ConcurrentBag_Ctor_ArgumentNullException", @"The collection argument is null."); }
        }
        internal static string ConcurrentBag_CopyTo_ArgumentNullException {
              get { return SR.GetResourceString("ConcurrentBag_CopyTo_ArgumentNullException", @"The array argument is null."); }
        }
        internal static string ConcurrentBag_CopyTo_ArgumentOutOfRangeException {
              get { return SR.GetResourceString("ConcurrentBag_CopyTo_ArgumentOutOfRangeException", @"The index argument must be greater than or equal zero."); }
        }
        internal static string ConcurrentCollection_SyncRoot_NotSupported {
              get { return SR.GetResourceString("ConcurrentCollection_SyncRoot_NotSupported", @"The SyncRoot property may not be used for the synchronization of concurrent collections."); }
        }
        internal static string ConcurrentDictionary_ArrayIncorrectType {
              get { return SR.GetResourceString("ConcurrentDictionary_ArrayIncorrectType", @"The array is multidimensional, or the type parameter for the set cannot be cast automatically to the type of the destination array."); }
        }
        internal static string ConcurrentDictionary_SourceContainsDuplicateKeys {
              get { return SR.GetResourceString("ConcurrentDictionary_SourceContainsDuplicateKeys", @"The source argument contains duplicate keys."); }
        }
        internal static string ConcurrentDictionary_ConcurrencyLevelMustBePositive {
              get { return SR.GetResourceString("ConcurrentDictionary_ConcurrencyLevelMustBePositive", @"The concurrencyLevel argument must be positive."); }
        }
        internal static string ConcurrentDictionary_CapacityMustNotBeNegative {
              get { return SR.GetResourceString("ConcurrentDictionary_CapacityMustNotBeNegative", @"The capacity argument must be greater than or equal to zero."); }
        }
        internal static string ConcurrentDictionary_IndexIsNegative {
              get { return SR.GetResourceString("ConcurrentDictionary_IndexIsNegative", @"The index argument is less than zero."); }
        }
        internal static string ConcurrentDictionary_ArrayNotLargeEnough {
              get { return SR.GetResourceString("ConcurrentDictionary_ArrayNotLargeEnough", @"The index is equal to or greater than the length of the array, or the number of elements in the dictionary is greater than the available space from index to the end of the destination array."); }
        }
        internal static string ConcurrentDictionary_KeyAlreadyExisted {
              get { return SR.GetResourceString("ConcurrentDictionary_KeyAlreadyExisted", @"The key already existed in the dictionary."); }
        }
        internal static string ConcurrentDictionary_ItemKeyIsNull {
              get { return SR.GetResourceString("ConcurrentDictionary_ItemKeyIsNull", @"TKey is a reference type and item.Key is null."); }
        }
        internal static string ConcurrentDictionary_TypeOfKeyIncorrect {
              get { return SR.GetResourceString("ConcurrentDictionary_TypeOfKeyIncorrect", @"The key was of an incorrect type for this dictionary."); }
        }
        internal static string ConcurrentDictionary_TypeOfValueIncorrect {
              get { return SR.GetResourceString("ConcurrentDictionary_TypeOfValueIncorrect", @"The value was of an incorrect type for this dictionary."); }
        }
        internal static string ConcurrentStack_PushPopRange_CountOutOfRange {
              get { return SR.GetResourceString("ConcurrentStack_PushPopRange_CountOutOfRange", @"The count argument must be greater than or equal to zero."); }
        }
        internal static string ConcurrentStack_PushPopRange_InvalidCount {
              get { return SR.GetResourceString("ConcurrentStack_PushPopRange_InvalidCount", @"The sum of the startIndex and count arguments must be less than or equal to the collection's Count."); }
        }
        internal static string ConcurrentStack_PushPopRange_StartOutOfRange {
              get { return SR.GetResourceString("ConcurrentStack_PushPopRange_StartOutOfRange", @"The startIndex argument must be greater than or equal to zero."); }
        }
        internal static string Partitioner_DynamicPartitionsNotSupported {
              get { return SR.GetResourceString("Partitioner_DynamicPartitionsNotSupported", @"Dynamic partitions are not supported by this partitioner."); }
        }
        internal static string PartitionerStatic_CanNotCallGetEnumeratorAfterSourceHasBeenDisposed {
              get { return SR.GetResourceString("PartitionerStatic_CanNotCallGetEnumeratorAfterSourceHasBeenDisposed", @"Can not call GetEnumerator on partitions after the source enumerable is disposed"); }
        }
        internal static string PartitionerStatic_CurrentCalledBeforeMoveNext {
              get { return SR.GetResourceString("PartitionerStatic_CurrentCalledBeforeMoveNext", @"MoveNext must be called at least once before calling Current."); }
        }

#endif
    }
}
