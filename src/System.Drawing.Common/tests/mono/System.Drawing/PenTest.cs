// Licensed to the .NET Foundation under one or more agreements.
// See the LICENSE file in the project root for more information.
//
// System.Drawing.Pen unit tests
//
// Authors:
//	Sebastien Pouliot  <sebastien@ximian.com>
//
// Copyright (C) 2006 Novell, Inc (http://www.novell.com)
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

using System;
using SC = System.ComponentModel;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Security.Permissions;
using Xunit;

namespace MonoTests.System.Drawing
{

    public class PenTest
    {

        private Pen default_pen;
        private CustomLineCap custom_line_cap;

        public PenTest()
        {
            default_pen = new Pen(Color.Empty);
            custom_line_cap = new CustomLineCap(new GraphicsPath(), new GraphicsPath());
        }

        private void Check(Pen p)
        {
            Assert.Equal(PenAlignment.Center, p.Alignment);
            Assert.Equal(typeof(SolidBrush), p.Brush.GetType());
            Assert.Equal(Color.Red.ToArgb(), (p.Brush as SolidBrush).Color.ToArgb());
            Assert.Equal(Color.Red.ToArgb(), p.Color.ToArgb());
            Assert.Equal(0, p.CompoundArray.Length);
            Assert.Equal(DashCap.Flat, p.DashCap);
            Assert.Equal(0, p.DashOffset);
            Assert.Equal(DashStyle.Solid, p.DashStyle);
            Assert.Equal(LineCap.Flat, p.EndCap);
            Assert.Equal(LineJoin.Miter, p.LineJoin);
            Assert.Equal(10, p.MiterLimit);
            Assert.Equal(PenType.SolidColor, p.PenType);
            Assert.Equal(LineCap.Flat, p.StartCap);
            Assert.True(p.Transform.IsIdentity);
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        public void Constructor_Color()
        {
            using (Pen p = new Pen(Color.Red))
            {
                Assert.Equal(1, p.Width);
                Check(p);
            }
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        public void Constructor_Color_Float()
        {
            using (Pen p = new Pen(Color.Red, 2.5f))
            {
                Assert.Equal(2.5f, p.Width);
                Check(p);
            }
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        public void Constructor_Color_Float_Zero()
        {
            using (Pen p = new Pen(Color.Red, 0.0f))
            {
                Assert.Equal(0.0f, p.Width);
                Check(p);
            }
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        public void Constructor_Color_Float_Negative()
        {
            using (Pen p = new Pen(Color.Red, -2))
            {
                Assert.Equal(-2, p.Width);
                Check(p);
            }
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        public void Constructor_Color_Float_MaxValue()
        {
            using (Pen p = new Pen(Color.Red, Single.MaxValue))
            {
                Assert.Equal(Single.MaxValue, p.Width);
                Check(p);
            }
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        public void Constructor_Brush()
        {
            using (Pen p = new Pen(Brushes.Red))
            {
                Assert.Equal(1, p.Width);
                Check(p);
            }
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        public void Constructor_Brush_Null()
        {
            Assert.Throws<ArgumentNullException>(() => new Pen((Brush)null));
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        public void Constructor_Brush_Float()
        {
            using (Pen p = new Pen(Brushes.Red, 2.5f))
            {
                Assert.Equal(2.5f, p.Width);
                Check(p);
            }
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        public void Constructor_Brush_Float_Null()
        {
            Assert.Throws<ArgumentNullException>(() => new Pen((Brush)null, Single.MaxValue));
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        public void Constructor_Brush_Float_Zero()
        {
            using (Pen p = new Pen(Brushes.Red, 0.0f))
            {
                Assert.Equal(0.0f, p.Width);
                Check(p);
            }
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        public void Constructor_Brush_Float_Negative()
        {
            using (Pen p = new Pen(Brushes.Red, -2))
            {
                Assert.Equal(-2, p.Width);
                Check(p);
            }
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        public void Constructor_Brush_Float_MaxValue()
        {
            using (Pen p = new Pen(Brushes.Red, Single.MaxValue))
            {
                Assert.Equal(Single.MaxValue, p.Width);
                Check(p);
            }
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        public void Constructor_Brush_DisposeBeforeUse()
        {
            using (SolidBrush b = new SolidBrush(Color.Red))
            {
                using (Pen p = new Pen(b, 1))
                {
                    b.Dispose();
                    Check(p);
                    using (Bitmap bmp = new Bitmap(12, 12))
                    {
                        using (Graphics g = Graphics.FromImage(bmp))
                        {
                            g.DrawLine(p, 1, 1, 10, 10);
                        }
                    }
                }
            }
        }

        private void Check2(Pen p)
        {
            Assert.Equal(typeof(SolidBrush), p.Brush.GetType());
            Assert.Equal(Color.Red.ToArgb(), (p.Brush as SolidBrush).Color.ToArgb());
            Assert.Equal(Color.Red.ToArgb(), p.Color.ToArgb());
            Assert.Equal(0, p.CompoundArray.Length);
            //			Assert.Equal (DashCap.Flat, p.DashCap);
            Assert.Equal(0, p.DashOffset);
            Assert.Equal(10, p.MiterLimit);
            Assert.Equal(PenType.SolidColor, p.PenType);
            Assert.True(p.Transform.IsIdentity);
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        public void Alignment()
        {
            using (Pen p = new Pen(Brushes.Gold, Single.NegativeInfinity))
            {
                foreach (PenAlignment pa in Enum.GetValues(typeof(PenAlignment)))
                {
                    p.Alignment = pa;
                    Assert.Equal(pa, p.Alignment);
                }
            }
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable, Skip = "Internal ArgumentException in System.Drawing")]
        public void Alignment_Invalid()
        {
            Assert.Throws<SC.InvalidEnumArgumentException>(() => default_pen.Alignment = (PenAlignment)Int32.MinValue);
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        public void Brush_Dispose()
        {
            using (Pen p = new Pen(Brushes.Red, 2.5f))
            {
                // are we getting the original brush ?
                Brush b1 = p.Brush;
                b1.Dispose();
                Check(p);
                using (Pen clone = (Pen)p.Clone())
                {
                    Check(clone);
                }
                Assert.False(Object.ReferenceEquals(b1, p.Brush));
                // nope :)
            }
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        public void Brush_Null()
        {
            Assert.Throws<ArgumentNullException>(() => default_pen.Brush = null);
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        public void DashCap_Valid()
        {
            // note: YellowGreen is broken by a destructive test so we can't use it afterward
            // note: this worked with nunit 2.2 because this test was executed before the destructive one
            using (Pen p = new Pen(Brushes.Yellow, 0))
            {
                foreach (DashCap dc in Enum.GetValues(typeof(DashCap)))
                {
                    p.DashCap = dc;
                    Assert.Equal(dc, p.DashCap);
                }
            }
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable, Skip = "Internal ArgumentException in System.Drawing")]
        public void DashCap_Invalid()
        {
            Assert.Throws<SC.InvalidEnumArgumentException>(() => default_pen.DashCap = (DashCap)Int32.MinValue);
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        public void DashOffset()
        {
            using (Pen p = new Pen(Brushes.Transparent, 32))
            {
                p.DashOffset = 0;
                Assert.Equal(0, p.DashOffset);
                p.DashOffset = Single.MaxValue;
                Assert.Equal(Single.MaxValue, p.DashOffset);
                p.DashOffset = Single.MinValue;
                Assert.Equal(Single.MinValue, p.DashOffset);
            }
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        public void DashPattern()
        {
            using (Pen p = new Pen(Brushes.Tomato, 1.1f))
            {
                Assert.Equal(DashStyle.Solid, p.DashStyle);
                p.DashPattern = new float[1] { 1 };
                Assert.Equal(DashStyle.Custom, p.DashStyle);
                Assert.Equal(1, p.DashPattern.Length);
            }
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        public void DashPattern_Empty()
        {
            Assert.Throws<ArgumentException>(() => default_pen.DashPattern = new float[0]);
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        public void DashStyle_Valid()
        {
            using (Pen p = new Pen(Brushes.Silver, Single.PositiveInfinity))
            {
                foreach (DashStyle ds in Enum.GetValues(typeof(DashStyle)))
                {
                    p.DashStyle = ds;
                    Assert.Equal(ds, p.DashStyle);
                }
            }
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable, Skip = "Internal ArgumentException in System.Drawing")]
        public void DashStyle_Invalid()
        {
            Assert.Throws<SC.InvalidEnumArgumentException>(() => default_pen.DashStyle = (DashStyle)Int32.MinValue);
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        public void DashStyle_Custom()
        {
            using (Pen p = new Pen(Brushes.Silver, Single.PositiveInfinity))
            {
                Assert.Equal(DashStyle.Solid, p.DashStyle);
                // can't ask for Solid (default) -> OutOfMemoryException
                p.DashStyle = DashStyle.Custom;
                Assert.Equal(DashStyle.Custom, p.DashStyle);
                Assert.Equal(1, p.DashPattern.Length);
                Assert.Equal(1, p.DashPattern[0]);

                p.DashStyle = DashStyle.Dot;
                Assert.Equal(DashStyle.Dot, p.DashStyle);
                Assert.Equal(2, p.DashPattern.Length);
                Assert.Equal(1, p.DashPattern[0]);
                Assert.Equal(1, p.DashPattern[1]);
                p.DashStyle = DashStyle.Custom;
                Assert.Equal(DashStyle.Custom, p.DashStyle);
                Assert.Equal(2, p.DashPattern.Length);
                Assert.Equal(1, p.DashPattern[0]);
                Assert.Equal(1, p.DashPattern[1]);

                p.DashStyle = DashStyle.Dash;
                Assert.Equal(DashStyle.Dash, p.DashStyle);
                Assert.Equal(2, p.DashPattern.Length);
                Assert.Equal(3, p.DashPattern[0]);
                Assert.Equal(1, p.DashPattern[1]);
                p.DashStyle = DashStyle.Custom;
                Assert.Equal(DashStyle.Custom, p.DashStyle);
                Assert.Equal(2, p.DashPattern.Length);
                Assert.Equal(3, p.DashPattern[0]);
                Assert.Equal(1, p.DashPattern[1]);

                p.DashStyle = DashStyle.DashDot;
                Assert.Equal(DashStyle.DashDot, p.DashStyle);
                Assert.Equal(4, p.DashPattern.Length);
                Assert.Equal(3, p.DashPattern[0]);
                Assert.Equal(1, p.DashPattern[1]);
                Assert.Equal(1, p.DashPattern[2]);
                Assert.Equal(1, p.DashPattern[3]);
                p.DashStyle = DashStyle.Custom;
                Assert.Equal(DashStyle.Custom, p.DashStyle);
                Assert.Equal(4, p.DashPattern.Length);
                Assert.Equal(3, p.DashPattern[0]);
                Assert.Equal(1, p.DashPattern[1]);
                Assert.Equal(1, p.DashPattern[2]);
                Assert.Equal(1, p.DashPattern[3]);

                p.DashStyle = DashStyle.DashDotDot;
                Assert.Equal(DashStyle.DashDotDot, p.DashStyle);
                Assert.Equal(6, p.DashPattern.Length);
                Assert.Equal(3, p.DashPattern[0]);
                Assert.Equal(1, p.DashPattern[1]);
                Assert.Equal(1, p.DashPattern[2]);
                Assert.Equal(1, p.DashPattern[3]);
                Assert.Equal(1, p.DashPattern[2]);
                Assert.Equal(1, p.DashPattern[3]);
                p.DashStyle = DashStyle.Custom;
                Assert.Equal(DashStyle.Custom, p.DashStyle);
                Assert.Equal(6, p.DashPattern.Length);
                Assert.Equal(3, p.DashPattern[0]);
                Assert.Equal(1, p.DashPattern[1]);
                Assert.Equal(1, p.DashPattern[2]);
                Assert.Equal(1, p.DashPattern[3]);
                Assert.Equal(1, p.DashPattern[2]);
                Assert.Equal(1, p.DashPattern[3]);

                // resetting to DashStyle.Solid doesn't throw the OutOfMemoryException
                // on MS runtime
                p.DashStyle = DashStyle.Solid;
                Assert.Equal(DashStyle.Solid, p.DashStyle);
                Assert.Equal(0, p.DashPattern.Length);
                p.DashStyle = DashStyle.Custom;
                Assert.Equal(DashStyle.Custom, p.DashStyle);
                Assert.Equal(1, p.DashPattern.Length);
                Assert.Equal(1, p.DashPattern[0]);
            }
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        public void EndCap_Valid()
        {
            using (Pen p = new Pen(Brushes.Silver, Single.PositiveInfinity))
            {
                foreach (LineCap lc in Enum.GetValues(typeof(LineCap)))
                {
                    p.EndCap = lc;
                    Assert.Equal(lc, p.EndCap);
                }
            }
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable, Skip = "Internal ArgumentException in System.Drawing")]
        public void EndCap_Invalid()
        {
            Assert.Throws<SC.InvalidEnumArgumentException>(() => default_pen.EndCap = (LineCap)Int32.MinValue);
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        public void LineJoin_Valid()
        {
            using (Pen p = new Pen(Brushes.Chocolate, Single.NaN))
            {
                foreach (LineJoin lj in Enum.GetValues(typeof(LineJoin)))
                {
                    p.LineJoin = lj;
                    Assert.Equal(lj, p.LineJoin);
                }
            }
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable, Skip = "Internal ArgumentException in System.Drawing")]
        public void LineJoin_Invalid()
        {
            Assert.Throws<SC.InvalidEnumArgumentException>(() => default_pen.LineJoin = (LineJoin)Int32.MinValue);
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        public void MiterLimit()
        {
            using (Pen p = new Pen(Brushes.Tan, 1))
            {
                p.MiterLimit = Single.MinValue;
                Assert.Equal(1, p.MiterLimit);
                p.MiterLimit = 0;
                Assert.Equal(1, p.MiterLimit);
                p.MiterLimit = Single.MaxValue;
                Assert.Equal(Single.MaxValue, p.MiterLimit);
            }
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        public void StartCap_Valid()
        {
            using (Pen p = new Pen(Brushes.Silver, Single.PositiveInfinity))
            {
                foreach (LineCap lc in Enum.GetValues(typeof(LineCap)))
                {
                    p.StartCap = lc;
                    Assert.Equal(lc, p.StartCap);
                }
            }
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable, Skip = "Internal ArgumentException in System.Drawing")]
        public void StartCap_Invalid()
        {
            Assert.Throws<SC.InvalidEnumArgumentException>(() => default_pen.StartCap = (LineCap)Int32.MinValue);
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        public void Transform_Null()
        {
            Assert.Throws<ArgumentNullException>(() => default_pen.Transform = null);
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        public void Transform_NonInvertible()
        {
            using (Pen p = new Pen(Brushes.Snow, Single.MaxValue))
            {
                Assert.Throws<ArgumentException>(() => p.Transform = new Matrix(123, 24, 82, 16, 47, 30));
            }
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        public void Width()
        {
            using (Pen p = new Pen(Brushes.Tan, Single.MinValue))
            {
                Assert.Equal(Single.MinValue, p.Width);
                p.Width = 0;
                Assert.Equal(0, p.Width);
                p.Width = Single.MaxValue;
                Assert.Equal(Single.MaxValue, p.Width);
            }
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        public void Clone()
        {
            using (Pen p = new Pen(Brushes.Red))
            {
                using (Pen clone = (Pen)p.Clone())
                {
                    Check(clone);
                }
            }
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        public void Dispose()
        {
            Pen p = new Pen(Brushes.Red);
            p.Dispose();
            Assert.Throws<ArgumentException>(() => p.Alignment = PenAlignment.Center);
            // exception but not an ObjectDisposedException
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        public void SetLineCap()
        {
            using (Pen p = new Pen(Brushes.Red))
            {
                foreach (LineCap sc in Enum.GetValues(typeof(LineCap)))
                {
                    foreach (LineCap ec in Enum.GetValues(typeof(LineCap)))
                    {
                        foreach (DashCap dc in Enum.GetValues(typeof(DashCap)))
                        {
                            string s = String.Format("{0}-{1}-{2}", sc, ec, dc);
                            p.SetLineCap(sc, ec, dc);
                            Assert.Equal(sc, p.StartCap);
                            Assert.Equal(ec, p.EndCap);
                            Assert.Equal(dc, p.DashCap);
                        }
                    }
                }
            }
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        public void SetLineCap_InvalidStartCap()
        {
            using (Pen p = new Pen(Brushes.Red))
            {
                p.SetLineCap((LineCap)Int32.MinValue, LineCap.Flat, DashCap.Flat);
                // no exception :( (reported as FDBK50057)
                Assert.Equal(Int32.MinValue, (int)p.StartCap);
                Assert.Equal(LineCap.Flat, p.EndCap);
                Assert.Equal(DashCap.Flat, p.DashCap);
            }
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        public void SetLineCap_InvalidEndCap()
        {
            using (Pen p = new Pen(Brushes.Red))
            {
                p.SetLineCap(LineCap.Flat, (LineCap)Int32.MinValue, DashCap.Flat);
                // no exception :( (reported as FDBK50057)
                Assert.Equal(LineCap.Flat, p.StartCap);
                Assert.Equal(Int32.MinValue, (int)p.EndCap);
                Assert.Equal(DashCap.Flat, p.DashCap);
            }
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        public void SetLineCap_InvalidDashCap()
        {
            using (Pen p = new Pen(Brushes.Red))
            {
                p.SetLineCap(LineCap.Flat, LineCap.Flat, (DashCap)Int32.MinValue);
                Assert.Equal(LineCap.Flat, p.StartCap);
                Assert.Equal(LineCap.Flat, p.EndCap);
                // invalid value was reseted to Flat (reported as FDBK50057)
                Assert.Equal(DashCap.Flat, p.DashCap);
            }
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        //[ExpectedException (typeof (ArgumentNullException))] // reported as FDBK50058
        public void MultiplyTransform1_Null()
        {
            Assert.Throws<NullReferenceException>(() => default_pen.MultiplyTransform(null));
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        //[ExpectedException (typeof (ArgumentNullException))] // reported as FDBK50058
        public void MultiplyTransform2_Null()
        {
            Assert.Throws<NullReferenceException>(() => default_pen.MultiplyTransform(null, MatrixOrder.Append));
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        public void MultiplyTransform2_InvalidMatrixOrder()
        {
            using (Pen p = new Pen(Brushes.Red))
            {
                Matrix m1 = new Matrix(2, 0.5f, 0.5f, 4, 10, 20);
                Matrix m2 = new Matrix(1, 0, 0, 1, -50, -30);

                p.Transform = m2;
                p.MultiplyTransform(m1, (MatrixOrder)Int32.MinValue);
                // no exception, but which order is it ?
                Matrix invalid = p.Transform;

                p.Transform = m2;
                p.MultiplyTransform(m1, MatrixOrder.Append);
                Assert.True(invalid.Equals(p.Transform));

                p.Transform = m2;
                p.MultiplyTransform(m1, MatrixOrder.Prepend);
                Assert.False(invalid.Equals(p.Transform));
            }
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        public void MultiplyTransform_NonInvertible()
        {
            using (Matrix noninvertible = new Matrix(123, 24, 82, 16, 47, 30))
            {
                using (Pen p = new Pen(Brushes.Red))
                {
                    Assert.Throws<ArgumentException>(() => p.MultiplyTransform(noninvertible));
                }
            }
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        public void ResetTransform()
        {
            using (Matrix m = new Matrix(2, 0, 0, 2, 10, -10))
            {
                using (Pen p = new Pen(Brushes.Red))
                {
                    p.Transform = m;
                    Assert.False(p.Transform.IsIdentity);
                    p.ResetTransform();
                    Assert.True(p.Transform.IsIdentity);
                }
            }
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        public void RotateTransform()
        {
            using (Pen p = new Pen(Brushes.Red))
            {
                p.RotateTransform(90);
                float[] elements = p.Transform.Elements;
                Assert.Equal(0, elements[0], 1);
                Assert.Equal(1, elements[1], 1);
                Assert.Equal(-1, elements[2], 1);
                Assert.Equal(0, elements[3], 1);
                Assert.Equal(0, elements[4], 1);
                Assert.Equal(0, elements[5], 1);

                p.RotateTransform(270);
                Assert.True(p.Transform.IsIdentity);
            }
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        public void RotateTransform_InvalidOrder()
        {
            Assert.Throws<ArgumentException>(() => default_pen.RotateTransform(720, (MatrixOrder)Int32.MinValue));
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        public void ScaleTransform()
        {
            using (Pen p = new Pen(Brushes.Red))
            {
                p.ScaleTransform(2, 4);
                float[] elements = p.Transform.Elements;
                Assert.Equal(2, elements[0], 1);
                Assert.Equal(0, elements[1], 1);
                Assert.Equal(0, elements[2], 1);
                Assert.Equal(4, elements[3], 1);
                Assert.Equal(0, elements[4], 1);
                Assert.Equal(0, elements[5], 1);

                p.ScaleTransform(0.5f, 0.25f);
                Assert.True(p.Transform.IsIdentity);
            }
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        public void ScaleTransform_MaxMin()
        {
            using (Pen p = new Pen(Brushes.Red))
            {
                p.ScaleTransform(Single.MaxValue, Single.MinValue);
                float[] elements = p.Transform.Elements;
                Assert.Equal(Single.MaxValue, elements[0]);
                Assert.Equal(0, elements[1], 1);
                Assert.Equal(0, elements[2], 1);
                Assert.Equal(Single.MinValue, elements[3]);
                Assert.Equal(0, elements[4], 1);
                Assert.Equal(0, elements[5], 1);
            }
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        public void ScaleTransform_InvalidOrder()
        {
            Assert.Throws<ArgumentException>(() => default_pen.ScaleTransform(1, 1, (MatrixOrder)Int32.MinValue));
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        public void TranslateTransform()
        {
            using (Pen p = new Pen(Brushes.Red))
            {
                p.TranslateTransform(1, 1);
                float[] elements = p.Transform.Elements;
                Assert.Equal(1, elements[0], 1);
                Assert.Equal(0, elements[1], 1);
                Assert.Equal(0, elements[2], 1);
                Assert.Equal(1, elements[3], 1);
                Assert.Equal(1, elements[4], 1);
                Assert.Equal(1, elements[5], 1);

                p.TranslateTransform(-1, -1);
                elements = p.Transform.Elements;
                Assert.Equal(1, elements[0], 1);
                Assert.Equal(0, elements[1], 1);
                Assert.Equal(0, elements[2], 1);
                Assert.Equal(1, elements[3], 1);
                Assert.Equal(0, elements[4], 1);
                Assert.Equal(0, elements[5], 1);
            }
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        public void TranslateTransform_InvalidOrder()
        {
            Assert.Throws<ArgumentException>(() => default_pen.TranslateTransform(1, 1, (MatrixOrder)Int32.MinValue));
        }

        [ConditionalFact(Helpers.GdiplusIsAvailable)]
        public void Transform_Operations()
        {
            using (Pen p = new Pen(Brushes.Red))
            {
                Matrix clone = p.Transform.Clone();
                Matrix mul = clone.Clone();

                clone.Multiply(mul, MatrixOrder.Append);
                p.MultiplyTransform(mul, MatrixOrder.Append);
                Assert.Equal(p.Transform, clone);

                clone.Multiply(mul, MatrixOrder.Prepend);
                p.MultiplyTransform(mul, MatrixOrder.Prepend);
                Assert.Equal(p.Transform, clone);

                clone.Rotate(45, MatrixOrder.Append);
                p.RotateTransform(45, MatrixOrder.Append);
                Assert.Equal(p.Transform, clone);

                clone.Rotate(45, MatrixOrder.Prepend);
                p.RotateTransform(45, MatrixOrder.Prepend);
                Assert.Equal(p.Transform, clone);

                clone.Scale(0.25f, 2, MatrixOrder.Append);
                p.ScaleTransform(0.25f, 2, MatrixOrder.Append);
                Assert.Equal(p.Transform, clone);

                clone.Scale(0.25f, 2, MatrixOrder.Prepend);
                p.ScaleTransform(0.25f, 2, MatrixOrder.Prepend);
                Assert.Equal(p.Transform, clone);

                clone.Translate(10, 20, MatrixOrder.Append);
                p.TranslateTransform(10, 20, MatrixOrder.Append);
                Assert.Equal(p.Transform, clone);

                clone.Translate(30, 40, MatrixOrder.Prepend);
                p.TranslateTransform(30, 40, MatrixOrder.Prepend);
                Assert.Equal(p.Transform, clone);

                clone.Reset();
                p.ResetTransform();
                Assert.Equal(p.Transform, clone);
            }
        }
    }
}
