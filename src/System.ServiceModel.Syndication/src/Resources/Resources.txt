XmlNodeIsNotAnElement=The XmlReader is not currently in a node of type Element.
InvalidSkipHours=The hour can't be lower than 0 or greater than 23.
NoIPEndpointsFoundForHost=No IPEndpoints were found for host {0}.
DnsResolveFailed=No DNS entries exist for host {0}.
RequiredAttributeMissing=Attribute '{0}' is required on element '{1}'.
UnsupportedCryptoAlgorithm=Crypto algorithm {0} not supported in this context.
CustomCryptoAlgorithmIsNotValidHashAlgorithm=The custom crypto algorithm '{0}' obtained using CryptoConfig is not a valid or supported hash algorithm.
InvalidClientCredentials=The client credential entered was invalid.
SspiErrorOrInvalidClientCredentials=Either the client credential was invalid or there was an error collecting the client credentials by the SSPI.
CustomCryptoAlgorithmIsNotValidAsymmetricSignature=The custom crypto algorithm '{0}' obtained using CryptoConfig is not a valid or supported asymmetric signature algorithm.
TokenSerializerNotSetonFederationProvider=The security token serializer must be specified on the security token provider.
IssuerBindingNotPresentInTokenRequirement=The key length '{0}' is not a multiple of 8 for symmetric keys.
IssuerChannelBehaviorsCannotContainSecurityCredentialsManager=The channel behaviors configured for the issuer address '{0}' cannot contain a behavior of type '{1}'.
ServiceBusyCountTrace=Operation Action={0}
SecurityTokenManagerCannotCreateProviderForRequirement=The security token manager cannot create a token provider for requirement '{0}'.
SecurityTokenManagerCannotCreateAuthenticatorForRequirement=The security token manager cannot create a token authenticator for requirement '{0}'.
FailedSignatureVerification=The signature verification failed. Please see inner exception for fault details.
SecurityTokenManagerCannotCreateSerializerForVersion=The security token manager cannot create a token serializer for security token version '{0}'.
SupportingSignatureIsNotDerivedFrom=The supporting signature is not signed with a derived key. The binding's supporting token parameter '{0}' requires key derivation.
PrimarySignatureWasNotSignedByDerivedKey=The primary signature is not signed with a derived key. The binding's primary token parameter '{0}' requires key derivation.
PrimarySignatureWasNotSignedByDerivedWrappedKey=The primary signature is not signed with a key derived from the encrypted key. The binding's token parameter '{0}' requires key derivation.
MessageWasNotEncryptedByDerivedWrappedKey=The message is not encrypted with a key derived from the encrypted key. The binding's token parameter '{0}' requires key derivation.
SecurityStateEncoderDecodingFailure=The DataProtectionSecurityStateEncoder is unable to decode the byte array. Ensure that a 'UserProfile' is loaded, if this is a 'web farm scenario' ensure all servers are running as the same user with the roaming profiles or provide a custom SecurityStateEncoder'.
SecurityStateEncoderEncodingFailure=The DataProtectionSecurityStateEncoder is unable to encode the byte array. Ensure that a 'UserProfile' is loaded, if this is a 'web farm scenario' ensure all servers are running as the same user with the roaming profiles or provide a custom SecurityStateEncoder'.
MessageWasNotEncryptedByDerivedEncryptionToken=The message is not encrypted with a key derived from the encryption token. The binding's token parameter '{0}' requires key derivation.
TokenAuthenticatorRequiresSecurityBindingElement=The security token manager requires the security binding element to be specified in order to create a token authenticator for requirement '{0}'.
TokenProviderRequiresSecurityBindingElement=The security token manager requires the security binding element to be specified in order to create a token provider for requirement '{0}'.
UnexpectedSecuritySessionCloseResponse=The security session received an unexpected close response from the other party.
UnexpectedSecuritySessionClose=The security session received an unexpected close from the other party.
CannotObtainSslConnectionInfo=The service was unable to verify the cipher strengths negotiated as part of the SSL handshake.
HeaderEncryptionNotSupportedInWsSecurityJan2004=SecurityVersion.WSSecurityJan2004 does not support header encryption. Header with name '{0}' and namespace '{1}' is configured for encryption. Consider using SecurityVersion.WsSecurity11 and above or use transport security to encrypt the full message.
EncryptedHeaderNotSigned=The Header ('{0}', '{1}') was encrypted but not signed. All encrypted headers outside the security header should be signed.
EncodingBindingElementDoesNotHandleReaderQuotas=Unable to obtain XmlDictionaryReaderQuotas from the Binding. If you have specified a custom EncodingBindingElement, verify that the EncodingBindingElement can handle XmlDictionaryReaderQuotas in its GetProperty<T>() method.
HeaderDecryptionNotSupportedInWsSecurityJan2004=SecurityVersion.WSSecurityJan2004 does not support header decryption. Use SecurityVersion.WsSecurity11 and above or use transport security to encrypt the full message.
DecryptionFailed=Unable to decrypt an encrypted data block. Please verify that the encryption algorithm and keys used by the sender and receiver match.
AuthenticationManagerShouldNotReturnNull=The authenticate method in the ServiceAuthenticationManager returned null. If you do not want to return any authorization policies in the collection then return an empty ReadOnlyCollection instead. 
ErrorSerializingSecurityToken=There was an error serializing the security token. Please see the inner exception for more details.
ErrorDeserializingKeyIdentifierClauseFromTokenXml=There was an error creating the security key identifier clause from the security token XML. Please see the inner exception for more details.
ErrorDeserializingTokenXml=There was an error deserializing the security token XML. Please see the inner exception for more details.
TokenRequirementDoesNotSpecifyTargetAddress=The token requirement '{0}' does not specify the target address. This is required by the token manager for creating the corresponding security token provider.
DerivedKeyNotInitialized=The derived key has not been computed for the security token.
IssuedKeySizeNotCompatibleWithAlgorithmSuite=The binding ('{0}', '{1}') has been configured with a security algorithm suite '{2}' that is incompatible with the issued token key size '{3}' specified on the binding.
IssuedTokenAuthenticationModeRequiresSymmetricIssuedKey=The IssuedToken security authentication mode requires the issued token to contain a symmetric key.
InvalidBearerKeyUsage=The binding ('{0}', '{1}') uses an Issued Token with Bearer Key Type in a invalid context. The Issued Token with a Bearer Key Type can only be used as a Signed Supporting token or a Signed Encrypted Supporting token. See the SecurityBindingElement.EndpointSupportingTokenParameters property.
MultipleIssuerEndpointsFound=Policy for multiple issuer endpoints was retrieved from '{0}' but the relying party's policy does not specify which issuer endpoint to use. One of the endpoints was selected as the issuer endpoint to use. If you are using svcutil, the other endpoints will be available in commented form in the configuration as <alternativeIssuedTokenParameters>. Check the configuration to ensure that the right issuer endpoint was selected.
MultipleAuthenticationManagersInServiceBindingParameters=The AuthenticationManager cannot be added to the binding parameters because the binding parameters already contains a AuthenticationManager '{0}'. If you are configuring a custom AuthenticationManager for the service, please first remove any existing AuthenticationManagers from the behaviors collection before adding the custom AuthenticationManager.
MultipleAuthenticationSchemesInServiceBindingParameters=The AuthenticationSchemes cannot be added to the binding parameters because the binding parameters already contains AuthenticationSchemes '{0}'. If you are configuring custom AuthenticationSchemes for the service, please first remove any existing AuthenticationSchemes from the behaviors collection before adding custom AuthenticationSchemes.
NoSecurityBindingElementFound=Unable to find a SecurityBindingElement.
MultipleSecurityCredentialsManagersInServiceBindingParameters=The ServiceCredentials cannot be added to the binding parameters because the binding parameters already contains a SecurityCredentialsManager '{0}'. If you are configuring custom credentials for the service, please first remove any existing ServiceCredentials from the behaviors collection before adding the custom credential.
MultipleSecurityCredentialsManagersInChannelBindingParameters=The ClientCredentials cannot be added to the binding parameters because the binding parameters already contains a SecurityCredentialsManager '{0}'. If you are configuring custom credentials for the channel, please first remove any existing ClientCredentials from the behaviors collection before adding the custom credential.
NoClientCertificate=The binding ('{0}', '{1}') has been configured with a MutualCertificateDuplexBindingElement that requires a client certificate. The client certificate is currently missing.
SecurityTokenParametersHasIncompatibleInclusionMode=The binding ('{0}', '{1}') is configured with a security token parameter '{2}' that has an incompatible security token inclusion mode '{3}'. Specify an alternate security token inclusion mode (for example, '{4}').
CannotCreateTwoWayListenerForNegotiation=Unable to create a bi-directional (request-reply or duplex) channel for security negotiation. Please ensure that the binding is capable of creating a bi-directional channel.
NegotiationQuotasExceededFaultReason=There are too many active security negotiations or secure conversations at the service. Please retry later.
PendingSessionsExceededFaultReason=There are too many pending secure conversations on the server. Please retry later.
RequestSecurityTokenDoesNotMatchEndpointFilters=The RequestSecurityToken message does not match the endpoint filters the service '{0}' is expecting incoming messages to match. This may be because the RequestSecurityToken was intended to be sent to a different service.
SecuritySessionRequiresIssuanceAuthenticator=The security session requires a security token authenticator that implements '{0}'. '{1}' does not implement '{0}'.
SecuritySessionRequiresSecurityContextTokenCache=The security session requires a security token resolver that implements '{1}'. The security token resolver '{0}' does not implement '{1}'.
SessionTokenIsNotSecurityContextToken=The session security token authenticator returned a token of type '{0}'. The token type expected is '{1}'.
SessionTokenIsNotGenericXmlToken=The session security token provider returned a token of type '{0}'. The token type expected is '{1}'.
SecurityStandardsManagerNotSet=The security standards manager was not specified on  '{0}'.
SecurityNegotiationMessageTooLarge=The security negotiation message with action '{0}' is larger than the maximum allowed buffer size '{1}'. If you are using a streamed transport consider increasing the maximum buffer size on the transport.
PreviousChannelDemuxerOpenFailed=The channel demuxer Open failed previously with exception '{0}'.
SecurityChannelListenerNotSet=The security channel listener was not specified on  '{0}'.
SecurityChannelListenerChannelExtendedProtectionNotSupported=ExtendedProtectionPolicy specified a PolicyEnforcement of 'Always' which is not supported for the authentication mode requested.  This prevents the ExtendedProtectionPolicy from being enforced. For StandardBindings use a SecurityMode of TransportWithMessageCredential and a ClientCredential type of Windows. For CustomBindings use SspiNegotiationOverTransport or KerberosOverTransport.  Alternatively, specify a PolicyEnforcement of 'Never'.
SecurityChannelBindingMissing=ExtendedProtectionPolicy specified a PolicyEnforcement of 'Always' and a ChannelBinding was not found.  This prevents the ExtendedProtectionPolicy from being enforced. Change the binding to make a ChannelBinding available, for StandardBindings use a SecurityMode of TransportWithMessageCredential and a ClientCredential type of Windows. For CustomBindings use SspiNegotiationOverTransport or KerberosOverTransport.  Alternatively, specify a PolicyEnforcement of 'Never'.
SecuritySettingsLifetimeManagerNotSet=The security settings lifetime manager was not specified on  '{0}'.
SecurityListenerClosing=The listener is not accepting new secure conversations because it is closing.
SecurityListenerClosingFaultReason=The server is not accepting new secure conversations currently because it is closing. Please retry later.
SslCipherKeyTooSmall=The cipher key negotiated by SSL is too small ('{0}' bits). Keys of such lengths are not allowed as they may result in information disclosure. Please configure the initiator machine to negotiate SSL cipher keys that are '{1}' bits or longer.
DerivedKeyTokenNonceTooLong=The length ('{0}' bytes) of the derived key's Nonce exceeds the maximum length ('{1}' bytes) allowed.
DerivedKeyTokenLabelTooLong=The length ('{0}' bytes) of the derived key's Label exceeds the maximum length ('{1}' bytes) allowed.
DerivedKeyTokenOffsetTooHigh=The derived key's Offset ('{0}' bytes) exceeds the maximum offset ('{1}' bytes) allowed.
DerivedKeyTokenGenerationAndLengthTooHigh=The derived key's generation ('{0}') and length ('{1}' bytes) result in a key derivation offset that is greater than the maximum offset ('{2}' bytes) allowed.
DerivedKeyLimitExceeded=The number of derived keys in the message has exceeded the maximum allowed number '{0}'.
WrappedKeyLimitExceeded=The number of encrypted keys in the message has exceeded the maximum allowed number '{0}'.
BufferQuotaExceededReadingBase64=Unable to finish reading Base64 data as the given buffer quota has been exceeded. Buffer quota: {0}. Consider increasing the MaxReceivedMessageSize quota on the TransportBindingElement. Please note that a very high value for MaxReceivedMessageSize will result in buffering a large message and might open the system to DOS attacks.
MessageSecurityDoesNotWorkWithManualAddressing=Manual addressing is not supported with message level security. Configure the binding ('{0}', '{1}') to use transport security or to not do manual addressing.
TargetAddressIsNotSet=The target service address was not specified on '{0}'.
IssuedTokenCacheNotSet=The issued token cache was not specified on '{0}'.
SecurityAlgorithmSuiteNotSet=The security algorithm suite was not specified on '{0}'.
SecurityTokenFoundOutsideSecurityHeader=A security token ('{0}', '{1}') was found outside the security header. The message may have been altered in transit.
SecurityTokenNotResolved=The SecurityTokenProvider '{0}' could not resolve the token.
SecureConversationCancelNotAllowedFaultReason=A secure conversation cancellation is not allowed by the binding.
BootstrapSecurityBindingElementNotSet=The security binding element for bootstrap security was not specified on '{0}'.
IssuerBuildContextNotSet=The context for building the issuer channel was  not specified on '{0}'.
StsBindingNotSet=The binding to use to communicate to the federation service at '{0}' is not specified.
SslCertMayNotDoKeyExchange=It is likely that certificate '{0}' may not have a private key that is capable of key exchange or the process may not have access rights for the private key. Please see inner exception for detail.
SslCertMustHavePrivateKey=The certificate '{0}' must have a private key. The process must have access rights for the private key.
NoOutgoingEndpointAddressAvailableForDoingIdentityCheck=No outgoing EndpointAddress is available to check the identity on a message to be sent.
NoOutgoingEndpointAddressAvailableForDoingIdentityCheckOnReply=No outgoing EndpointAddress is available to check the identity on a received reply.
NoSigningTokenAvailableToDoIncomingIdentityCheck=No signing token is available to do an incoming identity check.
Psha1KeyLengthInvalid=The PSHA1 key length '{0}' is invalid.
CloneNotImplementedCorrectly=Clone() was not implemented properly by '{0}'. The cloned object was '{1}'.
BadIssuedTokenType=The issued token is of unexpected type '{0}'. Expected token type '{1}'.
OperationDoesNotAllowImpersonation=The service operation '{0}' that belongs to the contract with the '{1}' name and the '{2}' namespace does not allow impersonation.
RstrHasMultipleIssuedTokens=The RequestSecurityTokenResponse has multiple RequestedSecurityToken elements.
RstrHasMultipleProofTokens=The RequestSecurityTokenResponse has multiple RequestedProofToken elements.
ProofTokenXmlUnexpectedInRstr=The proof token XML element is not expected in the response.
InvalidKeyLengthRequested=The key length '{0}' requested is invalid.
IssuedSecurityTokenParametersNotSet=The security token parameters to use for the issued token are not set on '{0}'.
InvalidOrUnrecognizedAction=The message could not be processed because the action '{0}' is invalid or unrecognized.
UnsupportedTokenInclusionMode=Token inclusion mode '{0}' is not supported.
CannotImportProtectionLevelForContract=The policy to import a process cannot import a binding for contract ({0},{1}). The protection requirements for the binding are not compatible with a binding already imported for the contract. You must reconfigure the binding.
OnlyOneOfEncryptedKeyOrSymmetricBindingCanBeSelected=The symmetric security protocol can either be configured with a symmetric token provider and a symmetric token authenticator or an asymmetric token provider. It cannot be configured with both.
ClientCredentialTypeMustBeSpecifiedForMixedMode=ClientCredentialType.None is not valid for the TransportWithMessageCredential security mode. Specify a message credential type or use a different security mode.
SecuritySessionIdAlreadyPresentInFilterTable=The security session id '{0}' is already present in the filter table.
SupportingTokenNotProvided=A supporting token that satisfies parameters '{0}' and attachment mode '{1}' was not provided.
SupportingTokenIsNotEndorsing=The supporting token provided for parameters '{0}' did not endorse the primary signature.
SupportingTokenIsNotSigned=The supporting token provided for parameters '{0}' was not signed as part of the primary signature.
SupportingTokenIsNotEncrypted=The supporting token provided for parameters '{0}' was not encrypted.
BasicTokenNotExpected=A basic token is not expected in the security header in this context.
FailedAuthenticationTrustFaultCode=The request for security token could not be satisfied because authentication failed.
AuthenticationOfClientFailed=The caller was not authenticated by the service.
InvalidRequestTrustFaultCode=The request for security token has invalid or malformed elements.
SignedSupportingTokenNotExpected=A signed supporting token is not expected in the security header in this context.
SenderSideSupportingTokensMustSpecifySecurityTokenParameters=Security token parameters must be specified with supporting tokens for each message.
SignatureAndEncryptionTokenMismatch=The signature token '{0}' is not the same token as the encryption token '{1}'.
RevertingPrivilegeFailed=The reverting operation failed with the exception '{0}'.
UnknownSupportingToken=Unrecognized supporting token '{0}' was encountered.
MoreThanOneSupportingSignature=More than one supporting signature was encountered using the same supporting token '{0}'.
UnsecuredMessageFaultReceived=An unsecured or incorrectly secured fault was received from the other party. See the inner FaultException for the fault code and detail.
FailedAuthenticationFaultReason=At least one security token in the message could not be validated.
BadContextTokenOrActionFaultReason=The message could not be processed. This is most likely because the action '{0}' is incorrect or because the message contains an invalid or expired security context token or because there is a mismatch between bindings. The security context token would be invalid if the service aborted the channel due to inactivity. To prevent the service from aborting idle sessions prematurely increase the Receive timeout on the service endpoint's binding.
BadContextTokenFaultReason=The security context token is expired or is not valid. The message was not processed.
NegotiationFailedIO=Transport security negotiation failed due to an underlying IO error: {0}.
SecurityNegotiationCannotProtectConfidentialEndpointHeader=The security negotiation with '{0}' cannot be initiated because the confidential endpoint address header ('{1}', '{2}') cannot be encrypted during the course of the negotiation.
InvalidSecurityTokenFaultReason=An error occurred when processing the security tokens in the message.
InvalidSecurityFaultReason=An error occurred when verifying security for the message.
AnonymousLogonsAreNotAllowed=The service does not allow you to log on anonymously.
UnableToObtainIssuerMetadata=Obtaining metadata from issuer '{0}' failed with error '{1}'.
ErrorImportingIssuerMetadata=Importing metadata from issuer '{0}' failed with error '{1}'.
MultipleCorrelationTokensFound=Multiple correlation tokens were found in the security correlation state.
NoCorrelationTokenFound=No correlation token was found in the security correlation state.
MultipleSupportingAuthenticatorsOfSameType=Multiple supporting token authenticators with the token parameter type equal to '{0}' cannot be specified. If more than one Supporting Token of the same type is expected in the response, then configure the supporting token collection with just one entry for that SecurityTokenParameters. The SecurityTokenAuthenticator that gets created from the SecurityTokenParameters will be used to authenticate multiple tokens. It is not possible to add SecurityTokenParameters of the same type in the SupportingTokenParameters collection or repeat it across EndpointSupportingTokenParameters and OperationSupportingTokenParameters.
TooManyIssuedSecurityTokenParameters=A leg of the federated security chain contains multiple IssuedSecurityTokenParameters. The InfoCard system only supports one IssuedSecurityTokenParameters for each leg.
UnknownTokenAuthenticatorUsedInTokenProcessing=An unrecognized token authenticator '{0}' was used for token processing.
TokenMustBeNullWhenTokenParametersAre=The SecurityTokenParameters and SecurityToken tuple specified for use in the security header must both be null or must both be non-null.
SecurityTokenParametersCloneInvalidResult=The CloneCore method of {0} type returned an invalid result. 
CertificateUnsupportedForHttpTransportCredentialOnly=Certificate-based client authentication is not supported in TransportCredentialOnly security mode. Select the Transport security mode.
BasicHttpMessageSecurityRequiresCertificate=BasicHttp binding requires that BasicHttpBinding.Security.Message.ClientCredentialType be equivalent to the BasicHttpMessageCredentialType.Certificate credential type for secure messages. Select Transport or TransportWithMessageCredential security for UserName credentials.
EntropyModeRequiresRequestorEntropy=The client must provide key entropy in key entropy mode '{0}'.
BearerKeyTypeCannotHaveProofKey=A Proof Token was found in the response that was returned by the Security Token Service for a Bearer Key Type token request. Note that Proof Tokens should not be generated when a Bearer Key Type request is made.
BearerKeyIncompatibleWithWSFederationHttpBinding=Bearer Key Type is not supported with WSFederationHttpBinding. Please use WS2007FederationHttpBinding.
UnableToCreateKeyTypeElementForUnknownKeyType=Unable to create Key Type element for the Key Type '{0}'. This might be due to a wrong version of MessageSecurityVersion set on the SecurityBindingElement.
EntropyModeCannotHaveProofTokenOrIssuerEntropy=The issuer cannot provide key entropy or a proof token in key entropy mode '{0}'.
EntropyModeCannotHaveRequestorEntropy=The client cannot provide key entropy in key entropy mode '{0}'.
EntropyModeRequiresProofToken=The issuer must provide a proof token in key entropy mode '{0}'.
EntropyModeRequiresComputedKey=The issuer must provide a computed key in key entropy mode '{0}'.
EntropyModeRequiresIssuerEntropy=The issuer must provide key entropy in key entropy mode '{0}'.
EntropyModeCannotHaveComputedKey=The issuer cannot provide a computed key in key entropy mode '{0}'.
UnknownComputedKeyAlgorithm=The computed key algorithm '{0}' is not supported.
NoncesCachedInfinitely=The ReplayWindow and ClockSkew cannot be the maximum possible value when replay detection is enabled.
ChannelMustBeOpenedToGetSessionId=The session channel must be opened before the session ID can be accessed.
SecurityVersionDoesNotSupportEncryptedKeyBinding=The binding ('{0}','{1}') for contract ('{2}','{3}') has been configured with an incompatible security version that does not support unattached references to EncryptedKeys. Use '{4}' or higher as the security version for the binding.
SecurityVersionDoesNotSupportThumbprintX509KeyIdentifierClause=The '{0}','{1}' binding for the '{2}','{3}' contract is configured with a security version that does not support external references to X.509 tokens using the certificate's thumbprint value. Use '{4}' or higher as the security version for the binding.
SecurityBindingSupportsOneWayOnly=The SecurityBinding for the ('{0}','{1}') binding for the ('{2}','{3}') contract only supports the OneWay operation.
DownlevelNameCannotMapToUpn=Cannot map Windows user '{0}' to a UserPrincipalName that can be used for S4U impersonation.
ResolvingExternalTokensRequireSecurityTokenParameters=Resolving an External reference token requires appropriate SecurityTokenParameters to be specified.
SecurityRenewFaultReason=The SecurityContextSecurityToken's key needs to be renewed.
ClientSecurityOutputSessionCloseTimeout=The client's security session was not able to close its output session within the configured timeout ({0}).
ClientSecurityNegotiationTimeout=Client is unable to finish the security negotiation within the configured timeout ({0}).  The current negotiation leg is {1} ({2}).  
ClientSecuritySessionRequestTimeout=Client is unable to request the security session within the configured timeout ({0}).
ServiceSecurityCloseOutputSessionTimeout=The service's security session was not able to close its output session within the configured timeout ({0}).
ServiceSecurityCloseTimeout=The service's security session did not receive a 'close' message from the client within the configured timeout ({0}).
ClientSecurityCloseTimeout=The client's security session did not receive a 'close response' message from the service within the configured timeout ({0}).
UnableToRenewSessionKey=Cannot renew the security session key.
SessionKeyRenewalNotSupported=Cannot renew the security session key. Session Key Renewal is not supported.
SctCookieXmlParseError=Error parsing SecurityContextSecurityToken Cookie XML.
SctCookieValueMissingOrIncorrect=The SecurityContextSecurityToken's Cookie element either does not contain '{0}' or has a wrong value for it.
SctCookieBlobDecodeFailure=Error decoding the Cookie element of SecurityContextSecurityToken.
SctCookieNotSupported=Issuing cookie SecurityContextSecurityToken is not supported.
CannotImportSupportingTokensForOperationWithoutRequestAction=Security policy import failed. The security policy contains supporting token requirements at the operation scope. The contract description does not specify the action for the request message associated with this operation.
SignatureConfirmationsNotExpected=Signature confirmation is not expected in the security header.
SignatureConfirmationsOccursAfterPrimarySignature=The signature confirmation elements cannot occur after the primary signature.
SignatureConfirmationWasExpected=Signature confirmation was expected to be present in the security header.
SecurityVersionDoesNotSupportSignatureConfirmation=The SecurityVersion '{0}' does not support signature confirmation. Use a later SecurityVersion.
SignatureConfirmationRequiresRequestReply=The protocol factory must support Request/Reply security in order to offer signature confirmation.
NotAllSignaturesConfirmed=Not all the signatures in the request message were confirmed in the reply message.
FoundUnexpectedSignatureConfirmations=The request did not have any signatures but the reply has signature confirmations.
TooManyPendingSessionKeys=There are too many renewed session keys that have not been used.
SecuritySessionKeyIsStale=The session key must be renewed before it can secure application messages.
MultipleMatchingCryptosFound=The token's crypto collection has multiple objects of type '{0}'.
CannotFindMatchingCrypto=The token's crypto collection does not support algorithm '{0}'.
SymmetricSecurityBindingElementNeedsProtectionTokenParameters=SymmetricSecurityBindingElement cannot build a channel or listener factory. The ProtectionTokenParameters property is required but not set. Binding element configuration: {0}
AsymmetricSecurityBindingElementNeedsInitiatorTokenParameters=AsymmetricSecurityBindingElement cannot build a channel or listener factory. The InitiatorTokenParameters property is required but not set. Binding element configuration: {0}
AsymmetricSecurityBindingElementNeedsRecipientTokenParameters=AsymmetricSecurityBindingElement cannot build a channel or listener factory. The RecipientTokenParameters property is required but not set. Binding element configuration: {0}
CachedNegotiationStateQuotaReached=The service cannot cache the negotiation state as the capacity '{0}' has been reached. Retry the request.
LsaAuthorityNotContacted=Internal SSL error (refer to Win32 status code for details). Check the server certificate to determine if it is capable of key exchange.
KeyRolloverGreaterThanKeyRenewal=The key rollover interval cannot be greater than the key renewal interval.
AtLeastOneContractOperationRequestRequiresProtectionLevelNotSupportedByBinding=The request message must be protected. This is required by an operation of the contract ('{0}','{1}'). The protection must be provided by the binding ('{2}','{3}').
AtLeastOneContractOperationResponseRequiresProtectionLevelNotSupportedByBinding=The response message must be protected. This is required by an operation of the contract ('{0}', '{1}'). The protection must be provided by the binding ('{2}', '{3}').
UnknownHeaderCannotProtected=The contract ('{0}','{1}') contains some unknown header ('{2}','{3}') which cannot be secured. Please choose ProtectionLevel.None for this header.   
NoStreamingWithSecurity=The binding ('{0}','{1}') supports streaming which cannot be configured together with message level security.  Consider choosing a different transfer mode or choosing the transport level security.
CurrentSessionTokenNotRenewed=The supporting token in the renew message has a different generation '{0}' than the current session token's generation '{1}'.
IncorrectSpnOrUpnSpecified=Security Support Provider Interface (SSPI) authentication failed. The server may not be running in an account with identity '{0}'. If the server is running in a service account (Network Service for example), specify the account's ServicePrincipalName as the identity in the EndpointAddress for the server. If the server is running in a user account, specify the account's UserPrincipalName as the identity in the EndpointAddress for the server.
IncomingSigningTokenMustBeAnEncryptedKey=For this security protocol, the incoming signing token must be an EncryptedKey.
SecuritySessionAbortedFaultReason=The security session was terminated This may be because no messages were received on the session for too long.
NoAppliesToPresent=No AppliesTo element is present in the deserialized RequestSecurityToken/RequestSecurityTokenResponse.
UnsupportedKeyLength=Symmetric Key length {0} is not supported by the algorithm suite '{1}'.
ForReplayDetectionToBeDoneRequireIntegrityMustBeSet=For replay detection to be done ProtectionLevel must be Sign or EncryptAndSign.
CantInferReferenceForToken=Can't infer an external reference for '{0}' token type.
TrustDriverIsUnableToCreatedNecessaryAttachedOrUnattachedReferences=Unable to create Attached or Unattached reference for '{0}'.
TrustDriverVersionDoesNotSupportSession=The configured Trust version does not support sessions. Use WSTrustFeb2005 or above.
TrustDriverVersionDoesNotSupportIssuedTokens=The configured WS-Trust version does not support issued tokens. WS-Trust February 2005 or later is required.
CannotPerformS4UImpersonationOnPlatform=The binding ('{0}','{1}') for contract ('{2}','{3}') supports impersonation only on Windows 2003 Server and newer version of Windows. Use SspiNegotiated authentication and a binding with Secure Conversation with cancellation enabled.
CannotPerformImpersonationOnUsernameToken=Impersonation using the client token is not possible. The binding ('{0}', '{1}') for contract ('{2}', '{3}') uses the Username Security Token for client authentication with a Membership Provider registered. Use a different type of security token for the client.
SecureConversationRequiredByReliableSession=Cannot establish a reliable session without secure conversation. Enable secure conversation.
RevertImpersonationFailure=Failed to revert impersonation. {0}
TransactionFlowRequiredIssuedTokens=In order to flow a transaction, flowing issued tokens must also be supported.
SignatureConfirmationNotSupported=The configured SecurityVersion does not support signature confirmation. Use WsSecurity11 or above.
SecureConversationDriverVersionDoesNotSupportSession=The configured SecureConversation version does not support sessions. Use WSSecureConversationFeb2005 or above.
SoapSecurityNegotiationFailed=SOAP security negotiation failed. See inner exception for more details.
SoapSecurityNegotiationFailedForIssuerAndTarget=SOAP security negotiation with '{0}' for target '{1}' failed. See inner exception for more details.
OneWayOperationReturnedFault=The one-way operation returned a fault message.  The reason for the fault was '{0}'.
OneWayOperationReturnedLargeFault=The one-way operation returned a fault message with Action='{0}'.
OneWayOperationReturnedMessage=The one-way operation returned a non-null message with Action='{0}'.
CannotFindSecuritySession=Cannot find the security session with the ID '{0}'.
SecurityContextKeyExpired=The SecurityContextSecurityToken with Context-id={0} (generation-id={1}) has expired.
SecurityContextKeyExpiredNoKeyGeneration=The SecurityContextSecurityToken with Context-id={0} (no key generation-id) has expired.
SecuritySessionRequiresMessageIntegrity=Security sessions require all messages to be signed.
RequiredTimestampMissingInSecurityHeader=Required timestamp missing in security header.
ReceivedMessageInRequestContextNull=The request message in the request context received from channel '{0}' is null.
KeyLifetimeNotWithinTokenLifetime=The key effective and expiration times must be bounded by the token effective and expiration times.
EffectiveGreaterThanExpiration=The valid from time is greater than the valid to time.
NoSessionTokenPresentInMessage=No session token was present in the message.
KeyLengthMustBeMultipleOfEight=Key length '{0}' is not a multiple of 8 for symmetric keys.
InvalidX509RawData=Invalid binary representation of an X.509 certificate.
ExportOfBindingWithTransportSecurityBindingElementAndNoTransportSecurityNotSupported=Security policy export failed. The binding contains a TransportSecurityBindingElement but no transport binding element that implements ITransportTokenAssertionProvider. Policy export for such a binding is not supported. Make sure the transport binding element in the binding implements the ITransportTokenAssertionProvider interface.
UnsupportedSecureConversationBootstrapProtectionRequirements=Cannot import the security policy. The protection requirements for the secure conversation bootstrap binding are not supported. Protection requirements for the secure conversation bootstrap must require both the request and the response to be signed and encrypted.
UnsupportedBooleanAttribute=Cannot import the policy. The value of the attribute '{0}' must be either 'true', 'false', '1' or '0'. The following error occurred: '{1}'.
NoTransportTokenAssertionProvided=The security policy expert failed. The provided transport token assertion of type '{0}' did not create a transport token assertion to include the sp:TransportBinding security policy assertion.
PolicyRequiresConfidentialityWithoutIntegrity=Message security policy for the '{0}' action requires confidentiality without integrity. Confidentiality without integrity is not supported.
PrimarySignatureIsRequiredToBeEncrypted=The primary signature must be encrypted.
TokenCannotCreateSymmetricCrypto=A symmetric crypto could not be created from token '{0}'.
TokenDoesNotMeetKeySizeRequirements=The key size requirements for the '{0}' algorithm suite are not met by the '{1}' token which has key size of '{2}'.
MessageProtectionOrderMismatch=The received message does not meet the required message protection order '{0}'.
PrimarySignatureMustBeComputedBeforeSupportingTokenSignatures=Primary signature must be computed before supporting token signatures.
ElementToSignMustHaveId=Element to sign must have id.
StandardsManagerCannotWriteObject=The token Serializer cannot serialize '{0}'.  If this is a custom type you must supply a custom serializer.
SigningWithoutPrimarySignatureRequiresTimestamp=Signing without primary signature requires timestamp.
OperationCannotBeDoneAfterProcessingIsStarted=This operation cannot be done after processing is started.
MaximumPolicyRedirectionsExceeded=The recursive policy fetching limit has been reached. Check to determine if there is a loop in the federation service chain.
InvalidAttributeInSignedHeader=The ('{0}', '{1}') signed header contains the ('{2}', '{3}') attribute. The expected attribute is ('{4}', '{5}').
StsAddressNotSet=The address of the security token issuer is not specified. An explicit issuer address must be specified in the binding for target '{0}' or the local issuer address must be configured in the credentials.
MoreThanOneSecurityBindingElementInTheBinding=More than one SecurityBindingElement found in the binding ('{0}', '{1}) for contract ('{2}', '{3}'). Only one SecurityBindingElement is allowed. 
ClientCredentialsUnableToCreateLocalTokenProvider=ClientCredentials cannot create a local token provider for token requirement {0}.
SecurityBindingElementCannotBeExpressedInConfig=A security policy was imported for the endpoint. The security policy contains requirements that cannot be represented in a Windows Communication Foundation configuration. Look for a comment about the SecurityBindingElement parameters that are required in the configuration file that was generated. Create the correct binding element with code. The binding configuration that is in the configuration file is not secure.
ConfigurationSchemaInsuffientForSecurityBindingElementInstance=The configuration schema is insufficient to describe the non-standard configuration of the following security binding element: 
ConfigurationSchemaContainsX509IssuerSerialReference=The wsdl schema that was used to create this configuration file contained a 'RequireIssuerSerialReference' assertion for a X509Token.  This can not be represented in configuration, you will need to programatically adjust the appropriate X509SecurityTokenParameters.X509KeyIdentifierClauseType to X509KeyIdentifierClauseType.IssuerSerial.  The default of X509KeyIdentifierClauseType.Thumbprint will be used, which may cause interop issues.
;OperationCannotBeDoneOnReceiverSideSecurityHeaders=This operation cannot be done on the receiver security headers.
SecurityProtocolCannotDoReplayDetection=The security protocol '{0}' cannot do replay detection.
UnableToFindSecurityHeaderInMessage=Security processor was unable to find a security header with actor '{0}' in the message. This might be because the message is an unsecured fault or because there is a binding mismatch between the communicating parties.  This can occur if the service is configured for security and the client is not using security.
UnableToFindSecurityHeaderInMessageNoActor=Security processor was unable to find a security header in the message. This might be because the message is an unsecured fault or because there is a binding mismatch between the communicating parties.   This can occur if the service is configured for security and the client is not using security.
NoPrimarySignatureAvailableForSupportingTokenSignatureVerification=No primary signature available for supporting token signature verification.
SupportingTokenSignaturesNotExpected=Supporting token signatures not expected.
CannotReadToken=Cannot read the token from the '{0}' element with the '{1}' namespace for BinarySecretSecurityToken, with a '{2}' ValueType. If this element is expected to be valid, ensure that security is configured to consume tokens with the name, namespace and value type specified.
ExpectedElementMissing=Element '{0}' with namespace '{1}' not found.
ExpectedOneOfTwoElementsFromNamespace=Expected element '{0}' or element '{1}' (from namespace '{2}').
RstDirectDoesNotExpectRstr=AcceleratedTokenAuthenticator does not expect RequestSecurityTokenResponse from the client.
RequireNonCookieMode=The '{0}' binding with the '{1}' namespace is configured to issue cookie security context tokens. COM+ Integration services does not support cookie security context tokens.
RequiredSignatureMissing=The signature must be in the security header.
RequiredMessagePartNotSigned=The '{0}' required message part was not signed.
RequiredMessagePartNotSignedNs=The '{0}', '{1}' required message part  was not signed.
RequiredMessagePartNotEncrypted=The '{0}' required message part was not encrypted.
RequiredMessagePartNotEncryptedNs=The '{0}', '{1}' required message part  was not encrypted.
SignatureVerificationFailed=Signature verification failed.
CannotIssueRstTokenType=Cannot issue the token type '{0}'.
NoNegotiationMessageToSend=There is no negotiation message to send.
InvalidIssuedTokenKeySize=The issued token has an invalid key size '{0}'.
CannotObtainIssuedTokenKeySize=Cannot determine the key size of the issued token.
NegotiationIsNotCompleted=The negotiation has not yet completed.
NegotiationIsCompleted=The negotiation has already completed.
MissingMessageID=Request Message is missing a MessageID header. One is required to correlate a reply.
SecuritySessionLimitReached=Cannot create a security session. Retry later.
SecuritySessionAlreadyPending=The security session with id '{0}' is already pending.
SecuritySessionNotPending=No security session with id '{0}' is pending.
SecuritySessionListenerNotFound=No security session listener was found for message with action '{0}'.
SessionTokenWasNotClosed=The session token was not closed by the server.
ProtocolMustBeInitiator='{0}' protocol can only be used by the Initiator.
ProtocolMustBeRecipient='{0}' protocol can only be used at the Recipient.
SendingOutgoingmessageOnRecipient=Unexpected code path for server security application, sending outgoing message on Recipient.
OnlyBodyReturnValuesSupported=Only body return values are supported currently for protection, MessagePartDescription was specified.
UnknownTokenAttachmentMode=Unknown token attachment mode: {0}.
ProtocolMisMatch=Security protocol must be '{0}', type is: '{1}'.;
AttemptToCreateMultipleRequestContext=The initial request context was already specified.  Can not create two for same message.
ServerReceivedCloseMessageStateIsCreated={0}.OnCloseMessageReceived when state == Created.
ShutdownRequestWasNotReceived=Shutdown request was not received.
UnknownFilterType=Unknown filter type: '{0}'.
StandardsManagerDoesNotMatch=Standards manager of filter does not match that of filter table.  Can not have two different filters.
FilterStrictModeDifferent=Session filter's isStrictMode differs from filter table's isStrictMode.
SSSSCreateAcceptor=SecuritySessionServerSettings.CreateAcceptor, channelAcceptor must be null, can not create twice.
TransactionFlowBadOption=Invalid TransactionFlowOption value.
TokenManagerCouldNotReadToken=Security token manager could not parse token with name '{0}', namespace '{1}', valueType '{2}'.
InvalidActionForNegotiationMessage=Security negotiation message has incorrect action '{0}'.
InvalidKeySizeSpecifiedInNegotiation=The specified key size {0} is invalid. The key size must be between {1} and {2}.
GetTokenInfoFailed=Could not get token information (error=0x{0:X}).
UnexpectedEndOfFile=Unexpected end of file.
TimeStampHasCreationAheadOfExpiry=The security timestamp is invalid because its creation time ('{0}') is greater than or equal to its expiration time ('{1}').
TimeStampHasExpiryTimeInPast=The security timestamp is stale because its expiration time ('{0}') is in the past. Current time is '{1}' and allowed clock skew is '{2}'.
TimeStampHasCreationTimeInFuture=The security timestamp is invalid because its creation time ('{0}') is in the future. Current time is '{1}' and allowed clock skew is '{2}'.
TimeStampWasCreatedTooLongAgo=The security timestamp is stale because its creation time ('{0}') is too far back in the past. Current time is '{1}', maximum timestamp lifetime is '{2}' and allowed clock skew is '{3}'.
InvalidOrReplayedNonce=The nonce is invalid or replayed.
MessagePartSpecificationMustBeImmutable=Message part specification must be made constant before being set.
UnsupportedIssuerEntropyType=Issuer entropy is not BinarySecretSecurityToken or WrappedKeySecurityToken.
NoRequestSecurityTokenResponseElements=No RequestSecurityTokenResponse elements were found.
NoCookieInSct=The SecurityContextSecurityToken does not have a cookie.
TokenProviderReturnedBadToken=TokenProvider returned token of incorrect type '{0}'.
ItemNotAvailableInDeserializedRST={0} is not available in deserialized RequestSecurityToken.
ItemAvailableInDeserializedRSTOnly={0} is only available in a deserialized RequestSecurityToken.
ItemNotAvailableInDeserializedRSTR={0} is not available in deserialized RequestSecurityTokenResponse.
ItemAvailableInDeserializedRSTROnly={0} is only available in a deserialized RequestSecurityTokenResponse.
MoreThanOneRSTRInRSTRC=The RequestSecurityTokenResponseCollection received has more than one RequestSecurityTokenResponse element. Only one RequestSecurityTokenResponse element was expected.
Hosting_VirtualPathExtenstionCanNotBeDetached=VirtualPathExtension is not allowed to be removed.
Hosting_NotSupportedProtocol=The protocol '{0}' is not supported.
Hosting_BaseUriDeserializedNotValid=The BaseUriWithWildcard object has invalid fields after deserialization.
Hosting_RelativeAddressFormatError=Registered relativeAddress '{0}' in configuration file is not a valid one. Possible causes could be : You specified an empty addreess or an absolute address (i.e., starting with '/' or '\\'), or the address contains invalid character[s]. The supported relativeAddress formats are "[folder/]filename" or "~/[folder/]filename".  
Hosting_NoAbsoluteRelativeAddress= '{0}' is an absolute address. The supported relativeAddress formats are "[subfolder/]filename" or "~/[subfolder/]filename".  
SecureConversationNeedsBootstrapSecurity=Cannot create security binding element based on the configuration data. When secure conversation authentication mode is selected, the secure conversation bootstrap binding element must also be specified. 
Hosting_MemoryGatesCheckFailedUnderPartialTrust=Setting minFreeMemoryPercentageToActivateService requires full trust privilege. Please change the application's trust level or remove this setting from the configuration file.
Hosting_CompatibilityServiceNotHosted=This service requires ASP.NET compatibility and must be hosted in IIS.  Either host the service in IIS with ASP.NET compatibility turned on in web.config or set the AspNetCompatibilityRequirementsAttribute.AspNetCompatibilityRequirementsMode property to a value other than Required.
Hosting_MisformattedPort=The '{0}' protocol binding '{1}' specifies an invalid port number '{2}'.
Hosting_MisformattedBinding=The protocol binding '{0}' does not conform to the syntax for '{1}'. The following is an example of valid '{1}' protocol bindings: '{2}'.
Hosting_MisformattedBindingData=The protocol binding '{0}' is not valid for '{1}'.  This might be because the port number is out of range.
Hosting_NoHttpTransportManagerForUri=There is no compatible TransportManager found for URI '{0}'. This may be because you have used an absolute address that points outside of the virtual application. Please use a relative address instead.
Hosting_NoTcpPipeTransportManagerForUri=There is no compatible TransportManager found for URI '{0}'. This may be because you have used an absolute address that points outside of the virtual application, or the binding settings of the endpoint do not match those that have been set by other services or endpoints. Note that all bindings for the same protocol should have the same settings in the same application.
Hosting_ProcessNotExecutingUnderHostedContext='{0}' cannot be invoked within the current hosting environment. This API requires that the calling application be hosted in IIS or WAS.
Hosting_ServiceActivationFailed=The requested service, '{0}' could not be activated. See the server's diagnostic trace logs for more information.
Hosting_ServiceTypeNotProvided=The value for the Service attribute was not provided in the ServiceHost directive.
SharedEndpointReadDenied=The service endpoint failed to listen on the URI '{0}' because access was denied.  Verify that the current user is granted access in the appropriate allowAccounts section of SMSvcHost.exe.config.
SharedEndpointReadNotFound=The service endpoint failed to listen on the URI '{0}' because the shared memory section was not found.  Verify that the '{1}' service is running.
SharedManagerBase=The TransportManager failed to listen on the supplied URI using the {0} service: {1}.
SharedManagerServiceStartFailure=failed to start the service ({0}). Refer to the Event Log for more details
SharedManagerServiceStartFailureDisabled=failed to start the service because it is disabled. An administrator can enable it by running 'sc.exe config {0} start= demand'.
SharedManagerServiceStartFailureNoError=failed to start the service. Refer to the Event Log for more details
SharedManagerServiceLookupFailure=failed to look up the service process in the SCM ({0})
SharedManagerServiceSidLookupFailure=failed to look up the service SID in the SCM ({0})
SharedManagerServiceEndpointReadFailure=failed to read the service's endpoint with native error code {0}.  See inner exception for details
SharedManagerServiceSecurityFailed=the service failed the security checks
SharedManagerUserSidLookupFailure=failed to retrieve the UserSid of the service process ({0})
SharedManagerCurrentUserSidLookupFailure=failed to retrieve the UserSid of the current process
SharedManagerLogonSidLookupFailure=failed to retrieve the LogonSid of the service process ({0})
SharedManagerDataConnectionFailure=failed to establish a data connection to the service
SharedManagerDataConnectionCreateFailure=failed to create a data connection to the service
;SharedManagerDataConnectionTimeout=failed to establish the data connection to the service because of a timeout
SharedManagerDataConnectionPipeFailed=failed to establish the data connection because of an I/O error
SharedManagerVersionUnsupported=the version is not supported by the service
SharedManagerAllowDupHandleFailed=failed to grant the PROCESS_DUP_HANDLE access right to the target service's account SID '{0}'.
SharedManagerPathTooLong=the URI is too long
SharedManagerRegistrationQuotaExceeded=the quota was exceeded
SharedManagerProtocolUnsupported=the protocol is not supported
SharedManagerConflictingRegistration=the URI is already registered with the service
SharedManagerFailedToListen=the service failed to listen
Sharing_ConnectionDispatchFailed=The message could not be dispatched to the service at address '{0}'. Refer to the server Event Log for more details
Sharing_EndpointUnavailable=The message could not be dispatched because the service at the endpoint address '{0}' is unavailable for the protocol of the address.
Sharing_EmptyListenerEndpoint=The endpoint address for the NT service '{0}' read from shared memory is empty.
Sharing_ListenerProxyStopped=The message could not be dispatched because the transport manager has been stopped.  This can happen if the application is being recycled or disabled.
UnexpectedEmptyElementExpectingClaim=The '{0}' from the '{1}' namespace is empty and does not specify a valid identity claim. 
UnexpectedElementExpectingElement='{0}' from namespace '{1}' is not expected. Expecting element '{2}' from namespace '{3}'
UnexpectedDuplicateElement='{0}' from namespace '{1}' is not expected to appear more than once
UnsupportedSecurityPolicyAssertion=An unsupported security policy assertion was detected during the security policy import: {0}
MultipleIdentities=The extensions cannot contain an Identity if one is supplied as a constructor argument.
InvalidUriValue=Value '{0}' provided for '{1}' from namespace '{2}' is an invalid absolute URI.
BindingDoesNotSupportProtectionForRst=The binding ('{0}','{1}') for contract ('{2}','{3}') is configured with SecureConversation, but the authentication mode is not able to provide the request/reply-based integrity and confidentiality required for the negotiation.
TransportDoesNotProtectMessage=The '{0}'.'{1}' binding for the '{2}'.'{3}' contract is configured with an authentication mode that requires transport level integrity and confidentiality. However the transport cannot provide integrity and confidentiality.
BindingDoesNotSupportWindowsIdenityForImpersonation=The contract operation '{0}' requires Windows identity for automatic impersonation. A Windows identity that represents the caller is not provided by binding ('{1}','{2}') for contract ('{3}','{4}'.
ListenUriNotSet=A listen URI must be specified in order to open this {0}.
UnsupportedChannelInterfaceType=Channel interface type '{0}' is not supported.
TransportManagerOpen=This property cannot be changed after the transport manager has been opened.
TransportManagerNotOpen=This operation is only valid after the transport manager has been opened.
UnrecognizedIdentityType=Unrecognized identity type Name='{0}', Namespace='{1}'.
InvalidIdentityElement=Cannot read the Identity element. The Identity type is not supported or the Identity element is empty.
UnableToLoadCertificateIdentity=Cannot load the X.509 certificate identity specified in the configuration.
UnrecognizedClaimTypeForIdentity=The ClaimType '{0}' is not recognized. Expected ClaimType '{1}'.
AsyncCallbackException=An AsyncCallback threw an exception.
SendCannotBeCalledAfterCloseOutputSession=You cannot Send messages on a channel after CloseOutputSession has been called.
CommunicationObjectCannotBeModifiedInState=The communication object, {0}, cannot be modified while it is in the {1} state.
CommunicationObjectCannotBeModified=The communication object, {0}, cannot be modified unless it is in the Created state.
CommunicationObjectCannotBeUsed=The communication object, {0}, is in the {1} state.  Communication objects cannot be used for communication unless they are in the Opened state.
CommunicationObjectFaulted1=The communication object, {0}, cannot be used for communication because it is in the Faulted state.
CommunicationObjectFaultedStack2=The communication object, {0}, cannot be used for communication because it is in the Faulted state: {1}
CommunicationObjectAborted1=The communication object, {0}, cannot be used for communication because it has been Aborted.
CommunicationObjectAbortedStack2=The communication object, {0}, cannot be used for communication because it has been Aborted: {1}
CommunicationObjectBaseClassMethodNotCalled=The communication object, {0}, has overridden the virtual function {1} but it does not call version defined in the base class.
CommunicationObjectInInvalidState=The communication object, {0}, is not part of WCF and is in an unsupported state '{1}'.  This indicates an internal error in the implementation of that communication object.
CommunicationObjectCloseInterrupted1=The communication object, {0}, cannot be used due to an error that occurred during close.
ChannelFactoryCannotBeUsedToCreateChannels=A call to IChannelFactory.CreateChannel made on an object of type {0} failed because Open has not been called on this object.
ChannelParametersCannotBeModified=Cannot modify channel parameters because the {0} is in the {1} state.  This operation is only supported in the Created state.
ChannelParametersCannotBePropagated=Cannot propagate channel parameters because the {0} is in the {1} state.  This operation is only supported in the Opening or Opened state when the collection is locked.
OneWayInternalTypeNotSupported=Binding '{0}' is not configured properly. OneWayBindingElement requires an inner binding element that supports IRequestChannel/IReplyChannel or IDuplexSessionChannel. 
ChannelTypeNotSupported=The specified channel type {0} is not supported by this channel manager.
SecurityContextMissing=SecurityContext for the UltimateReceiver role is missing from the SecurityContextProperty of the request message with action '{0}'.
SecurityContextDoesNotAllowImpersonation=Cannot start impersonation because the SecurityContext for the UltimateReceiver role from the request message with the '{0}' action is not mapped to a Windows identity.
InvalidEnumValue=Unexpected internal enum value: {0}.
InvalidDecoderStateMachine=Invalid decoder state machine.
OperationPropertyIsRequiredForAttributeGeneration=Operation property of OperationAttributeGenerationContext is required to generate an attribute based on settings. 
InvalidMembershipProviderSpecifiedInConfig=The username/password Membership provider {0} specified in the configuration is invalid. No such provider was found registered under system.web/membership/providers.
InvalidRoleProviderSpecifiedInConfig=The RoleProvider {0} specified in the configuration is invalid. No such provider was found registered under system.web/roleManager/providers.
ObjectDisposed=The {0} object has been disposed.
InvalidReaderPositionOnCreateMessage=The XmlReader used for the body of the message must be positioned on an element.
DuplicateMessageProperty=A property with the name '{0}' already exists.
MessagePropertyNotFound=A property with the name '{0}' is not present.
HeaderAlreadyUnderstood=The message header with name '{0}' and namespace '{1}' is already present in the set of understood headers.
HeaderAlreadyNotUnderstood=The message header with name '{0}' and namespace '{1}' is not present in the set of understood headers.
MultipleMessageHeaders=Multiple headers with name '{0}' and namespace '{1}' found.
MultipleMessageHeadersWithActor=Multiple headers with name '{0}' and namespace '{1}' and role '{2}' found.
MultipleRelatesToHeaders= Multiple RelatesTo headers with relationship '{0}' found.  Only one is allowed per relationship.
ExtraContentIsPresentInFaultDetail=Additional XML content is present in the fault detail element. Only a single element is allowed.
MessageIsEmpty=The body of the message cannot be read because it is empty.
MessageClosed=Message is closed.
StreamClosed=The operation cannot be completed because the stream is closed.
BodyWriterReturnedIsNotBuffered=The body writer returned from OnCreateBufferedCopy was not buffered.
BodyWriterCanOnlyBeWrittenOnce=The body writer does not support writing more than once because it is not buffered.
RstrKeySizeNotProvided=KeySize element not present in RequestSecurityTokenResponse.
RequestMessageDoesNotHaveAMessageID=A reply message cannot be created because the request message does not have a MessageID.
HeaderNotFound=There is not a header with name {0} and namespace {1} in the message.
MessageBufferIsClosed=MessageBuffer is closed.
MessageTextEncodingNotSupported=The text encoding '{0}' used in the text message format is not supported.
AtLeastOneFaultReasonMustBeSpecified=At least one fault reason must be specified.
NoNullTranslations=The translation set cannot contain nulls.
FaultDoesNotHaveAnyDetail=The fault does not have detail information.
InvalidXmlQualifiedName=Expected XML qualified name, found '{0}'.
UnboundPrefixInQName=Unbound prefix used in qualified name '{0}'.
MessageBodyIsUnknown=...
MessageBodyIsStream=... stream ...
MessageBodyToStringError=... Error reading body: {0}: {1} ...
NoMatchingTranslationFoundForFaultText=The fault reason does not contain any text translations.
CannotDetermineSPNBasedOnAddress=Client cannot determine the Service Principal Name based on the identity in the target address '{0}' for the purpose of SspiNegotiation/Kerberos. The target address identity must be a UPN identity (like acmedomain\\alice) or SPN identity (like host/bobs-machine).
XmlLangAttributeMissing=Required xml:lang attribute value is missing.
EncoderUnrecognizedCharSet=Unrecognized charSet '{0}' in contentType.
EncoderUnrecognizedContentType=Unrecognized contentType ({0}). Expected: {1}.
EncoderBadContentType=Cannot process contentType.
EncoderEnvelopeVersionMismatch=The envelope version of the incoming message ({0}) does not match that of the encoder ({1}). Make sure the binding is configured with the same version as the expected messages.
EncoderMessageVersionMismatch=The message version of the outgoing message ({0}) does not match that of the encoder ({1}). Make sure the binding is configured with the same version as the message.
MtomEncoderBadMessageVersion=MessageVersion '{0}' not supported by MTOM encoder.
ReadNotSupported=Read is not supported on this stream.
SeekNotSupported=Seek is not supported on this stream.
WriterAsyncWritePending=An asynchronous write is pending on the stream. Ensure that there are no uncompleted asynchronous writes before attempting the next write. 
ChannelInitializationTimeout=A newly accepted connection did not receive initialization data from the sender within the configured ChannelInitializationTimeout ({0}).  As a result, the connection will be aborted.  If you are on a highly congested network, or your sending machine is heavily loaded, consider increasing this value or load-balancing your server.
SocketCloseReadTimeout=The remote endpoint of the socket ({0}) did not respond to a close request within the allotted timeout ({1}). It is likely that the remote endpoint is not calling Close after receiving the EOF signal (null) from Receive. The time allotted to this operation may have been a portion of a longer timeout.
SocketCloseReadReceivedData=A graceful close was attempted on the socket, but the other side ({0}) is still sending data.
PipeCantCloseWithPendingWrite=The pipe cannot be closed while a write to the pipe is pending.
PipeShutdownWriteError=The shutdown indicator could not be written to the pipe.  The application on the other end of the pipe may not be listening for it.  The pipe will still be closed.
PipeShutdownReadError=The shutdown indicator was not received from the pipe.  The application on the other end of the pipe may not have sent it.  The pipe will still be closed.
PipeNameCanNotBeAccessed=The pipe name could not be obtained for the pipe URI: {0}
PipeNameCanNotBeAccessed2=The pipe name could not be obtained for {0}.
PipeModeChangeFailed=The pipe was not able to be set to message mode: {0}
PipeCloseFailed=The pipe could not close gracefully.  This may be caused by the application on the other end of the pipe exiting.
PipeAlreadyShuttingDown=The pipe cannot be written to because it is already in the process of shutting down.
PipeSignalExpected=The read from the pipe expected just a signal, but received actual data.
PipeAlreadyClosing=The pipe cannot be written to or read from because it is already in the process of being closed.
PipeAcceptFailed=Server cannot accept pipe: {0}
PipeListenFailed=Cannot listen on pipe '{0}': {1}
PipeNameInUse=Cannot listen on pipe name '{0}' because another pipe endpoint is already listening on that name.
PipeNameCantBeReserved=Cannot listen on pipe '{0}' because the pipe name could not be reserved: {1}
PipeListenerDisposed=The pipe listener has been disposed.
PipeListenerNotListening=Connections cannot be created until the pipe has started listening.  Call Listen() before attempting to accept a connection.
PipeConnectAddressFailed=A pipe endpoint exists for '{0}', but the connect failed: {1}
PipeConnectFailed=Cannot connect to endpoint '{0}'. 
PipeConnectTimedOut=Cannot connect to endpoint '{0}' within the allotted timeout of {1}. The time allotted to this operation may have been a portion of a longer timeout.
PipeConnectTimedOutServerTooBusy=Cannot connect to endpoint '{0}' within the allotted timeout of {1}. The server has likely reached the MaxConnections quota and is too busy to accept new connections. The time allotted to this operation may have been a portion of a longer timeout.
PipeEndpointNotFound=The pipe endpoint '{0}' could not be found on your local machine. 
PipeUriSchemeWrong=URIs used with pipes must use the scheme: 'net.pipe'.
PipeWriteIncomplete=The pipe write did not write all the bytes.
PipeClosed=The operation cannot be completed because the pipe was closed.  This may have been caused by the application on the other end of the pipe exiting.
PipeReadTimedOut=The read from the pipe did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.
PipeWriteTimedOut=The write to the pipe did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.
PipeConnectionAbortedReadTimedOut=The pipe connection was aborted because an asynchronous read from the pipe did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.
PipeConnectionAbortedWriteTimedOut=The pipe connection was aborted because an asynchronous write to the pipe did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.
PipeWriteError=There was an error writing to the pipe: {0}.
PipeReadError=There was an error reading from the pipe: {0}.
PipeUnknownWin32Error=Unrecognized error {0} (0x{1})
PipeKnownWin32Error={0} ({1}, 0x{2})
PipeWritePending=There is already a write in progress for the pipe.  Wait for the first operation to complete before attempting to write again.
PipeReadPending=There is already a read in progress for the pipe.  Wait for the first operation to complete before attempting to read again.
PipeDuplicationFailed=There was an error duplicating the.
SessionValueInvalid=The Session value '{0}' is invalid. Please specify 'CurrentSession','ServiceSession' or a valid non-negative Windows Session Id.
PackageFullNameInvalid=The package full name '{0}' is invalid.
SocketAbortedReceiveTimedOut=The socket was aborted because an asynchronous receive from the socket did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.
SocketAbortedSendTimedOut=The socket connection was aborted because an asynchronous send to the socket did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.
OperationInvalidBeforeSecurityNegotiation=This operation is not valid until security negotiation is complete.
FramingError=Error while reading message framing format at position {0} of stream (state: {1})
FramingPrematureEOF=More data was expected, but EOF was reached.
FramingRecordTypeMismatch=Expected record type '{0}', found '{1}'.
FramingVersionNotSupported=Framing major version {0} is not supported.
FramingModeNotSupported=Framing mode {0} is not supported.
FramingSizeTooLarge=Specified size is too large for this implementation.
FramingViaTooLong=The framing via size ({0}) exceeds the quota.
FramingViaNotUri=The framing via ({0}) is not a valid URI.
FramingFaultTooLong=The framing fault size ({0}) exceeds the quota.
FramingContentTypeTooLong=The framing content type size ({0}) exceeds the quota.
FramingValueNotAvailable=The value cannot be accessed because it has not yet been fully decoded.
FramingAtEnd=An attempt was made to decode a value after the framing stream was ended.
RemoteSecurityNotNegotiatedOnStreamUpgrade=Stream Security is required at {0}, but no security context was negotiated. This is likely caused by the remote endpoint missing a StreamSecurityBindingElement from its binding.
BinaryEncoderSessionTooLarge=The binary encoder session information exceeded the maximum size quota ({0}). To increase this quota, use the MaxSessionSize property on the BinaryMessageEncodingBindingElement.
BinaryEncoderSessionInvalid=The binary encoder session is not valid. There was an error decoding a previous message.
BinaryEncoderSessionMalformed=The binary encoder session information is not properly formed.
ReceiveShutdownReturnedFault=The channel received an unexpected fault input message while closing. The fault reason given is: '{0}'
ReceiveShutdownReturnedLargeFault=The channel received an unexpected fault input message with Action = '{0}' while closing. You should only close your channel when you are not expecting any more input messages.
ReceiveShutdownReturnedMessage=The channel received an unexpected input message with Action '{0}' while closing. You should only close your channel when you are not expecting any more input messages.
MaxReceivedMessageSizeExceeded=The maximum message size quota for incoming messages ({0}) has been exceeded. To increase the quota, use the MaxReceivedMessageSize property on the appropriate binding element.
MaxSentMessageSizeExceeded=The maximum message size quota for outgoing messages ({0}) has been exceeded.
FramingMaxMessageSizeExceeded=The maximum message size quota for incoming messages has been exceeded for the remote channel. See the server logs for more details.
StreamDoesNotSupportTimeout=TimeoutStream requires an inner Stream that supports timeouts; its CanTimeout property must be true.
FilterExists=The filter already exists in the filter table.
FilterUnexpectedError=An internal error has occurred. Unexpected error modifying filter table.
FilterNodeQuotaExceeded=The number of XML infoset nodes inspected by the navigator has exceeded the quota ({0}).
FilterCapacityNegative=Value cannot be negative.
ActionFilterEmptyList=The set of actions cannot be empty.
FilterUndefinedPrefix=The prefix '{0}' is not defined.
FilterMultipleMatches=Multiple filters matched.
FilterTableTypeMismatch=The type of IMessageFilterTable created for a particular Filter type must always be the same.
FilterTableInvalidForLookup=The MessageFilterTable state is corrupt. The requested lookup cannot be performed.
FilterBadTableType=The IMessageFilterTable created for a Filter cannot be a MessageFilterTable or a subclass of MessageFilterTable.
FilterQuotaRange=NodeQuota must be greater than 0.
FilterEmptyString=Parameter value cannot be an empty string.
FilterInvalidInner=Required inner element '{0}' was not found.
FilterInvalidAttribute=Invalid attribute on the XPath.
FilterInvalidDialect=When present, the dialect attribute must have the value '{0}'.
FilterCouldNotCompile=Could not compile the XPath expression '{0}' with the given XsltContext.
FilterReaderNotStartElem=XmlReader not positioned at a start element.
SeekableMessageNavInvalidPosition=The position is not valid for this navigator.
SeekableMessageNavNonAtomized=Cannot call '{0}' on a non-atomized navigator.
SeekableMessageNavIDNotSupported=XML unique ID not supported.
SeekableMessageNavBodyForbidden=A filter has attempted to access the body of a Message. Use a MessageBuffer instead if body filtering is required.
SeekableMessageNavOverrideForbidden=Not allowed to override prefix '{0}'.
QueryNotImplemented=The function '{0}' is not implemented.
QueryNotSortable=XPathNavigator positions cannot be compared.
QueryMustBeSeekable=XPathNavigator must be a SeekableXPathNavigator.
QueryContextNotSupportedInSequences=Context node is not supported in node sequences.
QueryFunctionTypeNotSupported=IXsltContextFunction return type '{0}' not supported.
QueryVariableTypeNotSupported=IXsltContextVariable type '{0}' not supported.
QueryVariableNull=IXsltContextVariables cannot return null.
QueryFunctionStringArg=The argument to an IXsltContextFunction could not be converted to a string.
QueryItemAlreadyExists=An internal error has occurred. Item already exists.
QueryBeforeNodes=Positioned before first element.
QueryAfterNodes=Positioned after last element.
QueryIteratorOutOfScope=The XPathNodeIterator has been invalidated. XPathNodeIterators passed as arguments to IXsltContextFunctions are only valid within the function. They cannot be cached for later use or returned as the result of the function.
QueryCantGetStringForMovedIterator=The string value can't be determined because the XPathNodeIterator has been moved past the first node.
MessageVersionToStringFormat={0} {1}
Addressing10ToStringFormat=Addressing10 ({0})
Addressing200408ToStringFormat=Addressing200408 ({0})
AddressingNoneToStringFormat=AddressingNone ({0})
AddressingVersionNotSupported=Addressing Version '{0}' is not supported.
SupportedAddressingModeNotSupported=The '{0}' addressing mode is not supported.
Soap11ToStringFormat=Soap11 ({0})
Soap12ToStringFormat=Soap12 ({0})
EnvelopeNoneToStringFormat=EnvelopeNone ({0})
MessagePropertyReturnedNullCopy=The IMessageProperty could not be copied. CreateCopy returned null.
MessageVersionUnknown=Unrecognized message version.
EnvelopeVersionUnknown=Unrecognized envelope version: {0}.
EnvelopeVersionNotSupported=Envelope Version '{0}' is not supported.
CannotDetectAddressingVersion=Cannot detect WS-Addressing version. EndpointReference does not start with an Element.
HeadersCannotBeAddedToEnvelopeVersion=Envelope Version '{0}' does not support adding Message Headers.
AddressingHeadersCannotBeAddedToAddressingVersion=Addressing Version '{0}' does not support adding WS-Addressing headers.
AddressingExtensionInBadNS=The element '{0}' in namespace '{1}' is not valid. This either means that element '{0}' is a duplicate element, or that it is not a legal extension because extension elements cannot be in the addressing namespace.
MessageHeaderVersionNotSupported=The '{0}' header cannot be added because it does not support the specified message version '{1}'.
MessageHasBeenCopied=This message cannot support the operation because it has been copied.
MessageHasBeenWritten=This message cannot support the operation because it has been written.
MessageHasBeenRead=This message cannot support the operation because it has been read.
InvalidMessageState=An internal error has occurred. Invalid MessageState.
MessageBodyReaderInvalidReadState=The body reader is in ReadState '{0}' and cannot be consumed.
XmlBufferQuotaExceeded=The size necessary to buffer the XML content exceeded the buffer quota.
XmlBufferInInvalidState=An internal error has occurred. The XML buffer is not in the correct state to perform the operation.
MessageBodyMissing=A body element was not found inside the message envelope.
MessageHeaderVersionMismatch=The version of the header(s) ({0}) differs from the version of the message ({1}).
ManualAddressingRequiresAddressedMessages=Manual addressing is enabled on this factory, so all messages sent must be pre-addressed.
OneWayHeaderNotFound=A one-way header was expected on this message and none was found. It is possible that your bindings are mismatched.
ReceiveTimedOut=Receive on local address {0} timed out after {1}. The time allotted to this operation may have been a portion of a longer timeout.
ReceiveTimedOut2=Receive timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.
WaitForMessageTimedOut=WaitForMessage timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.
ReceiveTimedOutNoLocalAddress=Receive timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.
ReceiveRequestTimedOutNoLocalAddress=Receive request timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.
ReceiveRequestTimedOut=Receive request on local address {0} timed out after {1}. The time allotted to this operation may have been a portion of a longer timeout.
SendToViaTimedOut=Sending to via {0} timed out after {1}. The time allotted to this operation may have been a portion of a longer timeout.
CloseTimedOut=Close timed out after {0}.  Increase the timeout value passed to the call to Close or increase the CloseTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.
OpenTimedOutEstablishingTransportSession=Open timed out after {0} while establishing a transport session to {1}. The time allotted to this operation may have been a portion of a longer timeout.
RequestTimedOutEstablishingTransportSession=Request timed out after {0} while establishing a transport connection to {1}. The time allotted to this operation may have been a portion of a longer timeout.
TcpConnectingToViaTimedOut=Connecting to via {0} timed out after {1}. Connection attempts were made to {2} of {3} available addresses ({4}). Check the RemoteAddress of your channel and verify that the DNS records for this endpoint correspond to valid IP Addresses. The time allotted to this operation may have been a portion of a longer timeout.
RequestChannelSendTimedOut=The request channel timed out attempting to send after {0}. Increase the timeout value passed to the call to Request or increase the SendTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.
RequestChannelWaitForReplyTimedOut=The request channel timed out while waiting for a reply after {0}. Increase the timeout value passed to the call to Request or increase the SendTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.
HttpTransportCannotHaveMultipleAuthenticationSchemes=The policy being imported for contract '{0}:{1}' contains multiple HTTP authentication scheme assertions.  Since at most one such assertion is allowed, policy import has failed.  This may be resolved by updating the policy to contain no more than one HTTP authentication scheme assertion.
MultipleCCbesInParameters=More than one '{0}' objects were found in the BindingParameters of the BindingContext.  This is usually caused by having multiple '{0}' objects in a CustomBinding. Remove all but one of these elements.
CookieContainerBindingElementNeedsHttp=The '{0}' can only be used with HTTP (or HTTPS) transport.
HttpIfModifiedSinceParseError=The value specified, '{0}', for the If-Modified-Since header does not parse into a valid date. Check the property value and ensure that it is of the proper format.
HttpSoapActionMismatch=The SOAP action specified on the message, '{0}', does not match the action specified on the HttpRequestMessageProperty, '{1}'.
HttpSoapActionMismatchContentType=The SOAP action specified on the message, '{0}', does not match the action specified in the content-type of the HttpRequestMessageProperty, '{1}'.
HttpSoapActionMismatchFault=The SOAP action specified on the message, '{0}', does not match the HTTP SOAP Action, '{1}'. 
HttpContentTypeFormatException=An error ({0}) occurred while parsing the content type of the HTTP request. The content type was: {1}.
HttpServerTooBusy=The HTTP service located at {0} is unavailable.  This could be because the service is too busy or because no endpoint was found listening at the specified address. Please ensure that the address is correct and try accessing the service again later.
HttpRequestAborted=The HTTP request to '{0}' was aborted.  This may be due to the local channel being closed while the request was still in progress.  If this behavior is not desired, then update your code so that it does not close the channel while request operations are still in progress.
HttpRequestTimedOut=The HTTP request to '{0}' has exceeded the allotted timeout of {1}. The time allotted to this operation may have been a portion of a longer timeout.
HttpResponseTimedOut=The HTTP request to '{0}' has exceeded the allotted timeout of {1} while reading the response. The time allotted to this operation may have been a portion of a longer timeout.
HttpTransferError=An error ({0}) occurred while transmitting data over the HTTP channel.
HttpReceiveFailure=An error occurred while receiving the HTTP response to {0}. This could be due to the service endpoint binding not using the HTTP protocol. This could also be due to an HTTP request context being aborted by the server (possibly due to the service shutting down). See server logs for more details.
HttpSendFailure=An error occurred while making the HTTP request to {0}. This could be due to the fact that the server certificate is not configured properly with HTTP.SYS in the HTTPS case. This could also be caused by a mismatch of the security binding between the client and the server.
HttpAuthDoesNotSupportRequestStreaming=HTTP request streaming cannot be used in conjunction with HTTP authentication.  Either disable request streaming or specify anonymous HTTP authentication.
ReplyAlreadySent=A reply has already been sent from this RequestContext.
HttpInvalidListenURI=Unable to start the HTTP listener. The URI provided, '{0}', is invalid for listening. Check the base address of your service and verify that it is a valid URI.
RequestContextAborted=The requestContext has been aborted.
ReceiveContextCannotBeUsed=The receive context, {0}, is in the {1} state.  Receive contexts cannot be used for sending delayed acks unless they are in the Received state.
ReceiveContextInInvalidState=The receive context, {0}, is in an unsupported state '{1}'.  This indicates an internal error in the implementation of that receive context.
ReceiveContextFaulted=The receive context, {0}, cannot be used for sending delayed acks because it is in the Faulted state.
UnrecognizedHostNameComparisonMode=Invalid HostNameComparisonMode value: {0}.
BadData=Invalid data buffer.
InvalidRenewResponseAction=A security session renew response was received with an invalid action '{0}'.
InvalidCloseResponseAction=A security session close response was received with an invalid action '{0}',
IncompatibleBehaviors=TransactedBatchingBehavior cannot be used when ReceiveContext is being used.
NullSessionRequestMessage=Could not formulate request message for security session operation '{0}'.
IssueSessionTokenHandlerNotSet=There is no handler registered for session token issuance event.
RenewSessionTokenHandlerNotSet=There is no handler registered for session token renew event.
WrongIdentityRenewingToken=The identity of the security session renew message does not match the identity of the session token.
InvalidRstRequestType=The RequestSecurityToken has an invalid or unspecified RequestType '{0}'.
NoCloseTargetSpecified=The RequestSecurityToken must specify a CloseTarget.
FailedSspiNegotiation=Secure channel cannot be opened because security negotiation with the remote endpoint has failed. This may be due to absent or incorrectly specified EndpointIdentity in the EndpointAddress used to create the channel. Please verify the EndpointIdentity specified or implied by the EndpointAddress correctly identifies the remote endpoint. 
BadCloseTarget=The CloseTarget specified '{0}' does not identify the security token that signed the message.
RenewSessionMissingSupportingToken=The renew security session message does not have the session token as a supporting token.
NoRenewTargetSpecified=The RequestSecurityToken must specify a RenewTarget.
BadRenewTarget=There is no endorsing session token that matches the specified RenewTarget '{0}'.
BadEncryptedBody=Invalid format for encrypted body.
BadEncryptionState=The EncryptedData or EncryptedKey is in an invalid state for this operation.
NoSignaturePartsSpecified=No signature message parts were specified for messages with the '{0}' action.
NoEncryptionPartsSpecified=No encryption message parts were specified for messages with the '{0}' action.
SecuritySessionFaultReplyWasSent=The receiver sent back a security session fault message. Retry the request.
InnerListenerFactoryNotSet=The Inner listener factory of {0} must be set before this operation.
SecureConversationBootstrapCannotUseSecureConversation=Cannot create security binding element based on configuration data. The secure conversation bootstrap requires another secure conversation which is not supported. 
InnerChannelFactoryWasNotSet=Cannot open ChannelFactory as the inner channel factory was not set during the initialization process.
SecurityProtocolFactoryDoesNotSupportDuplex=Duplex security is not supported by the security protocol factory '{0}'.
SecurityProtocolFactoryDoesNotSupportRequestReply=Request-reply security is not supported by the security protocol factory '{0}'.
SecurityProtocolFactoryShouldBeSetBeforeThisOperation=The security protocol factory must be set before this operation is performed.
SecuritySessionProtocolFactoryShouldBeSetBeforeThisOperation=Security session protocol factory must be set before this operation is performed.
SecureConversationSecurityTokenParametersRequireBootstrapBinding=Security channel or listener factory creation failed. Secure conversation security token parameters do not specify the bootstrap security binding element.
PropertySettingErrorOnProtocolFactory=The required '{0}' property on the '{1}' security protocol factory is not set or has an invalid value.
ProtocolFactoryCouldNotCreateProtocol=The protocol factory cannot create a protocol.
IdentityCheckFailedForOutgoingMessage=The identity check failed for the outgoing message. The expected identity is '{0}' for the '{1}' target endpoint.
IdentityCheckFailedForIncomingMessage=The identity check failed for the incoming message. The expected identity is '{0}' for the '{1}' target endpoint.
DnsIdentityCheckFailedForIncomingMessageLackOfDnsClaim=The Identity check failed for the incoming message. The remote endpoint did not provide a domain name system (DNS) claim and therefore did not satisfied DNS identity '{0}'. This may be caused by lack of DNS or CN name in the remote endpoint X.509 certificate's distinguished name.
DnsIdentityCheckFailedForOutgoingMessageLackOfDnsClaim=The Identity check failed for the outgoing message. The remote endpoint did not provide a domain name system (DNS) claim and therefore did not satisfied DNS identity '{0}'. This may be caused by lack of DNS or CN name in the remote endpoint X.509 certificate's distinguished name.
DnsIdentityCheckFailedForIncomingMessage=Identity check failed for incoming message. The expected DNS identity of the remote endpoint was '{0}' but the remote endpoint provided DNS claim '{1}'. If this is a legitimate remote endpoint, you can fix the problem by explicitly specifying DNS identity '{1}' as the Identity property of EndpointAddress when creating channel proxy. 
DnsIdentityCheckFailedForOutgoingMessage=Identity check failed for outgoing message. The expected DNS identity of the remote endpoint was '{0}' but the remote endpoint provided DNS claim '{1}'. If this is a legitimate remote endpoint, you can fix the problem by explicitly specifying DNS identity '{1}' as the Identity property of EndpointAddress when creating channel proxy. 
SerializedTokenVersionUnsupported=The serialized token version {0} is unsupported.
AuthenticatorNotPresentInRSTRCollection=The RequestSecurityTokenResponseCollection does not contain an authenticator.
RSTRAuthenticatorHasBadContext=The negotiation RequestSecurityTokenResponse has a different context from the authenticator RequestSecurityTokenResponse.
ServerCertificateNotProvided=The recipient did not provide its certificate.  This certificate is required by the TLS protocol.  Both parties must have access to their certificates.
RSTRAuthenticatorNotPresent=The authenticator was not included in the final leg of negotiation.
RSTRAuthenticatorIncorrect=The RequestSecurityTokenResponse CombinedHash is incorrect.
ClientCertificateNotProvided=The certificate for the client has not been provided.  The certificate can be set on the ClientCredentials or ServiceCredentials.
ClientCertificateNotProvidedOnServiceCredentials=The client certificate is not provided. Specify a client certificate in ServiceCredentials. 
ClientCertificateNotProvidedOnClientCredentials=The client certificate is not provided. Specify a client certificate in ClientCredentials. 
ServiceCertificateNotProvidedOnServiceCredentials=The service certificate is not provided. Specify a service certificate in ServiceCredentials. 
ServiceCertificateNotProvidedOnClientCredentials=The service certificate is not provided for target '{0}'. Specify a service certificate in ClientCredentials. 
UserNamePasswordNotProvidedOnClientCredentials=The username is not provided. Specify username in ClientCredentials.
ObjectIsReadOnly=Object is read-only.
EmptyXmlElementError=Element {0} cannot be empty.
UnexpectedXmlChildNode=XML child node {0} of type {1} is unexpected for element {2}.
ContextAlreadyRegistered=The context-id={0} (generation-id={1}) is already registered with SecurityContextSecurityTokenAuthenticator.
ContextAlreadyRegisteredNoKeyGeneration=The context-id={0} (no key generation-id) is already registered with SecurityContextSecurityTokenAuthenticator.
ContextNotPresent=There is no SecurityContextSecurityToken with context-id={0} (generation-id={1}) registered with SecurityContextSecurityTokenAuthenticator.
ContextNotPresentNoKeyGeneration=There is no SecurityContextSecurityToken with context-id={0} (no key generation-id) registered with SecurityContextSecurityTokenAuthenticator.
InvalidSecurityContextCookie=The SecurityContextSecurityToken has an invalid Cookie. The following error occurred when processing the Cookie: '{0}'.
SecurityContextNotRegistered=The SecurityContextSecurityToken with context-id={0} (key generation-id={1}) is not registered.
SecurityContextExpired=The SecurityContextSecurityToken with context-id={0} (key generation-id={1}) has expired.
SecurityContextExpiredNoKeyGeneration=The SecurityContextSecurityToken with context-id={0} (no key generation-id) has expired.
NoSecurityContextIdentifier=The SecurityContextSecurityToken does not have a context-id.
MessageMustHaveViaOrToSetForSendingOnServerSideCompositeDuplexChannels=For sending a message on server side composite duplex channels, the message must have either the 'Via' property or the 'To' header set.
MessageViaCannotBeAddressedToAnonymousOnServerSideCompositeDuplexChannels=The 'Via' property on the message is set to Anonymous Uri '{0}'. Please set the 'Via' property to a non-anonymous address as message cannot be addressed to anonymous Uri on server side composite duplex channels.
MessageToCannotBeAddressedToAnonymousOnServerSideCompositeDuplexChannels=The 'To' header on the message is set to Anonymous Uri '{0}'. Please set the 'To' header to a non-anonymous address as message cannot be addressed to anonymous Uri on server side composite duplex channels.
SecurityBindingNotSetUpToProcessOutgoingMessages=This SecurityProtocol instance was not set up to process outgoing messages.
SecurityBindingNotSetUpToProcessIncomingMessages=This SecurityProtocol instance was not set up to process incoming messages.
TokenProviderCannotGetTokensForTarget=The token provider cannot get tokens for target '{0}'.
UnsupportedKeyDerivationAlgorithm=Key derivation algorithm '{0}' is not supported.
CannotFindCorrelationStateForApplyingSecurity=Cannot find the correlation state for applying security to reply at the responder.
ReplyWasNotSignedWithRequiredSigningToken=The reply was not signed with the required signing token.
EncryptionNotExpected=Encryption not expected for this message.
SignatureNotExpected=A signature is not expected for this message.
InvalidQName=The QName is invalid.
UnknownICryptoType=The ICrypto implementation '{0}' is not supported.
SameProtocolFactoryCannotBeSetForBothDuplexDirections=On DuplexSecurityProtocolFactory, the same protocol factory cannot be set for the forward and reverse directions.
SuiteDoesNotAcceptAlgorithm=The algorithm '{0}' is not accepted for operation '{1}' by algorithm suite {2}.
TokenDoesNotSupportKeyIdentifierClauseCreation='{0}' does not support '{1}' creation.
UnableToCreateICryptoFromTokenForSignatureVerification=Cannot create an ICrypto interface from the '{0}' token for signature verification.
MessageSecurityVerificationFailed=Message security verification failed.
TransportSecurityRequireToHeader=Transport secured messages should have the 'To' header specified.
TransportSecuredMessageMissingToHeader=The message received over Transport security was missing the 'To' header.
UnsignedToHeaderInTransportSecuredMessage=The message received over Transport security has unsigned 'To' header.
TransportSecuredMessageHasMoreThanOneToHeader=More than one 'To' header specified in a message secured by Transport Security.
TokenNotExpectedInSecurityHeader=Received security header contains unexpected token '{0}'.
CannotFindCert=Cannot find the X.509 certificate using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}'.
CannotFindCertForTarget=Cannot find The X.509 certificate using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}' for target '{4}'.
FoundMultipleCerts=Found multiple X.509 certificates using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}'. Provide a more specific find value.
FoundMultipleCertsForTarget=Found multiple X.509 certificates using the following search criteria: StoreName '{0}', StoreLocation '{1}', FindType '{2}', FindValue '{3}' for target '{4}'. Provide a more specific find value.
MissingKeyInfoInEncryptedKey=The KeyInfo clause is missing or empty in EncryptedKey.
EncryptedKeyWasNotEncryptedWithTheRequiredEncryptingToken=The EncryptedKey clause was not wrapped with the required encryption token '{0}'.
MessageWasNotEncryptedWithTheRequiredEncryptingToken=The message was not encrypted with the required encryption token.
TimestampMustOccurFirstInSecurityHeaderLayout=The timestamp must occur first in this security header layout.
TimestampMustOccurLastInSecurityHeaderLayout=The timestamp must occur last in this security header layout.
AtMostOnePrimarySignatureInReceiveSecurityHeader=Only one primary signature is allowed in a security header.
SigningTokenHasNoKeys=The signing token {0} has no keys. The security token is used in a context that requires it to perform cryptographic operations, but the token contains no cryptographic keys. Either the token type does not support cryptographic operations, or the particular token instance does not contain cryptographic keys. Check your configuration to ensure that cryptographically disabled token types (for example, UserNameSecurityToken) are not specified in a context that requires cryptographic operations (for example, an endorsing supporting token).
SigningTokenHasNoKeysSupportingTheAlgorithmSuite=The signing token {0} has no key that supports the algorithm suite {1}.
DelayedSecurityApplicationAlreadyCompleted=Delayed security application has already been completed.
UnableToResolveKeyInfoClauseInDerivedKeyToken=Cannot resolve KeyInfo in derived key token for resolving source token: KeyInfoClause '{0}'.
UnableToDeriveKeyFromKeyInfoClause=KeyInfo clause '{0}' resolved to token '{1}', which does not contain a Symmetric key that can be used for derivation.
UnableToResolveKeyInfoForVerifyingSignature=Cannot resolve KeyInfo for verifying signature: KeyInfo '{0}', available tokens '{1}'.
UnableToResolveKeyInfoForUnwrappingToken=Cannot resolve KeyInfo for unwrapping key: KeyInfo '{0}', available tokens '{1}'.
UnableToResolveKeyInfoForDecryption=Cannot resolve KeyInfo for decryption: KeyInfo '{0}', available tokens '{1}'.
EmptyBase64Attribute=An empty value was found for the required base-64 attribute name '{0}', namespace '{1}'.
RequiredSecurityHeaderElementNotSigned=The security header element '{0}' with the '{1}' id must be signed.
RequiredSecurityTokenNotSigned=The '{0}' security token with the '{1}' attachment mode must be signed.
RequiredSecurityTokenNotEncrypted=The '{0}' security token with the '{1}' attachment mode must be encrypted.
MessageBodyOperationNotValidInBodyState=Operation '{0}' is not valid in message body state '{1}'.
EncryptedKeyWithReferenceListNotAllowed=EncryptedKey with ReferenceList is not allowed according to the current settings.
UnableToFindTokenAuthenticator=Cannot find a token authenticator for the '{0}' token type. Tokens of that type cannot be accepted according to current security settings.
NoPartsOfMessageMatchedPartsToSign=No signature was created because not part of the message matched the supplied message part specification.
BasicTokenCannotBeWrittenWithoutEncryption=Supporting SecurityToken cannot be written without encryption.
DuplicateIdInMessageToBeVerified=The '{0}' id occurred twice in the message that is supplied for verification.
UnsupportedCanonicalizationAlgorithm=Canonicalization algorithm '{0}' is not supported.
NoKeyInfoInEncryptedItemToFindDecryptingToken=The KeyInfo value was not found in the encrypted item to find the decrypting token.
NoKeyInfoInSignatureToFindVerificationToken=No KeyInfo in signature to find verification token.
SecurityHeaderIsEmpty=Security header is empty.
EncryptionMethodMissingInEncryptedData=The encryption method is missing in encrypted data.
EncryptedHeaderAttributeMismatch=The Encrypted Header and the Security Header '{0}' attribute did not match. Encrypted Header: {1}. Security Header: {2}.
AtMostOneReferenceListIsSupportedWithDefaultPolicyCheck=At most one reference list is supported with default policy check.
AtMostOneSignatureIsSupportedWithDefaultPolicyCheck=At most one signature is supported with default policy check.
UnexpectedEncryptedElementInSecurityHeader=Unexpected encrypted element in security header.
MissingIdInEncryptedElement=Id is missing in encrypted item in security header.
TokenManagerCannotCreateTokenReference=The supplied token manager cannot create a token reference.
TimestampToSignHasNoId=The timestamp element added to security header to sign has no id.
EncryptedHeaderXmlMustHaveId=An encrypted header must have an id.
UnableToResolveDataReference=The data reference '{0}' could not be resolved in the received message.
TimestampAlreadySetForSecurityHeader=A timestamp element has already been set for this security header.
DuplicateTimestampInSecurityHeader=More than one Timestamp element was present in security header.
MismatchInSecurityOperationToken=The incoming message was signed with a token which was different from what used to encrypt the body.  This was not expected.
UnableToCreateSymmetricAlgorithmFromToken=Cannot create the '{0}' symmetric algorithm from the token.
UnknownEncodingInBinarySecurityToken=Unrecognized encoding occurred while reading the binary security token.
UnableToResolveReferenceUriForSignature=Cannot resolve reference URI '{0}' in signature to compute digest.
NoTimestampAvailableInSecurityHeaderToDoReplayDetection=No timestamp is available in the security header to do replay detection.
NoSignatureAvailableInSecurityHeaderToDoReplayDetection=No signature is available in the security header to provide the nonce for replay detection.
CouldNotFindNamespaceForPrefix=There is no namespace binding for prefix '{0}' in scope.
DerivedKeyCannotDeriveFromSecret=Derived Key Token cannot derive key from the secret.
DerivedKeyPosAndGenBothSpecified=Both offset and generation cannot be specified for Derived Key Token.
DerivedKeyPosAndGenNotSpecified=Either offset or generation must be specified for Derived Key Token.
DerivedKeyTokenRequiresTokenReference=DerivedKeyToken requires a reference to a token.
DerivedKeyLengthTooLong=DerivedKey length ({0}) exceeds the allowed settings ({1}).
DerivedKeyLengthSpecifiedInImplicitDerivedKeyClauseTooLong=The Implicit derived key clause '{0}' specifies a derivation key length ({1}) which exceeds the allowed maximum length ({2}).
DerivedKeyInvalidOffsetSpecified=The received derived key token has a invalid offset value specified. Value: {0}. The value should be greater than or equal to zero.
DerivedKeyInvalidGenerationSpecified=The received derived key token has a invalid generation value specified. Value: {0}. The value should be greater than or equal to zero.
ChildNodeTypeMissing=The XML element {0} does not have a child of type {1}.
NoLicenseXml=RequestedSecurityToken not specified in RequestSecurityTokenResponse.
UnsupportedBinaryEncoding=Binary encoding {0} is not supported.
BadKeyEncryptionAlgorithm=Invalid key encryption algorithm {0}.
InvalidAsyncResult=The asynchronous result object used to end this operation was not the object that was returned when the operation was initiated.
UnableToCreateTokenReference=Unable to create token reference.
ConfigNull=null
NonceLengthTooShort=The specified nonce is too short. The minimum required nonce length is 4 bytes.
NoBinaryNegoToSend=There is no binary negotiation to send to the other party.
BadSecurityNegotiationContext=Security negotiation failure because an incorrect Context attribute specified in RequestSecurityToken/RequestSecurityTokenResponse from the other party.
NoBinaryNegoToReceive=No binary negotiation was received from the other party.
ProofTokenWasNotWrappedCorrectly=The proof token was not wrapped correctly in the RequestSecurityTokenResponse.
NoServiceTokenReceived=Final RSTR from other party does not contain a service token.
InvalidSspiNegotiation=The Security Support Provider Interface (SSPI) negotiation failed.
CannotAuthenticateServer=Cannot authenticate the other party.
IncorrectBinaryNegotiationValueType=Incoming binary negotiation has invalid ValueType {0}.
ChannelNotOpen=The channel is not open.
FailToRecieveReplyFromNegotiation=Security negotiation failed because the remote party did not send back a reply in a timely manner. This may be because the underlying transport connection was aborted.
MessageSecurityVersionOutOfRange=SecurityVersion must be WsSecurity10 or WsSecurity11.
CreationTimeUtcIsAfterExpiryTime=Creation time must be before expiration time.
NegotiationStateAlreadyPresent=Negotiation state already exists for context '{0}'.
CannotFindNegotiationState=Cannot find the negotiation state for the context '{0}'.
OutputNotExpected=Send cannot be called when the session does not expect output.
SessionClosedBeforeDone=The session was closed before message transfer was complete.
CacheQuotaReached=The item cannot be added. The maximum cache size is ({0} items).
NoServerX509TokenProvider=The server's X509SecurityTokenProvider cannot be null.
UnexpectedBinarySecretType=Expected binary secret of type {0} but got secret of type {1}.
UnsupportedPasswordType=The '{0}' username token has an unsupported password type.
;NoPassword=No password specified for username '{0}'.
UnrecognizedIdentityPropertyType=Unrecognized identity property type: '{0}'.
UnableToDemuxChannel=There was no channel that could accept the message with action '{0}'.
EndpointNotFound=There was no endpoint listening at {0} that could accept the message. This is often caused by an incorrect address or SOAP action. See InnerException, if present, for more details.
MaxReceivedMessageSizeMustBeInIntegerRange=This factory buffers messages, so the message sizes must be in the range of an integer value.
MaxBufferSizeMustMatchMaxReceivedMessageSize=For TransferMode.Buffered, MaxReceivedMessageSize and MaxBufferSize must be the same value.
MaxBufferSizeMustNotExceedMaxReceivedMessageSize=MaxBufferSize must not exceed MaxReceivedMessageSize.
MessageSizeMustBeInIntegerRange=This Factory buffers messages, so the message sizes must be in the range of a int value.
UriLengthExceedsMaxSupportedSize=URI {0} could not be set because its size ({1}) exceeds the max supported size ({2}).
InValidateIdPrefix=Expecting first char - c - to be in set [Char.IsLetter(c) && c == '_', found '{0}'.
InValidateId=Expecting all chars - c - of id to be in set [Char.IsLetter(c), Char.IsNumber(c), '.', '_', '-'], found '{0}'.
HttpRegistrationAlreadyExists=HTTP could not register URL {0}. Another application has already registered this URL with HTTP.SYS.
HttpRegistrationAccessDenied=HTTP could not register URL {0}. Your process does not have access rights to this namespace (see http://go.microsoft.com/fwlink/?LinkId=70353 for details).
HttpRegistrationPortInUse=HTTP could not register URL {0} because TCP port {1} is being used by another application.
HttpRegistrationLimitExceeded=HTTP could not register URL {0} because the MaxEndpoints quota has been exceeded. To correct this, either close other HTTP-based services, or increase your MaxEndpoints registry key setting (see http://go.microsoft.com/fwlink/?LinkId=70352 for details).
UnexpectedHttpResponseCode=The remote server returned an unexpected response: ({0}) {1}.
HttpContentLengthIncorrect=The number of bytes available is inconsistent with the HTTP Content-Length header.  There may have been a network error or the client may be sending invalid requests.
OneWayUnexpectedResponse=A response was received from a one-way send over the underlying IRequestChannel. Make sure the remote endpoint has a compatible binding at its endpoint (one that contains OneWayBindingElement).
MissingContentType=The receiver returned an error indicating that the content type was missing on the request to {0}.  See the inner exception for more information.
DuplexChannelAbortedDuringOpen=Duplex channel to {0} was aborted during the open process.
OperationAbortedDuringConnectionEstablishment=Operation was aborted while establishing a connection to {0}.
HttpAddressingNoneHeaderOnWire=The incoming message contains a SOAP header representing the WS-Addressing '{0}', yet the HTTP transport is configured with AddressingVersion.None.  As a result, the message is being dropped.  If this is not desired, then update your HTTP binding to support a different AddressingVersion.
MessageXmlProtocolError=There is a problem with the XML that was received from the network. See inner exception for more details.
TcpV4AddressInvalid=An IPv4 address was specified ({0}), but IPv4 is not enabled on this machine. 
TcpV6AddressInvalid=An IPv6 address was specified ({0}), but IPv6 is not enabled on this machine. 
UniquePortNotAvailable=Cannot find a unique port number that is available for both IPv4 and IPv6.
TcpAddressInUse=There is already a listener on IP endpoint {0}. This could happen if there is another application already listening on this endpoint or if you have multiple service endpoints in your service host with the same IP endpoint but with incompatible binding configurations.
TcpConnectNoBufs=Insufficient winsock resources available to complete socket connection initiation.
InsufficentMemory=Insufficient memory avaliable to complete the operation.
TcpConnectError=Could not connect to {0}. TCP error code {1}: {2}. 
TcpConnectErrorWithTimeSpan=Could not connect to {0}. The connection attempt lasted for a time span of {3}. TCP error code {1}: {2}. 
TcpListenError=A TCP error ({0}: {1}) occurred while listening on IP Endpoint={2}.
TcpTransferError=A TCP error ({0}: {1}) occurred while transmitting data.
TcpTransferErrorWithIP=A TCP error ({0}: {1}) occurred while transmitting data. The local IP address and port is {2}. The remote IP address and port is {3}.
TcpLocalConnectionAborted=The socket connection was aborted by your local machine. This could be caused by a channel Abort(), or a transmission error from another thread using this socket.
HttpResponseAborted=The HTTP request context was aborted while writing the response.  As a result, the response may not have been completely written to the network.  This can be remedied by gracefully closing the request context rather than aborting it.
TcpConnectionResetError=The socket connection was aborted. This could be caused by an error processing your message or a receive timeout being exceeded by the remote host, or an underlying network resource issue. Local socket timeout was '{0}'.
TcpConnectionResetErrorWithIP=The socket connection was aborted. This could be caused by an error processing your message or a receive timeout being exceeded by the remote host, or an underlying network resource issue. Local socket timeout was '{0}'. The local IP address and port is {1}. The remote IP address and port is {2}.
TcpConnectionTimedOut=The socket transfer timed out after {0}. You have exceeded the timeout set on your binding. The time allotted to this operation may have been a portion of a longer timeout.
TcpConnectionTimedOutWithIP=The socket transfer timed out after {0}. You have exceeded the timeout set on your binding. The time allotted to this operation may have been a portion of a longer timeout. The local IP address and port is {1}. The remote IP address and port is {2}.
SocketConnectionDisposed=The socket connection has been disposed.
SocketListenerDisposed=The socket listener has been disposed.
SocketListenerNotListening=The socket listener is not listening.
DuplexSessionListenerNotFound=No duplex session listener was listening at {0}. This could be due to an incorrect via set on the client or a binding mismatch.
HttpTargetNameDictionaryConflict=The entry found in AuthenticationManager's CustomTargetNameDictionary for {0} does not match the requested identity of {1}.
HttpContentTypeHeaderRequired=An HTTP Content-Type header is required for SOAP messaging and none was found.
ContentTypeMismatch=Content Type {0} was sent to a service expecting {1}.  The client and service bindings may be mismatched.
ResponseContentTypeMismatch=The content type {0} of the response message does not match the content type of the binding ({1}). If using a custom encoder, be sure that the IsContentTypeSupported method is implemented properly. The first {2} bytes of the response were: '{3}'.
ResponseContentTypeNotSupported=The content type {0} of the message is not supported by the encoder.
HttpToMustEqualVia=The binding specified requires that the to and via URIs must match because the Addressing Version is set to None. The to URI specified was '{0}'. The via URI specified was '{1}'.
NullReferenceOnHttpResponse=The server challenged this request and streamed requests cannot be resubmitted. To enable HTTP server challenges, set your TransferMode to Buffered or StreamedResponse.
FramingContentTypeMismatch=Content Type {0} was not supported by service {1}.  The client and service bindings may be mismatched.
FramingFaultUnrecognized=Server faulted with code '{0}'.
FramingContentTypeTooLongFault=Content type '{0}' is too long to be processed by the remote host. See the server logs for more details.
FramingViaTooLongFault=Via '{0}' is too long to be processed by the remote host. See the server logs for more details.
FramingModeNotSupportedFault=The .Net Framing mode being used is not supported by '{0}'. See the server logs for more details.
FramingVersionNotSupportedFault=The .Net Framing version being used is not supported by '{0}'. See the server logs for more details.
FramingUpgradeInvalid=The requested upgrade is not supported by '{0}'. This could be due to mismatched bindings (for example security enabled on the client and not on the server).
SecurityServerTooBusy=Server '{0}' sent back a fault indicating it is too busy to process the request. Please retry later. Please see the inner exception for fault details.
SecurityEndpointNotFound=Server '{0}' sent back a fault indicating it is in the process of shutting down. Please see the inner exception for fault details.
ServerTooBusy=Server '{0}' is too busy to process this request. Try again later.
UpgradeProtocolNotSupported=Protocol Type {0} was sent to a service that does not support that type of upgrade.
UpgradeRequestToNonupgradableService=.Net Framing upgrade request for {0} was sent to a service that is not setup to receive upgrades.
PreambleAckIncorrect=You have tried to create a channel to a service that does not support .Net Framing. 
PreambleAckIncorrectMaybeHttp=You have tried to create a channel to a service that does not support .Net Framing. It is possible that you are encountering an HTTP endpoint.
StreamError=An error occurred while transmitting data.
ServerRejectedUpgradeRequest=The server rejected the upgrade request.
ServerRejectedSessionPreamble=The server at {0} rejected the session-establishment request.
UnableToResolveHost=Cannot resolve the host name of URI \"{0}\" using DNS.
HttpRequiresSingleAuthScheme=The '{0}' authentication scheme has been specified on the HTTP factory. However, the factory only supports specification of exactly one authentication scheme. Valid authentication schemes are Digest, Negotiate, NTLM, Basic, or Anonymous.
HttpAuthSchemeCannotBeNone=The value specified for the AuthenticationScheme property on the HttpTransportBindingElement ('{0}') is not allowed when building a ChannelFactory. If you used a standard binding, ensure the ClientCredentialType is not set to HttpClientCredentialType.InheritedFromHost, a value which is invalid on a client. If you set the value to '{0}' directly on the HttpTransportBindingElement, please set it to Digest, Negotiate, NTLM, Basic, or Anonymous.
HttpProxyRequiresSingleAuthScheme=The '{0}' authentication scheme has been specified for the proxy on the HTTP factory. However, the factory only supports specification of exactly one authentication scheme. Valid authentication schemes are Digest, Negotiate, NTLM, Basic, or Anonymous.
HttpMutualAuthNotSatisfied=The remote HTTP server did not satisfy the mutual authentication requirement.
HttpAuthorizationFailed=The HTTP request is unauthorized with client authentication scheme '{0}'. The authentication header received from the server was '{1}'.
HttpAuthenticationFailed=The HTTP request with client authentication scheme '{0}' failed with '{1}' status.
HttpAuthorizationForbidden=The HTTP request was forbidden with client authentication scheme '{0}'.
InvalidUriScheme=The provided URI scheme '{0}' is invalid; expected '{1}'.
HttpAuthSchemeAndClientCert=The HTTPS listener factory was configured to require a client certificate and the '{0}' authentication scheme. However, only one form of client authentication can be required at once.
NoTransportManagerForUri=Could not find an appropriate transport manager for listen URI '{0}'.
ListenerFactoryNotRegistered=The specified channel listener at '{0}' is not registered with this transport manager.
HttpsExplicitIdentity=The HTTPS channel factory does not support explicit specification of an identity in the EndpointAddress unless the authentication scheme is NTLM or Negotiate.
HttpsIdentityMultipleCerts=The endpoint identity specified when creating the HTTPS channel to '{0}' contains multiple server certificates.  However, the HTTPS transport only supports the specification of a single server certificate.  In order to create an HTTPS channel, please specify no more than one server certificate in the endpoint identity.
HttpsServerCertThumbprintMismatch=The server certificate with name '{0}' failed identity verification because its thumbprint ('{1}') does not match the one specified in the endpoint identity ('{2}').  As a result, the current HTTPS request has failed.  Please update the endpoint identity used on the client or the certificate used by the server.
DuplicateRegistration=A registration already exists for URI '{0}'.
SecureChannelFailure=Could not establish secure channel for SSL/TLS with authority '{0}'.
TrustFailure=Could not establish trust relationship for the SSL/TLS secure channel with authority '{0}'.
NoCompatibleTransportManagerForUri=Could not find a compatible transport manager for URI '{0}'.
HttpSpnNotFound=The SPN for the responding server at URI '{0}' could not be determined.
StreamMutualAuthNotSatisfied=The remote server did not satisfy the mutual authentication requirement.
TransferModeNotSupported=Transfer mode {0} is not supported by {1}.
InvalidTokenProvided=The token provider of type '{0}' did not return a token of type '{1}'. Check the credential configuration.
NoUserNameTokenProvided=The required UserNameSecurityToken was not provided.
RemoteIdentityFailedVerification=The following remote identity failed verification: '{0}'.
UseDefaultWebProxyCantBeUsedWithExplicitProxyAddress=You cannot specify an explicit Proxy Address as well as UseDefaultWebProxy=true in your HTTP Transport Binding Element.
ProxyImpersonationLevelMismatch=The HTTP proxy authentication credential specified an impersonation level restriction ({0}) that is stricter than the restriction for target server authentication ({1}).
ProxyAuthenticationLevelMismatch=The HTTP proxy authentication credential specified an mutual authentication requirement ({0}) that is stricter than the requirement for target server authentication ({1}).
CredentialDisallowsNtlm=The NTLM authentication scheme was specified, but the target credential does not allow NTLM.
DigestExplicitCredsImpersonationLevel=The impersonation level '{0}' was specified, yet HTTP Digest authentication can only support 'Impersonation' level when used with an explicit credential.
UriGeneratorSchemeMustNotBeEmpty=The scheme parameter must not be empty.
UnsupportedSslProtectionLevel=The protection level '{0}' was specified, yet SSL transport security only supports EncryptAndSign.
HttpNoTrackingService={0}. This often indicates that a service that HTTP.SYS depends upon (such as httpfilter) is not started.
HttpNetnameDeleted={0}. This often indicates that the HTTP client has prematurely closed the underlying TCP connection.
TimeoutServiceChannelConcurrentOpen1=Opening the channel timed out after {0}. The time allotted to this operation may have been a portion of a longer timeout.
TimeoutServiceChannelConcurrentOpen2=Opening the {0} channel timed out after {1}. The time allotted to this operation may have been a portion of a longer timeout.
TimeSpanMustbeGreaterThanTimeSpanZero=TimeSpan must be greater than TimeSpan.Zero.
TimeSpanCannotBeLessThanTimeSpanZero=TimeSpan cannot be less than TimeSpan.Zero.
ValueMustBeNonNegative=The value of this argument must be non-negative.
ValueMustBePositive=The value of this argument must be positive.
ValueMustBeGreaterThanZero=The value of this argument must be greater than 0.
ValueMustBeInRange=The value of this argument must fall within the range {0} to {1}.
OffsetExceedsBufferBound=The specified offset exceeds the upper bound of the buffer ({0}).
OffsetExceedsBufferSize=The specified offset exceeds the buffer size ({0} bytes).
SizeExceedsRemainingBufferSpace=The specified size exceeds the remaining buffer space ({0} bytes).
SpaceNeededExceedsMessageFrameOffset=The space needed for encoding ({0} bytes) exceeds the message frame offset.
FaultConverterDidNotCreateFaultMessage={0} returned true from OnTryCreateFaultMessage, but did not return a fault message.
FaultConverterCreatedFaultMessage={0} returned false from OnTryCreateFaultMessage, but returned a non-null fault message.
FaultConverterDidNotCreateException={0} returned true from OnTryCreateException, but did not return an Exception.
FaultConverterCreatedException={0} returned false from OnTryCreateException, but returned a non-null Exception (See InnerException for details).
InfoCardInvalidChain=Policy chain contains self issued URI or a managed issuer in the wrong position.
FullTrustOnlyBindingElementSecurityCheck1=The Binding with name {0} failed validation because it contains a BindingElement with type {1} which is not supported in partial trust. Consider using BasicHttpBinding or WSHttpBinding, or hosting your application in a full-trust environment.
FullTrustOnlyBindingElementSecurityCheckWSHttpBinding1=The WSHttpBinding with name {0} failed validation because it contains a BindingElement with type {1} which is not supported in partial trust. Consider disabling the message security and reliable session options, using BasicHttpBinding, or hosting your application in a full-trust environment.
FullTrustOnlyBindingSecurityCheck1=The Binding with name {0} failed validation because the Binding type {1} is not supported in partial trust. Consider using BasicHttpBinding or WSHttpBinding, or hosting your application in a full-trust environment.
PartialTrustServiceCtorNotVisible=The Service with name '{0}' could not be constructed because the application does not have permission to construct the type: both the Type and its default parameter-less constructor must be public.
PartialTrustServiceMethodNotVisible=The Method with name '{1}' in Type '{0}' could not be invoked because the application does not have permission to invoke the method: both the Method and its containing Type must be public.
PartialTrustPerformanceCountersNotEnabled=Access to performance counters is denied. Application may be running in partial trust. Either disable performance counters or configure the application to run in full trust.
EnsureCategoriesExistFailedPermission=Performance counter instance names may not be unique. See "http://go.microsoft.com/fwlink/?LinkId=524462" for details.
PartialTrustWMINotEnabled=Access to windows management instrumentation (WMI) is denied. Application may be running in partial trust. Either disable WMI or configure the application to run in full trust.
PartialTrustMessageLoggingNotEnabled=Unable to log messages. Application may be running in partial trust. Either disable message logging or configure the application to run in full trust.
ScopeNameMustBeSpecified=The 'scopeName' argument to the InstanceKey constructor must be a non-empty string which indicates the scope of uniqueness for the key. Durable services use the service namespace and name as the scope of uniqueness.
ProviderCannotBeEmptyString=The 'provider' argument to the InstanceKey constructor must be a non-empty string which identifies the source of the key data. The 'provider' argument can be null, in which case the default correlation provider name is used.
CannotSetNameOnTheInvalidKey=The 'Name' property cannot be set on an invalid InstanceKey.
UnsupportedMessageQueryResultType=The type {0} is not a supported result type.
CannotRepresentResultAsNodeset=The result cannot be represented as a nodeset. Only results of type XPathResultType.NodeSet can be represented as nodesets.
MessageNotInLockedState=Message with id {0} was not in a locked state.
MessageValidityExpired=Validity of message with id {0} has expired.
UnsupportedUpgradeInitiator=The StreamUpgradeInitiator specified ({0}) is not supported by this IStreamUpgradeChannelBindingProvider  implementation.  The most likely cause of this is passing a StreamUpgradeInitiator that was not created by the StreamUpgradeProvider associated with the current IStreamUpgradeChannelBindingProvider  implementation.
UnsupportedUpgradeAcceptor=The StreamUpgradeAcceptor specified ({0}) is not supported by this IStreamUpgradeChannelBindingProvider  implementation.  The most likely cause of this is passing a StreamUpgradeAcceptor that was not created by the StreamUpgradeProvider associated with this IStreamUpgradeChannelBindingProvider  implementation.
StreamUpgradeUnsupportedChannelBindingKind=The StreamUpgradeProvider {0} does not support the specified ChannelBindingKind ({1}). 
ExtendedProtectionNotSupported=Extended protection is not supported on this platform.  Please install the appropriate patch or change the ExtendedProtectionPolicy on the Binding or BindingElement to a value with a PolicyEnforcement value of "Never" or "WhenSupported".
ExtendedProtectionPolicyBasicAuthNotSupported=The Authentication Scheme "Basic" does not support Extended Protection.  Please use a different authentication scheme or disable the ExtendedProtectionPolicy on the Binding or BindingElement by creating a new ExtendedProtectionPolicy with a PolicyEnforcement value of "Never".
ExtendedProtectionPolicyCustomChannelBindingNotSupported=CustomChannelBindings are not supported.  Please remove the CustomChannelBinding from the ExtendedProtectionPolicy".
HttpClientCredentialTypeInvalid=ClientCredentialType '{0}' can only be used on the server side, not the client side. Please use one of the following values instead 'None, Basic, Client, Digest, Ntlm, Windows'.
SecurityTokenProviderIncludeWindowsGroupsInconsistent=When authentication schemes 'Basic' and also '{0}' are enabled, the value of IncludeWindowsGroups for Windows ('{1}') and UserName authentication ('{2}') must match. Please consider using the same value in both places.
AuthenticationSchemesCannotBeInheritedFromHost=The authentication schemes cannot be inherited from the host for binding '{0}'. No AuthenticationScheme was specified on the ServiceHost or in the virtual application in IIS. This may be resolved by enabling at least one authentication scheme for this virtual application in IIS, through the ServiceHost.Authentication.AuthenticationSchemes property or in the configuration at the <serviceAuthenticationManager> element.
AuthenticationSchemes_BindingAndHostConflict=The authentication schemes configured on the host ('{0}') do not allow those configured on the binding '{1}' ('{2}').  Please ensure that the SecurityMode is set to Transport or TransportCredentialOnly.  Additionally, this may be resolved by changing the authentication schemes for this application through the IIS management tool, through the ServiceHost.Authentication.AuthenticationSchemes property, in the application configuration file at the <serviceAuthenticationManager> element, by updating the ClientCredentialType property on the binding, or by adjusting the AuthenticationScheme property on the HttpTransportBindingElement.
FlagEnumTypeExpected=Object type must be an enum with the flag attribute. '{0}' is not an enum - or the flag attribute is not set. Please use an enum type with the flag attribute instead.
InvalidFlagEnumType=Object type must be an enum with the flag attribute and may only contain powers of two for the flags enum values or a combination of such values. Please use an enum type according to these rules.
NoAsyncWritePending=There is no pending asynchronous write on this stream. Ensure that there is pending write on the stream or verify that the implementation does not try to complete the same operation multiple times.
FlushBufferAlreadyInUse=Cannot write to a buffer which is currently being flushed. 
WriteAsyncWithoutFreeBuffer=An asynchronous write was called on the stream without a free buffer.
TransportDoesNotSupportCompression=The transport configured on this binding does not appear to support the CompressionFormat specified ({0}) on the message encoder.  To resolve this issue, set the CompressionFormat on the {1} to '{2}' or use a different transport.
UnsupportedSecuritySetting=The value '{1}' is not supported in this context for the binding security property '{0}'.
UnsupportedBindingProperty=The value '{1}' is not supported in this context for the binding property '{0}'.
HttpMaxPendingAcceptsTooLargeError=The value of MaxPendingAccepts should not be larger than {0}.
RequestInitializationTimeoutReached=The initialization process of the request message timed out after {0}. To increase this quota, use the '{1}' property on the '{2}'.
UnsupportedTokenImpersonationLevel=The value '{1}' for the '{0}' property is not supported in Windows Store apps.

; ---------------------------------------------------------------------------------------------------------------------
; RM
; ---------------------------------------------------------------------------------------------------------------------
AcksToMustBeSameAsRemoteAddress=The remote endpoint requested an address for acknowledgements that is not the same as the address for application messages. The channel could not be opened because this is not supported. Ensure the endpoint address used to create the channel is identical to the one the remote endpoint was set up with.
AcksToMustBeSameAsRemoteAddressReason=The address for acknowledgements must be the same as the address for application messages. Verify that your endpoint is configured to use the same URI for these two addresses.
AssertionNotSupported=The {0}:{1} assertion is not supported.
CloseOutputSessionErrorReason=An unexpected error occurred while attempting to close the output half of the duplex reliable session.
ConflictingAddress=The remote endpoint sent conflicting requests to create a reliable session. The conflicting requests have inconsistent filter criteria such as address or action. The reliable session has been faulted.
ConflictingOffer=The remote endpoint sent conflicting requests to create a reliable session. The remote endpoint requested both a one way and a two way session. The reliable session has been faulted.
CouldNotParseWithAction=A message with action {0} could not be parsed.
CSRefused=The request to create a reliable session has been refused by the RM Destination. {0} The channel could not be opened.
CSRefusedAcksToMustEqualEndpoint=The endpoint processing requests to create a reliable session only supports sessions in which the AcksTo Uri and the Endpoint Uri are the same.
CSRefusedAcksToMustEqualReplyTo=The endpoint processing requests to create a reliable session only supports sessions in which the AcksTo Uri and the ReplyTo Uri are the same.
CSRefusedDuplexNoOffer=The endpoint at {0} processes duplex sessions. The create sequence request must contain an offer for a return sequence. This is likely caused by a binding mismatch.
CSRefusedInputOffer=The endpoint at {0} processes input sessions. The create sequence request must not contain an offer for a return sequence. This is likely caused by a binding mismatch.
CSRefusedInvalidIncompleteSequenceBehavior=The request to create a reliable session contains an invalid wsrm:IncompleteSequenceBehavior value. This is a WS-ReliableMessaging protocol violation.
CSRefusedNoSTRWSSecurity=The request to create a reliable session contains the wsse:SecurityTokenReference but does not carry a wsrm:UsesSequenceSTR header. This is a WS-ReliableMessaging protocol violation. The session could not be created.
CSRefusedReplyNoOffer=The endpoint at {0} processes reply sessions. The create sequence request must contain an offer for a return sequence. This is likely caused by a binding mismatch.
CSRefusedRequiredSecurityElementMissing=The RM Destination requires the WS-SecureConversation protocol in the binding. This is likely caused by a binding mismatch.
CSRefusedSSLNotSupported=The endpoint processing requests to create a reliable session does not support sessions that use SSL. This is likely caused by a binding mismatch. The session could not be created.
CSRefusedSTRNoWSSecurity=The request to create a reliable session carries a wsrm:UsesSequenceSTR header, but does not contain the wsse:SecurityTokenReference. This is a WS-ReliableMessaging protocol violation. The session could not be created.
CSRefusedUnexpectedElementAtEndOfCSMessage=The message is not a valid SOAP message. The body contains more than 1 root element.
CSResponseOfferRejected=The remote endpoint replied to a request for a two way session with an offer for a one way session. This is likely caused by a binding mismatch. The channel could not be opened.
CSResponseOfferRejectedReason=The client requested creation of a two way session. A one way session was created. The session cannot continue without as a one way session. This is likely caused by a binding mismatch.
CSResponseWithInvalidIncompleteSequenceBehavior=The response to the request to create a reliable session contains an invalid wsrm:IncompleteSequenceBehavior value. This is a WS-ReliableMessaging protocol violation.
CSResponseWithOffer=The remote endpoint replied to a request for a one way session with an offer for a two way session. This is a WS-ReliableMessaging protocol violation. The channel could not be opened.
CSResponseWithOfferReason=A return sequence was not offered by the create sequence request. The create sequence response cannot accept a return sequence.
CSResponseWithoutOffer=The remote endpoint replied to a request for a two way session with an offer for a one way session. This is a WS-ReliableMessaging protocol violation. The channel could not be opened.
CSResponseWithoutOfferReason=A return sequence was offered by the create sequence request but the create sequence response did not accept this sequence.
DeliveryAssuranceRequiredNothingFound=The WS-RM policy under the namespace {0} requires the wsrmp:ExactlyOnce, wsrmp:AtLeastOnce, or wsrmp:AtMostOnce assertion. Nothing was found.
DeliveryAssuranceRequired=The WS-RM policy under the namespace {0} requires the wsrmp:ExactlyOnce, wsrmp:AtLeastOnce, or wsrmp:AtMostOnce assertion. The {1} element under the {2} namespace was found.
EarlyRequestTerminateSequence=The remote endpoint sent a TerminateSequence protocol message before fully acknowledging all messages in the reply sequence. This is a violation of the reliable request reply protocol. The reliable session was faulted.
EarlySecurityClose=The remote endpoint has closed the underlying secure session before the reliable session fully completed. The reliable session was faulted.
EarlySecurityFaulted=The underlying secure session has faulted before the reliable session fully completed. The reliable session was faulted.
EarlyTerminateSequence=The remote endpoint has errantly sent a TerminateSequence protocol message before the sequence finished.
ElementFound=The {0}:{1} element requires a {2}:{3} child element but has the {4} child element under the {5} namespace.
ElementRequired=The {0}:{1} element requires a {2}:{3} child element but has no child elements.
InconsistentLastMsgNumberExceptionString=The remote endpoint specified two different last message numbers. The reliable session is in an inconsistent state since it cannot determine the actual last message. The reliable session was faulted.
InvalidAcknowledgementFaultReason=The SequenceAcknowledgement violates the cumulative acknowledgement invariant.
InvalidAcknowledgementReceived=A violation of acknowledgement protocol has been detected. An InvalidAcknowledgement fault was sent to the remote endpoint and the reliable session was faulted.
InvalidBufferRemaining=An acknowledgement was received indicating the remaining buffer space on the remote endpoint is {0}. This number cannot be less than zero. The reliable session was faulted.
InvalidSequenceNumber=A message was received with a sequence number of {0}. Sequence numbers cannot be less than 1. The reliable session was faulted.
InvalidSequenceRange=An acknowledgement range starting at {0} and ending at {1} was received. This is an invalid acknowledgement range. The reliable session was faulted.
InvalidWsrmResponseChannelNotOpened=The remote endpoint responded to the {0} request with a response with action {1}. The response must be a {0}Response with action {2}. The channel could not be opened.
InvalidWsrmResponseSessionFaultedExceptionString=The remote endpoint responded to the {0} request with a response with action {1}. The response must be a {0}Response with action {2}. The channel was faulted.
InvalidWsrmResponseSessionFaultedFaultString=The {0} request's response was a message with action {1}. The response must be a {0}Response with action {2}. The reliable session cannot continue.
LastMessageNumberExceeded=A message was received with a sequence number higher than the sequence number of the last message in this sequence. This is a violation of the sequence number protocol. The reliable session was faulted.
LastMessageNumberExceededFaultReason=The value for wsrm:MessageNumber exceeds the value of the MessageNumber accompanying a LastMessage element in this Sequence.
ManualAddressingNotSupported=Binding validation failed because the TransportBindingElement's ManualAddressing property was set to true on a binding that is configured to create reliable sessions. This combination is not supported and the channel factory or service host was not opened.
MaximumRetryCountExceeded=The maximum retry count has been exceeded with no response from the remote endpoint. The reliable session was faulted. This is often an indication that the remote endpoint is no longer available.
MessageExceptionOccurred=A problem occurred while reading a message. See inner exception for details.
MessageNumberRollover=The maximum message number for this sequence has been exceeded. The reliable session was faulted.
MessageNumberRolloverFaultReason=The maximum value for wsrm:MessageNumber has been exceeded.
MillisecondsNotConvertibleToBindingRange=The {0} assertion's Milliseconds attribute does not fall within the range this binding uses. The ReliableSessionBindingElement could not be created.
MissingFinalAckExceptionString=The remote endpoint did not include a final acknowledgement in the reply to the close sequence request message. This is a violation of the WS-ReliableMessaging protocol. The reliable session was faulted.
MissingMessageIdOnWsrmRequest=The wsa:MessageId header must be present on a wsrm:{0} message.
MissingRelatesToOnWsrmResponseReason=The returned wsrm:{0}Response message was missing the required wsa:RelatesTo header. This is a violation of the WS-Addressing request reply protocol. The reliable session was faulted.
MissingReplyToOnWsrmRequest=The wsa:ReplyTo header must be present on a wsrm:{0} message.
MultipleVersionsFoundInPolicy=More than one version of the {0} assertion was found. The ReliableSessionBindingElement could not be created.
NoActionNoSequenceHeaderReason=The endpoint only processes messages using the WS-ReliableMessaging protocol. The message sent to the endpoint does not have an action or any headers used by the protocol and cannot be processed.
NonEmptyWsrmMessageIsEmpty=A message with action {0} is an empty message. This message cannot be processed because the body of this WS-ReliableMessaging protocol message must carry information pertaining to a reliable session.
NonWsrmFeb2005ActionNotSupported=The action {0} is not supported by this endpoint. Only WS-ReliableMessaging February 2005 messages are processed by this endpoint.
NotAllRepliesAcknowledgedExceptionString=The remote endpoint closed the session before acknowledging all responses. All replies could not be delivered. The reliable session was faulted.
ReceivedResponseBeforeRequestExceptionString=The remote endpoint returned a {0}Response when the {0} request had not been sent. This is a WS-ReliableMessaging protocol violation. The reliable session was faulted.
ReceivedResponseBeforeRequestFaultString=The {0}Response was received when the {0} request had not been sent. This is a WS-ReliableMessaging protocol violation. The reliable session cannot continue.
ReplyMissingAcknowledgement=The remote endpoint failed to include a required SequenceAcknowledgement header on a reliable reply message. The reliable session was faulted.
ReliableRequestContextAborted=Due to a request context abort call, the reliable reply session channel potentially has a gap in its reply sequence. The ExactlyOnce assurance can no longer be satisfied. The reliable session was faulted.
RequiredAttributeIsMissing=The required {0} attribute is missing from the {1} element in the {2} assertion. The ReliableSessionBindingElement could not be created.
RequiredMillisecondsAttributeIncorrect=The {0} assertion's required Milliseconds attribute is not schema compliant. Milliseconds must be convertible to an unsigned long. The ReliableSessionBindingElement could not be created.
RMEndpointNotFoundReason=The endpoint at {0} has stopped accepting wsrm sessions.
SequenceClosedFaultString=The Sequence is closed and cannot accept new messages.
SequenceTerminatedAddLastToWindowTimedOut=The RM Source could not transfer the last message within the timeout the user specified.
SequenceTerminatedBeforeReplySequenceAcked=The server received a TerminateSequence message before all reply sequence messages were acknowledged. This is a violation of the reply sequence acknowledgement protocol.
SequenceTerminatedEarlyTerminateSequence=The wsrm:TerminateSequence protocol message was transmitted before the sequence was successfully completed.
SequenceTerminatedInactivityTimeoutExceeded=The inactivity timeout of ({0}) has been exceeded.
SequenceTerminatedInconsistentLastMsgNumber=Two different wsrm:LastMsgNumber values were specified. Because of this the reliable session cannot complete.
SequenceTerminatedMaximumRetryCountExceeded=The user specified maximum retry count for a particular message has been exceeded. Because of this the reliable session cannot continue.
SequenceTerminatedMissingFinalAck=The CloseSequence request's reply message must carry a final acknowledgement. This is a violation of the WS-ReliableMessaging protocol. The reliable session cannot continue.
SequenceTerminatedOnAbort=Due to a user abort the reliable session cannot continue.
SequenceTerminatedQuotaExceededException=The necessary size to buffer a sequence message has exceeded the configured buffer quota. Because of this the reliable session cannot continue.
SequenceTerminatedReliableRequestThrew=The session has stopped waiting for a particular reply. Because of this the reliable session cannot continue.
SequenceTerminatedReplyMissingAcknowledgement=A reply message was received with no acknowledgement.
SequenceTerminatedNotAllRepliesAcknowledged=All of the reply sequence's messages must be acknowledged prior to closing the request sequence. This is a violation of the reply sequence's delivery guarantee. The session cannot continue.
SequenceTerminatedSessionClosedBeforeDone=The user of the remote endpoint's reliable session expects no more messages and a new message arrived. Due to this the reliable session cannot continue.
SequenceTerminatedSmallLastMsgNumber=The wsrm:LastMsgNumber value is too small. A message with a larger sequence number has already been received.
SequenceTerminatedUnexpectedAcknowledgement=The RM destination received an acknowledgement message. The RM destination does not process acknowledgement messages.
SequenceTerminatedUnexpectedAckRequested=The RM source received an AckRequested message. The RM source does not process AckRequested messages.
SequenceTerminatedUnexpectedCloseSequence=The RM source received an CloseSequence message. The RM source does not process CloseSequence messages.
SequenceTerminatedUnexpectedCloseSequenceResponse=The RM destination received an CloseSequenceResponse message. The RM destination does not process CloseSequenceResponse messages.
SequenceTerminatedUnexpectedCS=The RM source received a CreateSequence request. The RM source does not process CreateSequence requests.
SequenceTerminatedUnexpectedCSOfferId=The RM destination received multiple CreateSequence requests with different OfferId values over the same session.
SequenceTerminatedUnexpectedCSR=The RM destination received a CreateSequenceResponse message. The RM destination does not process CreateSequenceResponse messages.
SequenceTerminatedUnexpectedCSROfferId=The RM source received multiple CreateSequenceResponse messages with different sequence identifiers over the same session.
SequenceTerminatedUnexpectedTerminateSequence=The RM source received a TerminateSequence message. The RM source does not process TerminateSequence messages.
SequenceTerminatedUnexpectedTerminateSequenceResponse=The RM destination received a TerminateSequenceResponse message. The RM destination does not process TerminateSequenceResponse messages.
SequenceTerminatedUnsupportedClose=The RM source does not support an RM destination initiated close since messages can be lost. The reliable session cannot continue.
SequenceTerminatedUnsupportedTerminateSequence=The RM source does not support an RM destination initiated termination since messages can be lost. The reliable session cannot continue.
SequenceTerminatedUnknownAddToWindowError=An unknown error occurred while trying to add a sequence message to the window.
SmallLastMsgNumberExceptionString=The remote endpoint specified a last message number that is smaller than a sequence number that has already been seen. The reliable session is in an inconsistent state since it cannot determine the actual last message. The reliable session was faulted.
TimeoutOnAddToWindow=The message could not be transferred within the allotted timeout of {0}. There was no space available in the reliable channel's transfer window. The time allotted to this operation may have been a portion of a longer timeout.
TimeoutOnClose=The close operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.
TimeoutOnOpen=The open operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.
TimeoutOnOperation=The operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.
TimeoutOnRequest=The request operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.
TimeoutOnSend=The send operation did not complete within the allotted timeout of {0}. The time allotted to this operation may have been a portion of a longer timeout.
UnexpectedAcknowledgement=The remote endpoint sent an unexpected ack. Simplex servers do not process acks.
UnexpectedAckRequested=The remote endpoint sent an unexpected request for an ack. Simplex clients do not send acks and do not process requests for acks.
UnexpectedCloseSequence=The remote endpoint sent an unexpected close sequence message. Simplex clients do not process this message.
UnexpectedCloseSequenceResponse=The remote endpoint sent an unexpected close sequence response message. Simplex servers do not process this message.
UnexpectedCS=The remote endpoint sent an unexpected request to create a sequence. Clients do not process requests for a sequence.
UnexpectedCSR=The remote endpoint sent an unexpected create sequence response. Servers do not process this message.
UnexpectedCSOfferId=The remote endpoint sent inconsistent requests to create the same sequence. The OfferId values are not identical.
UnexpectedCSROfferId=The remote endpoint sent inconsistent responses to the same create sequence request. The sequence identifiers are not identical.
UnexpectedTerminateSequence=The remote endpoint sent an unexpected terminate sequence message. Simplex clients do not process this message.
UnexpectedTerminateSequenceResponse=The remote endpoint sent an unexpected terminate sequence response message. Simplex servers do not process this message.
UnparsableCSResponse=The remote endpoint replied to the request for a sequence with a response that could not be parsed. See inner exception for details. The channel could not be opened.
UnknownSequenceFaultReason=The value of wsrm:Identifier is not a known Sequence identifier.
UnknownSequenceFaultReceived=The remote endpoint no longer recognizes this sequence. This is most likely due to an abort on the remote endpoint. {0} The reliable session was faulted.
UnknownSequenceMessageReceived=The remote endpoint has sent a message containing an unrecognized sequence identifier. The reliable session was faulted.
UnrecognizedFaultReceived=The remote endpoint has sent an unrecognized fault with namespace, {0}, name {1}, and reason {2}. The reliable session was faulted.
UnrecognizedFaultReceivedOnOpen=The remote endpoint has sent an unrecognized fault with namespace, {0}, name {1}, and reason {2}. The channel could not be opened.
UnsupportedCloseExceptionString=The remote endpoint closed the sequence before message transfer was complete. This is not supported since all messages could not be transferred. The reliable session was faulted.
UnsupportedTerminateSequenceExceptionString=The remote endpoint terminated the sequence before message transfer was complete. This is not supported since all messages could not be transferred. The reliable session was faulted.
WrongIdentifierFault=The remote endpoint has sent an fault message with an unexpected sequence identifier over a session. The fault may be intended for a different session. The fault reason is: {0} The reliable session was faulted.
WSHttpDoesNotSupportRMWithHttps=Binding validation failed because the WSHttpBinding does not support reliable sessions over transport security (HTTPS). The channel factory or service host could not be opened. Use message security for secure reliable messaging over HTTP.
WsrmFaultReceived=The sequence has been terminated by the remote endpoint. {0} The reliable session was faulted.
WsrmMessageProcessingError=An error occurred while processing a message. {0}
WsrmMessageWithWrongRelatesToExceptionString=The returned {0}Response was carrying the a wsa:RelatesTo header that does not correlate with the wsa:MessageId header on the {0} request. This is a violation of the WS-Addressing request reply protocol. The reliable session cannot continue.
WsrmMessageWithWrongRelatesToFaultString=The remote endpoint has responded to a {0} request message with an invalid reply. The reply has a wsa:RelatesTo header with an unexpected identifier. The reliable session cannot continue.
WsrmRequestIncorrectReplyToExceptionString=The remote endpoint sent a wsrm:{0} request message with a wsa:ReplyTo address containing a URI which is not equivalent to the remote address. This is not supported. The reliable session was faulted.
WsrmRequestIncorrectReplyToFaultString=The wsrm:{0} request message's wsa:ReplyTo address containing a URI which is not equivalent to the remote address. This is not supported. The reliable session was faulted.
WsrmRequiredExceptionString=The incoming message is not a WS-ReliableMessaging 1.1 message and could not be processed.
WsrmRequiredFaultString=The RM server requires the use of WS-ReliableMessaging 1.1 protocol. This is likely caused by a binding mismatch.
; ------------------------------------------------------------------------------------------------------------------------------
; Rule Manager and Routing
; ------------------------------------------------------------------------------------------------------------------------------
;
; Place Service Framework strings below prefixed by SFx
; ------------------------------------------------------------------------------------------------------------------------------
SFxActionDemuxerDuplicate=The operations {0} and {1} have the same action ({2}).  Every operation must have a unique action value.
SFxActionMismatch=Cannot create a typed message due to action mismatch, expecting {0} encountered {1}
SFxAnonymousTypeNotSupported=Part {1} in message {0} cannot be exported with RPC or encoded since its type is anonymous.
SFxAsyncResultsDontMatch0=The IAsyncResult returned from Begin and the IAsyncResult supplied to the Callback are on different objects. These are required to be the same object.
SFXBindingNameCannotBeNullOrEmpty=Binding name cannot be null or empty.
SFXUnvalidNamespaceValue=Value '{0}' provided for {1} property is an invalid URI.
SFXUnvalidNamespaceParam=Parameter value '{0}' is an invalid URI.
SFXHeaderNameCannotBeNullOrEmpty=Header name cannot be null or empty.
SFxEndpointNoMatchingScheme=Could not find a base address that matches scheme {0} for the endpoint with binding {1}. Registered base address schemes are [{2}].
SFxBindingSchemeDoesNotMatch=The scheme '{0}' used by binding {1} does not match the required scheme '{2}'.
SFxGetChannelDispatcherDoesNotSupportScheme=Only a '{0}' using '{1}' or '{2}' is supported in this scenario.
SFxIncorrectMessageVersion=MessageVersion '{0}' is not supported in this scenario.  Only MessageVersion '{1}' is supported.
SFxBindingNotSupportedForMetadataHttpGet=The binding associated with ServiceMetadataBehavior or ServiceDebugBehavior is not supported.  The inner binding elements used by this binding must support IReplyChannel. Verify that HttpGetBinding/HttpsGetBinding (on ServiceMetadataBehavior) and HttpHelpPageBinding/HttpsHelpPageBinding (on ServiceDebugBehavior) are supported.
SFxBadByReferenceParameterMetadata=Method '{0}' in class '{1}' has bad parameter metadata: a pass-by-reference parameter is marked with the 'in' but not the 'out' parameter mode.
SFxBadByValueParameterMetadata=Method '{0}' in class '{1}' has bad parameter metadata: a pass-by-value parameter is marked with the 'out' parameter mode.
SFxBadMetadataMustBePolicy=When calling the CreateFromPolicy method, the policy argument must be an XmlElement instance with LocalName '{1}' and NamespaceUri '{0}'. This XmlElement has LocalName '{3}' and NamespaceUri '{2}'. 
SFxBadMetadataLocationUri=The URI supplied to ServiceMetadataBehavior via the ExternalMetadataLocation property or the externalMetadataLocation attribute in the serviceMetadata section in config must be a relative URI or an absolute URI with an http or https scheme. '{0}' was specified, which is a absolute URI with {1} scheme.
SFxBadMetadataLocationNoAppropriateBaseAddress=The URL supplied to ServiceMetadataBehavior via the ExternalMetadataLocation property or the externalMetadataLocation attribute in the serviceMetadata section in config was a relative URL and there is no base address with which to resolve it. '{0}' was specified.
SFxBadMetadataDialect=There was a problem reading the MetadataSet argument: a MetadataSection instance with identifier '{0}' and dialect '{1}' has a Metadata property whose type does not match the dialect. The expected Metadata type for this dialect is '{2}' but was found to be '{3}'.
SFxBadMetadataReference=Metadata contains a reference that cannot be resolved: '{0}'.
SFxMaximumResolvedReferencesOutOfRange=The MaximumResolvedReferences property of MetadataExchangeClient must be greater than or equal to one.  '{0}' was specified.
SFxMetadataExchangeClientNoMetadataAddress=The MetadataExchangeClient was not supplied with a MetadataReference or MetadataLocation from which to get metadata.  You must supply one to the constructor, to the GetMetadata method, or to the BeginGetMetadata method.
SFxMetadataExchangeClientCouldNotCreateChannelFactory=The MetadataExchangeClient could not create an IChannelFactory for: address='{0}', dialect='{1}', and  identifier='{2}'. 
SFxMetadataExchangeClientCouldNotCreateWebRequest=The MetadataExchangeClient could not create an HttpWebRequest for: address='{0}', dialect='{1}', and  identifier='{2}'. 
SFxMetadataExchangeClientCouldNotCreateChannelFactoryBadScheme=The MetadataExchangeClient instance could not be initialized because no Binding is available for scheme '{0}'. You can supply a Binding in the constructor, or specify a configurationName.
SFxBadTransactionProtocols=The TransactionProtocol setting was not understood. A supported protocol must be specified.
SFxMetadataResolverKnownContractsArgumentCannotBeEmpty=The MetadataResolver cannot recieve an empty contracts argument to the Resolve or BeginResolve methods.  You must supply at least one ContractDescription.
SFxMetadataResolverKnownContractsUniqueQNames=The ContractDescriptions in contracts must all have unique Name and Namespace pairs.  More than one ContractDescription had the pair Name='{0}' and Namespace='{1}'. 
SFxMetadataResolverKnownContractsCannotContainNull=The contracts argument to the Resolve or BeginResolve methods cannot contain a null ContractDescription.
SFxBindingDoesNotHaveATransportBindingElement=The binding specified to do metadata exchange does not contain a TransportBindingElement.
SFxBindingMustContainTransport2=The binding (Name={0}, Namespace={1}) does not contain a TransportBindingElement.
SFxBodyCannotBeNull=Body object cannot be null in message {0}
SFxBodyObjectTypeCannotBeInherited=Type {0} cannot inherit from any class other than object to be used as body object in RPC style.
SFxBodyObjectTypeCannotBeInterface=Type {0} implements interface {1} which is not supported for body object in RPC style.
SFxCallbackBehaviorAttributeOnlyOnDuplex=CallbackBehaviorAttribute can only be run as a behavior on an endpoint with a duplex contract. Contract '{0}' is not duplex, as it contains no callback operations.
SFxCallbackRequestReplyInOrder1=This operation would deadlock because the reply cannot be received until the current Message completes processing. If you want to allow out-of-order message processing, specify ConcurrencyMode of Reentrant or Multiple on {0}.
SfxCallbackTypeCannotBeNull=In order to use the contract '{0}' with DuplexChannelFactory, the contract must specify a valid callback contract.  If your contract does not have a callback contract, consider using ChannelFactory instead of DuplexChannelFactory.
SFxCannotActivateCallbackInstace=The dispatch instance for duplex callbacks cannot be activated - you must provide an instance.
SFxCannotCallAddBaseAddress=ServiceHostBase's AddBaseAddress method cannot be called after the InitializeDescription method has completed.
SFxCannotCallAutoOpenWhenExplicitOpenCalled=Cannot make a call on this channel because a call to Open() is in progress.
SFxCannotGetMetadataFromRelativeAddress=The MetadataExchangeClient can only get metadata from absolute addresses.  It cannot get metadata from '{0}'.
SFxCannotHttpGetMetadataFromAddress=The MetadataExchangeClient can only get metadata from http or https addresses when using MetadataExchangeClientMode HttpGet. It cannot get metadata from '{0}'.
SFxCannotGetMetadataFromLocation=The MetadataExchangeClient can only get metadata from http and https MetadataLocations.  It cannot get metadata from '{0}'.
SFxCannotHaveDifferentTransactionProtocolsInOneBinding=The configured policy specifies more than one TransactionProtocol across the operations. A single TransactionProtocol for each endpoint must be specified.
SFxCannotImportAsParameters_Bare=Generating message contract since the operation {0} is neither RPC nor document wrapped.
SFxCannotImportAsParameters_DifferentWrapperNs=Generating message contract since the wrapper namespace ({1}) of message {0} does not match the default value ({2})
SFxCannotImportAsParameters_DifferentWrapperName=Generating message contract since the wrapper name ({1}) of message {0} does not match the default value ({2})
SFxCannotImportAsParameters_ElementIsNotNillable=Generating message contract since element name {0} from namespace {1} is not marked nillable
SFxCannotImportAsParameters_MessageHasProtectionLevel=Generating message contract since message {0} requires protection.
SFxCannotImportAsParameters_HeadersAreIgnoredInEncoded=Headers are not supported in RPC encoded format. Headers are ignored in message {0}.
SFxCannotImportAsParameters_HeadersAreUnsupported=Generating message contract since message {0} has headers
SFxCannotImportAsParameters_Message=Generating message contract since the operation {0} has untyped Message as argument or return type
SFxCannotImportAsParameters_NamespaceMismatch=Generating message contract since message part namespace ({0}) does not match the default value ({1})
SFxCannotRequireBothSessionAndDatagram3=There are two contracts listening on the same binding ({2}) and address with conflicting settings.  Specifically, the contract '{0}' specifies SessionMode.NotAllowed while the contract '{1}' specifies SessionMode.Required.  You should either change one of the SessionMode values or specify a different address (or ListenUri) for each endpoint.
SFxCannotSetExtensionsByIndex=This collection does not support setting extensions by index.  Please consider using the InsertItem or RemoveItem methods.
SFxChannelDispatcherDifferentHost0=This ChannelDispatcher is not currently attached to the provided ServiceHost.
SFxChannelDispatcherMultipleHost0=Cannot add a ChannelDispatcher to more than one ServiceHost.
SFxChannelDispatcherNoHost0=Cannot open ChannelDispatcher because it is not attached to a ServiceHost.
SFxChannelDispatcherNoMessageVersion=Cannot open ChannelDispatcher because it is does not have a MessageVersion set.
SFxChannelDispatcherUnableToOpen1=The ChannelDispatcher at '{0}' is unable to open its IChannelListener as there are no endpoints for the ChannelDispatcher.
SFxChannelDispatcherUnableToOpen2=The ChannelDispatcher at '{0}' with contract(s) '{1}' is unable to open its IChannelListener.
SFxChannelFactoryTypeMustBeInterface=The type argument passed to the generic ChannelFactory class must be an interface type.
SFxChannelFactoryCannotApplyConfigurationWithoutEndpoint=ApplyConfiguration requires that the Endpoint property be initialized. Either provide a valid ServiceEndpoint in the CreateDescription method or override the ApplyConfiguration method to provide an alternative implementation.
SFxChannelFactoryCannotCreateFactoryWithoutDescription=CreateFactory requires that the Endpoint property be initialized. Either provide a valid ServiceEndpoint in the CreateDescription method or override the CreateFactory method to provide an alternative implementation.
SFxChannelTerminated0=An operation marked as IsTerminating has already been invoked on this channel, causing the channel's connection to terminate.  No more operations may be invoked on this channel.  Please re-create the channel to continue communication.
SFxClientOutputSessionAutoClosed=This channel can no longer be used to send messages as the output session was auto-closed due to a server-initiated shutdown. Either disable auto-close by setting the DispatchRuntime.AutomaticInputSessionShutdown to false, or consider modifying the shutdown protocol with the remote server.
SFxCodeGenArrayTypeIsNotSupported=Array of type {0} is not supported.
SFxCodeGenCanOnlyStoreIntoArgOrLocGot0=Can only store into ArgBuilder or LocalBuilder. Got: {0}.
SFxCodeGenExpectingEnd=Expecting End {0}.
SFxCodeGenIsNotAssignableFrom={0} is not assignable from {1}.
SFxCodeGenNoConversionPossibleTo=No conversion possible to {0}.
SFxCodeGenWarning=CODEGEN: {0}
SFxCodeGenUnknownConstantType=Internal Error: Unrecognized constant type {0}.
SFxCollectionDoesNotSupportSet0=This collection does not support setting items by index.
SFxCollectionReadOnly=This operation is not supported because the collection is read-only.
SFxCollectionWrongType2=The collection of type {0} does not support values of type {1}.
SFxConflictingGlobalElement=Top level XML element with name {0} in namespace {1} cannot reference {2} type because it already references a different type ({3}). Use a different operation name or MessageBodyMemberAttribute to specify a different name for the Message or Message parts.
SFxConflictingGlobalType=Duplicate top level XML Schema type with name {0} in namespace {1}.
SFxContextModifiedInsideScope0=The value of OperationContext.Current is not the OperationContext value installed by this OperationContextScope.
SFxContractDescriptionNameCannotBeEmpty=ContractDescription's Name must be a non-empty string.
SFxContractHasZeroOperations=ContractDescription '{0}' has zero operations; a contract must have at least one operation.
SFxContractHasZeroInitiatingOperations=ContractDescription '{0}' has zero IsInitiating=true operations; a contract must have at least one IsInitiating=true operation.
SFxContractInheritanceRequiresInterfaces=The service class of type {0} both defines a ServiceContract and inherits a ServiceContract from type {1}. Contract inheritance can only be used among interface types.  If a class is marked with ServiceContractAttribute, it must be the only type in the hierarchy with ServiceContractAttribute.  Consider moving the ServiceContractAttribute on type {1} to a separate interface that type {1} implements.
SFxContractInheritanceRequiresInterfaces2=The service class of type {0} both defines a ServiceContract and inherits a ServiceContract from type {1}. Contract inheritance can only be used among interface types.  If a class is marked with ServiceContractAttribute, then another service class cannot derive from it.
SFxCopyToRequiresICollection=SynchronizedReadOnlyCollection's CopyTo only works if the underlying list implements ICollection.
SFxCreateDuplexChannel1=The callback contract of contract {0} either does not exist or does not define any operations.  If this is not a duplex contract, consider using ChannelFactory instead of DuplexChannelFactory.
SFxCreateDuplexChannelNoCallback=This CreateChannel overload cannot be called on this instance of DuplexChannelFactory, as the DuplexChannelFactory was not initialized with an InstanceContext.  Please call the CreateChannel overload that takes an InstanceContext.
SFxCreateDuplexChannelNoCallback1=This CreateChannel overload cannot be called on this instance of DuplexChannelFactory, as the DuplexChannelFactory was initialized with a Type and no valid InstanceContext was provided.  Please call the CreateChannel overload that takes an InstanceContext.
SFxCreateDuplexChannelNoCallbackUserObject=This CreateChannel overload cannot be called on this instance of DuplexChannelFactory, as the InstanceContext provided to the DuplexChannelFactory does not contain a valid UserObject.
SFxCreateDuplexChannelBadCallbackUserObject=The InstanceContext provided to the ChannelFactory contains a UserObject that does not implement the CallbackContractType '{0}'.
SFxCreateNonDuplexChannel1=ChannelFactory does not support the contract {0} as it defines a callback contract with one or more operations.  Please consider using DuplexChannelFactory instead of ChannelFactory.
SFxCustomBindingNeedsTransport1=The CustomBinding on the ServiceEndpoint with contract '{0}' lacks a TransportBindingElement.  Every binding must have at least one binding element that derives from TransportBindingElement.
SFxCustomBindingWithoutTransport=The Scheme cannot be computed for this binding because this CustomBinding lacks a TransportBindingElement.  Every binding must have at least one binding element that derives from TransportBindingElement.
SFxDeserializationFailed1=The formatter threw an exception while trying to deserialize the message: {0}
SFxDictionaryIsEmpty=This operation is not possible since the dictionary is empty.
SFxDisallowedAttributeCombination=The type or member named '{0}' could not be loaded because it has two incompatible attributes: '{1}' and '{2}'. To fix the problem, remove one of the attributes from the type or member.
SFxEndpointAddressNotSpecified=The endpoint's address is not specified. 
SFxEndpointContractNotSpecified=The endpoint's contract is not specified.
SFxEndpointBindingNotSpecified=The endpoint's binding is not specified.
SFxInitializationUINotCalled=The channel is configured to use interactive initializer '{0}', but the channel was Opened without calling DisplayInitializationUI.  Call DisplayInitializationUI before calling Open or other methods on this channel.
SFxInitializationUIDisallowed=AllowInitializationUI was set to false for this channel, but the channel is configured to use the '{0}' as an interactive initializer.
SFxDocExt_NoMetadataSection1=This is a Windows&#169; Communication Foundation service.<BR/><BR/><B>Metadata publishing for this service is currently disabled.</B><BR/><BR/>If you have access to the service, you can enable metadata publishing by completing the following steps to modify your web or application configuration file:<BR/><BR/>1. Create the following service behavior configuration, or add the &lt;serviceMetadata&gt; element to an existing service behavior configuration:
SFxDocExt_NoMetadataSection2=2. Add the behavior configuration to the service:
SFxDocExt_NoMetadataSection3=Note: the service name must match the configuration name for the service implementation.<BR/><BR/>3. Add the following endpoint to your service configuration:
SFxDocExt_NoMetadataSection4=Note: your service must have an http base address to add this endpoint.<BR/><BR/>The following is an example service configuration file with metadata publishing enabled:
SFxDocExt_NoMetadataSection5=For more information on publishing metadata please see the following documentation: <a href="http://go.microsoft.com/fwlink/?LinkId=65455">http://go.microsoft.com/fwlink/?LinkId=65455</a>.
SFxDocExt_NoMetadataConfigComment1=Note: the service name must match the configuration name for the service implementation.
SFxDocExt_NoMetadataConfigComment2=Add the following endpoint. 
SFxDocExt_NoMetadataConfigComment3=Note: your service must have an http base address to add this endpoint.
SFxDocExt_NoMetadataConfigComment4=Add the following element to your service behavior configuration.
SFxDocExt_CS=<P class='intro'><B>C#</B></P>
SFxDocExt_VB=<P class='intro'><B>Visual Basic</B></P>
SFxDocExt_MainPageTitleNoServiceName=Service
SFxDocExt_MainPageTitle={0} Service
SFxDocExt_MainPageIntro1a=You have created a service.<P class='intro'>To test this service, you will need to create a client and use it to call the service. You can do this using the svcutil.exe tool from the command line with the following syntax:</P> 
SFxDocExt_MainPageIntro1b=You have created a service.<P class='intro'>To test this service, you will need to create a client and use it to call the service; however, metadata publishing via ?WSDL is currently disabled. This can be enabled via the service's configuration file. </P>
SFxDocExt_MainPageIntro2=This will generate a configuration file and a code file that contains the client class. Add the two files to your client application and use the generated client class to call the Service. For example:<BR/>
SFxDocExt_MainPageComment=Use the 'client' variable to call operations on the service.
SFxDocExt_MainPageComment2=Always close the client.
SFxDocExt_Error=The service encountered an error.
SFxDocEncodedNotSupported=Operation '{0}' could not be loaded as it uses an unsupported combination of Use and Style settings: Document with Encoded. To fix the problem, change the Use setting to Literal or change the Style setting to Rpc.
SFxDocEncodedFaultNotSupported=Fault could not be loaded as the Use setting is Encoded and it references a schema definition using Element attribute. To fix the problem, change the Use setting to Literal.
SFxDuplicateMessageParts=Message part {0} in namespace {1} appears more than once in Message.
SFxDuplicateInitiatingActionAtSameVia=This service has multiple endpoints listening at '{0}' which share the same initiating action '{1}'.  As a result, messages with this action would be dropped since the dispatcher would not be able to determine the correct endpoint for handling the message.  Please consider hosting these Endpoints at separate ListenUris.
SFXEndpointBehaviorUsedOnWrongSide=The IEndpointBehavior '{0}' cannot be used on the server side; this behavior can only be applied to clients.
SFxEndpointDispatcherMultipleChannelDispatcher0=Cannot add EndpointDispatcher to more than one ChannelDispatcher.
SFxEndpointDispatcherDifferentChannelDispatcher0=This EndpointDispatcher is not currently attached to the provided ChannelDispatcher.
SFxErrorCreatingMtomReader=Error creating a reader for the MTOM message
SFxErrorDeserializingRequestBody=Error in deserializing body of request message for operation '{0}'.
SFxErrorDeserializingRequestBodyMore=Error in deserializing body of request message for operation '{0}'. {1}
SFxErrorDeserializingReplyBody=Error in deserializing body of reply message for operation '{0}'.
SFxErrorDeserializingReplyBodyMore=Error in deserializing body of reply message for operation '{0}'. {1}
SFxErrorSerializingBody=There was an error in serializing body of message {0}: '{1}'.  Please see InnerException for more details.
SFxErrorDeserializingHeader=There was an error in deserializing one of the headers in message {0}.  Please see InnerException for more details.
SFxErrorSerializingHeader=There was an error in serializing one of the headers in message {0}: '{1}'.  Please see InnerException for more details.
SFxErrorDeserializingFault=Server returned an invalid SOAP Fault.  Please see InnerException for more details.
SFxErrorReflectingOnType2=An error occurred while loading attribute '{0}' on type '{1}'.  Please see InnerException for more details.
SFxErrorReflectingOnMethod3=An error occurred while loading attribute '{0}' on method '{1}' in type '{2}'.  Please see InnerException for more details.
SFxErrorReflectingOnParameter4=An error occurred while loading attribute '{0}' on parameter {1} of method '{2}' in type '{3}'.  Please see InnerException for more details.
SFxErrorReflectionOnUnknown1=An error occurred while loading attribute '{0}'.  Please see InnerException for more details.
SFxExceptionDetailEndOfInner=--- End of inner ExceptionDetail stack trace ---
SFxExceptionDetailFormat=An ExceptionDetail, likely created by IncludeExceptionDetailInFaults=true, whose value is:
SFxExpectedIMethodCallMessage=Internal Error: Message must be a valid IMethodCallMessage.
SFxExportMustHaveType=The specified ContractDescription could not be exported to WSDL because the Type property of the MessagePartDescription with name '{1}' in the OperationDescription with name '{0}' is not set.  The Type property must be set in order to create WSDL.
SFxFaultCannotBeImported=Fault named {0} in operation {1} cannot be imported. {2}
SFxFaultContractDuplicateDetailType=In operation {0}, more than one fault is declared with detail type {1}
SFxFaultContractDuplicateElement=In operation {0}, more than one fault is declared with element name {1} in namespace {2}
SFxFaultExceptionToString3={0}: {1} (Fault Detail is equal to {2}).
SFxFaultReason=The creator of this fault did not specify a Reason.
SFxFaultTypeAnonymous=In operation {0}, the schema type corresponding to the fault detail type {1} is anonymous. Please set Fault name explicitly to export anonymous types.
SFxHeaderNameMismatchInMessageContract=Header name mismatch in member {1} of type {0}. The header name found in the description is {2}. The element name deduced by the formatter is {3}. This mismatch can happen if the ElementName specified in XmlElementAttribute or XmlArrayAttribute does not match the name specified in the MessageHeaderAttribute or MessageHeaderArrayAttribute or the member name.
SFxHeaderNameMismatchInOperation=Header name mismatch in operation {0} from contract {1}:{2}. The header name found in the description is {3}. The element name deduced by the formatter is {4}. This mismatch can happen if the ElementName specified in XmlElementAttribute or XmlArrayAttribute does not match the name specified in the MessageHeaderAttribute or MessageHeaderArrayAttribute or the member name.
SFxHeaderNamespaceMismatchInMessageContract=Header namespace mismatch in member {1} of type {0}. The header namespace found in the description is {2}. The element namespace deduced by the formatter is {3}. This mismatch can happen if the Namespace specified in XmlElementAttribute or XmlArrayAttribute does not match the namespace specified in the MessageHeaderAttribute or MessageHeaderArrayAttribute or the contract namespace.
SFxHeaderNamespaceMismatchInOperation=Header namespace mismatch in operation {0} from contract {1}:{2}. The header namespace found in the description is {3}. The element namespace deduced by the formatter is {4}. This mismatch can happen if the Namespace specified in XmlElementAttribute or XmlArrayAttribute does not match the namespace specified in the MessageHeaderAttribute or MessageHeaderArrayAttribute or the contract namespace.
SFxHeaderNotUnderstood=The header '{0}' from the namespace '{1}' was not understood by the recipient of this message, causing the message to not be processed.  This error typically indicates that the sender of this message has enabled a communication protocol that the receiver cannot process.  Please ensure that the configuration of the client's binding is consistent with the service's binding. 
SFxHeadersAreNotSupportedInEncoded=Message {0} must not have headers to be used in RPC encoded style.
SFxImmutableServiceHostBehavior0=This value cannot be changed after the ServiceHost has opened.
SFxImmutableChannelFactoryBehavior0=This value cannot be changed after the ChannelFactory has opened.
SFxImmutableClientBaseCacheSetting=This value cannot be changed after the first ClientBase of type '{0}' has been created.
SFxImmutableThrottle1={0} cannot be changed after the ServiceHost has opened.
SFxInconsistentBindingBodyParts=Operation {0} binding {1} has extra part {2} that is not present in other bindings
SFxInconsistentWsdlOperationStyleInHeader=Style {1} on header {0} does not match expected style {2}.
SFxInconsistentWsdlOperationStyleInMessageParts=All parts of message in operation {0} must either contain type or element. 
SFxInconsistentWsdlOperationStyleInOperationMessages=Style {1} inferred from messages in operation {0} does not match expected style {2} specified via bindings.
SFxInconsistentWsdlOperationUseAndStyleInBinding=Bindings for operation {0} cannot specify different use and style values. Binding {1} specifies use {2} and style {3} while binding {4} specifies use {5} and style {6}.
SFxInconsistentWsdlOperationUseInBindingExtensions=Extensions for operation {0} in binding {1} cannot specify different use values.
SFxInconsistentWsdlOperationUseInBindingMessages=Message bindings for operation {0} in binding {1} cannot specify different use values.
SFxInconsistentWsdlOperationUseInBindingFaults=Fault bindings for operation {0} in binding {1} cannot specify different use values.
SFxInputParametersToServiceInvalid=Service implementation object invoked with wrong number of input parameters, operation expects {0} parameters but was called with {1} parameters.
SFxInputParametersToServiceNull=Service implementation object invoked with null input parameters, but operation expects {0} parameters.
SFxInstanceNotInitialized=The InstanceContext has no provider for creating Service implementation objects.
SFxInterleavedContextScopes0=This OperationContextScope is being disposed out of order.
SFxInternalServerError=The server was unable to process the request due to an internal error.  For more information about the error, either turn on IncludeExceptionDetailInFaults (either from ServiceBehaviorAttribute or from the <serviceDebug> configuration behavior) on the server in order to send the exception information back to the client, or turn on tracing as per the Microsoft .NET Framework SDK documentation and inspect the server trace logs.
SFxInternalCallbackError=The client was unable to process the callback request due to an internal error.  For more information about the error, either turn on IncludeExceptionDetailInFaults (either from CallbackBehaviorAttribute or from the <clientDebug> configuration behavior) on the client in order to send the exception information back to the server, or turn on tracing as per the Microsoft .NET Framework SDK documentation and inspect the client trace logs.
SFxInvalidAsyncResultState0=IAsyncResult's State must be the state argument passed to your Begin call.
SFxInvalidCallbackIAsyncResult=IAsyncResult not provided or of wrong type.
SFxInvalidCallbackContractType=The CallbackContract {0} is invalid because it is not an interface type.
SFxInvalidChannelToOperationContext=Invalid IContextChannel passed to OperationContext. Must be either a server dispatching channel or a client proxy channel.
SFxInvalidContextScopeThread0=This OperationContextScope is being disposed on a different thread than it was created.
SFxInvalidMessageBody=OperationFormatter encountered an invalid Message body. Expected to find node type 'Element' with name '{0}' and namespace '{1}'. Found node type '{2}' with name '{3}' and namespace '{4}'
SFxInvalidMessageBodyEmptyMessage=The OperationFormatter could not deserialize any information from the Message because the Message is empty (IsEmpty = true).
SFxInvalidMessageBodyErrorSerializingParameter=There was an error while trying to serialize parameter {0}:{1}. The InnerException message was '{2}'.  Please see InnerException for more details.
SFxInvalidMessageBodyErrorDeserializingParameter=There was an error while trying to deserialize parameter {0}:{1}.  Please see InnerException for more details.
SFxInvalidMessageBodyErrorDeserializingParameterMore=There was an error while trying to deserialize parameter {0}:{1}. The InnerException message was '{2}'.  Please see InnerException for more details.
SFxInvalidMessageContractSignature=The operation {0} either has a parameter or a return type that is attributed with MessageContractAttribute.  In order to represent the request message using a Message Contract, the operation must have a single parameter attributed with MessageContractAttribute.  In order to represent the response message using a Message Contract, the operation's return value must be a type that is attributed with MessageContractAttribute and the operation may not have any out or ref parameters.
SFxInvalidMessageHeaderArrayType=MessageHeaderArrayAttribute found on member {0} is not a single dimensional array.
SFxInvalidRequestAction=Outgoing request message for operation '{0}' specified Action='{1}', but contract for that operation specifies Action='{2}'.  The Action specified in the Message must match the Action in the contract, or the operation contract must specify Action='*'.
SFxInvalidReplyAction=Outgoing reply message for operation '{0}' specified Action='{1}', but contract for that operation specifies ReplyAction='{2}'.    The Action specified in the Message must match the ReplyAction in the contract, or the operation contract must specify ReplyAction='*'.
SFxInvalidStreamInTypedMessage=In order to use Streams with the MessageContract programming model, the type {0} must have a single member with MessageBodyMember attribute and the member type must be Stream.
SFxInvalidStreamInRequest=For request in operation {0} to be a stream the operation must have a single parameter whose type is Stream.
SFxInvalidStreamInResponse=For response in operation {0} to be a stream the operation must have a single out parameter or return value whose type is Stream.
SFxInvalidStreamOffsetLength=Buffer size must be at least {0} bytes.
SFxInvalidUseOfPrimitiveOperationFormatter=The PrimitiveOperationFormatter was given a parameter or return type which it does not support.
SFxInvalidStaticOverloadCalledForDuplexChannelFactory1=The static CreateChannel method cannot be used with the contract {0} because that contract defines a callback contract.  Please try using one of the static CreateChannel overloads on DuplexChannelFactory<TChannel>.
SFxInvalidSoapAttribute=XmlSerializer attribute {0} is not valid in {1}. Only SoapElement attribute is supported.
SFxInvalidXmlAttributeInBare=XmlSerializer attribute {0} is not valid in {1}. Only XmlElement, XmlArray, XmlArrayItem and XmlAnyElement attributes are supported in MessageContract when IsWrapped is false.
SFxInvalidXmlAttributeInWrapped=XmlSerializer attribute {0} is not valid in {1}. Only XmlElement, XmlArray, XmlArrayItem, XmlAnyAttribute and XmlAnyElement attributes are supported when IsWrapped is true.
SFxKnownTypeAttributeInvalid1={0} must contain either a single ServiceKnownTypeAttribute that refers to a method or a set of ServiceKnownTypeAttributes, each specifying a valid type
SFxKnownTypeAttributeReturnType3=The return type of method {1} in type {2} must be IEnumerable<Type> to be used by ServiceKnownTypeAttribute in {0}
SFxKnownTypeAttributeUnknownMethod3=ServiceKnownTypeAttribute in {0} refers to a method {1} that does not exist in type {2}
SFxKnownTypeNull=KnownType cannot be null in operation {0}
SFxMessageContractBaseTypeNotValid=The type {1} defines a MessageContract but also derives from a type {0} that does not define a MessageContract.  All of the objects in the inheritance hierarchy of {1} must defines a MessageContract.
SFxMessageContractRequiresDefaultConstructor=The message cannot be deserialized into MessageContract type {0} since it does not have a default (parameterless) constructor.
SFxMessageOperationFormatterCannotSerializeFault=MessageOperationFormatter cannot serialize faults.
SFxMetadataReferenceInvalidLocation=The value '{0}' is not valid for the Location property. The Location property must be a valid absolute or relative URI.
SFxMethodNotSupported1=Method {0} is not supported on this proxy, this can happen if the method is not marked with OperationContractAttribute or if the interface type is not marked with ServiceContractAttribute.
SFxMethodNotSupportedOnCallback1=Callback method {0} is not supported, this can happen if the method is not marked with OperationContractAttribute or if its interface type is not the target of the ServiceContractAttribute's CallbackContract.
SFxMethodNotSupportedByType2=ServiceHost implementation type {0} does not implement ServiceContract {1}.
SFxMismatchedOperationParent=A DispatchOperation (or ClientOperation) can only be added to its parent DispatchRuntime (or ClientRuntime).
SFxMissingActionHeader=No Action header was found with namespace '{0}' for the given message.
SFxMultipleCallbackFromSynchronizationContext=Calling Post() on '{0}' resulted in multiple callbacks.  This indicates a problem in '{0}'.
SFxMultipleCallbackFromAsyncOperation=The callback passed to operation '{0}' was called more than once.  This indicates an internal error in the implementation of that operation.
SFxMultipleUnknownHeaders=Method {0} in type {1} has more than one header part of type array of XmlElement.
SFxMultipleContractStarOperations0=A ServiceContract has more the one operation with an Action of "*".  A ServiceContract can have at most one operation an Action = "*".
SFxMultipleContractsWithSameName=The Service contains multiple ServiceEndpoints with different ContractDescriptions which each have Name='{0}' and Namespace='{1}'.  Either provide ContractDescriptions with unique Name and Namespaces, or ensure the ServiceEndpoints have the same ContractDescription instance.
SFxMultiplePartsNotAllowedInEncoded=Part {1}:{0} is repeating and is not supported in Soap Encoding.
SFxNameCannotBeEmpty=The Name property must be a non-empty string.
SFxConfigurationNameCannotBeEmpty=The ConfigurationName property must be a non-empty string.
SFxNeedProxyBehaviorOperationSelector2=Cannot handle invocation of {0} on interface {1} because the OperationSelector on ClientRuntime is null.
SFxNoDefaultConstructor=The service type provided could not be loaded as a service because it does not have a default (parameter-less) constructor. To fix the problem, add a default constructor to the type, or pass an instance of the type to the host.
SFxNoMostDerivedContract=The contract specified by type '{0}' is ambiguous.  The type derives from at least two different types that each define its own service contract.  For this type to be used as a contract type, exactly one of its inherited contracts must be more derived than any of the others.
SFxNullReplyFromExtension2=Extension {0} prevented call to operation '{1}' from replying by setting the reply to null.
SFxNullReplyFromFormatter2=Formatter {0} returned a null reply message for call to operation '{1}'.
SFxServiceChannelIdleAborted=The operation '{0}' could not be completed because the sessionful channel timed out waiting to receive a message.  To increase the timeout, either set the receiveTimeout property on the binding in your configuration file, or set the ReceiveTimeout property on the Binding directly.
SFxServiceMetadataBehaviorUrlMustBeHttpOrRelative={0} must be a relative URI or an absolute URI with scheme '{1}'.  '{2}' is an absolute URI with scheme '{3}'. 
SFxServiceMetadataBehaviorNoHttpBaseAddress=The HttpGetEnabled property of ServiceMetadataBehavior is set to true and the HttpGetUrl property is a relative address, but there is no http base address.  Either supply an http base address or set HttpGetUrl to an absolute address.
SFxServiceMetadataBehaviorNoHttpsBaseAddress=The HttpsGetEnabled property of ServiceMetadataBehavior is set to true and the HttpsGetUrl property is a relative address, but there is no https base address.  Either supply an https base address or set HttpsGetUrl to an absolute address.
SFxServiceMetadataBehaviorInstancingError=The ChannelDispatcher with ListenUri '{0}' has endpoints with the following contracts: {1}. Metadata endpoints cannot share ListenUris. The conflicting endpoints were either specified in AddServiceEndpoint() calls, in a config file, or a combination of AddServiceEndpoint() and config.
SFxServiceTypeNotCreatable=Service implementation type is an interface or abstract class and no implementation object was provided.
SFxSetEnableFaultsOnChannelDispatcher0=This property sets EnableFaults on the client. To set EnableFaults on the server, use ChannelDispatcher's EnableFaults.
SFxSetManualAddresssingOnChannelDispatcher0=This property sets ManualAddressing on the client. To set ManualAddressing on the server, use ChannelDispatcher's ManualAddressing.
SFxNoBatchingForSession=TransactedBatchingBehavior validation failed. Service or client cannot be started. Transacted batching is not supported for session contracts. Remove transacted batching behavior from the endpoint or define a non-sessionful contract.
SFxNoBatchingForReleaseOnComplete=TransactedBatchingBehavior validation failed. Service cannot be started. Transacted batching requires ServiceBehavior.ReleaseServiceInstanceOnTransactionComplete to be false.
SFxNoServiceObject=The service implementation object was not initialized or is not available.
SFxNone2004=The WS-Addressing "none" value is not valid for the August 2004 version of WS-Addressing.
SFxNonExceptionThrown=An object that is not an exception was thrown.
SFxNonInitiatingOperation1=The operation '{0}' cannot be the first operation to be called because IsInitiating is false.
SfxNoTypeSpecifiedForParameter=There was no CLR type specified for parameter {0}, preventing the operation from being generated.
SFxOneWayAndTransactionsIncompatible=The one-way operation '{1}' on ServiceContract '{0}' is configured for transaction flow. Transactions cannot be flowed over one-way operations.
SFxOneWayMessageToTwoWayMethod0=The incoming message with action could not be processed because it is targeted at a request-reply operation, but cannot be replied to as the MessageId property is not set.
SFxOperationBehaviorAttributeOnlyOnServiceClass=OperationBehaviorAttribute can only go on the service class, it cannot be put on the ServiceContract interface. Method '{0}' on type '{1}' violates this.
SFxOperationBehaviorAttributeReleaseInstanceModeDoesNotApplyToCallback=The ReleaseInstanceMode property on OperationBehaviorAttribute can only be set on non-callback operations. Method '{0}' violates this.
SFxOperationContractOnNonServiceContract=Method '{0}' has OperationContractAttribute, but enclosing type '{1}' does not have ServiceContractAttribute. OperationContractAttribute can only be used on methods in ServiceContractAttribute types or on their CallbackContract types.
SFxOperationContractProviderOnNonServiceContract=Method '{1}' has {0}, but enclosing type '{2}' does not have ServiceContractAttribute. {0} can only be used on methods in ServiceContractAttribute types.
SFxOperationDescriptionNameCannotBeEmpty=OperationDescription's Name must be a non-empty string.
SFxParameterNameCannotBeNull=All parameter names used in operations that make up a service contract must not be null.
SFxOperationMustHaveOneOrTwoMessages=OperationDescription '{0}' is invalid because its Messages property contains an invalid number of MessageDescription instances. Each OperationDescription must have one or two messages.
SFxParameterCountMismatch=There was a mismatch between the number of supplied arguments and the number of expected arguments.  Specifically, the argument '{0}' has '{1}' elements while the argument '{2}' has '{3}' elements.
SFxParameterMustBeMessage=The 'parameters' argument must be an array that contains a single Message object.
SFxParametersMustBeEmpty=The 'parameters' argument must be either null or an empty array.
SFxParameterMustBeArrayOfOneElement=The 'parameters' argument must be an array of one element.
SFxPartNameMustBeUniqueInRpc=Message part name {0} is not unique in an RPC Message.
SFxReceiveContextSettingsPropertyMissing=The contract '{0}' has at least one operation annotated with '{1}', but the binding used for the contract endpoint at address '{2}' does not support required binding property '{3}'. Please ensure that the binding used for the contract supports the ReceiveContext capability.
SFxReceiveContextPropertyMissing=Required message property '{0}' is missing from the IncomingProperties collections of the received message. Ensure that when the receive context is enabled on the binding, the created channel ensures that '{0}' is present on all received messages.
SFxRequestHasInvalidReplyToOnClient=The request message has ReplyTo='{0}' but IContextChannel.LocalAddress is '{1}'.  When ManualAddressing is false, these values must be the same, null, or EndpointAddress.AnonymousAddress.  Enable ManualAddressing or avoid setting ReplyTo on the message.
SFxRequestHasInvalidFaultToOnClient=The request message has FaultTo='{0}' but IContextChannel.LocalAddress is '{1}'.  When ManualAddressing is false, these values must be the same, null, or EndpointAddress.AnonymousAddress.  Enable ManualAddressing or avoid setting FaultTo on the message.
SFxRequestHasInvalidFromOnClient=The request message has From='{0}' but IContextChannel.LocalAddress is '{1}'.  When ManualAddressing is false, these values must be the same, null, or EndpointAddress.AnonymousAddress.  Enable ManualAddressing or avoid setting From on the message.
SFxRequestHasInvalidReplyToOnServer=The request message has ReplyTo='{0}' but IContextChannel.RemoteAddress is '{1}'.  When ManualAddressing is false, these values must be the same, null, or EndpointAddress.AnonymousAddress because sending a reply to a different address than the original sender can create a security risk.  If you want to process such messages, enable ManualAddressing.
SFxRequestHasInvalidFaultToOnServer=The request message has FaultTo='{0}' but IContextChannel.RemoteAddress is '{1}'.  When ManualAddressing is false, these values must be the same, null, or EndpointAddress.AnonymousAddress because sending a reply to a different address than the original sender can create a security risk.  If you want to process such messages, enable ManualAddressing.
SFxRequestHasInvalidFromOnServer=The request message has From='{0}' but IContextChannel.RemoteAddress is '{1}'.  When ManualAddressing is false, these values must be the same, null, or EndpointAddress.AnonymousAddress because sending a reply to a different address than the original sender can create a security risk.  If you want to process such messages, enable ManualAddressing.
SFxRequestReplyNone=A message was received with a WS-Addressing ReplyTo or FaultTo header targeted at the "None" address.  These values are not valid for request-reply operations.  Please consider using a one-way operation or enabling ManualAddressing if you need to support ReplyTo or FaultTo values of "None."
SFxRequestTimedOut1=This request operation did not receive a reply within the configured timeout ({0}).  The time allotted to this operation may have been a portion of a longer timeout.  This may be because the service is still processing the operation or because the service was unable to send a reply message.  Please consider increasing the operation timeout (by casting the channel/proxy to IContextChannel and setting the OperationTimeout property) and ensure that the service is able to connect to the client.
SFxRequestTimedOut2=This request operation sent to {0} did not receive a reply within the configured timeout ({1}).  The time allotted to this operation may have been a portion of a longer timeout.  This may be because the service is still processing the operation or because the service was unable to send a reply message.  Please consider increasing the operation timeout (by casting the channel/proxy to IContextChannel and setting the OperationTimeout property) and ensure that the service is able to connect to the client.
SFxReplyActionMismatch3=A reply message was received for operation '{0}' with action '{1}'. However, your client code requires action '{2}'.
SFxRequiredRuntimePropertyMissing=Required runtime property '{0}' is not initialized on DispatchRuntime. Do not remove ServiceBehaviorAttribute from ServiceDescription.Behaviors or ensure that you include a third-party service behavior that supplies this value.
SFxResolvedMaxResolvedReferences=The MetadataExchangeClient has resolved more than MaximumResolvedReferences.
SFxResultMustBeMessage=The 'result' argument must be of type Message.
SFxRevertImpersonationFailed0=Could not revert impersonation on current thread. Continuing would compromise system security. Terminating process.
SFxRpcMessageBodyPartNameInvalid=RPC Message {1} in operation {0} has an invalid body name {2}. It must be {3}
SFxRpcMessageMustHaveASingleBody=RPC Message {1} in operation {0} must have a single MessageBodyMember.
SFxSchemaDoesNotContainElement=There was a problem loading the XSD documents provided: a reference to a schema element with name '{0}' and namespace '{1}' could not be resolved because the element definition could not be found in the schema for targetNamespace '{1}'. Please check the XSD documents provided and try again.
SFxSchemaDoesNotContainType=There was a problem loading the XSD documents provided: a reference to a schema type with name '{0}' and namespace '{1}' could not be resolved because the type definition could not be found in the schema for targetNamespace '{1}'. Please check the XSD documents provided and try again.
SFxWsdlMessageDoesNotContainPart3=Service description message '{1}' from target namespace '{2}' does not contain part named '{0}'.
SFxSchemaNotFound=Schema with target namespace '{0}' could not be found.
SFxSecurityContextPropertyMissingFromRequestMessage=SecurityContextProperty is missing from the request Message, this may indicate security is configured incorrectly.
SFxServerDidNotReply=The server did not provide a meaningful reply; this might be caused by a contract mismatch, a premature session shutdown or an internal server error.
SFxServiceHostBaseCannotAddEndpointAfterOpen=Endpoints cannot be added after the ServiceHost has been opened/faulted/aborted/closed.
SFxServiceHostBaseCannotAddEndpointWithoutDescription=Endpoints cannot be added before the Description property has been initialized.
SFxServiceHostBaseCannotApplyConfigurationWithoutDescription=ApplyConfiguration requires that the Description property be initialized. Either provide a valid ServiceDescription in the CreateDescription method or override the ApplyConfiguration method to provide an alternative implementation.
SFxServiceHostBaseCannotLoadConfigurationSectionWithoutDescription=LoadConfigurationSection requires that the Description property be initialized. Provide a valid ServiceDescription in the CreateDescription method.
SFxServiceHostBaseCannotInitializeRuntimeWithoutDescription=InitializeRuntime requires that the Description property be initialized. Either provide a valid ServiceDescription in the CreateDescription method or override the InitializeRuntime method to provide an alternative implementation.
SFxServiceHostCannotCreateDescriptionWithoutServiceType=InitializeDescription must be called with a serviceType or singletonInstance parameter.
SFxStaticMessageHeaderPropertiesNotAllowed=Header properties cannot be set in MessageHeaderAttribute of {0} as its type is MessageHeader<T>.
SFxStreamIOException=An exception has been thrown when reading the stream.
SFxStreamRequestMessageClosed=The message containing this stream has been closed. Note that request streams cannot be accessed after the service operation returns.
SFxStreamResponseMessageClosed=The message containing this stream has been closed. 
SFxTerminatingOperationAlreadyCalled1=This channel cannot send any more messages because IsTerminating operation '{0}' has already been called.
SFxThrottleLimitMustBeGreaterThanZero0=Throttle limit must be greater than zero. To disable, set to Int32.MaxValue.
SFxTimeoutInvalidStringFormat=The timeout value provided was not of a recognized format.  Please see InnerException for more details.
SFxTimeoutOutOfRange0=Timeout must be greater than or equal to TimeSpan.Zero. To disable timeout, specify TimeSpan.MaxValue.
SFxTimeoutOutOfRangeTooBig=Timeouts larger than Int32.MaxValue TotalMilliseconds (approximately 24 days) cannot be honored. To disable timeout, specify TimeSpan.MaxValue.
SFxTooManyPartsWithSameName=Cannot create a unique part name for {0}.
SFxTraceCodeElementIgnored=An unrecognized element was encountered in the XML during deserialization which was ignored.
SfxTransactedBindingNeeded=TransactedBatchingBehavior validation failed. The service endpoint cannot be started. TransactedBatchingBehavior requires a binding that contains a binding element ITransactedBindingElement that returns true for ITransactedBindingElement.TransactedReceiveEnabled. If you are using NetMsmqBinding or MsmqIntegrationBinding make sure that ExactlyOnce is set to true.
SFxTransactionNonConcurrentOrAutoComplete2=TThe operation '{1}' on contract '{0}' is configured with TransactionAutoComplete set to false and with ConcurrencyMode not set to Single. TransactionAutoComplete set to false requires ConcurrencyMode.Single.
SFxTransactionNonConcurrentOrReleaseServiceInstanceOnTxComplete=The '{0}' service is configured with ReleaseServiceInstanceOnTransactionComplete set to true, but the ConcurrencyMode is not set to Single. The ReleaseServiceInstanceOnTransactionComplete requires the use of ConcurrencyMode.Single.
SFxNonConcurrentOrEnsureOrderedDispatch=The '{0}' service is configured with EnsureOrderedDispatch set to true, but the ConcurrencyMode is not set to Single. EnsureOrderedDispatch requires the use of ConcurrencyMode.Single.
SfxDispatchRuntimeNonConcurrentOrEnsureOrderedDispatch=The DispatchRuntime.EnsureOrderedDispatch property is set to true, but the DispatchRuntime.ConcurrencyMode is not set to Single. EnsureOrderedDispatch requires the use of ConcurrencyMode.Single.
SFxTransactionsNotSupported=The service does not support concurrent transactions.
SFxTransactionAsyncAborted=The transaction under which this method call was executing was asynchronously aborted.
SFxTransactionInvalidSetTransactionComplete=The SetTransactionComplete method was called in the operation '{0}' on contract '{1}' when TransactionAutoComplete was set to true. The SetTransactionComplete method can only be called when TransactionAutoComplete is set to false. This is an invalid scenario and the current transaction was aborted.
SFxMultiSetTransactionComplete=The SetTransactionComplete method was wrongly called more than once in the operation '{0}' on contract '{1}'. The SetTransactionComplete method can only be called once. This is an invalid scenario and the current transaction was aborted.
SFxTransactionFlowAndMSMQ=The binding for the endpoint at address '{0}' is configured with both the MsmqTransportBindingElement and the TransactionFlowBindingElement. These two elements cannot be used together.
SFxTransactionAutoCompleteFalseAndInstanceContextMode=The operation '{1}' on contract '{0}' is configured with TransactionAutoComplete set to false and the InstanceContextMode is not set to PerSession. TransactionAutoComplete set to false requires the use of InstanceContextMode.PerSession.
SFxTransactionAutoCompleteFalseOnCallbackContract=The operation '{0}' on callback contract '{1}' is configured with TransactionAutoComplete set to false. TransactionAutoComplete set to false cannot be used with operations on callback contracts.
SFxTransactionAutoCompleteFalseAndSupportsSession=The operation '{1}' on contract '{0}' is configured with TransactionAutoComplete set to false but SessionMode is not set to Required. TransactionAutoComplete set to false requires SessionMode.Required.
SFxTransactionAutoCompleteOnSessionCloseNoSession=The service '{0}' is configured with TransactionAutoCompleteOnSessionClose set to true and with an InstanceContextMode not set to PerSession. TransactionAutoCompleteOnSessionClose set to true requires an instancing mode that uses sessions.
SFxTransactionTransactionTimeoutNeedsScope=The service '{0}' is configured with a TransactionTimeout but no operations are configured with TransactionScopeRequired set to true. TransactionTimeout requires at least one operation with TransactionScopeRequired set to true.
SFxTransactionIsolationLevelNeedsScope=The service '{0}' is configured with a TransactionIsolationLevel but no operations are configured with TransactionScopeRequired set to true. TransactionIsolationLevel requires at least one operation with TransactionScopeRequired set to true.
SFxTransactionReleaseServiceInstanceOnTransactionCompleteNeedsScope=The service '{0}' is configured with ReleaseServiceInstanceOnTransactionComplete but no operations are configured with TransactionScopeRequired set to true. The ReleaseServiceInstanceOnTransactionComplete property requires at least one operation with TransactionScopeRequired set to true. Remove the ReleaseServiceInstanceOnTransactionComplete property from the service if this is the case.
SFxTransactionTransactionAutoCompleteOnSessionCloseNeedsScope=The service '{0}' is configured with TransactionAutoCompleteOnSessionClose, but no operations are configured with TransactionScopeRequired set to true. The TransactionAutoCompleteOnSessionClose property requires at least one operation with TransactionScopeRequired set to true. Remove the TransactionAutoCompleteOnSessionClose property from the service if this is the case.
SFxTransactionFlowRequired=The service operation requires a transaction to be flowed.
SFxTransactionUnmarshalFailed=The flowed transaction could not be unmarshaled. The following exception occurred: {0}
SFxTransactionDeserializationFailed=The incoming transaction cannot be deserialized. The transaction header in the message was either malformed or in an unrecognized format. The client and the service must be configured to use the same protocol and protocol version. The following exception occurred: {0}
SFxTransactionHeaderNotUnderstood=The transaction header '{0}' within the namespace '{1}' was not understood by the service. The client and the service must be configured to use the same protocol and protocol version ('{2}').
SFxTryAddMultipleTransactionsOnMessage=An attempt was made to add more than one transaction to a message. At most one transaction can be added.
SFxTypedMessageCannotBeNull=Internal Error: The instance of the MessageContract cannot be null in {0}.
SFxTypedMessageCannotBeRpcLiteral=The operation '{0}' could not be loaded because it specifies "rpc-style" in "literal" mode, but uses message contract types or the System.ServiceModel.Channels.Message. This combination is disallowed -- specify a different value for style or use parameters other than message contract types or System.ServiceModel.Channels.Message.
SFxTypedOrUntypedMessageCannotBeMixedWithParameters=The operation '{0}' could not be loaded because it has a parameter or return type of type System.ServiceModel.Channels.Message or a type that has MessageContractAttribute and other parameters of different types. When using System.ServiceModel.Channels.Message or types with MessageContractAttribute, the method must not use any other types of parameters.
SFxTypedOrUntypedMessageCannotBeMixedWithVoidInRpc=When using the rpc-encoded style, message contract types or the System.ServiceModel.Channels.Message type cannot be used if the operation has no parameters or has a void return value. Add a blank message contract type as a parameter or return type to operation '{0}'.
SFxUnknownFaultNoMatchingTranslation1=This fault did not provide a matching translation: {0}
SFxUnknownFaultNullReason0=This fault did not provide a reason (MessageFault.Reason was null).
SFxUnknownFaultZeroReasons0=This fault did not provide a reason (MessageFault.Reason.Translations.Count was 0).
SFxUserCodeThrewException=User operation '{0}.{1}' threw an exception that is unhandled in user code. This exception will be rethrown. If this is a recurring problem, it may indicate an error in the implementation of the '{0}.{1}' method.
SfxUseTypedMessageForCustomAttributes=Parameter '{0}' requires additional schema information that cannot be captured using the parameter mode. The specific attribute is '{1}'.
SFxWellKnownNonSingleton0=In order to use one of the ServiceHost constructors that takes a service instance, the InstanceContextMode of the service must be set to InstanceContextMode.Single.  This can be configured via the ServiceBehaviorAttribute.  Otherwise, please consider using the ServiceHost constructors that take a Type argument.
SFxVersionMismatchInOperationContextAndMessage2=Cannot add outgoing headers to message as MessageVersion in OperationContext.Current '{0}' does not match with the header version of message being processed '{1}'.
SFxWhenMultipleEndpointsShareAListenUriTheyMustHaveSameIdentity=When multiple endpoints on a service share the same ListenUri, those endpoints must all have the same Identity in their EndpointAddress. The endpoints at ListenUri '{0}' do not meet this criteria.
SFxWrapperNameCannotBeEmpty=Wrapper element name cannot be empty.
SFxWrapperTypeHasMultipleNamespaces=Wrapper type for message {0} cannot be projected as a data contract type since it has multiple namespaces. Consider using the XmlSerializer
SFxWsdlPartMustHaveElementOrType=WSDL part {0} in message {1} from namespace {2} must have either an element or a type name
SFxDataContractSerializerDoesNotSupportBareArray=DataContractSerializer does not support collection specified on element '{0}' 
SFxDataContractSerializerDoesNotSupportEncoded=Invalid OperationFormatUse specified in the OperationFormatStyle of operation {0}, DataContractSerializer supports only Literal.
SFxXmlArrayNotAllowedForMultiple=XmlArrayAttribute cannot be used in repeating part {1}:{0}.
SFxConfigContractNotFound=Could not find default endpoint element that references contract '{0}' in the ServiceModel client configuration section. This might be because no configuration file was found for your application, or because no endpoint element matching this contract could be found in the client element.
SFxConfigChannelConfigurationNotFound=Could not find endpoint element with name '{0}' and contract '{1}' in the ServiceModel client configuration section. This might be because no configuration file was found for your application, or because no endpoint element matching this name could be found in the client element.
SFxChannelFactoryEndpointAddressUri=The Address property on ChannelFactory.Endpoint was null.  The ChannelFactory's Endpoint must have a valid Address specified.
SFxServiceContractGeneratorConfigRequired=In order to generate configuration information using the GenerateServiceEndpoint method, the ServiceContractGenerator instance must have been initialized with a valid Configuration object.
SFxCloseTimedOut1=The ServiceHost close operation timed out after {0}.  This could be because a client failed to close a sessionful channel within the required time.  The time allotted to this operation may have been a portion of a longer timeout.
SfxCloseTimedOutWaitingForDispatchToComplete=Close process timed out waiting for service dispatch to complete.
SFxInvalidWsdlBindingOpMismatch2=The WSDL binding named {0} is not valid because no match for operation {1} was found in the corresponding portType definition.
SFxInvalidWsdlBindingOpNoName=The WSDL binding named {0} is not valid because an operation binding doesn't have a name specified.
SFxChannelFactoryNoBindingFoundInConfig1=The underlying channel factory could not be created because no binding information was found in the configuration file for endpoint with name '{0}'.  Please check the endpoint configuration section with name '{0}' to ensure that binding information is present and correct.
SFxChannelFactoryNoBindingFoundInConfigOrCode=The underlying channel factory could not be created because no Binding was passed to the ChannelFactory. Please supply a valid Binding instance via the ChannelFactory constructor.
SFxConfigLoaderMultipleEndpointMatchesSpecified2=The endpoint configuration section for contract '{0}' with name '{1}' could not be loaded because more than one endpoint configuration with the same name and contract were found. Please check your config and try again.
SFxConfigLoaderMultipleEndpointMatchesWildcard1=An endpoint configuration section for contract '{0}' could not be loaded because more than one endpoint configuration for that contract was found. Please indicate the preferred endpoint configuration section by name.
SFxProxyRuntimeMessageCannotBeNull=In operation '{0}', cannot pass null to methods that take Message as input parameter.
SFxDispatchRuntimeMessageCannotBeNull=In operation '{0}', cannot return null from methods that return Message.
SFxServiceHostNeedsClass=ServiceHost only supports class service types.
SfxReflectedContractKeyNotFound2=The contract name '{0}' could not be found in the list of contracts implemented by the service '{1}'.
SfxReflectedContractKeyNotFoundEmpty=In order to add an endpoint to the service '{0}', a non-empty contract name must be specified.
SfxReflectedContractKeyNotFoundIMetadataExchange=The contract name 'IMetadataExchange' could not be found in the list of contracts implemented by the service {0}.  Add a ServiceMetadataBehavior to the configuration file or to the ServiceHost directly to enable support for this contract.
SfxServiceContractAttributeNotFound=The contract type {0} is not attributed with ServiceContractAttribute.  In order to define a valid contract, the specified type (either contract interface or service class) must be attributed with ServiceContractAttribute.
SfxReflectedContractsNotInitialized1=An endpoint for type '{0}' could not be added because the ServiceHost instance was not initialized properly.  In order to add endpoints by Type, the CreateDescription method must be called.  If you are using a class derived from ServiceHost, ensure that the class is properly calling base.CreateDescription.
SFxMessagePartDescriptionMissingType=Instance of MessagePartDescription Name='{0}' Namespace='{1}' cannot be used in this context: required 'Type' property was not set.
SFxWsdlOperationInputNeedsMessageAttribute2=The wsdl operation input {0} in portType {1} does not reference a message. This is either because the message attribute is missing or empty.
SFxWsdlOperationOutputNeedsMessageAttribute2=The wsdl operation output {0} in portType {1} does not reference a message. This is either because the message attribute is missing or empty.
SFxWsdlOperationFaultNeedsMessageAttribute2=The wsdl operation {0} in portType {1} contains a fault that does not reference a message. This is either because the message attribute is missing or empty.
SFxMessageContractAttributeRequired=Cannot create a typed message from type '{0}'.  The functionality only valid for types decorated with MessageContractAttribute.
AChannelServiceEndpointIsNull0=A Channel/Service Endpoint is null.
AChannelServiceEndpointSBindingIsNull0=A Channel/Service endpoint's Binding is null.
AChannelServiceEndpointSContractIsNull0=A Channel/Service endpoint's Contract is null.
AChannelServiceEndpointSContractSNameIsNull0=A Channel/Service endpoint's Contract's name is null or empty.
AChannelServiceEndpointSContractSNamespace0=A Channel/Service endpoint's Contract's namespace is null.
ServiceHasZeroAppEndpoints=Service '{0}' has zero application (non-infrastructure) endpoints. This might be because no configuration file was found for your application, or because no service element matching the service name could be found in the configuration file, or because no endpoints were defined in the service element.
BindingRequirementsAttributeRequiresQueuedDelivery1=DeliveryRequirementsAttribute requires QueuedDelivery, but binding for the endpoint with contract '{0}' doesn't support it or isn't configured properly to support it.
BindingRequirementsAttributeDisallowsQueuedDelivery1=DeliveryRequirementsAttribute disallows QueuedDelivery, but binding for the endpoint with contract '{0}' supports it.
SinceTheBindingForDoesnTSupportIBindingCapabilities1_1=The DeliveryRequirementsAttribute on contract '{0}' specifies that the binding must support ordered delivery (RequireOrderedDelivery).  This condition could not be verified because the configured binding does not implement IBindingDeliveryCapabilities.  The DeliveryRequirementsAttribute may only be used with bindings that implement the IBindingDeliveryCapabilities interface.
SinceTheBindingForDoesnTSupportIBindingCapabilities2_1=The DeliveryRequirementsAttribute on contract '{0}' specifies a QueuedDeliveryRequirements constraint.  This condition could not be verified because the configured binding does not implement IBindingDeliveryCapabilities.  The DeliveryRequirementsAttribute may only be used with bindings that implement the IBindingDeliveryCapabilities interface.
TheBindingForDoesnTSupportOrderedDelivery1=The DeliveryRequirementsAttribute on contract '{0}' specifies a QueuedDeliveryRequirements value of NotAllowed.  However, the configured binding for this contract specifies that it does support queued delivery.  A queued binding may not be used with this contract.
ChannelHasAtLeastOneOperationWithTransactionFlowEnabled=At least one operation on the '{0}' contract is configured with the TransactionFlowAttribute attribute set to Mandatory but the channel's binding '{1}' is not configured with a TransactionFlowBindingElement. The TransactionFlowAttribute attribute set to Mandatory cannot be used without a TransactionFlowBindingElement.
ServiceHasAtLeastOneOperationWithTransactionFlowEnabled=At least one operation on the '{0}' contract is configured with the TransactionFlowAttribute attribute set to Mandatory but the channel's binding '{1}' is not configured with a TransactionFlowBindingElement. The TransactionFlowAttribute attribute set to Mandatory cannot be used without a TransactionFlowBindingElement.
SFxNoEndpointMatchingContract=The message with Action '{0}' cannot be processed at the receiver, due to a ContractFilter mismatch at the EndpointDispatcher. This may be because of either a contract mismatch (mismatched Actions between sender and receiver) or a binding/security mismatch between the sender and the receiver.  Check that sender and receiver have the same contract and the same binding (including security requirements, e.g. Message, Transport, None).
SFxNoEndpointMatchingAddress=The message with To '{0}' cannot be processed at the receiver, due to an AddressFilter mismatch at the EndpointDispatcher.  Check that the sender and receiver's EndpointAddresses agree.
SFxNoEndpointMatchingAddressForConnectionOpeningMessage=The message with Action '{0}' cannot be processed at the receiver because this Action is reserved for the connection opening messages only and cannot be sent from client to server. To invoke this operation on the server, call the '{1}' method on the client proxy instead.
SFxServiceChannelCannotBeCalledBecauseIsSessionOpenNotificationEnabled=The operation '{0}' could not be invoked because the property '{1}' on the OperationContract is set to '{2}'. To invoke this operation on the server, call the '{3}' method on the client proxy instead.
EndMethodsCannotBeDecoratedWithOperationContractAttribute=When using the IAsyncResult design pattern, the End method cannot be decorated with OperationContractAttribute. Only the corresponding Begin method can be decorated with OperationContractAttribute; that attribute will apply to the Begin-End pair of methods. Method '{0}' in type '{1}' violates this.
WsatMessagingInitializationFailed=The WS-AT messaging library failed to initialize.
WsatProxyCreationFailed=A client-side channel to the WS-AT protocol service could not be created.
DispatchRuntimeRequiresFormatter0=The DispatchOperation '{0}' requires Formatter, since DeserializeRequest and SerializeReply are not both false.
ClientRuntimeRequiresFormatter0=The ClientOperation '{0}' requires Formatter, since SerializeRequest and DeserializeReply are not both false.
RuntimeRequiresInvoker0=DispatchOperation requires Invoker.
CouldnTCreateChannelForType2=Channel requirements cannot be met by the ChannelFactory for Binding '{0}' since the contract requires support for one of these channel types '{1}' but the binding doesn't support any of them.
CouldnTCreateChannelForChannelType2=Channel type '{1}' was requested, but Binding '{0}' doesn't support it or isn't configured properly to support it.
EndpointListenerRequirementsCannotBeMetBy3=ChannelDispatcher requirements cannot be met by the IChannelListener for Binding '{0}' since the contract requires support for one of these channel types '{1}' but the binding only supports these channel types '{2}'.
UnknownListenerType1=The listener at Uri '{0}' could not be initialized because it was created for an unrecognized channel type.
BindingDoesnTSupportSessionButContractRequires1=Contract requires Session, but Binding '{0}' doesn't support it or isn't configured properly to support it.
BindingDoesntSupportDatagramButContractRequires=Contract does not allow Session, but Binding '{0}' does not support Datagram or is not configured properly to support it.
BindingDoesnTSupportOneWayButContractRequires1=Contract requires OneWay, but Binding '{0}' doesn't support it or isn't configured properly to support it.
BindingDoesnTSupportTwoWayButContractRequires1=Contract requires TwoWay (either request-reply or duplex), but Binding '{0}' doesn't support it or isn't configured properly to support it.
BindingDoesnTSupportRequestReplyButContract1=Contract requires Request/Reply, but Binding '{0}' doesn't support it or isn't configured properly to support it.
BindingDoesnTSupportDuplexButContractRequires1=Contract requires Duplex, but Binding '{0}' doesn't support it or isn't configured properly to support it.
BindingDoesnTSupportAnyChannelTypes1=Binding '{0}' doesn't support creating any channel types. This often indicates that the BindingElements in a CustomBinding have been stacked incorrectly or in the wrong order. A Transport is required at the bottom of the stack. The recommended order for BindingElements is: TransactionFlow, ReliableSession, Security, CompositeDuplex, OneWay, StreamSecurity, MessageEncoding, Transport. 
ContractIsNotSelfConsistentItHasOneOrMore2=The contract '{0}' is not self-consistent -- it has one or more IsTerminating or non-IsInitiating operations, but it does not have the SessionMode property set to SessionMode.Required.  The IsInitiating and IsTerminating attributes can only be used in the context of a session.
ContractIsNotSelfConsistentWhenIsSessionOpenNotificationEnabled=The operation contract '{0}' is not self-consistent. When the '{1}' is set to '{2}', both '{3}' and '{4}' properties must be true, and the operation must not have any input parameters.
InstanceSettingsMustHaveTypeOrWellKnownObject0=The ServiceHost must be configured with either a serviceType or a serviceInstance.  Both of these values are currently null.
TheServiceMetadataExtensionInstanceCouldNot2_0=The ServiceMetadataExtension instance could not be added to the ServiceHost instance because it has already been added to another ServiceHost instance.
TheServiceMetadataExtensionInstanceCouldNot3_0=The ServiceMetadataExtension instance could not be removed from the ServiceHost instance because it has not been added to any ServiceHost instance.
TheServiceMetadataExtensionInstanceCouldNot4_0=The ServiceMetadataExtension instance could not be removed from the ServiceHost instance because it has already been added to a different ServiceHost instance.
SynchronizedCollectionWrongType1=A value of type '{0}' cannot be added to the generic collection, because the collection has been parameterized with a different type.
SynchronizedCollectionWrongTypeNull=A null value cannot be added to the generic collection, because the collection has been parameterized with a value type.
CannotAddTwoItemsWithTheSameKeyToSynchronizedKeyedCollection0=Cannot add two items with the same key to SynchronizedKeyedCollection.
ItemDoesNotExistInSynchronizedKeyedCollection0=Item does not exist in SynchronizedKeyedCollection.
SuppliedMessageIsNotAReplyItHasNoRelatesTo0=A reply message was received without a valid RelatesTo header.  This may have been caused by a missing RelatesTo header or a RelatesTo header with an invalid WS-Addressing Relationship type.
channelIsNotAvailable0=Internal Error: The InnerChannel property is null.
channelDoesNotHaveADuplexSession0=The current channel does not support closing the output session as this channel does not implement ISessionChannel<IDuplexSession>.
EndpointsMustHaveAValidBinding1=The ServiceEndpoint with name '{0}' could not be exported to WSDL because the Binding property is null. To fix this, set the Binding property to a valid Binding instance.
ABindingInstanceHasAlreadyBeenAssociatedTo1=A binding instance has already been associated to listen URI '{0}'. If two endpoints want to share the same ListenUri, they must also share the same binding object instance. The two conflicting endpoints were either specified in AddServiceEndpoint() calls, in a config file, or a combination of AddServiceEndpoint() and config. 
; ------------------------------------------------------------------------------------------------------------------------------
; Metadata Import/Export (WSDL, WS-Policy)
; ------------------------------------------------------------------------------------------------------------------------------
UnabletoImportPolicy=The following Policy Assertions were not Imported:\r\n
UnImportedAssertionList=   XPath:{0}\r\n  Assertions:
XPathUnavailable="XPath Unavailable"
DuplicatePolicyInWsdlSkipped=A policy expression was ignored because another policy expression with that ID has already been read in this document.\r\nXPath:{0}
DuplicatePolicyDocumentSkipped=A policy document was ignored because a policy expression with that ID has already been imported.\r\nPolicy ID:{0}
PolicyDocumentMustHaveIdentifier=A metadata section containing policy did not have an identifier so it cannot be referenced. 
XPathPointer=XPath:{0}
UnableToFindPolicyWithId=A policy reference was ignored because the policy with ID '{0}' could not be found.
PolicyReferenceInvalidId=A policy reference was ignored because the URI of the reference was empty.
PolicyReferenceMissingURI=A policy reference was ignored because the required {0} attribute was missing.
ExceededMaxPolicyComplexity=The policy expression was not fully imported because it exceeded the maximum allowable complexity. The import stopped at element '{0}' '{1}'.
ExceededMaxPolicySize=The policy expression was not fully imported because its normalized form was too large.
UnrecognizedPolicyElementInNamespace=Unrecognized policy element {0} in namespace {1}.
UnsupportedPolicyDocumentRoot="{0}" is not a supported WS-Policy document root element.
UnrecognizedPolicyDocumentNamespace=The "{0}" namespace is not a recognized WS-Policy namespace.
NoUsablePolicyAssertions=Cannot find usable policy alternatives.
PolicyInWsdlMustHaveFragmentId=Unreachable policy detected.\r\nA WS-Policy element embedded in WSDL is missing a fragment identifier. This policy cannot be referenced by any WS-PolicyAttachment mechanisms.\r\nXPath:{0}
FailedImportOfWsdl=The processing of the WSDL parameter failed. Error: {0}
OptionalWSDLExtensionIgnored=The optional WSDL extension element '{0}' from namespace '{1}' was not handled.\r\nXPath: {2}
RequiredWSDLExtensionIgnored=The required WSDL extension element '{0}' from namespace '{1}' was not handled.
UnknownWSDLExtensionIgnored=An unrecognized WSDL extension of Type '{0}' was not handled.
WsdlExporterIsFaulted=A previous call to this WsdlExporter left it in a faulted state. It is no longer usable.
WsdlImporterIsFaulted=A previous call to this WsdlImporter left it in a faulted state. It is no longer usable.
WsdlImporterContractMustBeInKnownContracts=The ContractDescription argument to ImportEndpoints must be contained in the KnownContracts collection.
WsdlItemAlreadyFaulted=A previous attempt to import this {0} already failed.
InvalidPolicyExtensionTypeInConfig=The type {0} registered as a policy extension does not implement IPolicyImportExtension
PolicyExtensionTypeRequiresDefaultConstructor=The type {0} registered as a policy extension does not have a public default constructor. Policy extensions must have a public default constructor
PolicyExtensionImportError=An exception was thrown in a call to a policy import extension.\r\nExtension: {0}\r\nError: {1}
PolicyExtensionExportError=An exception was thrown in a call to a policy export extension.\r\nExtension: {0}\r\nError: {1}
MultipleCallsToExportContractWithSameContract=Calling IWsdlExportExtension.ExportContract twice with the same ContractDescription is not supported.
DuplicateContractQNameNameOnExport=Duplicate contract XmlQualifiedNames are not supported.\r\nAnother ContractDescription with the Name: {0} and Namespace: {1} has already been exported.
WarnDuplicateBindingQNameNameOnExport=Similar ServiceEndpoints were exported. The WSDL export process was forced to suffix wsdl:binding names to avoid naming conflicts.\r\n Similar ServiceEndpoints means different binding instances having the Name: {0} and Namespace: {1} and either the same ContractDescription or at least the same contract Name: {2}.
WarnSkippingOpertationWithWildcardAction=An operation was skipped during export because it has a wildcard action. This is not supported in WSDL.\r\nContract Name:{0}\r\nContract Namespace:{1}\r\nOperation Name:{2}
WarnSkippingOpertationWithSessionOpenNotificationEnabled=An operation was skipped during export because the property '{0}' is set to '{1}'. This operation should be used for server only and should not be exposed from WSDL. \r\nContract Name:{2}\r\nContract Namespace:{3}\r\nOperation Name:{4}
InvalidWsdlExtensionTypeInConfig=The type {0} registered as a WSDL extension does not implement IWsdlImportExtension.
WsdlExtensionTypeRequiresDefaultConstructor=The type {0} registered as a WSDL extension does not have a public default constructor. WSDL extensions must have a public default constructor.
WsdlExtensionContractExportError=An exception was thrown in a call to a WSDL export extension: {0}\r\n contract: {1}
WsdlExtensionEndpointExportError=An exception was thrown in a call to a WSDL export extension: {0}\r\n Endpoint: {1}
WsdlExtensionBeforeImportError=A WSDL import extension threw an exception during the BeforeImport call: {0}\r\nError: {1}
WsdlExtensionImportError=An exception was thrown while running a WSDL import extension: {0}\r\nError: {1}
WsdlImportErrorMessageDetail=Cannot import {0}\r\nDetail: {2}\r\nXPath to Error Source: {1}
WsdlImportErrorDependencyDetail=There was an error importing a {0} that the {1} is dependent on.\r\nXPath to {0}: {2}
UnsupportedEnvelopeVersion=The {0} binding element requires envelope version '{1}' It doesn't support '{2}'.
NoValue0=No value.
UnsupportedBindingElementClone=The '{0}' binding element does not support cloning.
UnrecognizedBindingAssertions1=WsdlImporter encountered unrecognized policy assertions in ServiceDescription '{0}':

ServicesWithoutAServiceContractAttributeCan2=The {0} declared on method '{1}' in type '{2}' is invalid. {0}s are only valid on methods that are declared in a type that has ServiceContractAttribute. Either add ServiceContractAttribute to type '{2}' or remove {0} from method '{1}'.
tooManyAttributesOfTypeOn2=Too many attributes of type {0} on {1}.
couldnTFindRequiredAttributeOfTypeOn2=Couldn't find required attribute of type {0} on {1}.
AttemptedToGetContractTypeForButThatTypeIs1=Attempted to get contract type for {0}, but that type is not a ServiceContract, nor does it inherit a ServiceContract.
NoEndMethodFoundForAsyncBeginMethod3=OperationContract method '{0}' in type '{1}' does not properly implement the async pattern, as no corresponding method '{2}' could be found. Either provide a method called '{2}' or set the AsyncPattern property on method '{0}' to false.
MoreThanOneEndMethodFoundForAsyncBeginMethod3=OperationContract method '{0}' in type '{1}' does not properly implement the async pattern, as more than one corresponding method '{2}' was found. When using the async pattern, exactly one end method must be provided. Either remove or rename one or more of the '{2}' methods such that there is just one, or set the AsyncPattern property on method '{0}' to false.
InvalidAsyncEndMethodSignatureForMethod2=Invalid async End method signature for method {0} in ServiceContract type {1}. Your end method must take an IAsyncResult as the last argument.
InvalidAsyncBeginMethodSignatureForMethod2=Invalid async Begin method signature for method {0} in ServiceContract type {1}. Your begin method must take an AsyncCallback and an object as the last two arguments and return an IAsyncResult.
InAContractInheritanceHierarchyIfParentHasCallbackChildMustToo=Because base ServiceContract '{0}' has a CallbackContract '{1}', derived ServiceContract '{2}' must also specify either '{1}' or a derived type as its CallbackContract.
InAContractInheritanceHierarchyTheServiceContract3_2=In a contract inheritance hierarchy, the ServiceContract's CallbackContract must be a subtype of the CallbackContracts of all of the CallbackContracts of the ServiceContracts inherited by the original ServiceContract, Types {0} and {1} violate this rule.
CannotHaveTwoOperationsWithTheSameName3=Cannot have two operations in the same contract with the same name, methods {0} and {1} in type {2} violate this rule. You can change the name of one of the operations by changing the method name or by using the Name property of OperationContractAttribute.
CannotHaveTwoOperationsWithTheSameElement5=The {0}.{1} operation references a message element [{2}] that has already been exported from the {3}.{4} operation. You can change the name of one of the operations by changing the method name or using the Name property of OperationContractAttribute. Alternatively, you can control the element name in greater detail using the MessageContract programming model.
CannotInheritTwoOperationsWithTheSameName3=Cannot inherit two different operations with the same name, operation '{0}' from contracts '{1}' and '{2}' violate this rule. You can change the name of one of the operations by changing the method name or by using the Name property of OperationContractAttribute.
SyncAsyncMatchConsistency_Parameters5=The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must define the same number and types of parameters. In this case, some of the arguments are different. To fix it, ensure that the OperationContracts define the same number and types of arguments, in the same order. Alternatively, changing the name of one of the methods will prevent matching. 
SyncTaskMatchConsistency_Parameters5=The synchronous OperationContract method '{0}' in type '{1}' was matched with the task-based asynchronous OperationContract method '{2}' because they have the same operation name '{3}'. When a synchronous OperationContract method is matched to a task-based asynchronous OperationContract method, the two OperationContracts must define the same number and types of parameters. In this case, some of the arguments are different. To fix it, ensure that the OperationContracts define the same number and types of arguments, in the same order. Alternatively, changing the name of one of the methods will prevent matching. 
TaskAsyncMatchConsistency_Parameters5=The task-based asynchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a task-based asynchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must define the same number and types of parameters. In this case, some of the arguments are different. To fix it, ensure that the OperationContracts define the same number and types of arguments, in the same order. Alternatively, changing the name of one of the methods will prevent matching.
SyncAsyncMatchConsistency_ReturnType5=The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must define the same return type. In this case, the return types are different. To fix it, ensure that method '{0}' and method '{3}' have the same return type. Alternatively, changing the name of one of the methods will prevent matching. 
SyncTaskMatchConsistency_ReturnType5=The synchronous OperationContract method '{0}' in type '{1}' was matched with the task-based asynchronous OperationContract method '{2}' because they have the same operation name '{3}'. When a synchronous OperationContract method is matched to a task-based asynchronous OperationContract method, the two OperationContracts must define the same return type. In this case, the return types are different. To fix it, ensure that method '{0}' and method '{2}' have the same return type. Alternatively, changing the name of one of the methods will prevent matching. 
TaskAsyncMatchConsistency_ReturnType5=The task-based asynchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must define the same return type. In this case, the return types are different. To fix it, ensure that method '{0}' and method '{3}' have the same return type. Alternatively, changing the name of one of the methods will prevent matching. 
SyncAsyncMatchConsistency_Attributes6=The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, any additional attributes must be declared on the synchronous OperationContract method. In this case, the asynchronous OperationContract method '{2}' has one or more attributes of type '{5}'. To fix it, remove the '{5}' attribute or attributes from method '{2}'. Alternatively, changing the name of one of the methods will prevent matching. 
SyncTaskMatchConsistency_Attributes6=The synchronous OperationContract method '{0}' in type '{1}' was matched with the task-based asynchronous OperationContract method '{2}' because they have the same operation name '{3}'. When a synchronous OperationContract method is matched to a task-based asynchronous OperationContract method, any additional attributes must be declared on the synchronous OperationContract method. In this case, the task-based asynchronous OperationContract method '{2}' has one or more attributes of type '{4}'. To fix it, remove the '{4}' attribute or attributes from method '{2}'. Alternatively, changing the name of one of the methods will prevent matching. 
TaskAsyncMatchConsistency_Attributes6=The task-based asynchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract methods '{2}' and '{3}' because they have the same operation name '{4}'. When a task-based asynchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, any additional attributes must be declared on the task-based asynchronous OperationContract method. In this case, the asynchronous OperationContract method '{2}' has one or more attributes of type '{5}'. To fix it, remove the '{5}' attribute or attributes from method '{2}'. Alternatively, changing the name of one of the methods will prevent matching. 
SyncAsyncMatchConsistency_Property6=The synchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract  methods '{2}' and '{3}' because they have the same operation name '{4}'. When a synchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must have the same value for the '{5}' property. In this case, the values are different. To fix it, change the '{5} property of one of the OperationContracts to match the other. Alternatively, changing the name of one of the methods will prevent matching. 
SyncTaskMatchConsistency_Property6=The synchronous OperationContract method '{0}' in type '{1}' was matched with the task-based asynchronous OperationContract  method '{2}' because they have the same operation name '{3}'. When a synchronous OperationContract method is matched to a task-based asynchronous OperationContract method, the two OperationContracts must have the same value for the '{4}' property. In this case, the values are different. To fix it, change the '{4} property of one of the OperationContracts to match the other. Alternatively, changing the name of one of the methods will prevent matching. 
TaskAsyncMatchConsistency_Property6=The task-based asynchronous OperationContract method '{0}' in type '{1}' was matched with the asynchronous OperationContract  methods '{2}' and '{3}' because they have the same operation name '{4}'. When a task-based asynchronous OperationContract method is matched to a pair of asynchronous OperationContract methods, the two OperationContracts must have the same value for the '{5}' property. In this case, the values are different. To fix it, change the '{5} property of one of the OperationContracts to match the other. Alternatively, changing the name of one of the methods will prevent matching. 
ServiceOperationsMarkedWithIsOneWayTrueMust0=Operations marked with IsOneWay=true must not declare output parameters, by-reference parameters or return values.
OneWayOperationShouldNotSpecifyAReplyAction1=One way operation {0} cannot not specify a reply action.
OneWayAndFaultsIncompatible2=The method '{1}' in type '{0}' is marked IsOneWay=true and declares one or more FaultContractAttributes. One-way methods cannot declare FaultContractAttributes. To fix it, change IsOneWay to false or remove the FaultContractAttributes.
OnlyMalformedMessagesAreSupported=Only malformed Messages are supported.
UnableToLocateOperation2=Cannot locate operation {0} in Contract {1}.
UnsupportedWSDLOnlyOneMessage=Unsupported WSDL, only one message part is supported for fault messages. This fault message references zero or more than one message part. If you have edit access to the WSDL file, you can fix the problem by removing the extra message parts such that fault message references just one part.
UnsupportedWSDLTheFault=Unsupported WSDL, the fault message part must reference an element. This fault message does not reference an element. If you have edit access to the WSDL document, you can fix the problem by referencing a schema element using the 'element' attribute.
AsyncEndCalledOnWrongChannel=Async End called on wrong channel.
AsyncEndCalledWithAnIAsyncResult=Async End called with an IAsyncResult from a different Begin method.
IsolationLevelMismatch2=The received transaction has an isolation level of '{0}' but the service is configured with a TransactionIsolationLevel of '{1}'. The isolation level for received transactions and the service must be the same.
MessageHeaderIsNull0=The value of the addressHeaders argument is invalid because the collection contains null values. Null is not a valid value for the AddressHeaderCollection.
MessagePropertiesArraySize0=The array passed does not have enough space to hold all the properties contained by this collection.
DuplicateBehavior1=The value could not be added to the collection, as the collection already contains an item of the same type: '{0}'. This collection only supports one instance of each type.
CantCreateChannelWithManualAddressing=Cannot create channel for a contract that requires request/reply and a binding that requires manual addressing but only supports duplex communication.
XsdMissingRequiredAttribute1=Missing required '{0}' attribute.
IgnoreSoapHeaderBinding3=Ignoring invalid SOAP header extension in wsdl:operation name='{0}' from targetNamespace='{1}'. Reason: {2}
IgnoreSoapFaultBinding3=Ignoring invalid SOAP fault extension in wsdl:operation name='{0}' from targetNamespace='{1}'. Reason: {2}
IgnoreMessagePart3=Ignoring invalid part in wsdl:message name='{0}' from targetNamespace='{1}'. Reason: {2}
CannotImportPrivacyNoticeElementWithoutVersionAttribute=PrivacyNotice element must have a Version attribute.
PrivacyNoticeElementVersionAttributeInvalid=PrivacyNotice element Version attribute must have an integer value.

; ------------------------------------------------------------------------------------------------------------------------------
; Queues
; ------------------------------------------------------------------------------------------------------------------------------
MsmqActiveDirectoryRequiresNativeTransfer=Binding validation failed. The client cannot send messages. A conflict in the binding properties caused this failure. The UseActiveDirectory is set to true and QueueTransferProtocol is set to Native. To resolve the conflict, correct one of the properties.
MsmqAdvancedPoisonHandlingRequired=Binding validation failed because the binding's ReceiveErrorHandlig property is set to Move or Reject while the version of MSMQ installed on this system is not 4.0 or higher. The channel listener cannot be opened. Resolve the conflict by setting the ReceiveErrorHandling property to Drop or Fault, or by upgrading to MSMQ v4.0.
MsmqAmbientTransactionInactive=The Ambient transaction used to Complete the ReceiveContext Operation is not in an active state. 
MsmqAuthCertificateRequiresProtectionSign=Binding validation failed because the binding's MsmqAuthenticationMode property is set to Certificate while the MsmqProtectionLevel property is not set to Sign or EncryptAndSign. The channel factory or service host cannot be opened. Resolve the conflict by correcting one of the properties.
MsmqAuthNoneRequiresProtectionNone=Binding validation failed. The service or the client cannot be started. A conflict in the binding properties caused this failure. The MsmqAuthenticationMode is set to None and MsmqProtectionLevel is not set to None. To resolve to conflict, correct one of the properties.
MsmqAuthWindowsRequiresProtectionNotNone=Binding validation failed because the binding's MsmqAuthenticationMode property is set to WindowsDomain while the MsmqProtectionLevel property is not set to Sign or EncryptAndSign. The channel factory or service host cannot be opened. Resolve the conflict by correcting one of the properties.
MsmqBadCertificate=Creation of a message security context failed because the attached sender certificate was invalid or cannot be validated. The message cannot be received. Ensure that a valid certificate is attached to the message and that the certificate is present in the receiver's certificate store.
MsmqBadContentType=The content type of an incoming message is unknown or not supported. The message cannot be received. Ensure that the sender was configured to use the same message encoder as the receiver.
MsmqBadFrame=An incoming MSMQ message contained invalid or unexpected .NET Message Framing information in its body. The message cannot be received. Ensure that the sender is using a compatible service contract with a matching SessionMode.
MsmqBadXml=An XML error was encountered while reading a WCF message. The message cannot be received. Ensure the message was sent by a WCF client which used an identical message encoder.
MsmqBatchRequiresTransactionScope=TransactedBatchingBehavior validation failed because none of the service operations had the TransactionScopeRequired property set to true on their OperationBehavior attribute. The service host cannot be started. Ensure this requirement is met if you wish to use this behavior.
MsmqByteArrayBodyExpected=A mismatch was detected between the serialization format specified in the MsmqIntegrationMessageProperty and the body of the MSMQ message. The message cannot be sent. The serialization format ByteArray requires the body of the MSMQ message to be of type byte[].
MsmqCannotDeserializeActiveXMessage=An error occurred while deserializing an MSMQ message's ActiveX body. The message cannot be received. The specified variant type for the body does not match the actual MSMQ message body.
MsmqCannotDeserializeXmlMessage=An error occurred while deserializing an MSMQ message's XML body. The message cannot be received. Ensure that the service contract is decorated with appropriate [ServiceKnownType] attributes or the TargetSerializationTypes property is set on the MsmqIntegrationBindingElement.
MsmqCannotUseBodyTypeWithActiveXSerialization=The properties of the message are mismatched. The message cannot be sent. The BodyType message property cannot be specified if the ActiveX serialization format is used.
MsmqCertificateNotFound=The sender's X.509 certificate was not found. The message cannot be sent. Ensure the certificate is available in the sender's certificate store.
MsmqCustomRequiresPerAppDLQ=Binding validation failed. The client cannot send the message. The DeadLetterQueue is set to Custom, but the CustomDeadLetterQueue is not specified. Specify the URI of the dead letter queue for each application in the CustomDeadLetterQueue property.
MsmqDeserializationError=An error was encountered while deserializing the message. The message cannot be received.
MsmqDirectFormatNameRequiredForPoison=Binding validation failed because the endpoint listen URI does not represent an MSMQ direct format name. The service host cannot be opened. Make sure you use a direct format name for the endpoint's listen URI.
MsmqDLQNotLocal=The host in the CustomDeadLetterQueue URI is not "localhost" or the local machine name. A custom DLQ must reside on the sender's machine.
MsmqDLQNotWriteable=Binding validation failed. The client cannot send a message. The specified dead letter queue does not exist or cannot be written. Ensure the queue exists with the proper authorization to write to it.
MsmqEncryptRequiresUseAD=Binding validation failed because the binding's MsmqProtectionLevel property is set to EncryptAndSign while the UseActiveDirectory is not set to true. The channel factory or the service host cannot be opened. Resolve the conflict by correcting one of the properties.
MsmqExactlyOnceNeededForReceiveContext=Binding validation failed. The service or the client cannot be started. The ExactlyOnce property is set to false and ReceiveContext is enabled. This is not supported. To resolve the conflict, either set ExactlyOnce to true or disable ReceiveContext.
MsmqGetPrivateComputerInformationError=The version check failed with the error: '{0}'. The version of MSMQ cannot be detected All operations that are on the queued channel will fail. Ensure that MSMQ is installed and is available.
MsmqInvalidMessageId=The message ID '{0}' is not in the right format.
MsmqInvalidScheme=The specified addressing scheme is invalid for this binding. The NetMsmqBinding scheme must be net.msmq. The MsmqIntegrationBinding scheme must be msmq.formatname.
MsmqInvalidServiceOperationForMsmqIntegrationBinding=The MsmqIntegrationBinding validation failed. The service cannot be started. The {0} binding does not support the method signature for the service operation {1} in the {2} contract. Correct the service operation to use the MsmqIntegrationBinding.
MsmqInvalidTypeDeserialization=The ActiveX serialization failed because the serialization format cannot be recognized. The message cannot be received.
MsmqInvalidTypeSerialization=The variant type is not recognized. The ActiveX serialization failed. The message cannot be sent. The specified variant type is not supported.
MsmqKnownWin32Error={0} ({1}, 0x{2})
MsmqMessageDoesntHaveIntegrationProperty=The message cannot be sent because it's missing an MsmqIntegrationMessageProperty. All messages sent over MSMQ integration channels must carry the MsmqIntegrationMessageProperty.
MsmqNoAssurancesForVolatile=Binding validation failed. The service or the client cannot be started. The ExactlyOnce property is set to true and the Durable property is set to false. This is not supported. To resolve the conflict, correct one of these properties.
MsmqNonNegativeArgumentExpected=Argument must be a positive number or zero.
MsmqNonTransactionalQueueNeeded=A mismatch between the binding and MSMQ queue configuration was detected. The service cannot be started. The ExactlyOnce property is set to false and the queue to read messages from is a transactional queue, Correct the error by setting the ExactlyOnce property to true or create a non-transactional binding.
MsmqNoMoveForSubqueues=Binding validation failed because the URI represents a subqueue and the ReceiveErrorHandling parameter is set to Move. The service host or channel listener cannot be opened. Resolve this conflict by setting the ReceiveErrorHandling to Fault, Drop or Reject.
MsmqNoSid=Creation of a message security context failed because the sender's SID was not found in the message. The message cannot be received. The WindowsDomain MsmqAuthenticationMode requires the sender's SID.
MsmqOpenError=An error occurred while opening the queue:{0}. The  message cannot be sent or received from the queue. Ensure that MSMQ is installed and running. Also ensure that the queue is available to open with the required access mode and authorization.
MsmqPathLookupError=An error occurred when converting the '{0}' queue path name to the format name: {1}. All operations on the queued channel failed. Ensure that the queue address is valid. MSMQ must be installed with Active Directory integration enabled and access to it is available.
MsmqPerAppDLQRequiresCustom=Binding validation failed. The client cannot send messages. The CustomDeadLetterQueue property is set, but the DeadLetterQueue property is not set to Custom. Set the DeadLetterQueue property to Custom.
MsmqPerAppDLQRequiresExactlyOnce=Binding validation failed. The client cannot send messages. A conflict in the binding properties is causing the failure. To use the custom dead letter queue, ExactlyOnce must be set to true to resolve to conflict.
MsmqPerAppDLQRequiresMsmq4=A mismatch between the binding and MSMQ configuration was detected. The client cannot send messages. To use the custom dead letter queue, you must have MSMQ version 4.0 or higher. If you do not have MSMQ version 4.0 or higher set the DeadLetterQueue property to System or None. 
MsmqPoisonMessage=The transport channel detected a poison message. This occurred because the message exceeded the maximum number of delivery attempts or because the channel detected a fundamental problem with the message. The inner exception may contain additional information.
MsmqQueueNotReadable=There was an error opening the queue. Ensure that MSMQ is installed and running, the queue exists and has proper authorization to be read from. The inner exception may contain additional information.
MsmqReceiveContextMessageNotReceived=The ReceiveContext delete operation failed because the message with Id '{0}' could not be received from the lock subqueue. 
MsmqReceiveContextMessageNotMoved=The ReceiveContext unlock operation failed because the message with Id '{0}' could not be moved from the lock subqueue to the main queue.
MsmqReceiveContextSubqueuesNotSupported=The queue could not be opened because the ReceiveContext feature is not supported on subqueues. Specify a different queue to receive from, or disable ReceiveContext.
MsmqReceiveError=An error occurred while receiving a message from the queue: {0}. Ensure that MSMQ is installed and running. Make sure the queue is available to receive from.
MsmqSameTransactionExpected=A transaction error occurred for this session. The session channel is faulted. Messages in the session cannot be sent or received. A queued session cannot be associated with more than one transaction. Ensure that all messages in the session are sent or received using a single transaction.
MsmqSendError=An error occurred while sending to the queue: {0}.Ensure that MSMQ is installed and running. If you are sending to a local queue, ensure the queue exists with the required access mode and authorization.
MsmqSerializationTableFull=A serialization error occurred. The message cannot be sent or received. The MSMQ integration channel is able to serialize no more than {0} types.
MsmqSessionChannelAbort=The transaction associated with this session channel has been rolled back because Abort was called on the session channel before the transaction committed. 
MsmqSessionChannelHasPendingItems=Session channels must not have pending messages when the transactions associated with these channels are committed. Pending messages are either messages that have not been received from the session channel or messages that have been received but Complete has not been called for them. The channel has faulted and the transaction was rolled back.
MsmqSessionChannelsMustBeClosed=Session channels must be closed before the transaction is committed. The channel has faulted and the transaction was rolled back.
MsmqSessionGramSizeMustBeInIntegerRange=The total size of messages sent in this session exceeded the maximum value of Int32. The messages in this session cannot be sent.
MsmqSessionMessagesNotConsumed=An attempt made to close the session channel while there are still messages pending in the session. Current transaction will be rolled back and the session channel will be faulted. Messages in a session must be consumed all at once.
MsmqSessionPrematureClose=An attempt was made to close the session channel while there are still messages pending in the session. The sessiongram will be rolled back to the queue and the session channel will be faulted. 
MsmqStreamBodyExpected=A serialization error occurred because of a mismatch between the value of the SerializationFormat property and the type of the body. The message cannot be sent. Ensure the type of the body is Stream or use a different SerializationFormat.
MsmqTimeSpanTooLarge=The message time to live (TTL) is too large. The message cannot be sent. The message TTL cannot exceed the Int32 maximum value.
MsmqTokenProviderNeededForCertificates=A client X.509 certificate was not specified through the channel factory's Credentials property, but one is required when the binding's MsmqAuthenticationMode property is set to Certificate. The message cannot be sent.
MsmqTransactionNotActive=The current transaction is not active. Messages in this session cannot be sent or received and the session channel will be faulted. All messages in a session must be sent or received using a single transaction.
MsmqTransactionalQueueNeeded=Binding validation failed because the binding's ExactlyOnce property is set to true while the destination queue is non-transactional. The service host cannot be opened. Resolve this conflict by setting the ExactlyOnce property to false or creating a transactional queue for this binding.
MsmqTransactionCurrentRequired=A transaction was not found in Transaction.Current but one is required for this operation. The channel cannot be opened. Ensure this operation is being called within a transaction scope.
MsmqTransactionRequired=A transaction is required but is not available. Messages cannot be sent or received. Ensure that the transaction scope is specified to send or receive messages.
MsmqTransactedDLQExpected=A mismatch occurred between the binding and the MSMQ configuration. Messages cannot be sent. The custom dead letter queue specified in the binding must be a transactional queue. Ensure that the  custom dead letter queue address is correct and the queue is a transactional queue.
MsmqUnexpectedPort=The net.msmq scheme does not support port numbers. To correct this, remove the port number from the URI.
MsmqUnknownWin32Error=Unrecognized error {0} (0x{1})
MsmqUnsupportedSerializationFormat=The serialization failed because the serialization format '{0}' is not supported. The message cannot be sent or received.
MsmqWindowsAuthnRequiresAD=Binding validation failed because the binding's MsmqAuthenticationMode property is set to WindowsDomain but MSMQ is installed with Active Directory integration disabled. The channel factory or service host cannot be opened.
MsmqWrongPrivateQueueSyntax=The URL in invalid. The URL for the queue cannot contain the '$' character. Use the syntax in net.msmq://machine/private/queueName to address a private queue.
MsmqWrongUri=The URI is invalid because it is missing a host.
MsmqCannotReacquireLock=Failed to reacquire lock for message. 

; XD Gen
XDCannotFindValueInDictionaryString=Cannot find '{0}' value in dictionary string.
; ------------------------------------------------------------------------------------------------------------------------------
WmiGetObject=WMI GetObject Query: {0}
WmiPutInstance=WMI PutInstance Class: {0}
;
; 

ObjectMustBeOpenedToDequeue=Cannot dequeue a '{0}' object while in the Created state.
NoChannelBuilderAvailable=The binding (Name={0}, Namespace={1}) cannot be used to create a ChannelFactory or a ChannelListener because it appears to be missing a TransportBindingElement.  Every binding must have at least one binding element that derives from TransportBindingElement.
InvalidBindingScheme=The TransportBindingElement of type '{0}' in this CustomBinding returned a null or empty string for the Scheme. TransportBindingElement's Scheme must be a non-empty string.
CustomBindingRequiresTransport=Binding '{0}' lacks a TransportBindingElement.  Every binding must have a binding element that derives from TransportBindingElement. This binding element must appear last in the BindingElementCollection.
TransportBindingElementMustBeLast=In Binding '{0}', TransportBindingElement '{1}' does not appear last in the BindingElementCollection.  Please change the order of elements such that the TransportBindingElement is last.
MessageVersionMissingFromBinding=None of the binding elements in binding '{0}' define a message version. At least one binding element must define a message version and return it from the GetProperty<MessageVersion> method.
NotAllBindingElementsBuilt=Some of the binding elements in this binding were not used when building the ChannelFactory / ChannelListener.  This may be have been caused by the binding elements being misordered.  The recommended order for binding elements is: TransactionFlow, ReliableSession, Security, CompositeDuplex, OneWay, StreamSecurity, MessageEncoding, Transport.  Note that the TransportBindingElement must be last.  The following binding elements were not built: {0}.
MultipleMebesInParameters=More than one MessageEncodingBindingElement was found in the BindingParameters of the BindingContext.  This usually is caused by having multiple MessageEncodingBindingElements in a CustomBinding. Remove all but one of these elements.
MultipleStreamUpgradeProvidersInParameters=More than one IStreamUpgradeProviderElement was found in the BindingParameters of the BindingContext.  This usually is caused by having multiple IStreamUpgradeProviderElements in a CustomBinding. Remove all but one of these elements.
MultiplePeerResolverBindingElementsinParameters=More than one PeerResolverBindingElement was found in the BindingParameters of the BindingContext.  This usually is caused by having multiple PeerResolverBindingElements in a CustomBinding. Remove all but one of these elements.
MultiplePeerCustomResolverBindingElementsInParameters=More than one PeerCustomResolverBindingElement was found in the BindingParameters of the BindingContext.  This usually is caused by having multiple PeerCustomResolverBindingElement in a CustomBinding. Remove all but one of these elements.
SecurityCapabilitiesMismatched=The security capabilities of binding '{0}' do not match those of the generated runtime object. Most likely this means the binding contains a StreamSecurityBindingElement, but lacks a TransportBindingElement that supports Stream Security (such as TCP or Named Pipes). Either remove the unused StreamSecurityBindingElement or use a transport that supports this element.
BaseAddressMustBeAbsolute=Only an absolute Uri can be used as a base address.
BaseAddressDuplicateScheme=This collection already contains an address with scheme {0}.  There can be at most one address per scheme in this collection. If your service is being hosted in IIS you can fix the problem by setting 'system.serviceModel/serviceHostingEnvironment/multipleSiteBindingsEnabled' to true or specifying 'system.serviceModel/serviceHostingEnvironment/baseAddressPrefixFilters'.
BaseAddressCannotHaveUserInfo=A base address cannot contain a Uri user info section.
TransportBindingElementNotFound=The binding does not contain a TransportBindingElement.
ChannelDemuxerBindingElementNotFound=The binding does not contain a ChannelDemuxerBindingElement.
BaseAddressCannotHaveQuery=A base address cannot contain a Uri query string.
BaseAddressCannotHaveFragment=A base address cannot contain a Uri fragment.
UriMustBeAbsolute=The given URI must be absolute.
; 
; Configuration strings
;
BindingProtocolMappingNotDefined=The binding for scheme '{0}' specified in the protocol mapping does not exist and must be created.
ConfigBindingCannotBeConfigured=The binding on the service endpoint cannot be configured.
ConfigBindingExtensionNotFound=Configuration binding extension '{0}' could not be found. Verify that this binding extension is properly registered in system.serviceModel/extensions/bindingExtensions and that it is spelled correctly.
ConfigBindingReferenceCycleDetected=A binding reference cycle was detected in your configuration. The following reference cycle must be removed: {0}.
ConfigBindingTypeCannotBeNullOrEmpty=The binding specified cannot be null or an empty string.  Please specify a valid binding.  Valid binding values can be found in the system.serviceModel/extensions/bindingExtensions collection.
ConfigCannotParseXPathFilter=Cannot parse type '{0}' into a System.ServiceModel.Dispatcher.XPathMessageFilter.
ConfigEndpointExtensionNotFound=Configuration endpoint extension '{0}' could not be found. Verify that this endpoint extension is properly registered in system.serviceModel/extensions/endpointExtensions and that it is spelled correctly.
ConfigEndpointReferenceCycleDetected=An endpoint reference cycle was detected in your configuration. The following reference cycle must be removed: {0}.
ConfigEndpointTypeCannotBeNullOrEmpty=The endpoint specified cannot be null or an empty string.  Please specify a valid endpoint.  Valid endpoint values can be found in the system.serviceModel/extensions/endpointExtensions collection.
ConfigXPathFilterMustNotBeEmpty=Filter element body must not be empty.
ConfigDuplicateItem=An extension named {0} already appears in the {1}. Extension names must be unique.
ConfigDuplicateExtensionName= An extension of name '{0}' already appears in extension collection. Extension names must be unique.
ConfigDuplicateExtensionType=An extension of type '{0}' already appears in extension collection. Extension types must be unique.
ConfigDuplicateKey=A child element with the element name '{0}' already exists.  Child elements can only be added once.
ConfigDuplicateKeyAtSameScope=A child element named '{0}' with same key already exists at the same configuration scope. Collection elements must be unique within the same configuration scope (e.g. the same application.config file). Duplicate key value:  '{1}'.
ConfigElementKeyNull=The '{0}' configuration element key cannot be null.
ConfigElementKeysNull=At least one of the configuration element keys '{0}' must not be null.
ConfigElementTypeNotAllowed=Extension element '{0}' cannot be added to this element.  Verify that the extension is registered in the extension collection at system.serviceModel/extensions/{1}.
ConfigExtensionCollectionNotFound=Extension collection '{0}' not found.
ConfigExtensionTypeNotRegisteredInCollection=The extension of type '{0}' is not registered in the extension collection '{1}'.
ConfigInvalidServiceAuthenticationManagerType=Invalid value for serviceAuthenticationManagerType. The serviceAuthenticationManagerType '{0}' does not derive from '{1}'. 
ConfigInvalidAuthorizationPolicyType=Invalid value in policyType. The policyType '{0}' does not implement from '{1}'. 
ConfigInvalidBindingConfigurationName=The {1} binding does not have a configured binding named '{0}'.
ConfigInvalidBindingName=The binding at {1} does not have a configured binding named '{0}'. This is an invalid value for {2}.
ConfigInvalidCommonEndpointBehaviorType=Cannot add the behavior extension '{0}' to the common endpoint behavior because it does not implement '{1}'.
ConfigInvalidCommonServiceBehaviorType=Cannot add the behavior extension '{0}' to the common service behavior because it does not implement '{1}'.
ConfigInvalidCertificateValidatorType=Invalid value for the certificate validator type. The type '{0}' does not derive from the appropriate base class '{1}'.
ConfigInvalidClientCredentialsType=Invalid value for the client credentials type. The type '{0}' does not derive from the appropriate base class '{1}'.
ConfigInvalidClassFactoryValue=The value '{0}' is not a valid instance of type '{1}'.
ConfigInvalidClassInstanceValue=The instance is not a valid configurable value of type '{0}'.
ConfigInvalidEncodingValue={0} is not a valid encoding string for System.Text.Encoding.GetEncoding(string).
ConfigInvalidEndpointBehavior=There is no endpoint behavior named '{0}'.
ConfigInvalidEndpointBehaviorType=Cannot add the '{0}' behavior extension to '{1}' endpoint behavior because the underlying behavior type does not implement the IEndpointBehavior interface.
ConfigInvalidEndpointName=The endpoint at {1} does not have a configured endpoint named '{0}'. This is an invalid value for {2}.
ConfigInvalidAttribute=The attribute '{0}' cannot be specified on element '{1}' when attribute '{2}' is not specified.
ConfigNoEndpointCreated=The CreateServiceEndpoint method in type '{0}' returned null instead of an instance of type '{1}'.
ConfigInvalidExtensionElement=Invalid element in configuration. The extension '{0}' does not derive from correct extension base type '{1}'. 
ConfigInvalidExtensionElementName=Invalid element in configuration. The extension name '{0}' is not registered in the collection at system.serviceModel/extensions/{1}. 
ConfigInvalidExtensionType=The '{0}' type must derive from {1} to be used in the {2} collection.
ConfigInvalidKeyType=The element {0} requires a key of type '{1}'. Type of the key passed in: '{2}'.
ConfigInvalidReliableMessagingVersionValue='{0}' is not a valid reliable messaging version.  Valid values are 'WSReliableMessagingFebruary2005' and 'WSReliableMessaging11'.
ConfigInvalidSamlSerializerType=Invalid value for the saml serializer type. The type '{0}' does not derive from the appropriate base class: '{1}'.
ConfigInvalidSection=Invalid binding path.  There is no binding registered with the configuration path '{0}'.
ConfigInvalidServiceCredentialsType=Invalid value for the service credentials type. The type '{0}' does not derive from the appropriate base class '{1}'.
ConfigInvalidSecurityStateEncoderType=Invalid value for the  security state encoder type. The type '{0}' does not derive from the appropriate base class '{1}'.
ConfigInvalidUserNamePasswordValidatorType=Invalid value for the username password validator type. The type '{0}' does not derive from the appropriate base class '{1}'.
ConfigInvalidServiceAuthorizationManagerType=Invalid value for serviceAuthorizationManagerType. The serviceAuthorizationManagerType '{0}' does not derive from '{1}'. 
ConfigInvalidServiceBehavior=There is no service behavior named '{0}'.
ConfigInvalidServiceBehaviorType=Cannot add the behavior extension '{0}' to the service behavior named '{1}' because the underlying behavior type does not implement the IServiceBehavior interface.
ConfigInvalidStartValue=Start must be between 0 and {0}. Value passed in is {1}.
ConfigInvalidTransactionFlowProtocolValue='{0}' is not a valid transaction protocol.  Valid values are 'OleTransactions', 'WSAtomicTransactionOctober2004', and 'WSAtomicTransaction11'.
ConfigInvalidType=The type '{0}' registered for extension '{1}' could not be loaded.
ConfigInvalidTypeForBinding=Invalid binding type for binding extension configuration object.  This binding extension manages configuration of binding type '{0}' and cannot act upon type '{1}'.
ConfigInvalidTypeForBindingElement=Invalid binding element type for binding element extension configuration object.  This binding element extension manages configuration of binding element type '{0}' and cannot act upon type '{1}'.
ConfigInvalidTypeForEndpoint=Invalid endpoint type for endpoint extension configuration object.  This endpoint extension manages configuration of endpoint type '{0}' and cannot act upon type '{1}'.
ConfigKeyNotFoundInElementCollection=No elements matching the key '{0}' were found in the configuration element collection.
ConfigKeysDoNotMatch=The key does not match the indexer key. When setting the value of a specific index, the key of the desired value must match the index at which it is being set. Key on element (expected value): {0}. Key provided to indexer: {1}.
ConfigMessageEncodingAlreadyInBinding=Cannot add the message encoding element '{0}'. Another message encoding element already exists in the binding '{1}'. There can only be one message encoding element for each binding.
ConfigNoExtensionCollectionAssociatedWithType=Cannot find the extension collection associated with extension of type '{0}'.
ConfigNullIssuerAddress=Federated issuer address cannot be null when specifying an issuer binding.
ConfigReadOnly=The configuration is read only.
ConfigSectionNotFound=The '{0}' configuration section cannot be created. The machine.config file is missing information. Verify that this configuration section is properly registered and that you have correctly spelled the section name. For Windows Communication Foundation sections, run ServiceModelReg.exe -i to fix this error.
ConfigStreamUpgradeElementAlreadyInBinding=Cannot add stream upgrade element '{0}'. Another stream upgrade element already exists in the binding '{1}'. There can only be one stream update element per binding.
ConfigTransportAlreadyInBinding=Cannot add the transport element '{0}'. Another transport element already exists in the binding '{1}'. There can only be one transport element for each binding.
ConfigXmlElementMustBeSet=The XmlElement must contain XML content.
ConfigXPathFilterIsNull=The XPathFilter for an XPathFilterElement cannot be null.
ConfigXPathNamespacePrefixNotFound=Namespace prefix '{0}' referenced in XPath expression was not found.
Default=(Default)

;
; Administration Strings
;
AdminMTAWorkerThreadException=MTAWorkerThread exception
;
; WSTransfer/WSEnumeration strings
;
InternalError=An unexpected error has occurred.
;
; COM+ Integration strings
;
ClsidNotInApplication=The CLSID specified in the service file is not configured in the specified application. (The CLSID is {0}, the AppID is {1}.)
ClsidNotInConfiguration=The CLSID specified in the service file does not have a service element in a configuration file. (The CLSID is {0}.)
EndpointNotAnIID=An endpoint configured for the COM+ CLSID {0} is not a configured interface on the class. (The contract type is {1}.)
ServiceStringFormatError=The COM+ string in the .svc file was formatted incorrectly. (The string is "{0}".)
ContractTypeNotAnIID=The contract type name in the configuration file was not in the form of an interface identifier. (The string is "{0}".)
ApplicationNotFound=The configured application was not found. (The Application ID was {0}.)
NoVoteIssued= A transaction vote request was completed, but there was no outstanding vote request.
FailedToConvertTypelibraryToAssembly=Failed to convert type library to assembly
BadInterfaceVersion=Incorrect Interface version in registry
FailedToLoadTypeLibrary=Failed to load type library
NativeTypeLibraryNotAllowed= An attempt to load the native type library '{0}' was made. Native type libraries cannot be loaded.
InterfaceNotFoundInAssembly=Could not find interface in the Assembly
UdtNotFoundInAssembly=The '{0}' user-defined type could not be found. Ensure that the correct type and type library are registered and specified.
UnknownMonikerKeyword=Could not find keyword {0}.
MonikerIncorectSerializer=Invalid serializer specified. The only valid values are 'xml' and 'datacontract'.
NoEqualSignFound=The keyword '{0}' has no equal sign following it. Ensure that each keyword is followed by an equal sign and a value. 
KewordMissingValue=No value found for a keyword.
BadlyTerminatedValue=Badly terminated value {0}.
MissingQuote=Missing Quote in value {0}.
RepeatedKeyword=Repeated moniker keyword.
InterfaceNotFoundInConfig=Interface {0} not found in configuration.
CannotHaveNullOrEmptyNameOrNamespaceForIID=Interface {0} has a null namespace or name.
MethodGivenInConfigNotFoundOnInterface=Method {0} given in config was not found on interface {1}.
MonikerIncorrectServerIdentityForMex=Only one type of server identity can be specified.
MonikerAddressNotSpecified=Address not specified.
MonikerMexBindingSectionNameNotSpecified=Mex binding section name attribute not specified.
MonikerMexAddressNotSpecified=Mex address not specified.
MonikerContractNotSpecified=Contract not specified.
MonikerBindingNotSpecified=Binding not specified.
MonikerBindingNamespacetNotSpecified=Binding namespace not specified.
MonikerFailedToDoMexRetrieve=Failed to do mex retrieval:{0}.
MonikerContractNotFoundInRetreivedMex=None of the contract in metadata matched the contract specified.
MonikerNoneOfTheBindingMatchedTheSpecifiedBinding=The contract does not have an endpoint supporting the binding specified.
MonikerMissingColon=Moniker Missing Colon
MonikerIncorrectServerIdentity=Multiple server identity keywords were specified. Ensure that at most one identity keyword is specified.
NoInterface=The object does not support the interface '{0}'.
DuplicateTokenExFailed=Could not duplicate the token (error=0x{0:X}).
AccessCheckFailed=Could not perform an AccessCheck (error=0x{0:X}).
ImpersonateAnonymousTokenFailed=Could not impersonate the anonymous user (error=0x{0:X}).
OnlyByRefVariantSafeArraysAllowed=The provided SafeArray parameter was passed by value. SafeArray parameters must be passed by reference.
OnlyOneDimensionalSafeArraysAllowed= Multi-dimensional SafeArray parameters cannot be used.
OnlyVariantTypeElementsAllowed=The elements of the SafeArray must be of the type VARIANT.
OnlyZeroLBoundAllowed=The lower bound of the SafeArray was not zero. SafeArrays with a lower bound other than zero cannot be used.
OpenThreadTokenFailed=Could not open the thread token (error=0x{0:X}).
OpenProcessTokenFailed=Could not open the process token (error=0x{0:X}).
InvalidIsolationLevelValue=The isolation level for component {0} is invalid. (The value was {1}.)
UnsupportedConversion=The conversion between the client parameter type '{0}' to the required server parameter type '{1}' cannot be performed.
FailedProxyProviderCreation=The required outer proxy could not be created. Ensure that the service moniker is correctly installed and registered.
UnableToLoadDll=Cannot load library {0}. Ensure that WCF is properly installed.
InterfaceNotRegistered=Interface Not Registered
BadInterfaceRegistration=Bad Interface Registration
NotAComObject=The argument passed to SetObject is not a COM object.
NoTypeLibraryFoundForInterface=No type library available for interface
CannotFindClsidInApplication=Cannot find CLSID {0} in COM+ application {1}.
ComActivationAccessDenied=Cannot create an instance of the specified service: access is denied.
ComActivationFailure=An internal error occurred attempting to create an instance of the specified service.
ComDllHostInitializerFoundNoServices=No services are configured for the application.
ComRequiresWindowsSecurity=Access is denied. The message was not authenticated with a valid windows identity.
ComInconsistentSessionRequirements=The session requirements of the contracts are inconsistent. All COM contracts in a service must have the same session requirement.
ComMessageAccessDenied=Access is denied.
VariantArrayNull=Parameter at index {0} is null.
UnableToRetrievepUnk=Unable to retrieve IUnknown for object.
PersistWrapperIsNull=QueryInterface succeeded but the persistable type wrapper was null.
UnexpectedThreadingModel=Unexpected threading model. WCF/COM+ integration only supports STA and MTA threading models.
NoneOfTheMethodsForInterfaceFoundInConfig=None of the methods were found for interface {0}.
ComOperationNotFound=The {0} operation on the service {1} could not be found in the catalog.
InvalidWebServiceInterface=The interface with IID {0} cannot be exposed as a web service
InvalidWebServiceParameter=The parameter named {0} of type {1} on method {2} of interface {3} cannot be serialized.
InvalidWebServiceReturnValue=The return value of type {0} on method {1} of interface {2} cannot be serialized.
OnlyClsidsAllowedForServiceType=The COM+ Integration service '{0}' specified in configuration is not in a supported format and could not be started. Ensure that the configuration is correctly specified.
OperationNotFound=The method '{0}' could not be found. Ensure that the correct method name is specified.
BadDispID=The Dispatch ID '{0}' could not be found or is invalid.
ComNoAsyncOperationsAllowed=At least one operation is asynchronous. Asynchronous operations are not allowed.
ComDuplicateOperation=There are duplicate operations, which is invalid. Remove the duplicates.
BadParamCount=The number of parameters in the request did not match the number supported by the method. Ensure that the correct number of parameters are specified.
BindingNotFoundInConfig=Binding type {0} instance {1} not found in config.
AddressNotSpecified=The required address keyword was not specified.
BindingNotSpecified=The required binding keyword was not specified or is not valid.
OnlyVariantAllowedByRef=A VARIANT parameter was passed by value. VARIANT parameters must be passed by reference.
CannotResolveTypeForParamInMessageDescription=The type for the '{0}' parameter in '{1}' within the namespace '{2}' cannot not be resolved.
TooLate=The operation cannot be performed after the communications channel has been created.
RequireConfiguredMethods=The interface with IID {0} has no methods configured in the COM+ catalog and cannot be exposed as a web service.
RequireConfiguredInterfaces=The interface with IID {0} is not configured in the COM+ catalog and cannot be exposed as a web service.
CannotCreateChannelOption=The channeloption intrinsic object cannot be created because the channel builder is not initialized.
NoTransactionInContext=There is no transaction in the context of the operation.
IssuedTokenFlowNotAllowed=The service does not accept issued tokens.
GeneralSchemaValidationError=There was an error verifying some XML Schemas generated during export:\r\n{0}
SchemaValidationError=There was a validation error on a schema generated during export:\r\n    Source: {0}\r\n    Line: {1} Column: {2}\r\n   Validation Error: {3}
ContractBindingAddressCannotBeNull=The Address, Binding and Contract keywords are required.
TypeLoadForContractTypeIIDFailedWith=Type load for contract interface ID {0} failed with Error:{1}.
BindingLoadFromConfigFailedWith=Fail to load binding {0} from config. Error:{1}.
PooledApplicationNotSupportedForComplusHostedScenarios=Application {0} is marked Pooled. Pooled applications are not supported under COM+ hosting.
RecycledApplicationNotSupportedForComplusHostedScenarios=Application {0} has recycling enabled. Recycling of applications is not supported under COM+ hosting.
BadImpersonationLevelForOutOfProcWas=The client token at least needs to have the SecurityImpersonationLevel of at least Impersonation for Out of process Webhost activations.
ComPlusInstanceProviderRequiresMessage0=This InstanceContext requires a valid Message to obtain the instance.
ComPlusInstanceCreationRequestSchema=From: {0}\nAppId: {1}\nClsId: {2}\nIncoming TransactionId: {3}\nRequesting Identity: {4}
ComPlusMethodCallSchema=From: {0}\nAppId: {1}\nClsId: {2}\nIid: {3}\nAction: {4}\nInstance Id: {5}\nManaged Thread Id: {6}\nUnmanaged Thread Id: {7}\nRequesting Identity: {8}
ComPlusServiceSchema=AppId: {0}\nClsId: {1}\n
ComPlusServiceSchemaDllHost=AppId: {0}
ComPlusTLBImportSchema=Iid: {0}\nType Library ID: {1}
ComPlusServiceHostStartingServiceErrorNoQFE=A Windows hotfix or later service pack is required on Windows XP and Windows Server 2003 to use WS-AtomicTransaction and COM+ Integration Web service transaction functionality. See the Microsoft .NET Framework release notes for instructions on installing the required hotfix.
ComIntegrationManifestCreationFailed=Generating manifest file {0} failed with {1}.
TempDirectoryNotFound=Directory {0} not found.
CannotAccessDirectory=Cannot access directory {0}.
CLSIDDoesNotSupportIPersistStream=The object with CLSID '{0}' does not support the required IPersistStream interface.
CLSIDOfTypeDoesNotMatch=CLSID of type {0} does not match the CLSID on PersistStreamTypeWrapper which is {1}.
TargetObjectDoesNotSupportIPersistStream=Target object does not support IPersistStream.
TargetTypeIsAnIntefaceButCorrespoindingTypeIsNotPersistStreamTypeWrapper=Target type is an interface but corresponding type is not PersistStreamTypeWrapper.
NotAllowedPersistableCLSID=CLSID {0} is not allowed.
TransferringToComplus=Transferring to ComPlus logical thread {0}.
NamedArgsNotSupported=The cNamedArgs parameter is not supported and must be 0.
MexBindingNotFoundInConfig=Binding '{0}' was not found in config. The config file must be present and contain a binding matching the one specified in the moniker.
;
; System.ServiceModel.Security.Tokens
;
ClaimTypeCannotBeEmpty=The claimType cannot be an empty string.
X509ChainIsEmpty=X509Chain does not have any valid certificates.
MissingCustomCertificateValidator=X509CertificateValidationMode.Custom requires a CustomCertificateValidator. Specify the CustomCertificateValidator property.
MissingMembershipProvider=UserNamePasswordValidationMode.MembershipProvider requires a MembershipProvider. Specify the MembershipProvider property.
MissingCustomUserNamePasswordValidator=UserNamePasswordValidationMode.Custom requires a CustomUserNamePasswordValidator. Specify the CustomUserNamePasswordValidator property.
SpnegoImpersonationLevelCannotBeSetToNone=The Security Support Provider Interface does not support Impersonation level 'None'. Specify Identification, Impersonation or Delegation level.
PublicKeyNotRSA=The public key is not an RSA key.
SecurityAuditFailToLoadDll=The '{0}' dynamic link library (dll) failed to load.
SecurityAuditPlatformNotSupported=Writing audit messages to the Security log is not supported by the current platform. You must write audit messages to the Application log.
NoPrincipalSpecifiedInAuthorizationContext=No custom principal is specified in the authorization context.
AccessDenied=Access is denied.
SecurityAuditNotSupportedOnChannelFactory=SecurityAuditBehavior is not supported on the channel factory.
;
; Infocard related strings
;
ExpiredTokenInChannelParameters=The Infocard token created during channel intialization has expired. Please create a new channel to reacquire token. 
NoTokenInChannelParameters=No Infocard token was found in the ChannelParameters. Infocard requires that the security token be created during channel intialization.
;
; KerberosToken SSPI errors
;
;
; Peer Channel strings
;
PeerMessageMustHaveVia=Message with action {0} received from a neighbor is missing a via Header.
PeerLinkUtilityInvalidValues=The LinkUtility message received from a neighbor has invalid values for usefull '{0}' and total '{1}'.
PeerNeighborInvalidState=Internal Error: Peer Neighbor state change from {0} to {1} is invalid.
PeerMaxReceivedMessageSizeConflict=The MaxReceivedMessageSize of the associated listener ({0}) is greater than the MaxReceivedMessageSize of the PeerNode ({1}) with the meshid ({2}), ensure that all ChannelFactories and Endpoints for this mesh have the same configuration for MaxRecievedMessageSize.
PeerConflictingPeerNodeSettings=Binding settings conflict with an existing instance that is using the same mesh name. Check the value of the property {0}.
ArgumentOutOfRange=value must be >= {0} and <= {1}.
PeerChannelViaTooLong=Invalid message: the peer channel via ({0}) has a size of ({1}) it exceeds the maximum via size of ({2}).
PeerNodeAborted=The PeerNode cannot be opened because it has been Aborted.
PeerPnrpNotAvailable=PNRP is not available. Please refer to the documentation with your system for details on how to install and enable PNRP.
PeerPnrpNotInstalled=The PNRP service is not installed on this machine. Please refer to the documentation with your system for details on how to install and enable PNRP.
PeerResolverBindingElementRequired=A PeerResolverBindingElement is required in the {0} binding. The default resolver (PNRP) is not available.
PeerResolverRequired=Resolver must be specified. The default resolver (PNRP) is not available. Please refer to the documentation with your system for details on how to install and enable PNRP.
PeerResolverInvalid=The specified ResolverType: {0} cannot be loaded.  Please ensure that the type name specified refers to a type that can be loaded.
PeerResolverSettingsInvalid=Specified resolver settings are not enough to create a valid resolver.  Please ensure that a ResolverType and an Address is specified for the custom resolver.
PeerListenIPAddressInvalid=The ListenIPAddress {0} is invalid.
PeerFlooderDisposed=Internal Error. PeerFlooder instance is already disposed. It cannot be used to send messages.
PeerPnrpIllegalUri=Internal Error. Address of the Service cannot be registered with PNRP.
PeerInvalidRegistrationId=The registrationId {0} is invalid.
PeerConflictingHeader=Application message contains a header that conflicts with a PeerChannel specific header. Name = {0} and Namespace = {1}.
PnrpNoClouds=PNRP could not find any clouds that match the current operation.
PnrpAddressesUnsupported="Specified addresses can not be registered with PNRP because either PNRP is not enabled or the specified addresses do not have corresponding clouds. Please refer to the documentation with your system for details on how to install and enable PNRP."
InsufficientCryptoSupport=The binding's PeerTransportSecuritySettings can not be supported under the current system security configuration.
InsufficientCredentials=Credentials specified are not sufficient to carry requested operation. Please specify a valid value for {0}. 
UnexpectedSecurityTokensDuringHandshake=Connection was not accepted because the SecurityContext contained tokens that do not match the current security settings.
PnrpAddressesExceedLimit=Addresses specified in the registration exceed PNRP's per registration address limit.
InsufficientResolverSettings=Provided information is Insufficient to create a valid connection to the resolver service.
InvalidResolverMode=Specified PeerResolverMode value {0} is invalid. Please specify either PeerResolveMode.Auto, Default, or Pnrp.
MustOverrideInitialize=concrete PeerResolver implementation must override Initialize to accept metadata about resolver service.
NotValidWhenOpen=The operation: {0} is not valid while the object is in open state.
NotValidWhenClosed=The operation: {0} is not valid while the object is in closed state.
PeerNullRegistrationInfo=Registration info can not be null.  Please ensure that the Register operation is invoked with a valid RegistrationInfo object.
PeerNullResolveInfo=Resolve info can not be null.  Please ensure that the Resolve operation is invoked with a valid ResolveInfo object.
PeerNullRefreshInfo=Refresh info can not be null.  Please ensure that the Refresh operation is invoked with a valid RefreshInfo object.
PeerInvalidMessageBody=MessageBody does not contain a valid {0} message.  Please ensure that the message is well formed.
DuplicatePeerRegistration=A peer registration with the service address {0} already exists.
PeerNodeToStringFormat=MeshId: {0}, Node Id: {1}, Online: {2}, Open: {3}, Port: {4}
MessagePropagationException=The MessagePropagationFilter threw an exception. Please refer to InnerException.
NotificationException=An event notification threw an exception. Please refer to InnerException.
ResolverException=The Peer resolver threw an exception.  Please refer to InnerException.
PnrpCloudNotFound=One of the addresses specified doesn't match any PNRP cloud for registration.{0}
PnrpCloudDisabled=Specified cloud {0} could not be used for the specified operation because it is disabled.
PnrpCloudResolveOnly=Specified cloud {0} is configured for Resolve operations only.
PnrpPortBlocked=Requested PNRP operation {0} could not be performed because the port is blocked possibly by a firewall.
PnrpDuplicatePeerName=Specified mesh name {0} cannot be used because a name can only be registered once per process.
RefreshIntervalMustBeGreaterThanZero=Invalid RefreshInterval value of {0}; it must be greater than zero
CleanupIntervalMustBeGreaterThanZero=Invalid CleanupInterval value of {0}; it must be greater than zero
AmbiguousConnectivitySpec=Multiple link-local only interfaces detected.  Please specifiy the interface you require by using the ListenIpAddress attribute in the PeerTransportBindingElement
MustRegisterMoreThanZeroAddresses=Registration with zero addresses detected.   Please call Register with more than zero addresses.
PeerCertGenFailure=Certificate generation has failed. Please see the inner exception for more information.
PeerThrottleWaiting=Throttle on the mesh {0} waiting.
PeerThrottlePruning=Attempting to prune the slow neighbor for the mesh {0}.
PeerMaintainerStarting=Maintainer is starting for the mesh {0}.
PeerMaintainerConnect=Maintainer is attempting a connection to Peer {0} for the mesh {1}.
PeerMaintainerConnectFailure=Maintainer encountered exception when attempting a connection to Peer {0} for the mesh {1}. Exception is {2}.
PeerMaintainerInitialConnect=Mantainer's InitialConnect is running for the mesh {0}.
PeerMaintainerPruneMode=Mantainer is attempting to prune connections for the mesh {0}.
PeerMaintainerConnectMode=Mantainer is attempting to establish additional connections for the mesh {0}.

;
; Context Channel strings
;
BasicHttpContextBindingRequiresAllowCookie=BasicHttpContextBinding {0}:{1} requires that AllowCookies property is set to true.
CallbackContextOnlySupportedInWSAddressing10=The message contains a callback context header with an endpoint reference for AddressingVersion '{0}'. Callback context can only be transmitted when the AddressingVersion is configured with 'WSAddressing10'.
ListenAddressAlreadyContainsContext=The callback address already has a context header in it.
MultipleContextHeadersFoundInCallbackAddress=The callback address contains multiple context headers. There can be at most one context header in a callback address.
CallbackContextNotExpectedOnIncomingMessageAtClient=The incoming message with action '{0}' contains a callback context header with name '{1}' and namespace '{2}'. Callback context headers are not expected in incoming messages at the client.
CallbackContextOnlySupportedInSoap=The message contains a callback context message property. Callback context can be transmitted only when the ContextBindingElement is configured with ContextExchangeMechanism of ContextSoapHeader.
ContextBindingElementCannotProvideChannelFactory=ContextBindingElement cannot provide channel factory for the requested channel shape {0}.
ContextBindingElementCannotProvideChannelListener=ContextBindingElement cannot provide channel listener for the requested channel shape {0}.
InvalidCookieContent=Value '{0}' specified for 'name' attribute of ContextMessageProperty is either null or has invalid character(s). Please ensure value of 'name' is within the allowed value space.
SchemaViolationInsideContextHeader=Context protocol was unable to parse the context header. Nodes disallowed by the context header schema were found inside the context header.
CallbackContextNotExpectedOnOutgoingMessageAtServer=The outgoing message with action '{0}' contains a callback context message property. Callback context cannot be transmitted in outgoing messages at the server.
ChannelIsOpen=Channel context management cannot be enabled or disabled after the channel is opened.
ContextManagementNotEnabled=Context cached at the channel cannot be set or retrieved when the context management is disabled at the channel layer. Ensure context channel property 'IContextManager.Enabled' is set to true.
CachedContextIsImmutable=Context cached at the channel layer cannot be changed after the channel is opened.
InvalidMessageContext=Cannot specify 'ContextMessageProperty' in message when using context channel with context management enabled. Ensure the message does not have 'ContextMessageProperty' or disable context management by setting channel property 'IContextManager.Enabled' to false.
InvalidContextReceived=Context channel received a message with context which does not match the current context cached at the channel. Ensure service does not change context after it was originally set or disable context management by setting channel property 'IContextManager.Enabled' to false.
BehaviorRequiresContextProtocolSupportInBinding=Service behavior {0} requires that the binding associated with endpoint {1} listening on {2} supports the context protocol, because the contract associated with this endpoint may require a session. Currently configured binding for this endpoint does not support the context protocol. Please modify the binding to add support for the context protocol or modify the SessionMode on the contract to NotAllowed.
HttpCookieContextExchangeMechanismNotCompatibleWithTransportType=Binding {1}:{2} is configured with ContextExchangeMechanism.HttpCookie which is not compatible with the transport type {0}. Please modify the ContextExchangeMechanism or use HTTP or HTTPS transport.
HttpCookieContextExchangeMechanismNotCompatibleWithTransportCookieSetting=ContextBindingElement of binding {0}:{1} is configured with ContextExchangeMode.HttpCookie but the configuration of this binding's HttpTransportBindingElement prevents upper channel layers from managing cookies. Please set the HttpTransportBindingElement.AllowCookies property to false or change the ContextExchangeMechanism of ContextBindingElement to SoapHeader.
PolicyImportContextBindingElementCollectionIsNull=ContextBindingElementImporter cannot import policy because PolicyImportContext.BindingElements collection is null.
ContextChannelFactoryChannelCreatedDetail=EndpointAddress: {0}, Via:{1}
XmlFormatViolationInContextHeader=Context protocol was unable to parse the context header.
XmlFormatViolationInCallbackContextHeader=Context protocol was unable to parse the callback context header.

;
; Transaction formatter strings
;
OleTxHeaderCorrupt=The OLE Transactions header was invalid or corrupt.
WsatHeaderCorrupt=The WS-AtomicTransaction header was invalid or corrupt.
FailedToDeserializeIssuedToken=The issued token accompanying the WS-AtomicTransaction coordination context was invalid or corrupt.
InvalidPropagationToken=The OLE Transactions propagation token received in the message could not be used to unmarshal a transaction. It may be invalid or corrupt.
InvalidWsatExtendedInfo=The WS-AtomicTransaction extended information included in the OLE Transactions propagation token was invalid or corrupt.
TMCommunicationError=An error occurred communicating with the distributed transaction manager.
UnmarshalTransactionFaulted=The WS-AtomicTransaction protocol service could not unmarshal the flowed transaction. The following exception occured: {0}
InvalidRegistrationHeaderTransactionId=The transaction identifier element in the registration header is invalid
InvalidRegistrationHeaderIdentifier=The context identifier element in the registration header is invalid.
InvalidRegistrationHeaderTokenId=The token identifier element in the registration header is invalid.
InvalidCoordinationContextTransactionId=The transaction identifier element in the coordination context is invalid.
WsatRegistryValueReadError=The WS-AtomicTransaction transaction formatter could not read the registry value '{0}'.
WsatProtocolServiceDisabled=The MSDTC transaction manager's WS-AtomicTransaction protocol service '{0}' is disabled and cannot unmarshal incoming transactions.
InboundTransactionsDisabled=The MSDTC transaction manager has disabled incoming transactions.
SourceTransactionsDisabled=The incoming transaction cannot be unmarshaled because the source MSDTC transaction manager has either disabled outbound transactions or disabled its WS-AtomicTransaction protocol service.
WsatUriCreationFailed=A registration service address could not be created from MSDTC whereabouts information.
WhereaboutsReadFailed=The MSDTC whereabouts information could not be deserialized.
WhereaboutsSignatureMissing=The standard whereabouts signature was missing from the MSDTC whereabouts information.
WhereaboutsImplausibleProtocolCount=The MSDTC whereabouts information's protocol count was invalid.
WhereaboutsImplausibleHostNameByteCount=The MSDTC whereabouts information's host name byte count was invalid.
WhereaboutsInvalidHostName=The MSDTC whereabouts information's host name was invalid.
WhereaboutsNoHostName=The MSDTC whereabouts information did not contain a host name.
InvalidWsatProtocolVersion=The specified WSAT protocol version is invalid.
;
; SOAP Redirection
;
ParameterCannotBeEmpty=The parameter cannot be empty.
RedirectCache=The requested resouce has not changed and should be taken from cache.
RedirectResource=The requested resource has moved to one of the following locations:\n{0}
RedirectUseIntermediary=The requested resource must be accessed through one of the following intermediary service locations:\n{0}
RedirectGenericMessage=The requested resource has been moved.
RedirectMustProvideLocation=At least one RedirectionLocation must be provided for this RedirectionType.
RedirectCacheNoLocationAllowed=RedirectionType 'Cache' does not allow any RedirectionLocation objects be passed into the constructor.
RedirectionInfoStringFormatWithNamespace={0} ({1})
RedirectionInfoStringFormatNoNamespace={0}
RetryGenericMessage=The requested resource is available.
;
; Activity Names
;
ActivityCallback=Executing user callback.
ActivityClose=Close '{0}'.
ActivityConstructChannelFactory=Construct ChannelFactory. Contract type: '{0}'.
ActivityConstructServiceHost=Construct ServiceHost '{0}'.
ActivityExecuteMethod=Execute '{0}.{1}'.
ActivityExecuteAsyncMethod=Execute Async: Begin: '{0}.{1}'; End: '{2}.{3}'.
ActivityCloseChannelFactory=Close ChannelFactory. Contract type: '{0}'.
ActivityCloseClientBase=Close ClientBase. Contract type: '{0}'.
ActivityCloseServiceHost=Close ServiceHost '{0}'.
ActivityListenAt=Listen at '{0}'.
ActivityOpen=Open '{0}'.
ActivityOpenServiceHost=Open ServiceHost '{0}'.
ActivityOpenChannelFactory=Open ChannelFactory. Contract type: '{0}'.
ActivityOpenClientBase=Open ClientBase. Contract type: '{0}'.
ActivityProcessAction=Process action '{0}'.
ActivityProcessingMessage=Processing message {0}.
ActivityReceiveBytes=Receive bytes on connection '{0}'.
ActivitySecuritySetup=Set up Secure Session.
ActivitySecurityRenew=Renew Secure Session.
ActivitySecurityClose=Close Security Session.
ActivitySharedListenerConnection=Shared listener connection: '{0}'.
ActivitySocketConnection=Socket connection: '{0}'.
ActivityReadOnConnection=Reading data from connection on '{0}'.
ActivityReceiveAtVia=Receiving data at via '{0}'.
;
; Trace Codes
;
TraceCodeBeginExecuteMethod=Begin method execution.
TraceCodeChannelCreated=Created: {0}
TraceCodeChannelDisposed=Disposed: {0}
TraceCodeChannelMessageSent=Sent a message over a channel
TraceCodeChannelPreparedMessage=Prepared message for sending over a channel
TraceCodeComIntegrationChannelCreated=ComPlus:channel created.
TraceCodeComIntegrationDispatchMethod=ComPlus:Dispatch method details.
TraceCodeComIntegrationDllHostInitializerAddingHost=ComPlus:DllHost initializer:Adding host.
TraceCodeComIntegrationDllHostInitializerStarted=ComPlus:Started DllHost initializer.
TraceCodeComIntegrationDllHostInitializerStarting=ComPlus:Starting DllHost initializer.
TraceCodeComIntegrationDllHostInitializerStopped=ComPlus:Stopped DllHost initializer.
TraceCodeComIntegrationDllHostInitializerStopping=ComPlus:Stopping DllHost initializer.
TraceCodeComIntegrationEnteringActivity=ComPlus:Entering COM+ activity.
TraceCodeComIntegrationExecutingCall=ComPlus:Executing COM call.
TraceCodeComIntegrationInstanceCreationRequest=ComPlus:Received instance creation request.
TraceCodeComIntegrationInstanceCreationSuccess=ComPlus:Created instance.
TraceCodeComIntegrationInstanceReleased=ComPlus:Released instance.
TraceCodeComIntegrationInvokedMethod=ComPlus:Invoked method.
TraceCodeComIntegrationInvokingMethod=ComPlus:Invoking method.
TraceCodeComIntegrationInvokingMethodContextTransaction=Complus:Invoking method with transaction in COM+ context.
TraceCodeComIntegrationInvokingMethodNewTransaction=Complus:Invoking method with new incoming transaction.
TraceCodeComIntegrationLeftActivity=ComPlus:Left COM+ activity.
TraceCodeComIntegrationMexChannelBuilderLoaded=Complus:Mex channel loader loaded.
TraceCodeComIntegrationMexMonikerMetadataExchangeComplete=Complus:Metadata exchange completed successfully.
TraceCodeComIntegrationServiceHostCreatedServiceContract=ComPlus:Created service contract.
TraceCodeComIntegrationServiceHostCreatedServiceEndpoint=ComPlus:Created service endpoint.
TraceCodeComIntegrationServiceHostStartedService=ComPlus:Started service.
TraceCodeComIntegrationServiceHostStartedServiceDetails=ComPlus:Started service:details.
TraceCodeComIntegrationServiceHostStartingService=ComPlus:Starting service.
TraceCodeComIntegrationServiceHostStoppedService=ComPlus:Stopped service.
TraceCodeComIntegrationServiceHostStoppingService=ComPlus:Stopping service.
TraceCodeComIntegrationServiceMonikerParsed=ComPlus:Service moniker parsed.
TraceCodeComIntegrationTLBImportConverterEvent=ComPlus:Type library converter event.
TraceCodeComIntegrationTLBImportFinished=ComPlus:Finished type library import.
TraceCodeComIntegrationTLBImportFromAssembly=ComPlus:Type library import: using assembly.
TraceCodeComIntegrationTLBImportFromTypelib=ComPlus:Type library import: using type library.
TraceCodeComIntegrationTLBImportStarting=ComPlus:Starting type library import.
TraceCodeComIntegrationTxProxyTxAbortedByContext=ComPlus:Transaction aborted by COM+ context.
TraceCodeComIntegrationTxProxyTxAbortedByTM=ComPlus:Transaction aborted by Transaction Manager.
TraceCodeComIntegrationTxProxyTxCommitted=ComPlus:Transaction committed.
TraceCodeComIntegrationTypedChannelBuilderLoaded=ComPlus:Typed channel builder loaded.
TraceCodeComIntegrationWsdlChannelBuilderLoaded=ComPlus:WSDL channel builder loaded.
TraceCodeCommunicationObjectAborted=Aborted '{0}'.
TraceCodeCommunicationObjectAbortFailed=Failed to abort {0}
TraceCodeCommunicationObjectCloseFailed=Failed to close {0}
TraceCodeCommunicationObjectClosed=Closed {0}
TraceCodeCommunicationObjectCreated=Created {0}
TraceCodeCommunicationObjectClosing=Closing {0}
TraceCodeCommunicationObjectDisposing=Disposing {0}
TraceCodeCommunicationObjectFaultReason=CommunicationObject faulted due to exception.
TraceCodeCommunicationObjectFaulted=Faulted {0}
TraceCodeCommunicationObjectOpenFailed=Failed to open {0}
TraceCodeCommunicationObjectOpened=Opened {0}
TraceCodeCommunicationObjectOpening=Opening {0}
TraceCodeConfigurationIsReadOnly=The configuration is read-only.
TraceCodeConfiguredExtensionTypeNotFound=Extension type is not configured.
TraceCodeConnectionAbandoned=The connection has been abandoned.
TraceCodeConnectToIPEndpoint=Connection information.
TraceCodeConnectionPoolCloseException=An exception occurred while closing the connections in this connection pool.
TraceCodeConnectionPoolIdleTimeoutReached=A connection has exceeded the idle timeout of this connection pool ({0}) and been closed.
TraceCodeConnectionPoolLeaseTimeoutReached=A connection has exceeded the connection lease timeout of this connection pool ({0}) and been closed.
TraceCodeConnectionPoolMaxOutboundConnectionsPerEndpointQuotaReached=MaxOutboundConnectionsPerEndpoint quota ({0}) has been reached, so connection was closed and not stored in this connection pool.
TraceCodeServerMaxPooledConnectionsQuotaReached=MaxOutboundConnectionsPerEndpoint quota ({0}) has been reached, so the connection was closed and not reused by the listener.
TraceCodeDefaultEndpointsAdded=No matching <service> tag was found. Default endpoints added.
TraceCodeDiagnosticsFailedMessageTrace=Failed to trace a message
TraceCodeDidNotUnderstandMessageHeader=Did not understand message header.
TraceCodeDroppedAMessage=A response message was received, but there are no outstanding requests waiting for this message. The message is being dropped.
TraceCodeCannotBeImportedInCurrentFormat=The given schema cannot be imported in this format.
TraceCodeElementTypeDoesntMatchConfiguredType=The type of the element does not match the configuration type.
TraceCodeEndExecuteMethod=End method execution.
TraceCodeEndpointListenerClose=Endpoint listener closed.
TraceCodeEndpointListenerOpen=Endpoint listener opened.
TraceCodeErrorInvokingUserCode=Error invoking user code
TraceCodeEvaluationContextNotFound=Configuration evaluation context not found.
TraceCodeExportSecurityChannelBindingEntry=Starting Security ExportChannelBinding
TraceCodeExportSecurityChannelBindingExit=Finished Security ExportChannelBinding
TraceCodeExtensionCollectionDoesNotExist=The extension collection does not exist.
TraceCodeExtensionCollectionIsEmpty=The extension collection is empty.
TraceCodeExtensionCollectionNameNotFound=Extension element not associated with an extension collection.
TraceCodeExtensionElementAlreadyExistsInCollection=The extension element already exists in the collection.
TraceCodeExtensionTypeNotFound=Extension type not found.
TraceCodeFailedToAddAnActivityIdHeader=Failed to set an activity id header on an outgoing message
TraceCodeFailedToReadAnActivityIdHeader=Failed to read an activity id header on a message
TraceCodeFilterNotMatchedNodeQuotaExceeded=Evaluating message logging filter against the message exceeded the node quota set on the filter.
TraceCodeGetBehaviorElement=Get BehaviorElement.
TraceCodeGetChannelEndpointElement=Get ChannelEndpointElement.
TraceCodeGetCommonBehaviors=Get machine.config common behaviors.
TraceCodeGetConfigurationSection=Get configuration section.
TraceCodeGetConfiguredBinding=Get configured binding.
TraceCodeGetDefaultConfiguredBinding=Get default configured binding.
TraceCodeGetConfiguredEndpoint=Get configured endpoint.
TraceCodeGetDefaultConfiguredEndpoint=Get default configured endpoint.
TraceCodeGetServiceElement=Get ServiceElement.
TraceCodeHttpAuthFailed=Authentication failed for HTTP(S) connection
TraceCodeHttpActionMismatch=The HTTP SOAPAction header and the wsa:Action SOAP header did not match. 
TraceCodeHttpChannelMessageReceiveFailed=Failed to lookup a channel to receive an incoming message. Either the endpoint or the SOAP action was not found.
TraceCodeHttpChannelRequestAborted=Failed to send request message over HTTP
TraceCodeHttpChannelResponseAborted=Failed to send response message over HTTP
TraceCodeHttpChannelUnexpectedResponse=Received bad HTTP response
TraceCodeHttpResponseReceived=HTTP response was received
TraceCodeHttpChannelConcurrentReceiveQuotaReached=The HTTP concurrent receive quota was reached.
TraceCodeHttpsClientCertificateInvalid=Client certificate is invalid.
TraceCodeHttpsClientCertificateInvalid1=Client certificate is invalid with native error code {0} (see http://go.microsoft.com/fwlink/?LinkId=187517 for details).
TraceCodeHttpsClientCertificateNotPresent=Client certificate is required.  No certificate was found in the request.  This might be because the client certificate could not be successfully validated by the operating system or IIS.  For information on how to bypass those validations and use a custom X509CertificateValidator in WCF please see http://go.microsoft.com/fwlink/?LinkId=208540.
TraceCodeImportSecurityChannelBindingEntry=Starting Security ImportChannelBinding
TraceCodeImportSecurityChannelBindingExit=Finished Security ImportChannelBinding
TraceCodeIncompatibleExistingTransportManager=An existing incompatible transport manager was found for the specified URI.
TraceCodeInitiatingNamedPipeConnection=Initiating Named Pipe connection.
TraceCodeInitiatingTcpConnection=Initiating TCP connection.
TraceCodeIssuanceTokenProviderBeginSecurityNegotiation=The IssuanceTokenProvider has started a new security negotiation.
TraceCodeIssuanceTokenProviderEndSecurityNegotiation=The IssuanceTokenProvider has completed the security negotiation.
TraceCodeIssuanceTokenProviderRedirectApplied=The IssuanceTokenProvider applied a redirection header.
TraceCodeIssuanceTokenProviderRemovedCachedToken=The IssuanceTokenProvider removed the expired service token.
TraceCodeIssuanceTokenProviderServiceTokenCacheFull=IssuanceTokenProvider pruned service token cache.
TraceCodeIssuanceTokenProviderUsingCachedToken=The IssuanceTokenProvider used the cached service token.
TraceCodeListenerCreated=Listener created
TraceCodeListenerDisposed=Listener disposed
TraceCodeMaxPendingConnectionsReached=Maximum number of pending connections has been reached. 
TraceCodeMaxAcceptedChannelsReached=Maximum number of inbound session channel has been reached. 
TraceCodeMessageClosed=A message was closed
TraceCodeMessageClosedAgain=A message was closed again
TraceCodeMessageCopied=A message was copied
TraceCodeMessageCountLimitExceeded=Reached the limit of messages to log. Message logging is stopping. 
TraceCodeMessageNotLoggedQuotaExceeded=Message not logged because its size exceeds configured quota
TraceCodeMessageRead=A message was read
TraceCodeMessageSent=Sent a message over a channel.
TraceCodeMessageReceived=Received a message over a channel.
TraceCodeMessageWritten=A message was written
TraceCodeMessageProcessingPaused=Switched threads while processing a message.
TraceCodeMsmqCannotPeekOnQueue=MsmqActivation service cannot peek on the queue.
TraceCodeMsmqCannotReadQueues=MsmqActivation service cannot discover queues.
TraceCodeMsmqDatagramReceived=MSMQ datagram message received.
TraceCodeMsmqDatagramSent=MSMQ datagram message sent.
TraceCodeMsmqDetected=MSMQ detected successfully.
TraceCodeMsmqEnteredBatch=Entered batching mode.
TraceCodeMsmqExpectedException=Expected exception caught.
TraceCodeMsmqFoundBaseAddress=Hosting environment found the base address for the service.
TraceCodeMsmqLeftBatch=Left batching mode.
TraceCodeMsmqMatchedApplicationFound=MsmqActivation service found application matching queue.
TraceCodeMsmqMessageLockedUnderTheTransaction=Cannot move or delete message because it is still locked under the transaction.
TraceCodeMsmqMessageDropped=Message was dropped.
TraceCodeMsmqMessageRejected=Message was rejected.
TraceCodeMsmqMoveOrDeleteAttemptFailed=Cannot move or delete message.
TraceCodeMsmqPoisonMessageMovedPoison=Poison message moved to the poison subqueue.
TraceCodeMsmqPoisonMessageMovedRetry=Poison message moved to the retry subqueue.
TraceCodeMsmqPoisonMessageRejected=Poison message rejected.
TraceCodeMsmqPoolFull=Pool of the native MSMQ messages is full. This may affect performance.
TraceCodeMsmqPotentiallyPoisonMessageDetected=Transaction which received this message was aborted at least once.
TraceCodeMsmqQueueClosed=MSMQ queue closed.
TraceCodeMsmqQueueOpened=MSMQ queue opened.
TraceCodeMsmqQueueTransactionalStatusUnknown=Cannot detect if the queue is transactional.
TraceCodeMsmqScanStarted=MsmqActivation service started scan for queues.
TraceCodeMsmqSessiongramReceived=MSMQ transport session received.
TraceCodeMsmqSessiongramSent=MSMQ transport session sent.
TraceCodeMsmqStartingApplication=MSMQ Activation service started application.
TraceCodeMsmqStartingService=Hosting environment started service.
TraceCodeMsmqUnexpectedAcknowledgment=Unexpected acknowledgment value.
TraceCodeNamedPipeChannelMessageReceiveFailed=Failed to receive a message over a named pipe channel.
TraceCodeNamedPipeChannelMessageReceived=Received a message over a named pipe channel.
TraceCodeNegotiationAuthenticatorAttached=NegotiationTokenAuthenticator was attached.
TraceCodeNegotiationTokenProviderAttached=NegotiationTokenProvider was attached.
TraceCodeNoExistingTransportManager=No existing transport manager was found for the specified URI.
TraceCodeOpenedListener=Transport is listening at base URI.
TraceCodeOverridingDuplicateConfigurationKey=The configuration system has detected a duplicate key in a different configuration scope and is overriding with the more recent value.
TraceCodePeerChannelMessageReceived=A message was received by a peer channel.
TraceCodePeerChannelMessageSent=A message was sent on a peer channel.
TraceCodePeerFloodedMessageNotMatched=A PeerNode received a message that did not match any local channels.
TraceCodePeerFloodedMessageNotPropagated=A PeerNode received a flooded message that was not propagated further.
TraceCodePeerFloodedMessageReceived=A PeerNode received a flooded message.
TraceCodePeerFlooderReceiveMessageQuotaExceeded=Received message could not be forwarded to other neighbors since it exceeded the quota set for the peer node.
TraceCodePeerNeighborCloseFailed=A Peer Neighbor close has failed.
TraceCodePeerNeighborClosingFailed=A Peer Neighbor closing has failed.
TraceCodePeerNeighborManagerOffline=A Peer Neighbor Manager is offline.
TraceCodePeerNeighborManagerOnline=A Peer Neighbor Manager is online.
TraceCodePeerNeighborMessageReceived=A message was received by a Peer Neighbor.
TraceCodePeerNeighborNotAccepted=A Peer Neighbor was not accepted.
TraceCodePeerNeighborNotFound=A Peer Neighbor was not found.
TraceCodePeerNeighborOpenFailed=A Peer Neighbor open has failed.
TraceCodePeerNeighborStateChangeFailed=A Peer Neighbor state change has failed.
TraceCodePeerNeighborStateChanged=A Peer Neighbor state has changed.
TraceCodePeerNodeAddressChanged=A PeerNode address has changed.
TraceCodePeerNodeAuthenticationFailure=A neighbor connection could not be established due to insufficient or wrong credentials.
TraceCodePeerNodeAuthenticationTimeout=A neighbor security handshake as timed out.
TraceCodePeerNodeClosed=A PeerNode was closed.
TraceCodePeerNodeClosing=A PeerNode is closing.
TraceCodePeerNodeOpenFailed=Peer node open failed.
TraceCodePeerNodeOpened=A PeerNode was opened.
TraceCodePeerNodeOpening=A PeerNode is opening.
TraceCodePeerReceiveMessageAuthenticationFailure=Message source could not be authenticated.
TraceCodePeerServiceOpened=PeerService Opened and listening at '{0}'.
TraceCodePerformanceCounterFailedToLoad=A performance counter failed to load. Some performance counters will not be available.
TraceCodePerformanceCountersFailed=Failed to load the performance counter '{0}'. Some performance counters will not be available
TraceCodePerformanceCountersFailedDuringUpdate=There was an error while updating the performance counter '{0}'. This performance counter will be disabled.
TraceCodePerformanceCountersFailedForService=Loading performance counters for the service failed. Performance counters will not be available for this service.
TraceCodePerformanceCountersFailedOnRelease=Unloading the performance counters failed.
TraceCodePnrpRegisteredAddresses=Registered addresses in PNRP.
TraceCodePnrpResolvedAddresses=Resolved addresses in PNRP.
TraceCodePnrpResolveException=Unexpected Exception during PNRP resolve operation.
TraceCodePnrpUnregisteredAddresses=Unregistered addresses in PNRP.
TraceCodePrematureDatagramEof=A null Message (signalling end of channel) was received from a datagram channel, but the channel is still in the Opened state. This indicates a bug in the datagram channel, and the demuxer receive loop has been prematurely stalled. 
TraceCodePeerMaintainerActivity=PeerMaintainer Activity.
TraceCodeReliableChannelOpened=A reliable channel has been opened.
TraceCodeRemoveBehavior=Behavior type already exists in the collection
TraceCodeRequestChannelReplyReceived=Received reply over request channel
TraceCodeSecurity=A failure occured while performing a security related operation.
TraceCodeSecurityActiveServerSessionRemoved=An active security session was removed by the server.
TraceCodeSecurityAuditWrittenFailure=A failure occurred while writing to the security audit log.
TraceCodeSecurityAuditWrittenSuccess=The security audit log is written successfully.
TraceCodeSecurityBindingIncomingMessageVerified=The security protocol verified the incoming message.
TraceCodeSecurityBindingOutgoingMessageSecured=The security protocol secured the outgoing message.
TraceCodeSecurityBindingSecureOutgoingMessageFailure=The security protocol cannot secure the outgoing message.
TraceCodeSecurityBindingVerifyIncomingMessageFailure=The security protocol cannot verify the incoming message.
TraceCodeSecurityClientSessionKeyRenewed=The client security session renewed the session key.
TraceCodeSecurityClientSessionCloseSent=A Close message was sent by the client security session.
TraceCodeSecurityClientSessionCloseResponseSent=Close response message was sent by client security session.
TraceCodeSecurityClientSessionCloseMessageReceived=Close message was received by client security session.TraceCodeSecurityClientSessionKeyRenewed=Client security session renewed session key.
TraceCodeSecurityClientSessionPreviousKeyDiscarded=The client security session discarded the previous session key.
TraceCodeSecurityContextTokenCacheFull=The SecurityContextSecurityToken cache is full.
TraceCodeSecurityIdentityDeterminationFailure=Identity cannot be determined for an EndpointReference.
TraceCodeSecurityIdentityDeterminationSuccess=Identity was determined for an EndpointReference.
TraceCodeSecurityIdentityHostNameNormalizationFailure=The HostName portion of an endpoint address cannot be normalized.
TraceCodeSecurityIdentityVerificationFailure=Identity verification failed.
TraceCodeSecurityIdentityVerificationSuccess=Identity verification succeeded.
TraceCodeSecurityImpersonationFailure=Security impersonation failed at the server.
TraceCodeSecurityImpersonationSuccess=Security Impersonation succeeded at the server.
TraceCodeSecurityInactiveSessionFaulted=An inactive security session was faulted by the server.
TraceCodeSecurityNegotiationProcessingFailure=Service security negotiation processing failure.
TraceCodeSecurityNewServerSessionKeyIssued=A new security session key was issued by the server.
TraceCodeSecurityPendingServerSessionAdded=A pending security session was added to the server.
TraceCodeSecurityPendingServerSessionClosed=The pending security session was closed by the server.
TraceCodeSecurityPendingServerSessionActivated=A pending security session was activated by the server.
TraceCodeSecurityServerSessionCloseReceived=The server security session received a close message from the client.
TraceCodeSecurityServerSessionCloseResponseReceived=Server security session received Close response message from client.
TraceCodeSecurityServerSessionAbortedFaultSent=Server security session sent session aborted fault to client.
TraceCodeSecurityServerSessionKeyUpdated=The security session key was updated by the server.
TraceCodeSecurityServerSessionRenewalFaultSent=The server security session sent a key renewal fault to the client.
TraceCodeSecuritySessionCloseResponseSent=The server security session sent a close response to the client.
TraceCodeSecuritySessionServerCloseSent=Server security session sent Close to client.
TraceCodeSecuritySessionAbortedFaultReceived=Client security session received session aborted fault from server.
TraceCodeSecuritySessionAbortedFaultSendFailure=Failure sending security session aborted fault to client.
TraceCodeSecuritySessionClosedResponseReceived=The client security session received a closed reponse from the server.
TraceCodeSecuritySessionClosedResponseSendFailure=A failure occurred when sending a security session Close response to the client.
TraceCodeSecuritySessionServerCloseSendFailure=Failure sending security session Close to client.
TraceCodeSecuritySessionKeyRenewalFaultReceived=The client security session received a key renewal fault from the server.
TraceCodeSecuritySessionRedirectApplied=The client security session was redirected.
TraceCodeSecuritySessionRenewFaultSendFailure=A failure occurred when sending a renewal fault on the security session key to the client.
TraceCodeSecuritySessionRequestorOperationFailure=The client security session operation failed.
TraceCodeSecuritySessionRequestorOperationSuccess=The security session operation completed successfully at the client.
TraceCodeSecuritySessionRequestorStartOperation=A security session operation was started at the client.
TraceCodeSecuritySessionResponderOperationFailure=The security session operation failed at the server.
TraceCodeSecuritySpnToSidMappingFailure=The ServicePrincipalName could not be mapped to a SecurityIdentifier.
TraceCodeSecurityTokenAuthenticatorClosed=Security Token Authenticator was closed.
TraceCodeSecurityTokenAuthenticatorOpened=Security Token Authenticator was opened.
TraceCodeSecurityTokenProviderClosed=Security Token Provider was closed.
TraceCodeSecurityTokenProviderOpened=Security Token Provider was opened.
TraceCodeServiceChannelLifetime=ServiceChannel information.
TraceCodeServiceHostBaseAddresses=ServiceHost base addresses.
TraceCodeServiceHostTimeoutOnClose=ServiceHost close operation timedout.
TraceCodeServiceHostFaulted=ServiceHost faulted.
TraceCodeServiceHostErrorOnReleasePerformanceCounter=ServiceHost error on calling ReleasePerformanceCounters.
TraceCodeServiceThrottleLimitReached=The system hit the limit set for throttle '{0}'. Limit for this throttle was set to {1}. Throttle value can be changed by modifying attribute '{2}' in serviceThrottle element or by modifying '{0}' property on behavior ServiceThrottlingBehavior.
TraceCodeServiceThrottleLimitReachedInternal=The system hit an internal throttle limit. Limit for this throttle was set to {0}. This throttle cannot be configured.
TraceCodeManualFlowThrottleLimitReached=The system hit the limit set for the '{0}' throttle. Throttle value can be changed by modifying {0} property on {1}.
TraceCodeProcessMessage2Paused=Switched threads while processing a message for Contract '{0}' at Address '{1}'. ConcurrencyMode for service is set to Single/Reentrant and the service is currently processing another message.
TraceCodeProcessMessage3Paused=Switched threads while processing a message for Contract '{0}' at Address '{1}'. Cannot process more than one transaction at a time and the transaction associated with the previous message is not yet complete. Ensure that the caller has committed the transaction.
TraceCodeProcessMessage31Paused=Switched threads while processing a message for Contract '{0}' at Address '{1}'. Waiting for the completion of ReceiveContext acknowledgement. If your service seems to be not processing the message ensure that the channel implementation of receive context completes the operation.
TraceCodeProcessMessage4Paused=Switched threads while processing a message for Contract '{0}' at Address '{1}'. UseSynchronizationContext property on ServiceBehaviorAttribute is set to true, and SynchronizationContext.Current was non-null when opening ServiceHost.  If your service seems to be not processing messages, consider setting UseSynchronizationContext to false.
TraceCodeServiceOperationExceptionOnReply=Replying to an operation threw a exception.
TraceCodeServiceOperationMissingReply=The Request/Reply operation {0} has no Reply Message.
TraceCodeServiceOperationMissingReplyContext=The Request/Reply operation {0} has no IRequestContext to use for the reply.
TraceCodeServiceSecurityNegotiationCompleted=Service security negotiation completed.
TraceCodeSecuritySessionDemuxFailure=The incoming message is not part of an existing security session.
TraceCodeServiceHostCreation=Create ServiceHost.
TraceCodePortSharingClosed=The TransportManager was successfully closed.
TraceCodePortSharingDuplicatedPipe=A named pipe was successfully duplicated.
TraceCodePortSharingDuplicatedSocket=A socket was successfully duplicated.
TraceCodePortSharingDupHandleGranted=The PROCESS_DUP_HANDLE access right has been granted to the {0} service's account with SID '{1}'.
TraceCodePortSharingListening=The TransportManager is now successfully listening.
TraceCodeSkipBehavior=Behavior type is not of expected type
TraceCodeFailedAcceptFromPool=An attempt to reuse a pooled connection failed. Another attempt will be made with {0} remaining in the overall timeout.
TraceCodeFailedPipeConnect=An attempt to connect to the named pipe endpoint at '{1}' failed. Another attempt will be made with {0} remaining in the overall timeout.
TraceCodeSystemTimeResolution=The operating system's timer resolution was detected as {0} ticks, which is about {1} milliseconds.
TraceCodeRequestContextAbort=RequestContext aborted
TraceCodePipeConnectionAbort=PipeConnection aborted
TraceCodeSharedManagerServiceEndpointNotExist=The shared memory for the endpoint of the service '{0}' does not exist. The service may not be started.
TraceCodeSocketConnectionAbort=SocketConnection aborted
TraceCodeSocketConnectionAbortClose=SocketConnection aborted under Close
TraceCodeSocketConnectionClose=SocketConnection close
TraceCodeSocketConnectionCreate=SocketConnection create
TraceCodeSpnegoClientNegotiationCompleted=SpnegoTokenProvider completed SSPI negotiation.
TraceCodeSpnegoServiceNegotiationCompleted=SpnegoTokenAuthenticator completed SSPI negotiation.
TraceCodeSpnegoClientNegotiation=Client's outgoing SSPI negotiation.
TraceCodeSpnegoServiceNegotiation=Service's outgoing SSPI negotiation.
TraceCodeSslClientCertMissing=The remote SSL client failed to provide a required certificate.
TraceCodeStreamSecurityUpgradeAccepted=The stream security upgrade was accepted successfully.
TraceCodeTcpChannelMessageReceiveFailed=Failed to receive a message over TCP channel
TraceCodeTcpChannelMessageReceived=Received a message over TCP channel
TraceCodeUnderstoodMessageHeader=Understood message header.
TraceCodeUnhandledAction=No service available to handle this action
TraceCodeUnhandledExceptionInUserOperation=Unhandled exception in user operation '{0}.{1}'.
TraceCodeWebHostFailedToActivateService=Webhost could not activate service
TraceCodeWebHostFailedToCompile=Webhost couldn't compile service
TraceCodeWmiPut=Setting a value via WMI.
TraceCodeWsmexNonCriticalWsdlExportError=A non-critical error or warning occurred during WSDL Export
TraceCodeWsmexNonCriticalWsdlImportError=A non-critical error or warning occurred in the MetadataExchangeClient during WSDL Import This could result in some endpoints not being imported.
TraceCodeFailedToOpenIncomingChannel=An incoming channel was disposed because there was an error while attempting to open it.
TraceCodeTransportListen=Listen at '{0}'.
TraceCodeWsrmInvalidCreateSequence=An invalid create sequence message was received.
TraceCodeWsrmInvalidMessage=An invalid WS-RM message was received.
TraceCodeWsrmMaxPendingChannelsReached=An incoming create sequence request was rejected because the maximum pending channel count was reached.
TraceCodeWsrmMessageDropped=A message in a WS-RM sequence has been dropped because it could not be buffered.
TraceCodeWsrmNegativeElapsedTimeDetected=The reliable session infrastructure detected a system clock change. This will temporarily result in a less optimal message retry strategy.
TraceCodeWsrmReceiveAcknowledgement=WS-RM SequenceAcknowledgement received.
TraceCodeWsrmReceiveLastSequenceMessage=WS-RM Last Sequence message received.
TraceCodeWsrmReceiveSequenceMessage=WS-RM Sequence message received.
TraceCodeWsrmSendAcknowledgement=WS-RM SequenceAcknowledgement sent.
TraceCodeWsrmSendLastSequenceMessage=WS-RM Last Sequence message sent.
TraceCodeWsrmSendSequenceMessage=WS-RM Sequence message sent.
TraceCodeWsrmSequenceFaulted=A WS-RM sequence has faulted.
TraceCodeChannelConnectionDropped=Channel connection was dropped
TraceCodeAsyncCallbackThrewException=An async callback threw an exception!
TraceCodeMetadataExchangeClientSendRequest=The MetadataExchangeClient is sending a request for metadata.
TraceCodeMetadataExchangeClientReceiveReply=The MetadataExchangeClient received a reply.
TraceCodeWarnHelpPageEnabledNoBaseAddress=The ServiceDebugBehavior Help Page is enabled at a relative address and cannot be created because there is no base address.
TraceCodeTcpConnectError=The TCP connect operation failed.
TraceCodeTxSourceTxScopeRequiredIsTransactedTransport=The transaction '{0}' was received for operation '{1}' from a transacted transport, such as MSMQ.
TraceCodeTxSourceTxScopeRequiredIsTransactionFlow=The transaction '{0}' was flowed to operation '{1}'.
TraceCodeTxSourceTxScopeRequiredIsAttachedTransaction=The transaction '{0}' was received for operation '{1}' from an InstanceContext transaction.
TraceCodeTxSourceTxScopeRequiredUsingExistingTransaction=Existing transaction '{0}' being used for operation '{1}'.
TraceCodeTxCompletionStatusCompletedForAutocomplete=The transaction '{0}' for operation '{1}' was completed due to the TransactionAutoComplete OperationBehaviorAttribute member being set to true.
TraceCodeTxCompletionStatusCompletedForError=The transaction '{0}' for operation '{1}' was completed due to an unhandled execution exception.
TraceCodeTxCompletionStatusCompletedForSetComplete=The transaction '{0}' for operation '{1}' was completed due to a call to SetTransactionComplete.
TraceCodeTxCompletionStatusCompletedForTACOSC=The transaction '{0}' was completed when the session was closed due to the TransactionAutoCompleteOnSessionClose ServiceBehaviorAttribute member.
TraceCodeTxCompletionStatusCompletedForAsyncAbort=The transaction '{0}' for operation '{1}' was completed due to asynchronous abort.
TraceCodeTxCompletionStatusRemainsAttached=The transaction '{0}' for operation '{1}' remains attached to the InstanceContext.
TraceCodeTxCompletionStatusAbortedOnSessionClose=The transaction '{0}' was aborted because it was uncompleted when the session was closed and the TransactionAutoCompleteOnSessionClose OperationBehaviorAttribute was set to false.
TraceCodeTxReleaseServiceInstanceOnCompletion=The service instance was released on the completion of the transaction '{0}' because the ReleaseServiceInstanceOnTransactionComplete ServiceBehaviorAttribute was set to true.
TraceCodeTxAsyncAbort=The transaction '{0}' was asynchronously aborted.
TraceCodeTxFailedToNegotiateOleTx=The OleTransactions protocol negotiation failed for coordination context '{0}'.
TraceCodeTxSourceTxScopeRequiredIsCreateNewTransaction=The transaction '{0}' for operation '{1}' was newly created.

;
;CfxGreen TraceCodes
;
TraceCodeActivatingMessageReceived=Activating message received.
TraceCodeDICPInstanceContextCached=InstanceContext cached for InstanceId {0}.
TraceCodeDICPInstanceContextRemovedFromCache=InstanceContext for InstanceId {0} removed from cache.
TraceCodeInstanceContextBoundToDurableInstance=DurableInstance's InstanceContext refcount incremented.
TraceCodeInstanceContextDetachedFromDurableInstance=DurableInstance's InstanceContext refcount decremented.
TraceCodeContextChannelFactoryChannelCreated=ContextChannel created.
TraceCodeContextChannelListenerChannelAccepted=A new ContextChannel was accepted.
TraceCodeContextProtocolContextAddedToMessage=Context added to Message.
TraceCodeContextProtocolContextRetrievedFromMessage=Context retrieved from Message.
TraceCodeWorkflowServiceHostCreated=WorkflowServiceHost created.
TraceCodeServiceDurableInstanceDeleted=ServiceDurableInstance '{0}' deleted from persistence store.
TraceCodeServiceDurableInstanceDisposed=ServiceDurableInstance '{0}' disposed.
TraceCodeServiceDurableInstanceLoaded=ServiceDurableInstance loaded from persistence store.
TraceCodeServiceDurableInstanceSaved=ServiceDurableInstance saved to persistence store.
TraceCodeWorkflowDurableInstanceLoaded=WorkflowDurableInstance '{0}' loaded.
TraceCodeWorkflowDurableInstanceActivated=WorkflowDurableInstance '{0}' activated.
TraceCodeWorkflowDurableInstanceAborted=WorkflowDurableInstance aborted.
TraceCodeWorkflowOperationInvokerItemQueued=Work item enqueued.
TraceCodeWorkflowRequestContextReplySent=Reply sent for InstanceId {0}.
TraceCodeWorkflowRequestContextFaultSent=Fault Sent for InstanceId {0}.
TraceCodeSqlPersistenceProviderSQLCallStart=Sql execution started.
TraceCodeSqlPersistenceProviderSQLCallEnd=Sql execution complete.
TraceCodeSqlPersistenceProviderOpenParameters=SqlPersistenceProvider.Open() parameters.
TraceCodeSyncContextSchedulerServiceTimerCancelled=SynchronizationContextWorkflowSchedulerService - Timer {0} cancelled.
TraceCodeSyncContextSchedulerServiceTimerCreated=SynchronizationContextWorkflowSchedulerService - Timer {0} created for InstanceId {1}.
TraceCodeSyndicationReadFeedBegin=Reading of a syndication feed started.
TraceCodeSyndicationReadFeedEnd=Reading of a syndication feed completed.
TraceCodeSyndicationReadItemBegin=Reading of a syndication item started.
TraceCodeSyndicationReadItemEnd=Reading of a syndication item completed.
TraceCodeSyndicationWriteFeedBegin=Writing of a syndication feed started.
TraceCodeSyndicationWriteFeedEnd=Writing of a syndication feed completed.
TraceCodeSyndicationWriteItemBegin=Writing of a syndication item started.
TraceCodeSyndicationWriteItemEnd=Writing of a syndication item completed.
TraceCodeSyndicationProtocolElementIgnoredOnWrite=Syndication element with name '{0}' and namespace '{1}' was not written.
TraceCodeSyndicationProtocolElementInvalid=Syndication element with name '{0}' and namespace '{1}' is invalid.
TraceCodeWebUnknownQueryParameterIgnored=HTTP query string parameter with name '{0}' was ignored.
TraceCodeWebRequestMatchesOperation=Incoming HTTP request with URI '{0}' matched operation '{1}'.
TraceCodeWebRequestDoesNotMatchOperations=Incoming HTTP request with URI '{0}' does not match any operation.
;
; UriTemplate strings
;
UTTMustBeAbsolute=Parameter 'baseAddress' must an absolute uri.
UTTBaseAddressMustBeAbsolute=BaseAddress must an absolute uri.
UTTCannotChangeBaseAddress=Cannot change BaseAddress after calling MakeReadOnly.
UTTMultipleMatches=There were multiple UriTemplateMatch results, but MatchSingle was called.
UTTBaseAddressNotSet=BaseAddress has not been set. Set the BaseAddress property before calling MakeReadOnly, Match, or MatchSingle.
UTTEmptyKeyValuePairs=KeyValuePairs must have at least one element.
UTBindByPositionWrongCount=UriTemplate '{0}' contains {1} path variables and {2} query variables but {3} values were passed to the BindByPosition method. The number of values passed to BindByPosition should be greater than or equal to the number of path variables in the template and cannot be greater than the total number of variables in the template.
UTBadBaseAddress=baseAddress must an absolute Uri.
UTQueryNamesMustBeUnique=The UriTemplate '{0}' is not valid; each portion of the query string must be of the form 'name' or of the form 'name=value', where each name is unique. Note that the names are case-insensitive. See the documentation for UriTemplate for more details.
UTQueryCannotEndInAmpersand=The UriTemplate '{0}' is not valid; the query string cannot end with '&amp;'. See the documentation for UriTemplate for more details.
UTQueryCannotHaveEmptyName=The UriTemplate '{0}' is not valid; each portion of the query string must be of the form 'name' or of the form 'name=value'. See the documentation for UriTemplate for more details.
UTVarNamesMustBeUnique=The UriTemplate '{0}' is not valid; the UriTemplate variable named '{1}' appears multiple times in the template. Note that UriTemplate variable names are case-insensitive. See the documentation for UriTemplate for more details.
UTTAmbiguousQueries=UriTemplateTable does not support '{0}' and '{1}' since they are not equivalent, but cannot be disambiguated because they have equivalent paths and the same common literal values for the query string. See the documentation for UriTemplateTable for more detail.
UTTOtherAmbiguousQueries=UriTemplateTable does not support multiple templates that have equivalent path as template '{0}' but have different query strings, where the query strings cannot all be disambiguated via literal values. See the documentation for UriTemplateTable for more detail.
UTTDuplicate=UriTemplateTable (with allowDuplicateEquivalentUriTemplates = false) does not support both '{0}' and '{1}', since they are equivalent. Call MakeReadOnly with allowDuplicateEquivalentUriTemplates = true to use both of these UriTemplates in the same table. See the documentation for UriTemplateTable for more detail.
UTInvalidFormatSegmentOrQueryPart=UriTemplate does not support '{0}' as a valid format for a segment or a query part.
BindUriTemplateToNullOrEmptyPathParam=The path variable '{0}' in the UriTemplate must be bound to a non-empty string value.
UTBindByPositionNoVariables=UriTemplate '{0}' contains no variables; yet the BindByPosition method was called with {1} values.
UTCSRLookupBeforeMatch=UTCSR - Lookup was called before match
UTDoesNotSupportAdjacentVarsInCompoundSegment=The UriTemplate '{0}' is not valid; UriTemplate does not support two adjacent variables with no literal in compound segments, such as in the segment '{1}'.
UTQueryCannotHaveCompoundValue=The UriTemplate '{0}' is not valid; each portion of the query string must be of the form 'name=value', when value cannot be a compound segment. See the documentation for UriTemplate for more details.
UTQueryMustHaveLiteralNames=The UriTemplate '{0}' is not valid; each portion of the query string must be of the form 'name' or of the form 'name=value', where name is a simple literal. See the documentation for UriTemplate for more details.
UTAdditionalDefaultIsInvalid=Changing an inline default value with information from the additional default values is not supported; the default value to the variable '{0}' was already provided as part of the UriTemplate '{1}'. See the documentation for UriTemplate for more details.
UTDefaultValuesAreImmutable=The default values of UriTemplate are immutable; they cannot be modified after the construction of the UriTemplate instance. See the documentation of UriTemplate for more details.
UTDefaultValueToCompoundSegmentVar=The UriTemplate '{0}' is not valid; the UriTemplate compound path segment '{1}' provides a default value to variable '{2}'. Note that UriTemplate doesn't support default values to variables in compound segments. See the documentation for UriTemplate for more details.
UTDefaultValueToQueryVar=The UriTemplate '{0}' is not valid; the UriTemplate variable declaration '{1}' provides a default value to query variable '{2}'. Note that UriTemplate doesn't support default values to query variables. See the documentation for UriTemplate for more details.
UTInvalidDefaultPathValue=The UriTemplate '{0}' is not valid; the UriTemplate variable declaration '{1}' provides an empty default value to path variable '{2}'. Note that UriTemplate path variables cannot be bound to a null or empty value. See the documentation for UriTemplate for more details.
UTInvalidVarDeclaration=The UriTemplate '{0}' is not valid; the UriTemplate variable declaration '{1}' isn't a valid variable construct. Note that UriTemplate variable definitions are either a simple, non-empty, variable name or a 'name=value' format, where the name must not be empty and the value provides a default value to the variable. See the documentation for UriTemplate for more details.
UTInvalidWildcardInVariableOrLiteral=The UriTemplate '{0}' is not valid; the wildcard ('{1}') cannot appear in a variable name or literal, unless as a construct for a wildcard segment. Note that a wildcard segment, either a literal or a variable, is valid only as the last path segment in the template; the wildcard can appear only once. See the documentation for UriTemplate for more details.
UTStarVariableWithDefaults=The UriTemplate '{0}' is not valid; the UriTemplate last path segment '{1}' provides a default value to final star variable '{2}'. Note that UriTemplate doesn't support default values to final star variable. See the documentation for UriTemplate for more details.
UTDefaultValueToCompoundSegmentVarFromAdditionalDefaults=The UriTemplate '{0}' is not valid; the path variable '{1}', defined as part of a compound path segment has been provided with a default value as part of the additional defaults. Note that UriTemplate doesn't support default values to variables in compound segments. See the documentation for UriTemplate for more details.
UTDefaultValueToQueryVarFromAdditionalDefaults=The UriTemplate '{0}' is not valid; the query variable '{1}' has been provided a default value as part of the additional defaults. Note that UriTemplate doesn't support default values to query variables. See the documentation for UriTemplate for more details.
UTNullableDefaultAtAdditionalDefaults=The UriTemplate '{0}' is not valid; the additional default value '{1}' has a null value as default value. Note that null default values must be only provided to concrete path variables. See the documentation for UriTemplate for more details.
UTNullableDefaultMustBeFollowedWithNullables=The UriTemplate '{0}' is not valid; the UriTemplate path variable '{1}' has a null default value while following path variable '{2}' has no defaults or provides a non-null default value. Note that UriTemplate path variable with null default value must be followed only with other path variables with null defaulted values. See the documentation for UriTemplate for more details.
UTNullableDefaultMustNotBeFollowedWithLiteral=The UriTemplate '{0}' is not valid; the UriTemplate path variable '{1}' has a null default value while the following path segment '{2}' is not a variable segment with a null default value. Note that UriTemplate path variable with null default values must be followed only with other path variables with null defaulted value. See the documentation for UriTemplate for more details.
UTNullableDefaultMustNotBeFollowedWithWildcard=The UriTemplate '{0}' is not valid; the UriTemplate path variable '{1}' has a null default value while the template is finished with a wildcard. Note that UriTemplate path variable with null default values must be followed only with other path variables with null defaulted value. See the documentation for UriTemplate for more details.
UTStarVariableWithDefaultsFromAdditionalDefaults=The UriTemplate '{0}' is not valid; the UriTemplate final star variable '{1}' has been provides a default value as part of the additional defaults information. Note that UriTemplate doesn't support default values to final star variable. See the documentation for UriTemplate for more details.
UTTInvalidTemplateKey=An invalid template '{0}' was passed as the key in a pair of template and its associated object. UriTemplateTable Key-Value pairs must always contain a valid UriTemplate object as key; note that UriTemplateTable doesn't support templates that are ignoring the trailing slash in respect to matching. See the documentation for UriTemplateTable for more details.
UTTNullTemplateKey=A null UriTemplate was passed as the key in a pair of template and its associated object. UriTemplateTable Key-Value pairs must always contain a valid UriTemplate object as key. See the documentation for UriTemplateTable for more details.
UTBindByNameCalledWithEmptyKey=The BindByName method of UriTemplate was called with an empty name in the collection of arguments for the bind. Note that the NameValueCollection or the Dictionary passed to BindByName cannot contain an empty (or null) name as a key. See the documentation of UriTemplate for more details.
UTBothLiteralAndNameValueCollectionKey=The UriTemplate contains a literal value for query key '{0}', but that key also is present in the NameValueCollection. Either remove that key from the NameValueCollection, or else change the UriTemplate to not have a query literal for that key.
;
; Syndication strings
;
ExtensionNameNotSpecified=The name of the extension element must be specified.
UnsupportedRssVersion=The Rss20Serializer does not support RSS version '{0}'.
Atom10SpecRequiresTextConstruct=The Atom10 specification requires '{0}' to have one of these values: \"text\", \"html\", \"xhtml\", however this value is '{1}' in the document being deserialized.
ErrorInLine=Error in line {0} position {1}.
ErrorParsingFeed=An error was encountered when parsing the feed's XML. Refer to the inner exception for more details.
ErrorParsingDocument=An error was encountered when parsing the document's XML. Refer to the inner exception for more details.
ErrorParsingItem=An error was encountered when parsing the item's XML. Refer to the inner exception for more details.
ErrorParsingDateTime=An error was encountered when parsing a DateTime value in the XML.
OuterElementNameNotSpecified=The outer element name must be specified.
UnknownFeedXml=The element with name '{0}' and namespace '{1}' is not an allowed feed format.
UnknownDocumentXml=The element with name '{0}' and namespace '{1}' is not an allowed document format.
UnknownItemXml=The element with name '{0}' and namespace '{1}' is not an allowed item format.
FeedFormatterDoesNotHaveFeed=The syndication feed formatter must be configured with a syndication feed.
DocumentFormatterDoesNotHaveDocument=The document formatter must be configured with a document.
ItemFormatterDoesNotHaveItem=The syndication item formatter must be configured with a syndication item.
UnbufferedItemsCannotBeCloned=A feed containing items that are not buffered (i.e. the items are not stored in an IList) cannot clone its items. Buffer the items in the feed before calling Clone on it or pass false to the Clone method.
FeedHasNonContiguousItems=The feed being deserialized has non-contiguous sets of items in it. This is not supported by '{0}'.
FeedCreatedNullCategory=The feed created a null category.
ItemCreatedNullCategory=The item created a null category.
FeedCreatedNullPerson=The feed created a null person.
ItemCreatedNullPerson=The item created a null person.
FeedCreatedNullItem==The feed created a null item.
TraceCodeSyndicationFeedReadBegin=Reading of a syndication feed started.
TraceCodeSyndicationFeedReadEnd=Reading of a syndication feed completed.
TraceCodeSyndicationItemReadBegin=Reading of a syndication item started.
TraceCodeSyndicationItemReadEnd=Reading of a syndication item completed.
TraceCodeSyndicationFeedWriteBegin=Writing of a syndication feed started.
TraceCodeSyndicationFeedWriteEnd=Writing of a syndication feed completed.
TraceCodeSyndicationItemWriteBegin=Writing of a syndication item started.
TraceCodeSyndicationItemWriteEnd=Writing of a syndication item completed.
TraceCodeSyndicationProtocolElementIgnoredOnRead=Syndication XML node of type '{0}' with name '{1}' and namespace '{2}' ignored on read.
TraceCodeSyndicationReadServiceDocumentBegin=Reading of a service document started.
TraceCodeSyndicationReadServiceDocumentEnd=Reading of a service document completed.
TraceCodeSyndicationWriteServiceDocumentBegin=Writing of a service document started.
TraceCodeSyndicationWriteServiceDocumentEnd=Writing of a service document completed.
TraceCodeSyndicationReadCategoriesDocumentBegin=Reading of a categories document started.
TraceCodeSyndicationReadCategoriesDocumentEnd=Reading of a categories document completed.
TraceCodeSyndicationWriteCategoriesDocumentBegin=Writing of a categories document started.
TraceCodeSyndicationWriteCategoriesDocumentEnd=Writing of a categories document completed.
FeedAuthorsIgnoredOnWrite=The feed's authors were not serialized as part of serializing the feed in RSS 2.0 format.
FeedContributorsIgnoredOnWrite=The feed's contributors were not serialized as part of serializing the feed in RSS 2.0 format.
FeedIdIgnoredOnWrite=The feed's id was not serialized as part of serializing the feed in RSS 2.0 format.
FeedLinksIgnoredOnWrite=The feed's links were not serialized as part of serializing the feed in RSS 2.0 format.
ItemAuthorsIgnoredOnWrite=The item's authors were not serialized as part of serializing the feed in RSS 2.0 format.
ItemContributorsIgnoredOnWrite=The item's contributors were not serialized as part of serializing the feed in RSS 2.0 format.
ItemLinksIgnoredOnWrite=The item's links were not serialized as part of serializing the feed in RSS 2.0 format.
ItemCopyrightIgnoredOnWrite=The item's copyrights were not serialized as part of serializing the feed in RSS 2.0 format.
ItemContentIgnoredOnWrite=The item's content was not serialized as part of serializing the feed in RSS 2.0 format.
ItemLastUpdatedTimeIgnoredOnWrite=The item's last updated time was not serialized as part of serializing the feed in RSS 2.0 format.
OuterNameOfElementExtensionEmpty=The outer name of the element extension cannot be empty.
InvalidObjectTypePassed=The Type of object passed as parameter '{0}' is not derived from {1}. Ensure that the type of object passed is either of type {1} or derived from {1}.
UnableToImpersonateWhileSerializingReponse=Failed to impersonate client identity during serialization of the response message.
XmlLineInfo=Line {0}, position {1}.
XmlFoundEndOfFile=end of file
XmlFoundElement=element '{0}' from namespace '{1}'
XmlFoundEndElement=end element '{0}' from namespace '{1}'
XmlFoundText=text '{0}'
XmlFoundCData=cdata '{0}'
XmlFoundComment=comment '{0}'
XmlFoundNodeType=node {0}
XmlStartElementExpected=Start element expected. Found {0}.
;
; Single WSDL Strings
;
SingleWsdlNotGenerated=A single WSDL document could not be generated for this service. Multiple service contract namespaces were found ({0}). Ensure that all your service contracts have the same namespace.
SFxDocExt_MainPageIntroSingleWsdl=You can also access the service description as a single file:
;
; Task-based asynchronous method Strings
;
TaskMethodParameterNotSupported=The use of '{0}' on the task-based asynchronous method is not supported.
TaskMethodMustNotHaveOutParameter=Client side task-based asynchronous method must not have any out or ref parameters. Any data that would have been returned through an out or ref parameter should instead be returned as part of the TResult in the resulting task.
SFxCannotImportAsParameters_OutputParameterAndTask=Generating message contract since the operation has multiple return values.




;
; WIF (Windows Identity Foundation)
;
ID0020=ID0020: The collection is empty.
ID2004=ID2004: IAsyncResult must be the AsyncResult instance returned from the Begin call. The runtime is expecting '{0}', and the actual type is '{1}'.
ID3002=ID3002: WSTrustServiceContract could not create a SecurityTokenService instance from WSTrustServiceContract.SecurityTokenServiceConfiguration.
ID3004=ID3004: Cannot obtain the schema for namespace: '{0}'.
ID3022=ID3022: The WSTrustServiceContract only supports receiving RequestSecurityToken messages. If you need to support more message types, override the WSTrustServiceContract.DispatchRequest method.
ID3023=ID3023: The WSTrustServiceContract only supports receiving RequestSecurityToken messages asynchronously. If you need to support more message types, override the WSTrustServiceContract.BeginDispatchRequest and EndDispatchRequest.
ID3097=ID3097: ServiceHost does not contain any valid Endpoints. Add at least one valid endpoint in the SecurityTokenServiceConfiguration.TrustEndpoints collection.
ID3112=ID3112: Unrecognized RequestType '{0}' specified in the incoming request.
ID3113=ID3113: The WSTrustServiceContract does not support receiving '{0}' messages with the '{1}' SOAP action. If you need to support this, override the ValidateDispatchContext method.
ID3114=ID3114: The WSTrustServiceContract cannot deserialize the WS-Trust request.
ID3137=ID3137: The TrustVersion '{0}', is not supported, only 'TrustVersion.WSTrust13' and 'TrustVersion.WSTrustFeb2005' is supported.
ID3138=ID3138: The RequestSecurityTokenResponse that was received did not contain a SecurityToken.
ID3139=ID3139: The WSTrustChannel cannot compute a proof key. The KeyType '{0}' is not supported. Valid proof key types supported by the WSTrustChannel are WSTrust13 and WSTrustFeb2005.
ID3140=ID3140: Specify one or more BaseAddresses to enable metadata or set DisableWsdl to true in the SecurityTokenServiceConfiguration.
ID3141=ID3141: The RequestType '{0}', is not supported. If you need to support this RequestType, override the corresponding virtual method in your SecurityTokenService derived class.
ID3144=ID3144: The PortType '{0}' Operation '{1}' has Message '{2}' is expected to have only one part but contains '{3}'.
ID3146=ID3146: WsdlEndpointConversionContext.WsdlPort cannot be null.
ID3147=ID3147: WsdlEndpointConversionContext.WsdlPort.Service cannot be null.
ID3148=ID3148: WsdlEndpointConversionContext.WsdlPort.Service.ServiceDescription cannot be null.
ID3149=ID3149: Cannot find an input message type for PortType '({0}, {1})' for operation '{2}' in the given ServiceDescription.
ID3150=ID3150: Cannot find an output message type for PortType '({0}, {1})' for operation '{2}' in the given ServiceDescription.
ID3190=ID3190: The WSTrustChannel cannot compute a proof key without a valid SecurityToken set as the RequestSecurityToken.UseKey when the RequestSecurityToken.KeyType is '{0}'.
ID3191=ID3191: The WSTrustChannel received a RequestedSecurityTokenResponse message containing an Entropy without a ComputedKeyAlgorithm.
ID3192=ID3192: The WSTrustChannel cannot compute a proof key. The received RequestedSecurityTokenResponse does not contain a RequestedProofToken and the ComputedKeyAlgorithm specified in the response is not supported: '{0}'.
ID3193=ID3193: The WSTrustChannel cannot compute a proof key. The received RequestedSecurityTokenResponse indicates that the proof key is computed using combined entropy. However, the response does not include an entropy.
ID3194=ID3194: The WSTrustChannel cannot compute a proof key. The received RequestedSecurityTokenResponse indicates that the proof key is computed using combined entropy. However, the request does not include an entropy.
ID3269=ID3269: Cannot determine the TrustVersion. It must either be specified explicitly, or a SecurityBindingElement must be present in the binding.
ID3270=ID3270: The WSTrustChannel does not support multi-leg issuance protocols. The RSTR received from the STS must be enclosed in a RequestSecurityTokenResponseCollection element.
ID3285=ID3285: The WS-Trust operation '{0}' is not valid or unsupported.
ID3286=ID3286: The 'inner' parameter must implement the 'System.ServiceModel.Channels.IChannel' interface.
ID3287=ID3287: WSTrustChannelFactory does not support changing the value of this property after a channel is created.
ID4008=ID4008: '{0}' does not provide an implementation for '{1}'.
ID4039=ID4039: A custom ServiceAuthorizationManager has been configured. Any custom ServiceAuthorizationManager must be derived from IdentityModelServiceAuthorizationManager.
ID4041=ID4041: Cannot configure the ServiceHost '{0}'. The ServiceHost is in a bad state and cannot be configured.
ID4053=ID4053: The token has WS-SecureConversation version '{0}'.  Version '{1}' was expected.
ID4072=ID4072: The SecurityTokenHandler '{0}' registered for TokenType '{1}' must derive from '{2}'.
ID4101=ID4101: The token cannot be validated because it is not a SamlSecurityToken or a Saml2SecurityToken. Token type: '{0}'
ID4192=ID4192: The reader is not positioned on a KeyInfo element that can be read.
ID4240=ID4240: The tokenRequirement must derived from 'RecipientServiceModelSecurityTokenRequirement' for SecureConversationSecurityTokens. The tokenRequirement is of type '{0}'.
ID4244=ID4244: Internal error: sessionAuthenticator must support IIssuanceSecurityTokenAuthenticator.
ID4245=ID4245: Internal error: sessionAuthenticator must support ICommunicationObject.
ID4268=ID4268: MergeClaims must have at least one identity that is not null.
ID4271=ID4271: No IAuthorizationPolicy was found for the Transport security token '{0}'.
ID4274=ID4274: The Configuration property of this SecurityTokenHandler is set to null. Tokens cannot be read or validated in this state. Set this property or add this SecurityTokenHandler to a SecurityTokenHandlerCollection with a valid Configuration property.
ID4285=ID4285: Cannot replace SecurityToken with Id '{0}' in cache with new one. Token must exist in cache to be replaced.
ID4287=ID4287: The SecurityTokenRequirement '{0}' doesn't contain a ListenUri.
ID5004=ID5004: Unrecognized namespace: '{0}'.

TraceAuthorize=Authorize
TraceOnAuthorizeRequestFailed=OnAuthorizeRequest Failed.
TraceOnAuthorizeRequestSucceed=OnAuthorizeRequest Succeeded.



;WIF resource strings
;ID3024=AuthFailed
AuthFailed=Authentication failed.
;ID3266=DuplicateFederatedClientCredentialsParameters
DuplicateFederatedClientCredentialsParameters=The IssuedSecurityTokenProvider cannot support the FederatedClientCredentialsParameters. The FederatedClientCredentialsParameters has already provided the '{0}' parameter.
;ID3137=UnsupportedTrustVersion
UnsupportedTrustVersion=The TrustVersion '{0}', is not supported, only 'TrustVersion.WSTrust13' and 'TrustVersion.WSTrustFeb2005' is supported.

;HttpPipeline
InputMustBeDelegatingHandlerElementError=The input {0} must be a '{1}' object.
InputTypeListEmptyError=The input handler list cannot be empty.
DelegatingHandlerArrayHasNonNullInnerHandler=The '{0}' list is invalid because the property '{1}' of '{2}' is not null.
DelegatingHandlerArrayFromFuncContainsNullItem=The '{0}' list created by the Func '{1}' is invalid because it contains one or more null items.
HttpMessageHandlerFactoryConfigInvalid_WithBothTypeAndHandlerList=The config element '{0}' is invalid because the attribute '{1}' and the sub element '{2}' were both specified. These are mutually exclusive items and cannot be used simultaneouly.
HttpMessageHandlerFactoryWithFuncCannotGenerateConfig=This '{0}' object cannot be used to generate configuration because it was created with the constructor that takes a '{1}' as the paramter.  This functionality is not supported through configuration files.  Please use a different constructor if you wish to generate a configuration file.
HttpMessageHandlerTypeNotSupported=Invalid type: '{0}'. It must inherit from base type '{1}', cannot be abstract, and must expose a public default constructor.
HttpMessageHandlerChannelFactoryNullPipeline='{0}' cannot return a null '{1}' instance. Please ensure that '{0}' returns a valid '{1}' instance.
HttpPipelineOperationCanceledError=HTTP pipeline operation cancelled.
HttpPipelineMessagePropertyMissingError=The message property '{0}' is missing in the HttpRequestMessage. Please make sure this property not removed or changed from the properties of the HttpRequestMessage. If you are creating a new HttpRequestMessage, please copy this property from the old message to the new one.
HttpPipelineMessagePropertyTypeError=The message property '{0}' inside the HttpRequestMessage is not with expected type '{1}'. Please make sure this property not removed or changed from the properties of the HttpRequestMessage. If you are creating a new HttpRequestMessage, please copy this property from the old message to the new one.
InvalidContentTypeError=The value '{0}' is not a valid content type.
HttpPipelineNotSupportedOnClientSide=The property '{0}' is not supported when building a ChannelFactory. The property value must be null when calling BuildChannelFactory.
CanNotLoadTypeGotFromConfig=Cound not load type '{0}' from the assemblies in current AppDomain.
HttpPipelineNotSupportNullResponseMessage=The HTTP response message should not be null. Please ensure your '{0}' instance returns a non-null '{1}' object.

;WebSocket
WebSocketInvalidProtocolNoHeader=The subprotocol '{0}' was not requested by the client - no '{1}' header was included in the request.
WebSocketInvalidProtocolNotInClientList=The subprotocol '{0}' was not requested by the client. The client requested the following subprotocol(s): '{1}'.
WebSocketInvalidProtocolInvalidCharInProtocolString=The subprotocol '{0}' is invalid because it contains the invalid character '{1}'.
WebSocketInvalidProtocolContainsMultipleSubProtocolString=The value specified ('{0}') contains more than one subprotocol which is not supported.
WebSocketInvalidProtocolEmptySubprotocolString=Empty string is not a valid subprotocol value. Please use "null" to specify no value.
WebSocketOpaqueStreamContentNotSupportError=This method is not supported for this HTTP content.
WebSocketElementConfigInvalidHttpMessageHandlerFactoryType=Invalid value for the {0} type. The type '{1}' does not derive from the appropriate base class '{2}' or is abstract.
WebSocketEndpointOnlySupportWebSocketError=This service only supports WebSocket connections.
WebSocketEndpointDoesNotSupportWebSocketError=This service does not support WebSocket connections.
WebSocketUpgradeFailedError=WebSocket upgrade request failed. Received response status code '{0} ({1})', expected: '{2} ({3})'.
WebSocketUpgradeFailedHeaderMissingError=WebSocket upgrade request failed. The header '{0}' is missing in the response.
WebSocketUpgradeFailedWrongHeaderError=WebSocket upgrade request failed. The value of header '{0}' is '{1}'. The expected value is '{2}'.
WebSocketUpgradeFailedInvalidProtocolError=Unexpected response - the server accepted the upgrade request but specified the subprotocol '{0}' when no subprotocol was requested.
WebSocketContextWebSocketCannotBeAccessedError=WebSocket object cannot be accessed directly.
WebSocketTransportError=A WebSocket error occurred.
WebSocketUnexpectedCloseMessageError=Unexpected WebSocket close message received when receiving a message.
WebSocketStreamWriteCalledAfterEOMSent=Cannot write to the stream because the end of the stream marker was already written.
WebSocketCannotCreateRequestClientChannelWithCertainWebSocketTransportUsage=HttpChannelFactory cannot create the channel with shape '{0}' when the {1} of {2} was set as '{3}'.
WebSocketMaxPendingConnectionsReached=Maximum number of pending WebSocket connections ({0}) has been reached. Consider increasing the '{1}' quota on the '{2}' property of the transport.
WebSocketOpeningHandshakePropertiesNotAvailable=The opening handshake properties associated with the current WebSocket connection are not available. The most likely cause is that the property '{0}' on the '{1}' object returned from the custom '{2}' is not set.
AcceptWebSocketTimedOutError=The operation to establish the WebSocket connection timed out. To increase this time limit, use the OpenTimeout property on the service endpoint's binding.
TaskCancelledError=The task was cancelled.
ClientWebSocketFactory_GetWebSocketVersionFailed=An error occured when getting the WebSocketVersion from the WebSocket factory of type '{0}'. See the inner exception for details.
ClientWebSocketFactory_InvalidWebSocketVersion=The WebSocketVersion returned by the WebSocket factory of type '{0}' is either null, empty or invalid.
ClientWebSocketFactory_CreateWebSocketFailed=An error occurred when creating the WebSocket with the factory of type '{0}'. See the inner exception for details.
ClientWebSocketFactory_InvalidWebSocket=WebSocket creation failed. The '{0}' returned a WebSocket that is either null or not opened.
ClientWebSocketFactory_InvalidSubProtocol=The WebSocket returned by the factory of type '{0}' has the SubProtocol '{1}' that doesn't match the requested SubProtocol value '{2}'.
MultipleClientWebSocketFactoriesSpecified=The '{0}' contains multiple '{1}' objects, which is invalid. At most one '{1}' should be specified.
WebSocketSendTimedOut=The Send operation timed out after '{0}'. Increase the SendTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.
WebSocketReceiveTimedOut=The Receive operation timed out after '{0}'. For duplex sessionful channels, the receive timeout is also the idle timeout for the channel, so consider setting a suitably large value for the ReceiveTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.
WebSocketOperationTimedOut=The '{0}' operation timed out after '{1}'. The time allotted to this operation may have been a portion of a longer timeout.
WebSocketsServerSideNotSupported=This platform does not support server side WebSockets.
WebSocketsClientSideNotSupported=This platform does not support client side WebSockets natively. Support for client side WebSockets can be enabled on this platform by providing an implementation of {0}.
WebSocketsNotSupportedInClassicPipeline=WebSockets are not supported in the classic pipeline mode. Consider using the integrated pipeline mode for the application pool.
WebSocketModuleNotLoaded=The WebSocketModule is not loaded. Check if the WebSocket feature is installed and the WebSocketModule is enabled in the list of IIS modules (see http://go.microsoft.com/fwlink/?LinkId=231398 for details).
WebSocketTransportPolicyAssertionInvalid=The name of the policy being imported for contract '{0}:{1}' is invalid:'{2}'. It should be either '{3}', '{4}' or '{5}'.
WebSocketVersionMismatchFromServer=The server didn't accept the connection request. It is possible that the WebSocket protocol version on your client doesn't match the one on the server('{0}').
WebSocketSubProtocolMismatchFromServer=The server didn't accept the connection request. It is possible that the WebSocket subprotocol sent by your client is not supported by the server. Protocol(s) supported by the server are '{0}'.
WebSocketContentTypeMismatchFromServer=The server didn't accept the connection request. It is possible that the client side message encoding format doesn't match the setting on the server side. Please check your binding settings.
WebSocketContentTypeAndTransferModeMismatchFromServer=The server didn't accept the connection request. It is possible that the client side message encoding format or message transfer mode doesn't match the setting on the server side. Please check your binding settings.

;HttpMessage
ResponseHeaderWithRequestHeadersCollection=This collection holds request headers and cannot contain the specified response header '{0}'.
RequestHeaderWithResponseHeadersCollection=This collection holds response headers and cannot contain the specified request header '{0}'.
MessageVersionNoneRequiredForHttpMessageSupport=Support for {0} and {1} can not be enabled with {2} when the {3} of the {4} is '{5}'.  Ensure the {4} used with the binding has a {3} of '{6}'. 
; copied for code cloned from WebHeaderCollection
WebHeaderEnumOperationCantHappen=Enumeration has either not started or has already finished.
WebHeaderEmptyStringCall=The parameter '{0}' cannot be an empty string.
WebHeaderInvalidControlChars=Specified value has invalid Control characters.
WebHeaderInvalidCRLFChars=Specified value has invalid CRLF characters.
WebHeaderInvalidHeaderChars=Specified value has invalid HTTP Header characters.
WebHeaderInvalidNonAsciiChars=Specified value has invalid non-ASCII characters.
WebHeaderArgumentOutOfRange=Specified argument was out of the range of valid values.
CopyHttpHeaderFailed=Failed to copy the HTTP header '{0}' with value '{1}' to '{2}'.
