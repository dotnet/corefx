// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

#include <assert.h>
#include <errno.h>
#include <fcntl.h>
#include <sched.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <time.h>
#include <unistd.h>

#include "pal_config.h"
#include "pal_random.h"

#if defined(__linux__)
#include <sys/syscall.h>
#if defined(SYS_getrandom)
# define PAL_GRND_NONBLOCK 1
#endif // SYS_getrandom
#endif // __linux__

/*

Generate random bytes. The generated bytes are not cryptographically strong.

*/

#if !HAVE_ARC4RANDOM_BUF
static int GetUrandomFileDescriptor(void)
{
    static int fd = -1;
    int newFd;

    if (fd >= 0)
    {
        return fd;
    }

    do
    {
#if HAVE_O_CLOEXEC
        newFd = open("/dev/urandom", O_RDONLY | O_CLOEXEC);
#else
        newFd = open("/dev/urandom", O_RDONLY);
        fcntl(newFd, F_SETFD, FD_CLOEXEC);
#endif
    }
    while ((newFd == -1) && (errno == EINTR));

    int unsetFd = -1;
    if (!__atomic_compare_exchange_n(&fd, &unsetFd, newFd, false, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST))
    {
        close(newFd);
    }

    return fd;
}

static void XorWithLrand48(uint8_t *buffer, int32_t bufferLength)
{
    static bool sInitializedLrand;
    size_t length = (size_t)bufferLength;

    if (!sInitializedLrand)
    {
        bool lRandUninitialized = false;

        if (__atomic_compare_exchange_n(&sInitializedLrand, &lRandUninitialized, true, false,
                                        __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST))
        {
            // TODO(38034): There's not enough entropy in time(NULL) to seed the
            // PRNG.
            srand48(time(NULL));
        }
        else
        {
            // Setting the flag and initializing srand should be quick, so
            // if we lose the race, it's very unlikely this will spin for
            // too much time.
            while (!__atomic_load_n(&sInitializedLrand, __ATOMIC_SEQ_CST))
            {
                sched_yield();
            }
        }
    }

    uint32_t randNum, bufferSlice;

    while (length >= sizeof(uint32_t))
    {
        // lrand48(3) generates a random number in the interval [0, 2^31).
        randNum = (uint32_t)lrand48();

        // memcpy() + XOR + memcpy() is duplicated because compilers are often
        // smart enough to not generate a call to memcpy() if the size argument
        // is a compile-time constant the size of a register.
        memcpy(&bufferSlice, buffer, sizeof(uint32_t));
        bufferSlice ^= randNum;
        memcpy(buffer, &bufferSlice, sizeof(uint32_t));

        buffer += sizeof(uint32_t);
        length -= sizeof(uint32_t);
    }

    if (length)
    {
        // Ensure all bits in bufferSlice are initialized, so that the XOR will
        // flip bits with non-garbage values regardless of the endianess.
        bufferSlice = randNum = (uint32_t)lrand48();

        memcpy(&bufferSlice, buffer, length);
        bufferSlice ^= randNum;
        memcpy(buffer, &bufferSlice, length);
    }
}

#ifdef PAL_GRND_NONBLOCK
static bool IsGetRandomAvailable(void)
{
    uint8_t buffer;
    long r = syscall(SYS_getrandom, &buffer, 1, PAL_GRND_NONBLOCK);

    if (r == 1)
    {
        return true;
    }

    if ((r == -1) && (errno != ENOSYS))
    {
        // At this point, we're only interested if getrandom(2) is available
        // in this kernel.  If errno isn't ENOSYS, then we're (probably) good.
        return true;
    }

    return false;
}

static void FillWithGetRandom(uint8_t* buffer, int32_t bufferLength)
{
    size_t length = (size_t)bufferLength;

    do
    {
        long n = syscall(SYS_getrandom, buffer, length, PAL_GRND_NONBLOCK);

        if (n == -1)
        {
            if (errno == EINTR)
            {
                continue;
            }

            assert(false && "getrandom() has failed");
            break;
        }

        buffer += n;
        length -= (size_t)n;
    }
    while(length);
}
#endif // PAL_GRND_NONBLOCK

static void FillWithDevUrandom(uint8_t *buffer, int32_t bufferLength)
{
    int fd = GetUrandomFileDescriptor();
    size_t length = (size_t)bufferLength;

    do
    {
        ssize_t n = read(fd, buffer, length);

        if (n == -1)
        {
            if (errno == EINTR)
            {
                continue;
            }

            assert(false && "read from /dev/urandom has failed");
            break;
        }

        buffer += n;
        length -= (size_t)n;
    }
    while(length);
}

enum RandomFillMethod {
    FILL_UNSET,
#ifdef PAL_GRND_NONBLOCK
    FILL_WITH_GET_RANDOM,
#endif // PAL_GRND_NONBLOCK
    FILL_WITH_DEV_URANDOM,
    FILL_WITH_LRAND48,
};

static enum RandomFillMethod ResolveRandomFillMethod(void)
{
#ifdef PAL_GRND_NONBLOCK
    if (IsGetRandomAvailable())
    {
        return FILL_WITH_GET_RANDOM;
    }
#endif // PAL_GRND_NONBLOCK

    if (GetUrandomFileDescriptor() >= 0)
    {
        return FILL_WITH_DEV_URANDOM;
    }

    return FILL_WITH_LRAND48;
}

void SystemNative_GetNonCryptographicallySecureRandomBytes(uint8_t* buffer, int32_t bufferLength)
{
    static enum RandomFillMethod fillMethod = FILL_UNSET;

    if (fillMethod == FILL_UNSET)
    {
        if (__atomic_load_n(&fillMethod, __ATOMIC_RELAXED) == FILL_UNSET)
        {
            // ResolveRandomFillMethod() is idempotent.  In the unlikelyhood that concurrent
            // threads race to initialize fillMethod, there shouldn't be any unobservable
            // side-effects from calling it.  Atomics are used to read/write fillMethod just in
            // case; it's not really necessary here.
            enum RandomFillMethod newMethod = ResolveRandomFillMethod();

            __atomic_store(&fillMethod, &newMethod, __ATOMIC_RELEASE);
        }
    }

    assert(buffer != NULL);

    switch (fillMethod)
    {
        case FILL_UNSET:
            assert(false && "fillMethod is still unset; this shouldn't happen");
            // Fallthrough, so the buffer is 0-filled before being XOR-ed with lrand48().
        case FILL_WITH_LRAND48:
            // Zero out the buffer first so XorWithLrand48() won't XOR uninitialized memory.
            memset(buffer, 0, (size_t)bufferLength);
            break;
#ifdef PAL_GRND_NONBLOCK
        case FILL_WITH_GET_RANDOM:
            FillWithGetRandom(buffer, bufferLength);
            break;
#endif // PAL_GRND_NONBLOCK
        case FILL_WITH_DEV_URANDOM:
            FillWithDevUrandom(buffer, bufferLength);
            break;
    }

    // Always XOR with the result of lrand() as a workaround against poor hardware RNGs that
    // sometimes return only zeros in some rare circumstances.
    XorWithLrand48(buffer, bufferLength);
}
#else
void SystemNative_GetNonCryptographicallySecureRandomBytes(uint8_t* buffer, int32_t bufferLength)
{
    assert(buffer != NULL);
    arc4random_buf(buffer, (size_t)bufferLength);
}
#endif // !HAVE_ARC4RANDOM_BUF
